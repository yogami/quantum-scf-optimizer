import {
  require_react
} from "./chunk-VX2H6PUQ.js";
import {
  ACESFilmicToneMapping,
  AddEquation,
  AddOperation,
  AdditiveBlending,
  AgXToneMapping,
  AlphaFormat,
  AlwaysCompare,
  AlwaysDepth,
  AlwaysStencilFunc,
  AmbientLight,
  ArrayCamera,
  BackSide,
  BasicShadowMap,
  Box3,
  BoxGeometry,
  BufferAttribute,
  BufferGeometry,
  ByteType,
  Camera,
  CineonToneMapping,
  ClampToEdgeWrapping,
  Clock,
  Color,
  ColorManagement,
  ConeGeometry,
  Controls,
  CubeCamera,
  CubeDepthTexture,
  CubeReflectionMapping,
  CubeRefractionMapping,
  CubeTexture,
  CubeUVReflectionMapping,
  CubicBezierCurve3,
  CullFaceBack,
  CullFaceFront,
  CullFaceNone,
  CustomBlending,
  CylinderGeometry,
  DataArrayTexture,
  DataTexture,
  DecrementStencilOp,
  DecrementWrapStencilOp,
  DepthFormat,
  DepthStencilFormat,
  DepthTexture,
  DirectionalLight,
  DoubleSide,
  DstAlphaFactor,
  DstColorFactor,
  DynamicDrawUsage,
  EqualCompare,
  EqualDepth,
  EqualStencilFunc,
  EquirectangularReflectionMapping,
  EquirectangularRefractionMapping,
  Euler,
  EventDispatcher,
  Float16BufferAttribute,
  Float32BufferAttribute,
  FloatType,
  FramebufferTexture,
  FrontSide,
  Frustum,
  FrustumArray,
  GreaterCompare,
  GreaterDepth,
  GreaterEqualCompare,
  GreaterEqualDepth,
  GreaterEqualStencilFunc,
  GreaterStencilFunc,
  Group,
  HalfFloatType,
  HemisphereLight,
  IncrementStencilOp,
  IncrementWrapStencilOp,
  InstancedBufferAttribute,
  InstancedInterleavedBuffer,
  IntType,
  InterleavedBuffer,
  InterleavedBufferAttribute,
  InvertStencilOp,
  KeepStencilOp,
  LessCompare,
  LessDepth,
  LessEqualCompare,
  LessEqualDepth,
  LessEqualStencilFunc,
  LessStencilFunc,
  LightProbe,
  Line,
  LineBasicMaterial,
  LineDashedMaterial,
  LinearFilter,
  LinearMipMapLinearFilter,
  LinearMipmapLinearFilter,
  LinearMipmapNearestFilter,
  LinearSRGBColorSpace,
  LinearToneMapping,
  LinearTransfer,
  MOUSE,
  Material,
  MathUtils,
  Matrix2,
  Matrix3,
  Matrix4,
  MaxEquation,
  Mesh,
  MeshBasicMaterial,
  MeshLambertMaterial,
  MeshMatcapMaterial,
  MeshNormalMaterial,
  MeshPhongMaterial,
  MeshPhysicalMaterial,
  MeshStandardMaterial,
  MeshToonMaterial,
  MinEquation,
  MirroredRepeatWrapping,
  MixOperation,
  MultiplyBlending,
  MultiplyOperation,
  NearestFilter,
  NearestMipmapLinearFilter,
  NearestMipmapNearestFilter,
  NeutralToneMapping,
  NeverCompare,
  NeverDepth,
  NeverStencilFunc,
  NoBlending,
  NoColorSpace,
  NoNormalPacking,
  NoToneMapping,
  NormalBlending,
  NormalGAPacking,
  NormalRGPacking,
  NotEqualCompare,
  NotEqualDepth,
  NotEqualStencilFunc,
  Object3D,
  ObjectSpaceNormalMap,
  OneFactor,
  OneMinusDstAlphaFactor,
  OneMinusDstColorFactor,
  OneMinusSrcAlphaFactor,
  OneMinusSrcColorFactor,
  OrthographicCamera,
  PCFShadowMap,
  PerspectiveCamera,
  Plane,
  PlaneGeometry,
  PointLight,
  PointsMaterial,
  QuadraticBezierCurve3,
  Quaternion,
  R11_EAC_Format,
  RAD2DEG,
  RED_GREEN_RGTC2_Format,
  RED_RGTC1_Format,
  REVISION,
  RG11_EAC_Format,
  RGBAFormat,
  RGBAIntegerFormat,
  RGBA_ASTC_10x10_Format,
  RGBA_ASTC_10x5_Format,
  RGBA_ASTC_10x6_Format,
  RGBA_ASTC_10x8_Format,
  RGBA_ASTC_12x10_Format,
  RGBA_ASTC_12x12_Format,
  RGBA_ASTC_4x4_Format,
  RGBA_ASTC_5x4_Format,
  RGBA_ASTC_5x5_Format,
  RGBA_ASTC_6x5_Format,
  RGBA_ASTC_6x6_Format,
  RGBA_ASTC_8x5_Format,
  RGBA_ASTC_8x6_Format,
  RGBA_ASTC_8x8_Format,
  RGBA_BPTC_Format,
  RGBA_ETC2_EAC_Format,
  RGBA_PVRTC_2BPPV1_Format,
  RGBA_PVRTC_4BPPV1_Format,
  RGBA_S3TC_DXT1_Format,
  RGBA_S3TC_DXT3_Format,
  RGBA_S3TC_DXT5_Format,
  RGBFormat,
  RGBIntegerFormat,
  RGB_ETC1_Format,
  RGB_ETC2_Format,
  RGB_PVRTC_2BPPV1_Format,
  RGB_PVRTC_4BPPV1_Format,
  RGB_S3TC_DXT1_Format,
  RGFormat,
  RGIntegerFormat,
  Ray,
  Raycaster,
  RectAreaLight,
  RedFormat,
  RedIntegerFormat,
  ReinhardToneMapping,
  RenderTarget,
  RepeatWrapping,
  ReplaceStencilOp,
  ReverseSubtractEquation,
  SIGNED_R11_EAC_Format,
  SIGNED_RED_GREEN_RGTC2_Format,
  SIGNED_RED_RGTC1_Format,
  SIGNED_RG11_EAC_Format,
  SRGBColorSpace,
  SRGBTransfer,
  Scene,
  ShaderMaterial,
  ShadowMaterial,
  ShortType,
  Sphere,
  SphereGeometry,
  Spherical,
  SpotLight,
  SpriteMaterial,
  SrcAlphaFactor,
  SrcAlphaSaturateFactor,
  SrcColorFactor,
  StaticDrawUsage,
  SubtractEquation,
  SubtractiveBlending,
  TOUCH,
  TangentSpaceNormalMap,
  Texture,
  TextureLoader,
  TimestampQuery,
  Triangle,
  TubeGeometry,
  UVMapping,
  Uint16BufferAttribute,
  Uint32BufferAttribute,
  UniformsUtils,
  UnsignedByteType,
  UnsignedInt101111Type,
  UnsignedInt248Type,
  UnsignedInt5999Type,
  UnsignedIntType,
  UnsignedShort4444Type,
  UnsignedShort5551Type,
  UnsignedShortType,
  VSMShadowMap,
  Vector2,
  Vector3,
  Vector4,
  WebGLCoordinateSystem,
  WebGLCubeRenderTarget,
  WebGLRenderTarget,
  WebGLRenderer,
  WebGPUCoordinateSystem,
  WebXRController,
  ZeroFactor,
  ZeroStencilOp,
  arrayNeedsUint32,
  createCanvasElement,
  error,
  getByteLength,
  isTypedArray,
  log,
  warn,
  warnOnce
} from "./chunk-PSGFQQOX.js";
import {
  __commonJS,
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/ngraph.forcelayout/lib/codeGenerators/getVariableName.js
var require_getVariableName = __commonJS({
  "node_modules/ngraph.forcelayout/lib/codeGenerators/getVariableName.js"(exports2, module2) {
    module2.exports = function getVariableName(index8) {
      if (index8 === 0) return "x";
      if (index8 === 1) return "y";
      if (index8 === 2) return "z";
      return "c" + (index8 + 1);
    };
  }
});

// node_modules/ngraph.forcelayout/lib/codeGenerators/createPatternBuilder.js
var require_createPatternBuilder = __commonJS({
  "node_modules/ngraph.forcelayout/lib/codeGenerators/createPatternBuilder.js"(exports2, module2) {
    var getVariableName = require_getVariableName();
    module2.exports = function createPatternBuilder(dimension) {
      return pattern;
      function pattern(template2, config) {
        let indent = config && config.indent || 0;
        let join2 = config && config.join !== void 0 ? config.join : "\n";
        let indentString = Array(indent + 1).join(" ");
        let buffer2 = [];
        for (let i2 = 0; i2 < dimension; ++i2) {
          let variableName = getVariableName(i2);
          let prefix = i2 === 0 ? "" : indentString;
          buffer2.push(prefix + template2.replace(/{var}/g, variableName));
        }
        return buffer2.join(join2);
      }
    };
  }
});

// node_modules/ngraph.forcelayout/lib/codeGenerators/generateCreateBody.js
var require_generateCreateBody = __commonJS({
  "node_modules/ngraph.forcelayout/lib/codeGenerators/generateCreateBody.js"(exports2, module2) {
    var createPatternBuilder = require_createPatternBuilder();
    module2.exports = generateCreateBodyFunction;
    module2.exports.generateCreateBodyFunctionBody = generateCreateBodyFunctionBody;
    module2.exports.getVectorCode = getVectorCode;
    module2.exports.getBodyCode = getBodyCode;
    function generateCreateBodyFunction(dimension, debugSetters) {
      let code2 = generateCreateBodyFunctionBody(dimension, debugSetters);
      let { Body } = new Function(code2)();
      return Body;
    }
    function generateCreateBodyFunctionBody(dimension, debugSetters) {
      let code2 = `
${getVectorCode(dimension, debugSetters)}
${getBodyCode(dimension, debugSetters)}
return {Body: Body, Vector: Vector};
`;
      return code2;
    }
    function getBodyCode(dimension) {
      let pattern = createPatternBuilder(dimension);
      let variableList = pattern("{var}", { join: ", " });
      return `
function Body(${variableList}) {
  this.isPinned = false;
  this.pos = new Vector(${variableList});
  this.force = new Vector();
  this.velocity = new Vector();
  this.mass = 1;

  this.springCount = 0;
  this.springLength = 0;
}

Body.prototype.reset = function() {
  this.force.reset();
  this.springCount = 0;
  this.springLength = 0;
}

Body.prototype.setPosition = function (${variableList}) {
  ${pattern("this.pos.{var} = {var} || 0;", { indent: 2 })}
};`;
    }
    function getVectorCode(dimension, debugSetters) {
      let pattern = createPatternBuilder(dimension);
      let setters = "";
      if (debugSetters) {
        setters = `${pattern("\n   var v{var};\nObject.defineProperty(this, '{var}', {\n  set: function(v) { \n    if (!Number.isFinite(v)) throw new Error('Cannot set non-numbers to {var}');\n    v{var} = v; \n  },\n  get: function() { return v{var}; }\n});")}`;
      }
      let variableList = pattern("{var}", { join: ", " });
      return `function Vector(${variableList}) {
  ${setters}
    if (typeof arguments[0] === 'object') {
      // could be another vector
      let v = arguments[0];
      ${pattern('if (!Number.isFinite(v.{var})) throw new Error("Expected value is not a finite number at Vector constructor ({var})");', { indent: 4 })}
      ${pattern("this.{var} = v.{var};", { indent: 4 })}
    } else {
      ${pattern('this.{var} = typeof {var} === "number" ? {var} : 0;', { indent: 4 })}
    }
  }
  
  Vector.prototype.reset = function () {
    ${pattern("this.{var} = ", { join: "" })}0;
  };`;
    }
  }
});

// node_modules/ngraph.forcelayout/lib/codeGenerators/generateQuadTree.js
var require_generateQuadTree = __commonJS({
  "node_modules/ngraph.forcelayout/lib/codeGenerators/generateQuadTree.js"(exports2, module2) {
    var createPatternBuilder = require_createPatternBuilder();
    var getVariableName = require_getVariableName();
    module2.exports = generateQuadTreeFunction;
    module2.exports.generateQuadTreeFunctionBody = generateQuadTreeFunctionBody;
    module2.exports.getInsertStackCode = getInsertStackCode;
    module2.exports.getQuadNodeCode = getQuadNodeCode;
    module2.exports.isSamePosition = isSamePosition;
    module2.exports.getChildBodyCode = getChildBodyCode;
    module2.exports.setChildBodyCode = setChildBodyCode;
    function generateQuadTreeFunction(dimension) {
      let code2 = generateQuadTreeFunctionBody(dimension);
      return new Function(code2)();
    }
    function generateQuadTreeFunctionBody(dimension) {
      let pattern = createPatternBuilder(dimension);
      let quadCount = Math.pow(2, dimension);
      let code2 = `
${getInsertStackCode()}
${getQuadNodeCode(dimension)}
${isSamePosition(dimension)}
${getChildBodyCode(dimension)}
${setChildBodyCode(dimension)}

function createQuadTree(options, random) {
  options = options || {};
  options.gravity = typeof options.gravity === 'number' ? options.gravity : -1;
  options.theta = typeof options.theta === 'number' ? options.theta : 0.8;

  var gravity = options.gravity;
  var updateQueue = [];
  var insertStack = new InsertStack();
  var theta = options.theta;

  var nodesCache = [];
  var currentInCache = 0;
  var root = newNode();

  return {
    insertBodies: insertBodies,

    /**
     * Gets root node if it is present
     */
    getRoot: function() {
      return root;
    },

    updateBodyForce: update,

    options: function(newOptions) {
      if (newOptions) {
        if (typeof newOptions.gravity === 'number') {
          gravity = newOptions.gravity;
        }
        if (typeof newOptions.theta === 'number') {
          theta = newOptions.theta;
        }

        return this;
      }

      return {
        gravity: gravity,
        theta: theta
      };
    }
  };

  function newNode() {
    // To avoid pressure on GC we reuse nodes.
    var node = nodesCache[currentInCache];
    if (node) {
${assignQuads("      node.")}
      node.body = null;
      node.mass = ${pattern("node.mass_{var} = ", { join: "" })}0;
      ${pattern("node.min_{var} = node.max_{var} = ", { join: "" })}0;
    } else {
      node = new QuadNode();
      nodesCache[currentInCache] = node;
    }

    ++currentInCache;
    return node;
  }

  function update(sourceBody) {
    var queue = updateQueue;
    var v;
    ${pattern("var d{var};", { indent: 4 })}
    var r; 
    ${pattern("var f{var} = 0;", { indent: 4 })}
    var queueLength = 1;
    var shiftIdx = 0;
    var pushIdx = 1;

    queue[0] = root;

    while (queueLength) {
      var node = queue[shiftIdx];
      var body = node.body;

      queueLength -= 1;
      shiftIdx += 1;
      var differentBody = (body !== sourceBody);
      if (body && differentBody) {
        // If the current node is a leaf node (and it is not source body),
        // calculate the force exerted by the current node on body, and add this
        // amount to body's net force.
        ${pattern("d{var} = body.pos.{var} - sourceBody.pos.{var};", { indent: 8 })}
        r = Math.sqrt(${pattern("d{var} * d{var}", { join: " + " })});

        if (r === 0) {
          // Poor man's protection against zero distance.
          ${pattern("d{var} = (random.nextDouble() - 0.5) / 50;", { indent: 10 })}
          r = Math.sqrt(${pattern("d{var} * d{var}", { join: " + " })});
        }

        // This is standard gravitation force calculation but we divide
        // by r^3 to save two operations when normalizing force vector.
        v = gravity * body.mass * sourceBody.mass / (r * r * r);
        ${pattern("f{var} += v * d{var};", { indent: 8 })}
      } else if (differentBody) {
        // Otherwise, calculate the ratio s / r,  where s is the width of the region
        // represented by the internal node, and r is the distance between the body
        // and the node's center-of-mass
        ${pattern("d{var} = node.mass_{var} / node.mass - sourceBody.pos.{var};", { indent: 8 })}
        r = Math.sqrt(${pattern("d{var} * d{var}", { join: " + " })});

        if (r === 0) {
          // Sorry about code duplication. I don't want to create many functions
          // right away. Just want to see performance first.
          ${pattern("d{var} = (random.nextDouble() - 0.5) / 50;", { indent: 10 })}
          r = Math.sqrt(${pattern("d{var} * d{var}", { join: " + " })});
        }
        // If s / r < Î¸, treat this internal node as a single body, and calculate the
        // force it exerts on sourceBody, and add this amount to sourceBody's net force.
        if ((node.max_${getVariableName(0)} - node.min_${getVariableName(0)}) / r < theta) {
          // in the if statement above we consider node's width only
          // because the region was made into square during tree creation.
          // Thus there is no difference between using width or height.
          v = gravity * node.mass * sourceBody.mass / (r * r * r);
          ${pattern("f{var} += v * d{var};", { indent: 10 })}
        } else {
          // Otherwise, run the procedure recursively on each of the current node's children.

          // I intentionally unfolded this loop, to save several CPU cycles.
${runRecursiveOnChildren()}
        }
      }
    }

    ${pattern("sourceBody.force.{var} += f{var};", { indent: 4 })}
  }

  function insertBodies(bodies) {
    ${pattern("var {var}min = Number.MAX_VALUE;", { indent: 4 })}
    ${pattern("var {var}max = Number.MIN_VALUE;", { indent: 4 })}
    var i = bodies.length;

    // To reduce quad tree depth we are looking for exact bounding box of all particles.
    while (i--) {
      var pos = bodies[i].pos;
      ${pattern("if (pos.{var} < {var}min) {var}min = pos.{var};", { indent: 6 })}
      ${pattern("if (pos.{var} > {var}max) {var}max = pos.{var};", { indent: 6 })}
    }

    // Makes the bounds square.
    var maxSideLength = -Infinity;
    ${pattern("if ({var}max - {var}min > maxSideLength) maxSideLength = {var}max - {var}min ;", { indent: 4 })}

    currentInCache = 0;
    root = newNode();
    ${pattern("root.min_{var} = {var}min;", { indent: 4 })}
    ${pattern("root.max_{var} = {var}min + maxSideLength;", { indent: 4 })}

    i = bodies.length - 1;
    if (i >= 0) {
      root.body = bodies[i];
    }
    while (i--) {
      insert(bodies[i], root);
    }
  }

  function insert(newBody) {
    insertStack.reset();
    insertStack.push(root, newBody);

    while (!insertStack.isEmpty()) {
      var stackItem = insertStack.pop();
      var node = stackItem.node;
      var body = stackItem.body;

      if (!node.body) {
        // This is internal node. Update the total mass of the node and center-of-mass.
        ${pattern("var {var} = body.pos.{var};", { indent: 8 })}
        node.mass += body.mass;
        ${pattern("node.mass_{var} += body.mass * {var};", { indent: 8 })}

        // Recursively insert the body in the appropriate quadrant.
        // But first find the appropriate quadrant.
        var quadIdx = 0; // Assume we are in the 0's quad.
        ${pattern("var min_{var} = node.min_{var};", { indent: 8 })}
        ${pattern("var max_{var} = (min_{var} + node.max_{var}) / 2;", { indent: 8 })}

${assignInsertionQuadIndex(8)}

        var child = getChild(node, quadIdx);

        if (!child) {
          // The node is internal but this quadrant is not taken. Add
          // subnode to it.
          child = newNode();
          ${pattern("child.min_{var} = min_{var};", { indent: 10 })}
          ${pattern("child.max_{var} = max_{var};", { indent: 10 })}
          child.body = body;

          setChild(node, quadIdx, child);
        } else {
          // continue searching in this quadrant.
          insertStack.push(child, body);
        }
      } else {
        // We are trying to add to the leaf node.
        // We have to convert current leaf into internal node
        // and continue adding two nodes.
        var oldBody = node.body;
        node.body = null; // internal nodes do not cary bodies

        if (isSamePosition(oldBody.pos, body.pos)) {
          // Prevent infinite subdivision by bumping one node
          // anywhere in this quadrant
          var retriesCount = 3;
          do {
            var offset = random.nextDouble();
            ${pattern("var d{var} = (node.max_{var} - node.min_{var}) * offset;", { indent: 12 })}

            ${pattern("oldBody.pos.{var} = node.min_{var} + d{var};", { indent: 12 })}
            retriesCount -= 1;
            // Make sure we don't bump it out of the box. If we do, next iteration should fix it
          } while (retriesCount > 0 && isSamePosition(oldBody.pos, body.pos));

          if (retriesCount === 0 && isSamePosition(oldBody.pos, body.pos)) {
            // This is very bad, we ran out of precision.
            // if we do not return from the method we'll get into
            // infinite loop here. So we sacrifice correctness of layout, and keep the app running
            // Next layout iteration should get larger bounding box in the first step and fix this
            return;
          }
        }
        // Next iteration should subdivide node further.
        insertStack.push(node, oldBody);
        insertStack.push(node, body);
      }
    }
  }
}
return createQuadTree;

`;
      return code2;
      function assignInsertionQuadIndex(indentCount) {
        let insertionCode = [];
        let indent = Array(indentCount + 1).join(" ");
        for (let i2 = 0; i2 < dimension; ++i2) {
          insertionCode.push(indent + `if (${getVariableName(i2)} > max_${getVariableName(i2)}) {`);
          insertionCode.push(indent + `  quadIdx = quadIdx + ${Math.pow(2, i2)};`);
          insertionCode.push(indent + `  min_${getVariableName(i2)} = max_${getVariableName(i2)};`);
          insertionCode.push(indent + `  max_${getVariableName(i2)} = node.max_${getVariableName(i2)};`);
          insertionCode.push(indent + `}`);
        }
        return insertionCode.join("\n");
      }
      function runRecursiveOnChildren() {
        let indent = Array(11).join(" ");
        let recursiveCode = [];
        for (let i2 = 0; i2 < quadCount; ++i2) {
          recursiveCode.push(indent + `if (node.quad${i2}) {`);
          recursiveCode.push(indent + `  queue[pushIdx] = node.quad${i2};`);
          recursiveCode.push(indent + `  queueLength += 1;`);
          recursiveCode.push(indent + `  pushIdx += 1;`);
          recursiveCode.push(indent + `}`);
        }
        return recursiveCode.join("\n");
      }
      function assignQuads(indent) {
        let quads = [];
        for (let i2 = 0; i2 < quadCount; ++i2) {
          quads.push(`${indent}quad${i2} = null;`);
        }
        return quads.join("\n");
      }
    }
    function isSamePosition(dimension) {
      let pattern = createPatternBuilder(dimension);
      return `
  function isSamePosition(point1, point2) {
    ${pattern("var d{var} = Math.abs(point1.{var} - point2.{var});", { indent: 2 })}
  
    return ${pattern("d{var} < 1e-8", { join: " && " })};
  }  
`;
    }
    function setChildBodyCode(dimension) {
      var quadCount = Math.pow(2, dimension);
      return `
function setChild(node, idx, child) {
  ${setChildBody()}
}`;
      function setChildBody() {
        let childBody = [];
        for (let i2 = 0; i2 < quadCount; ++i2) {
          let prefix = i2 === 0 ? "  " : "  else ";
          childBody.push(`${prefix}if (idx === ${i2}) node.quad${i2} = child;`);
        }
        return childBody.join("\n");
      }
    }
    function getChildBodyCode(dimension) {
      return `function getChild(node, idx) {
${getChildBody()}
  return null;
}`;
      function getChildBody() {
        let childBody = [];
        let quadCount = Math.pow(2, dimension);
        for (let i2 = 0; i2 < quadCount; ++i2) {
          childBody.push(`  if (idx === ${i2}) return node.quad${i2};`);
        }
        return childBody.join("\n");
      }
    }
    function getQuadNodeCode(dimension) {
      let pattern = createPatternBuilder(dimension);
      let quadCount = Math.pow(2, dimension);
      var quadNodeCode = `
function QuadNode() {
  // body stored inside this node. In quad tree only leaf nodes (by construction)
  // contain bodies:
  this.body = null;

  // Child nodes are stored in quads. Each quad is presented by number:
  // 0 | 1
  // -----
  // 2 | 3
${assignQuads("  this.")}

  // Total mass of current node
  this.mass = 0;

  // Center of mass coordinates
  ${pattern("this.mass_{var} = 0;", { indent: 2 })}

  // bounding box coordinates
  ${pattern("this.min_{var} = 0;", { indent: 2 })}
  ${pattern("this.max_{var} = 0;", { indent: 2 })}
}
`;
      return quadNodeCode;
      function assignQuads(indent) {
        let quads = [];
        for (let i2 = 0; i2 < quadCount; ++i2) {
          quads.push(`${indent}quad${i2} = null;`);
        }
        return quads.join("\n");
      }
    }
    function getInsertStackCode() {
      return `
/**
 * Our implementation of QuadTree is non-recursive to avoid GC hit
 * This data structure represent stack of elements
 * which we are trying to insert into quad tree.
 */
function InsertStack () {
    this.stack = [];
    this.popIdx = 0;
}

InsertStack.prototype = {
    isEmpty: function() {
        return this.popIdx === 0;
    },
    push: function (node, body) {
        var item = this.stack[this.popIdx];
        if (!item) {
            // we are trying to avoid memory pressure: create new element
            // only when absolutely necessary
            this.stack[this.popIdx] = new InsertStackElement(node, body);
        } else {
            item.node = node;
            item.body = body;
        }
        ++this.popIdx;
    },
    pop: function () {
        if (this.popIdx > 0) {
            return this.stack[--this.popIdx];
        }
    },
    reset: function () {
        this.popIdx = 0;
    }
};

function InsertStackElement(node, body) {
    this.node = node; // QuadTree node
    this.body = body; // physical body which needs to be inserted to node
}
`;
    }
  }
});

// node_modules/ngraph.forcelayout/lib/codeGenerators/generateBounds.js
var require_generateBounds = __commonJS({
  "node_modules/ngraph.forcelayout/lib/codeGenerators/generateBounds.js"(exports2, module2) {
    module2.exports = generateBoundsFunction;
    module2.exports.generateFunctionBody = generateBoundsFunctionBody;
    var createPatternBuilder = require_createPatternBuilder();
    function generateBoundsFunction(dimension) {
      let code2 = generateBoundsFunctionBody(dimension);
      return new Function("bodies", "settings", "random", code2);
    }
    function generateBoundsFunctionBody(dimension) {
      let pattern = createPatternBuilder(dimension);
      let code2 = `
  var boundingBox = {
    ${pattern("min_{var}: 0, max_{var}: 0,", { indent: 4 })}
  };

  return {
    box: boundingBox,

    update: updateBoundingBox,

    reset: resetBoundingBox,

    getBestNewPosition: function (neighbors) {
      var ${pattern("base_{var} = 0", { join: ", " })};

      if (neighbors.length) {
        for (var i = 0; i < neighbors.length; ++i) {
          let neighborPos = neighbors[i].pos;
          ${pattern("base_{var} += neighborPos.{var};", { indent: 10 })}
        }

        ${pattern("base_{var} /= neighbors.length;", { indent: 8 })}
      } else {
        ${pattern("base_{var} = (boundingBox.min_{var} + boundingBox.max_{var}) / 2;", { indent: 8 })}
      }

      var springLength = settings.springLength;
      return {
        ${pattern("{var}: base_{var} + (random.nextDouble() - 0.5) * springLength,", { indent: 8 })}
      };
    }
  };

  function updateBoundingBox() {
    var i = bodies.length;
    if (i === 0) return; // No bodies - no borders.

    ${pattern("var max_{var} = -Infinity;", { indent: 4 })}
    ${pattern("var min_{var} = Infinity;", { indent: 4 })}

    while(i--) {
      // this is O(n), it could be done faster with quadtree, if we check the root node bounds
      var bodyPos = bodies[i].pos;
      ${pattern("if (bodyPos.{var} < min_{var}) min_{var} = bodyPos.{var};", { indent: 6 })}
      ${pattern("if (bodyPos.{var} > max_{var}) max_{var} = bodyPos.{var};", { indent: 6 })}
    }

    ${pattern("boundingBox.min_{var} = min_{var};", { indent: 4 })}
    ${pattern("boundingBox.max_{var} = max_{var};", { indent: 4 })}
  }

  function resetBoundingBox() {
    ${pattern("boundingBox.min_{var} = boundingBox.max_{var} = 0;", { indent: 4 })}
  }
`;
      return code2;
    }
  }
});

// node_modules/ngraph.forcelayout/lib/codeGenerators/generateCreateDragForce.js
var require_generateCreateDragForce = __commonJS({
  "node_modules/ngraph.forcelayout/lib/codeGenerators/generateCreateDragForce.js"(exports2, module2) {
    var createPatternBuilder = require_createPatternBuilder();
    module2.exports = generateCreateDragForceFunction;
    module2.exports.generateCreateDragForceFunctionBody = generateCreateDragForceFunctionBody;
    function generateCreateDragForceFunction(dimension) {
      let code2 = generateCreateDragForceFunctionBody(dimension);
      return new Function("options", code2);
    }
    function generateCreateDragForceFunctionBody(dimension) {
      let pattern = createPatternBuilder(dimension);
      let code2 = `
  if (!Number.isFinite(options.dragCoefficient)) throw new Error('dragCoefficient is not a finite number');

  return {
    update: function(body) {
      ${pattern("body.force.{var} -= options.dragCoefficient * body.velocity.{var};", { indent: 6 })}
    }
  };
`;
      return code2;
    }
  }
});

// node_modules/ngraph.forcelayout/lib/codeGenerators/generateCreateSpringForce.js
var require_generateCreateSpringForce = __commonJS({
  "node_modules/ngraph.forcelayout/lib/codeGenerators/generateCreateSpringForce.js"(exports2, module2) {
    var createPatternBuilder = require_createPatternBuilder();
    module2.exports = generateCreateSpringForceFunction;
    module2.exports.generateCreateSpringForceFunctionBody = generateCreateSpringForceFunctionBody;
    function generateCreateSpringForceFunction(dimension) {
      let code2 = generateCreateSpringForceFunctionBody(dimension);
      return new Function("options", "random", code2);
    }
    function generateCreateSpringForceFunctionBody(dimension) {
      let pattern = createPatternBuilder(dimension);
      let code2 = `
  if (!Number.isFinite(options.springCoefficient)) throw new Error('Spring coefficient is not a number');
  if (!Number.isFinite(options.springLength)) throw new Error('Spring length is not a number');

  return {
    /**
     * Updates forces acting on a spring
     */
    update: function (spring) {
      var body1 = spring.from;
      var body2 = spring.to;
      var length = spring.length < 0 ? options.springLength : spring.length;
      ${pattern("var d{var} = body2.pos.{var} - body1.pos.{var};", { indent: 6 })}
      var r = Math.sqrt(${pattern("d{var} * d{var}", { join: " + " })});

      if (r === 0) {
        ${pattern("d{var} = (random.nextDouble() - 0.5) / 50;", { indent: 8 })}
        r = Math.sqrt(${pattern("d{var} * d{var}", { join: " + " })});
      }

      var d = r - length;
      var coefficient = ((spring.coefficient > 0) ? spring.coefficient : options.springCoefficient) * d / r;

      ${pattern("body1.force.{var} += coefficient * d{var}", { indent: 6 })};
      body1.springCount += 1;
      body1.springLength += r;

      ${pattern("body2.force.{var} -= coefficient * d{var}", { indent: 6 })};
      body2.springCount += 1;
      body2.springLength += r;
    }
  };
`;
      return code2;
    }
  }
});

// node_modules/ngraph.forcelayout/lib/codeGenerators/generateIntegrator.js
var require_generateIntegrator = __commonJS({
  "node_modules/ngraph.forcelayout/lib/codeGenerators/generateIntegrator.js"(exports2, module2) {
    var createPatternBuilder = require_createPatternBuilder();
    module2.exports = generateIntegratorFunction;
    module2.exports.generateIntegratorFunctionBody = generateIntegratorFunctionBody;
    function generateIntegratorFunction(dimension) {
      let code2 = generateIntegratorFunctionBody(dimension);
      return new Function("bodies", "timeStep", "adaptiveTimeStepWeight", code2);
    }
    function generateIntegratorFunctionBody(dimension) {
      let pattern = createPatternBuilder(dimension);
      let code2 = `
  var length = bodies.length;
  if (length === 0) return 0;

  ${pattern("var d{var} = 0, t{var} = 0;", { indent: 2 })}

  for (var i = 0; i < length; ++i) {
    var body = bodies[i];
    if (body.isPinned) continue;

    if (adaptiveTimeStepWeight && body.springCount) {
      timeStep = (adaptiveTimeStepWeight * body.springLength/body.springCount);
    }

    var coeff = timeStep / body.mass;

    ${pattern("body.velocity.{var} += coeff * body.force.{var};", { indent: 4 })}
    ${pattern("var v{var} = body.velocity.{var};", { indent: 4 })}
    var v = Math.sqrt(${pattern("v{var} * v{var}", { join: " + " })});

    if (v > 1) {
      // We normalize it so that we move within timeStep range. 
      // for the case when v <= 1 - we let velocity to fade out.
      ${pattern("body.velocity.{var} = v{var} / v;", { indent: 6 })}
    }

    ${pattern("d{var} = timeStep * body.velocity.{var};", { indent: 4 })}

    ${pattern("body.pos.{var} += d{var};", { indent: 4 })}

    ${pattern("t{var} += Math.abs(d{var});", { indent: 4 })}
  }

  return (${pattern("t{var} * t{var}", { join: " + " })})/length;
`;
      return code2;
    }
  }
});

// node_modules/ngraph.forcelayout/lib/spring.js
var require_spring = __commonJS({
  "node_modules/ngraph.forcelayout/lib/spring.js"(exports2, module2) {
    module2.exports = Spring;
    function Spring(fromBody, toBody, length2, springCoefficient) {
      this.from = fromBody;
      this.to = toBody;
      this.length = length2;
      this.coefficient = springCoefficient;
    }
  }
});

// node_modules/ngraph.merge/index.js
var require_ngraph = __commonJS({
  "node_modules/ngraph.merge/index.js"(exports2, module2) {
    module2.exports = merge3;
    function merge3(target, options) {
      var key;
      if (!target) {
        target = {};
      }
      if (options) {
        for (key in options) {
          if (options.hasOwnProperty(key)) {
            var targetHasIt = target.hasOwnProperty(key), optionsValueType = typeof options[key], shouldReplace = !targetHasIt || typeof target[key] !== optionsValueType;
            if (shouldReplace) {
              target[key] = options[key];
            } else if (optionsValueType === "object") {
              target[key] = merge3(target[key], options[key]);
            }
          }
        }
      }
      return target;
    }
  }
});

// node_modules/ngraph.events/dist/ngraph.events.cjs
var require_ngraph_events = __commonJS({
  "node_modules/ngraph.events/dist/ngraph.events.cjs"(exports2, module2) {
    "use strict";
    function c5(e3) {
      s2(e3);
      const t5 = a3(e3);
      return e3.on = t5.on, e3.off = t5.off, e3.fire = t5.fire, e3;
    }
    function a3(e3) {
      let t5 = /* @__PURE__ */ Object.create(null);
      return { on: function(n2, r2, f3) {
        if (typeof r2 != "function") throw new Error("callback is expected to be a function");
        let o2 = t5[n2];
        return o2 || (o2 = t5[n2] = []), o2.push({ callback: r2, ctx: f3 }), e3;
      }, off: function(n2, r2) {
        if (typeof n2 > "u") return t5 = /* @__PURE__ */ Object.create(null), e3;
        if (t5[n2]) if (typeof r2 != "function") delete t5[n2];
        else {
          const l2 = t5[n2];
          for (let i2 = 0; i2 < l2.length; ++i2) l2[i2].callback === r2 && l2.splice(i2, 1);
        }
        return e3;
      }, fire: function(n2) {
        const r2 = t5[n2];
        if (!r2) return e3;
        let f3;
        arguments.length > 1 && (f3 = Array.prototype.slice.call(arguments, 1));
        for (let o2 = 0; o2 < r2.length; ++o2) {
          const l2 = r2[o2];
          l2.callback.apply(l2.ctx, f3);
        }
        return e3;
      } };
    }
    function s2(e3) {
      if (!e3) throw new Error("Eventify cannot use falsy object as events subject");
      const t5 = ["on", "fire", "off"];
      for (let n2 = 0; n2 < t5.length; ++n2) if (e3.hasOwnProperty(t5[n2])) throw new Error("Subject cannot be eventified, since it already has property '" + t5[n2] + "'");
    }
    module2.exports = c5;
  }
});

// node_modules/ngraph.random/index.js
var require_ngraph2 = __commonJS({
  "node_modules/ngraph.random/index.js"(exports2, module2) {
    module2.exports = random2;
    module2.exports.random = random2, module2.exports.randomIterator = randomIterator;
    function random2(inputSeed) {
      var seed = typeof inputSeed === "number" ? inputSeed : +/* @__PURE__ */ new Date();
      return new Generator(seed);
    }
    function Generator(seed) {
      this.seed = seed;
    }
    Generator.prototype.next = next;
    Generator.prototype.nextDouble = nextDouble;
    Generator.prototype.uniform = nextDouble;
    Generator.prototype.gaussian = gaussian;
    Generator.prototype.random = nextDouble;
    function gaussian() {
      var r2, x3, y3;
      do {
        x3 = this.nextDouble() * 2 - 1;
        y3 = this.nextDouble() * 2 - 1;
        r2 = x3 * x3 + y3 * y3;
      } while (r2 >= 1 || r2 === 0);
      return x3 * Math.sqrt(-2 * Math.log(r2) / r2);
    }
    Generator.prototype.levy = levy;
    function levy() {
      var beta = 3 / 2;
      var sigma = Math.pow(
        gamma2(1 + beta) * Math.sin(Math.PI * beta / 2) / (gamma2((1 + beta) / 2) * beta * Math.pow(2, (beta - 1) / 2)),
        1 / beta
      );
      return this.gaussian() * sigma / Math.pow(Math.abs(this.gaussian()), 1 / beta);
    }
    function gamma2(z3) {
      return Math.sqrt(2 * Math.PI / z3) * Math.pow(1 / Math.E * (z3 + 1 / (12 * z3 - 1 / (10 * z3))), z3);
    }
    function nextDouble() {
      var seed = this.seed;
      seed = seed + 2127912214 + (seed << 12) & 4294967295;
      seed = (seed ^ 3345072700 ^ seed >>> 19) & 4294967295;
      seed = seed + 374761393 + (seed << 5) & 4294967295;
      seed = (seed + 3550635116 ^ seed << 9) & 4294967295;
      seed = seed + 4251993797 + (seed << 3) & 4294967295;
      seed = (seed ^ 3042594569 ^ seed >>> 16) & 4294967295;
      this.seed = seed;
      return (seed & 268435455) / 268435456;
    }
    function next(maxValue) {
      return Math.floor(this.nextDouble() * maxValue);
    }
    function randomIterator(array4, customRandom) {
      var localRandom = customRandom || random2();
      if (typeof localRandom.next !== "function") {
        throw new Error("customRandom does not match expected API: next() function is missing");
      }
      return {
        /**
         * Visits every single element of a collection once, in a random order.
         * Note: collection is modified in place.
         */
        forEach: forEach2,
        /**
         * Shuffles array randomly, in place.
         */
        shuffle: shuffle2
      };
      function shuffle2() {
        var i2, j2, t5;
        for (i2 = array4.length - 1; i2 > 0; --i2) {
          j2 = localRandom.next(i2 + 1);
          t5 = array4[j2];
          array4[j2] = array4[i2];
          array4[i2] = t5;
        }
        return array4;
      }
      function forEach2(callback) {
        var i2, j2, t5;
        for (i2 = array4.length - 1; i2 > 0; --i2) {
          j2 = localRandom.next(i2 + 1);
          t5 = array4[j2];
          array4[j2] = array4[i2];
          array4[i2] = t5;
          callback(t5);
        }
        if (array4.length) {
          callback(array4[0]);
        }
      }
    }
  }
});

// node_modules/ngraph.forcelayout/lib/createPhysicsSimulator.js
var require_createPhysicsSimulator = __commonJS({
  "node_modules/ngraph.forcelayout/lib/createPhysicsSimulator.js"(exports2, module2) {
    module2.exports = createPhysicsSimulator;
    var generateCreateBodyFunction = require_generateCreateBody();
    var generateQuadTreeFunction = require_generateQuadTree();
    var generateBoundsFunction = require_generateBounds();
    var generateCreateDragForceFunction = require_generateCreateDragForce();
    var generateCreateSpringForceFunction = require_generateCreateSpringForce();
    var generateIntegratorFunction = require_generateIntegrator();
    var dimensionalCache = {};
    function createPhysicsSimulator(settings) {
      var Spring = require_spring();
      var merge3 = require_ngraph();
      var eventify2 = require_ngraph_events();
      if (settings) {
        if (settings.springCoeff !== void 0) throw new Error("springCoeff was renamed to springCoefficient");
        if (settings.dragCoeff !== void 0) throw new Error("dragCoeff was renamed to dragCoefficient");
      }
      settings = merge3(settings, {
        /**
         * Ideal length for links (springs in physical model).
         */
        springLength: 10,
        /**
         * Hook's law coefficient. 1 - solid spring.
         */
        springCoefficient: 0.8,
        /**
         * Coulomb's law coefficient. It's used to repel nodes thus should be negative
         * if you make it positive nodes start attract each other :).
         */
        gravity: -12,
        /**
         * Theta coefficient from Barnes Hut simulation. Ranged between (0, 1).
         * The closer it's to 1 the more nodes algorithm will have to go through.
         * Setting it to one makes Barnes Hut simulation no different from
         * brute-force forces calculation (each node is considered).
         */
        theta: 0.8,
        /**
         * Drag force coefficient. Used to slow down system, thus should be less than 1.
         * The closer it is to 0 the less tight system will be.
         */
        dragCoefficient: 0.9,
        // TODO: Need to rename this to something better. E.g. `dragCoefficient`
        /**
         * Default time step (dt) for forces integration
         */
        timeStep: 0.5,
        /**
         * Adaptive time step uses average spring length to compute actual time step:
         * See: https://twitter.com/anvaka/status/1293067160755957760
         */
        adaptiveTimeStepWeight: 0,
        /**
         * This parameter defines number of dimensions of the space where simulation
         * is performed. 
         */
        dimensions: 2,
        /**
         * In debug mode more checks are performed, this will help you catch errors
         * quickly, however for production build it is recommended to turn off this flag
         * to speed up computation.
         */
        debug: false
      });
      var factory2 = dimensionalCache[settings.dimensions];
      if (!factory2) {
        var dimensions = settings.dimensions;
        factory2 = {
          Body: generateCreateBodyFunction(dimensions, settings.debug),
          createQuadTree: generateQuadTreeFunction(dimensions),
          createBounds: generateBoundsFunction(dimensions),
          createDragForce: generateCreateDragForceFunction(dimensions),
          createSpringForce: generateCreateSpringForceFunction(dimensions),
          integrate: generateIntegratorFunction(dimensions)
        };
        dimensionalCache[dimensions] = factory2;
      }
      var Body = factory2.Body;
      var createQuadTree = factory2.createQuadTree;
      var createBounds = factory2.createBounds;
      var createDragForce = factory2.createDragForce;
      var createSpringForce = factory2.createSpringForce;
      var integrate = factory2.integrate;
      var createBody = (pos) => new Body(pos);
      var random2 = require_ngraph2().random(42);
      var bodies = [];
      var springs = [];
      var quadTree = createQuadTree(settings, random2);
      var bounds = createBounds(bodies, settings, random2);
      var springForce = createSpringForce(settings, random2);
      var dragForce = createDragForce(settings);
      var totalMovement = 0;
      var forces = [];
      var forceMap = /* @__PURE__ */ new Map();
      var iterationNumber = 0;
      addForce("nbody", nbodyForce);
      addForce("spring", updateSpringForce);
      var publicApi = {
        /**
         * Array of bodies, registered with current simulator
         *
         * Note: To add new body, use addBody() method. This property is only
         * exposed for testing/performance purposes.
         */
        bodies,
        quadTree,
        /**
         * Array of springs, registered with current simulator
         *
         * Note: To add new spring, use addSpring() method. This property is only
         * exposed for testing/performance purposes.
         */
        springs,
        /**
         * Returns settings with which current simulator was initialized
         */
        settings,
        /**
         * Adds a new force to simulation
         */
        addForce,
        /**
         * Removes a force from the simulation.
         */
        removeForce,
        /**
         * Returns a map of all registered forces.
         */
        getForces,
        /**
         * Performs one step of force simulation.
         *
         * @returns {boolean} true if system is considered stable; False otherwise.
         */
        step: function() {
          for (var i2 = 0; i2 < forces.length; ++i2) {
            forces[i2](iterationNumber);
          }
          var movement = integrate(bodies, settings.timeStep, settings.adaptiveTimeStepWeight);
          iterationNumber += 1;
          return movement;
        },
        /**
         * Adds body to the system
         *
         * @param {ngraph.physics.primitives.Body} body physical body
         *
         * @returns {ngraph.physics.primitives.Body} added body
         */
        addBody: function(body) {
          if (!body) {
            throw new Error("Body is required");
          }
          bodies.push(body);
          return body;
        },
        /**
         * Adds body to the system at given position
         *
         * @param {Object} pos position of a body
         *
         * @returns {ngraph.physics.primitives.Body} added body
         */
        addBodyAt: function(pos) {
          if (!pos) {
            throw new Error("Body position is required");
          }
          var body = createBody(pos);
          bodies.push(body);
          return body;
        },
        /**
         * Removes body from the system
         *
         * @param {ngraph.physics.primitives.Body} body to remove
         *
         * @returns {Boolean} true if body found and removed. falsy otherwise;
         */
        removeBody: function(body) {
          if (!body) {
            return;
          }
          var idx = bodies.indexOf(body);
          if (idx < 0) {
            return;
          }
          bodies.splice(idx, 1);
          if (bodies.length === 0) {
            bounds.reset();
          }
          return true;
        },
        /**
         * Adds a spring to this simulation.
         *
         * @returns {Object} - a handle for a spring. If you want to later remove
         * spring pass it to removeSpring() method.
         */
        addSpring: function(body1, body2, springLength, springCoefficient) {
          if (!body1 || !body2) {
            throw new Error("Cannot add null spring to force simulator");
          }
          if (typeof springLength !== "number") {
            springLength = -1;
          }
          var spring = new Spring(body1, body2, springLength, springCoefficient >= 0 ? springCoefficient : -1);
          springs.push(spring);
          return spring;
        },
        /**
         * Returns amount of movement performed on last step() call
         */
        getTotalMovement: function() {
          return totalMovement;
        },
        /**
         * Removes spring from the system
         *
         * @param {Object} spring to remove. Spring is an object returned by addSpring
         *
         * @returns {Boolean} true if spring found and removed. falsy otherwise;
         */
        removeSpring: function(spring) {
          if (!spring) {
            return;
          }
          var idx = springs.indexOf(spring);
          if (idx > -1) {
            springs.splice(idx, 1);
            return true;
          }
        },
        getBestNewBodyPosition: function(neighbors) {
          return bounds.getBestNewPosition(neighbors);
        },
        /**
         * Returns bounding box which covers all bodies
         */
        getBBox: getBoundingBox,
        getBoundingBox,
        invalidateBBox: function() {
          console.warn("invalidateBBox() is deprecated, bounds always recomputed on `getBBox()` call");
        },
        // TODO: Move the force specific stuff to force
        gravity: function(value) {
          if (value !== void 0) {
            settings.gravity = value;
            quadTree.options({ gravity: value });
            return this;
          } else {
            return settings.gravity;
          }
        },
        theta: function(value) {
          if (value !== void 0) {
            settings.theta = value;
            quadTree.options({ theta: value });
            return this;
          } else {
            return settings.theta;
          }
        },
        /**
         * Returns pseudo-random number generator instance.
         */
        random: random2
      };
      expose(settings, publicApi);
      eventify2(publicApi);
      return publicApi;
      function getBoundingBox() {
        bounds.update();
        return bounds.box;
      }
      function addForce(forceName, forceFunction) {
        if (forceMap.has(forceName)) throw new Error("Force " + forceName + " is already added");
        forceMap.set(forceName, forceFunction);
        forces.push(forceFunction);
      }
      function removeForce(forceName) {
        var forceIndex = forces.indexOf(forceMap.get(forceName));
        if (forceIndex < 0) return;
        forces.splice(forceIndex, 1);
        forceMap.delete(forceName);
      }
      function getForces() {
        return forceMap;
      }
      function nbodyForce() {
        if (bodies.length === 0) return;
        quadTree.insertBodies(bodies);
        var i2 = bodies.length;
        while (i2--) {
          var body = bodies[i2];
          if (!body.isPinned) {
            body.reset();
            quadTree.updateBodyForce(body);
            dragForce.update(body);
          }
        }
      }
      function updateSpringForce() {
        var i2 = springs.length;
        while (i2--) {
          springForce.update(springs[i2]);
        }
      }
    }
    function expose(settings, target) {
      for (var key in settings) {
        augment(settings, target, key);
      }
    }
    function augment(source, target, key) {
      if (!source.hasOwnProperty(key)) return;
      if (typeof target[key] === "function") {
        return;
      }
      var sourceIsNumber = Number.isFinite(source[key]);
      if (sourceIsNumber) {
        target[key] = function(value) {
          if (value !== void 0) {
            if (!Number.isFinite(value)) throw new Error("Value of " + key + " should be a valid number.");
            source[key] = value;
            return target;
          }
          return source[key];
        };
      } else {
        target[key] = function(value) {
          if (value !== void 0) {
            source[key] = value;
            return target;
          }
          return source[key];
        };
      }
    }
  }
});

// node_modules/ngraph.forcelayout/index.js
var require_ngraph3 = __commonJS({
  "node_modules/ngraph.forcelayout/index.js"(exports2, module2) {
    module2.exports = createLayout;
    module2.exports.simulator = require_createPhysicsSimulator();
    var eventify2 = require_ngraph_events();
    function createLayout(graph, physicsSettings) {
      if (!graph) {
        throw new Error("Graph structure cannot be undefined");
      }
      var createSimulator = physicsSettings && physicsSettings.createSimulator || require_createPhysicsSimulator();
      var physicsSimulator = createSimulator(physicsSettings);
      if (Array.isArray(physicsSettings)) throw new Error("Physics settings is expected to be an object");
      var nodeMass = graph.version > 19 ? defaultSetNodeMass : defaultArrayNodeMass;
      if (physicsSettings && typeof physicsSettings.nodeMass === "function") {
        nodeMass = physicsSettings.nodeMass;
      }
      var nodeBodies = /* @__PURE__ */ new Map();
      var springs = {};
      var bodiesCount = 0;
      var springTransform = physicsSimulator.settings.springTransform || noop3;
      initPhysics();
      listenToEvents();
      var wasStable = false;
      var api = {
        /**
         * Performs one step of iterative layout algorithm
         *
         * @returns {boolean} true if the system should be considered stable; False otherwise.
         * The system is stable if no further call to `step()` can improve the layout.
         */
        step: function() {
          if (bodiesCount === 0) {
            updateStableStatus(true);
            return true;
          }
          var lastMove = physicsSimulator.step();
          api.lastMove = lastMove;
          api.fire("step");
          var ratio = lastMove / bodiesCount;
          var isStableNow = ratio <= 0.01;
          updateStableStatus(isStableNow);
          return isStableNow;
        },
        /**
         * For a given `nodeId` returns position
         */
        getNodePosition: function(nodeId) {
          return getInitializedBody(nodeId).pos;
        },
        /**
         * Sets position of a node to a given coordinates
         * @param {string} nodeId node identifier
         * @param {number} x position of a node
         * @param {number} y position of a node
         * @param {number=} z position of node (only if applicable to body)
         */
        setNodePosition: function(nodeId) {
          var body = getInitializedBody(nodeId);
          body.setPosition.apply(body, Array.prototype.slice.call(arguments, 1));
        },
        /**
         * @returns {Object} Link position by link id
         * @returns {Object.from} {x, y} coordinates of link start
         * @returns {Object.to} {x, y} coordinates of link end
         */
        getLinkPosition: function(linkId) {
          var spring = springs[linkId];
          if (spring) {
            return {
              from: spring.from.pos,
              to: spring.to.pos
            };
          }
        },
        /**
         * @returns {Object} area required to fit in the graph. Object contains
         * `x1`, `y1` - top left coordinates
         * `x2`, `y2` - bottom right coordinates
         */
        getGraphRect: function() {
          return physicsSimulator.getBBox();
        },
        /**
         * Iterates over each body in the layout simulator and performs a callback(body, nodeId)
         */
        forEachBody,
        /*
         * Requests layout algorithm to pin/unpin node to its current position
         * Pinned nodes should not be affected by layout algorithm and always
         * remain at their position
         */
        pinNode: function(node, isPinned) {
          var body = getInitializedBody(node.id);
          body.isPinned = !!isPinned;
        },
        /**
         * Checks whether given graph's node is currently pinned
         */
        isNodePinned: function(node) {
          return getInitializedBody(node.id).isPinned;
        },
        /**
         * Request to release all resources
         */
        dispose: function() {
          graph.off("changed", onGraphChanged);
          api.fire("disposed");
        },
        /**
         * Gets physical body for a given node id. If node is not found undefined
         * value is returned.
         */
        getBody,
        /**
         * Gets spring for a given edge.
         *
         * @param {string} linkId link identifer. If two arguments are passed then
         * this argument is treated as formNodeId
         * @param {string=} toId when defined this parameter denotes head of the link
         * and first argument is treated as tail of the link (fromId)
         */
        getSpring,
        /**
         * Returns length of cumulative force vector. The closer this to zero - the more stable the system is
         */
        getForceVectorLength,
        /**
         * [Read only] Gets current physics simulator
         */
        simulator: physicsSimulator,
        /**
         * Gets the graph that was used for layout
         */
        graph,
        /**
         * Gets amount of movement performed during last step operation
         */
        lastMove: 0
      };
      eventify2(api);
      return api;
      function updateStableStatus(isStableNow) {
        if (wasStable !== isStableNow) {
          wasStable = isStableNow;
          onStableChanged(isStableNow);
        }
      }
      function forEachBody(cb) {
        nodeBodies.forEach(cb);
      }
      function getForceVectorLength() {
        var fx = 0, fy = 0;
        forEachBody(function(body) {
          fx += Math.abs(body.force.x);
          fy += Math.abs(body.force.y);
        });
        return Math.sqrt(fx * fx + fy * fy);
      }
      function getSpring(fromId, toId) {
        var linkId;
        if (toId === void 0) {
          if (typeof fromId !== "object") {
            linkId = fromId;
          } else {
            linkId = fromId.id;
          }
        } else {
          var link = graph.hasLink(fromId, toId);
          if (!link) return;
          linkId = link.id;
        }
        return springs[linkId];
      }
      function getBody(nodeId) {
        return nodeBodies.get(nodeId);
      }
      function listenToEvents() {
        graph.on("changed", onGraphChanged);
      }
      function onStableChanged(isStable) {
        api.fire("stable", isStable);
      }
      function onGraphChanged(changes) {
        for (var i2 = 0; i2 < changes.length; ++i2) {
          var change = changes[i2];
          if (change.changeType === "add") {
            if (change.node) {
              initBody(change.node.id);
            }
            if (change.link) {
              initLink(change.link);
            }
          } else if (change.changeType === "remove") {
            if (change.node) {
              releaseNode(change.node);
            }
            if (change.link) {
              releaseLink(change.link);
            }
          }
        }
        bodiesCount = graph.getNodesCount();
      }
      function initPhysics() {
        bodiesCount = 0;
        graph.forEachNode(function(node) {
          initBody(node.id);
          bodiesCount += 1;
        });
        graph.forEachLink(initLink);
      }
      function initBody(nodeId) {
        var body = nodeBodies.get(nodeId);
        if (!body) {
          var node = graph.getNode(nodeId);
          if (!node) {
            throw new Error("initBody() was called with unknown node id");
          }
          var pos = node.position;
          if (!pos) {
            var neighbors = getNeighborBodies(node);
            pos = physicsSimulator.getBestNewBodyPosition(neighbors);
          }
          body = physicsSimulator.addBodyAt(pos);
          body.id = nodeId;
          nodeBodies.set(nodeId, body);
          updateBodyMass(nodeId);
          if (isNodeOriginallyPinned(node)) {
            body.isPinned = true;
          }
        }
      }
      function releaseNode(node) {
        var nodeId = node.id;
        var body = nodeBodies.get(nodeId);
        if (body) {
          nodeBodies.delete(nodeId);
          physicsSimulator.removeBody(body);
        }
      }
      function initLink(link) {
        updateBodyMass(link.fromId);
        updateBodyMass(link.toId);
        var fromBody = nodeBodies.get(link.fromId), toBody = nodeBodies.get(link.toId), spring = physicsSimulator.addSpring(fromBody, toBody, link.length);
        springTransform(link, spring);
        springs[link.id] = spring;
      }
      function releaseLink(link) {
        var spring = springs[link.id];
        if (spring) {
          var from = graph.getNode(link.fromId), to = graph.getNode(link.toId);
          if (from) updateBodyMass(from.id);
          if (to) updateBodyMass(to.id);
          delete springs[link.id];
          physicsSimulator.removeSpring(spring);
        }
      }
      function getNeighborBodies(node) {
        var neighbors = [];
        if (!node.links) {
          return neighbors;
        }
        var maxNeighbors = Math.min(node.links.length, 2);
        for (var i2 = 0; i2 < maxNeighbors; ++i2) {
          var link = node.links[i2];
          var otherBody = link.fromId !== node.id ? nodeBodies.get(link.fromId) : nodeBodies.get(link.toId);
          if (otherBody && otherBody.pos) {
            neighbors.push(otherBody);
          }
        }
        return neighbors;
      }
      function updateBodyMass(nodeId) {
        var body = nodeBodies.get(nodeId);
        body.mass = nodeMass(nodeId);
        if (Number.isNaN(body.mass)) {
          throw new Error("Node mass should be a number");
        }
      }
      function isNodeOriginallyPinned(node) {
        return node && (node.isPinned || node.data && node.data.isPinned);
      }
      function getInitializedBody(nodeId) {
        var body = nodeBodies.get(nodeId);
        if (!body) {
          initBody(nodeId);
          body = nodeBodies.get(nodeId);
        }
        return body;
      }
      function defaultArrayNodeMass(nodeId) {
        var links = graph.getLinks(nodeId);
        if (!links) return 1;
        return 1 + links.length / 3;
      }
      function defaultSetNodeMass(nodeId) {
        var links = graph.getLinks(nodeId);
        if (!links) return 1;
        return 1 + links.size / 3;
      }
    }
    function noop3() {
    }
  }
});

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports2) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.scope") : 60119;
        function isValidElementType(type) {
          return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement2(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports2.AsyncMode = AsyncMode;
        exports2.ConcurrentMode = ConcurrentMode;
        exports2.ContextConsumer = ContextConsumer;
        exports2.ContextProvider = ContextProvider;
        exports2.Element = Element;
        exports2.ForwardRef = ForwardRef;
        exports2.Fragment = Fragment;
        exports2.Lazy = Lazy;
        exports2.Memo = Memo;
        exports2.Portal = Portal;
        exports2.Profiler = Profiler;
        exports2.StrictMode = StrictMode;
        exports2.Suspense = Suspense;
        exports2.isAsyncMode = isAsyncMode;
        exports2.isConcurrentMode = isConcurrentMode;
        exports2.isContextConsumer = isContextConsumer;
        exports2.isContextProvider = isContextProvider;
        exports2.isElement = isElement2;
        exports2.isForwardRef = isForwardRef;
        exports2.isFragment = isFragment;
        exports2.isLazy = isLazy;
        exports2.isMemo = isMemo;
        exports2.isPortal = isPortal;
        exports2.isProfiler = isProfiler;
        exports2.isStrictMode = isStrictMode;
        exports2.isSuspense = isSuspense;
        exports2.isValidElementType = isValidElementType;
        exports2.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/react-is/index.js"(exports2, module2) {
    "use strict";
    if (false) {
      module2.exports = null;
    } else {
      module2.exports = require_react_is_development();
    }
  }
});

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports2, module2) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty27 = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i2 = 0; i2 < 10; i2++) {
          test2["_" + String.fromCharCode(i2)] = i2;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n2) {
          return test2[n2];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err2) {
        return false;
      }
    }
    module2.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s2 = 1; s2 < arguments.length; s2++) {
        from = Object(arguments[s2]);
        for (var key in from) {
          if (hasOwnProperty27.call(from, key)) {
            to[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i2 = 0; i2 < symbols.length; i2++) {
            if (propIsEnumerable.call(from, symbols[i2])) {
              to[symbols[i2]] = from[symbols[i2]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
  "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports2, module2) {
    "use strict";
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module2.exports = ReactPropTypesSecret;
  }
});

// node_modules/prop-types/lib/has.js
var require_has = __commonJS({
  "node_modules/prop-types/lib/has.js"(exports2, module2) {
    module2.exports = Function.call.bind(Object.prototype.hasOwnProperty);
  }
});

// node_modules/prop-types/checkPropTypes.js
var require_checkPropTypes = __commonJS({
  "node_modules/prop-types/checkPropTypes.js"(exports2, module2) {
    "use strict";
    var printWarning = function() {
    };
    if (true) {
      ReactPropTypesSecret = require_ReactPropTypesSecret();
      loggedTypeFailures = {};
      has2 = require_has();
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x3) {
        }
      };
    }
    var ReactPropTypesSecret;
    var loggedTypeFailures;
    var has2;
    function checkPropTypes(typeSpecs, values2, location, componentName, getStack) {
      if (true) {
        for (var typeSpecName in typeSpecs) {
          if (has2(typeSpecs, typeSpecName)) {
            var error2;
            try {
              if (typeof typeSpecs[typeSpecName] !== "function") {
                var err2 = Error(
                  (componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
                );
                err2.name = "Invariant Violation";
                throw err2;
              }
              error2 = typeSpecs[typeSpecName](values2, typeSpecName, componentName, location, null, ReactPropTypesSecret);
            } catch (ex) {
              error2 = ex;
            }
            if (error2 && !(error2 instanceof Error)) {
              printWarning(
                (componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error2 + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
              );
            }
            if (error2 instanceof Error && !(error2.message in loggedTypeFailures)) {
              loggedTypeFailures[error2.message] = true;
              var stack2 = getStack ? getStack() : "";
              printWarning(
                "Failed " + location + " type: " + error2.message + (stack2 != null ? stack2 : "")
              );
            }
          }
        }
      }
    }
    checkPropTypes.resetWarningCache = function() {
      if (true) {
        loggedTypeFailures = {};
      }
    };
    module2.exports = checkPropTypes;
  }
});

// node_modules/prop-types/factoryWithTypeCheckers.js
var require_factoryWithTypeCheckers = __commonJS({
  "node_modules/prop-types/factoryWithTypeCheckers.js"(exports2, module2) {
    "use strict";
    var ReactIs = require_react_is();
    var assign3 = require_object_assign();
    var ReactPropTypesSecret = require_ReactPropTypesSecret();
    var has2 = require_has();
    var checkPropTypes = require_checkPropTypes();
    var printWarning = function() {
    };
    if (true) {
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x3) {
        }
      };
    }
    function emptyFunctionThatReturnsNull() {
      return null;
    }
    module2.exports = function(isValidElement, throwOnDirectAccess) {
      var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === "function") {
          return iteratorFn;
        }
      }
      var ANONYMOUS = "<<anonymous>>";
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bigint: createPrimitiveTypeChecker("bigint"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        symbol: createPrimitiveTypeChecker("symbol"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
      };
      function is(x3, y3) {
        if (x3 === y3) {
          return x3 !== 0 || 1 / x3 === 1 / y3;
        } else {
          return x3 !== x3 && y3 !== y3;
        }
      }
      function PropTypeError(message, data) {
        this.message = message;
        this.data = data && typeof data === "object" ? data : {};
        this.stack = "";
      }
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate) {
        if (true) {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;
          if (secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess) {
              var err2 = new Error(
                "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
              );
              err2.name = "Invariant Violation";
              throw err2;
            } else if (typeof console !== "undefined") {
              var cacheKey = componentName + ":" + propName;
              if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
              manualPropTypeWarningCount < 3) {
                printWarning(
                  "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
                );
                manualPropTypeCallCache[cacheKey] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props[propName] == null) {
            if (isRequired) {
              if (props[propName] === null) {
                return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
              }
              return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
            }
            return null;
          } else {
            return validate(props, propName, componentName, location, propFullName);
          }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
      }
      function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location, propFullName, secret) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError(
              "Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
              { expectedType }
            );
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }
      function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
          }
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
          }
          for (var i2 = 0; i2 < propValue.length; i2++) {
            var error2 = typeChecker(propValue, i2, componentName, location, propFullName + "[" + i2 + "]", ReactPropTypesSecret);
            if (error2 instanceof Error) {
              return error2;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!isValidElement(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!ReactIs.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location, propFullName) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props[propName]);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          if (true) {
            if (arguments.length > 1) {
              printWarning(
                "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
              );
            } else {
              printWarning("Invalid argument supplied to oneOf, expected an array.");
            }
          }
          return emptyFunctionThatReturnsNull;
        }
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          for (var i2 = 0; i2 < expectedValues.length; i2++) {
            if (is(propValue, expectedValues[i2])) {
              return null;
            }
          }
          var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
            var type = getPreciseType(value);
            if (type === "symbol") {
              return String(value);
            }
            return value;
          });
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
          }
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
          }
          for (var key in propValue) {
            if (has2(propValue, key)) {
              var error2 = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error2 instanceof Error) {
                return error2;
              }
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
          return emptyFunctionThatReturnsNull;
        }
        for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
          var checker2 = arrayOfTypeCheckers[i2];
          if (typeof checker2 !== "function") {
            printWarning(
              "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker2) + " at index " + i2 + "."
            );
            return emptyFunctionThatReturnsNull;
          }
        }
        function validate(props, propName, componentName, location, propFullName) {
          var expectedTypes = [];
          for (var i3 = 0; i3 < arrayOfTypeCheckers.length; i3++) {
            var checker3 = arrayOfTypeCheckers[i3];
            var checkerResult = checker3(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
            if (checkerResult == null) {
              return null;
            }
            if (checkerResult.data && has2(checkerResult.data, "expectedType")) {
              expectedTypes.push(checkerResult.data.expectedType);
            }
          }
          var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createNodeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          if (!isNode(props[propName])) {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function invalidValidatorError(componentName, location, propFullName, key, type) {
        return new PropTypeError(
          (componentName || "React class") + ": " + location + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`."
        );
      }
      function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          for (var key in shapeTypes) {
            var checker2 = shapeTypes[key];
            if (typeof checker2 !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker2));
            }
            var error2 = checker2(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error2) {
              return error2;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          var allKeys = assign3({}, props[propName], shapeTypes);
          for (var key in allKeys) {
            var checker2 = shapeTypes[key];
            if (has2(shapeTypes, key) && typeof checker2 !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker2));
            }
            if (!checker2) {
              return new PropTypeError(
                "Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
              );
            }
            var error2 = checker2(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error2) {
              return error2;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function isNode(propValue) {
        switch (typeof propValue) {
          case "number":
          case "string":
          case "undefined":
            return true;
          case "boolean":
            return !propValue;
          case "object":
            if (Array.isArray(propValue)) {
              return propValue.every(isNode);
            }
            if (propValue === null || isValidElement(propValue)) {
              return true;
            }
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator = iteratorFn.call(propValue);
              var step2;
              if (iteratorFn !== propValue.entries) {
                while (!(step2 = iterator.next()).done) {
                  if (!isNode(step2.value)) {
                    return false;
                  }
                }
              } else {
                while (!(step2 = iterator.next()).done) {
                  var entry = step2.value;
                  if (entry) {
                    if (!isNode(entry[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }
            return true;
          default:
            return false;
        }
      }
      function isSymbol2(propType, propValue) {
        if (propType === "symbol") {
          return true;
        }
        if (!propValue) {
          return false;
        }
        if (propValue["@@toStringTag"] === "Symbol") {
          return true;
        }
        if (typeof Symbol === "function" && propValue instanceof Symbol) {
          return true;
        }
        return false;
      }
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return "array";
        }
        if (propValue instanceof RegExp) {
          return "object";
        }
        if (isSymbol2(propType, propValue)) {
          return "symbol";
        }
        return propType;
      }
      function getPreciseType(propValue) {
        if (typeof propValue === "undefined" || propValue === null) {
          return "" + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === "object") {
          if (propValue instanceof Date) {
            return "date";
          } else if (propValue instanceof RegExp) {
            return "regexp";
          }
        }
        return propType;
      }
      function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch (type) {
          case "array":
          case "object":
            return "an " + type;
          case "boolean":
          case "date":
          case "regexp":
            return "a " + type;
          default:
            return type;
        }
      }
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }
      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  }
});

// node_modules/prop-types/index.js
var require_prop_types = __commonJS({
  "node_modules/prop-types/index.js"(exports2, module2) {
    if (true) {
      ReactIs = require_react_is();
      throwOnDirectAccess = true;
      module2.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
    } else {
      module2.exports = null();
    }
    var ReactIs;
    var throwOnDirectAccess;
  }
});

// node_modules/react-kapsule/dist/react-kapsule.mjs
var import_react = __toESM(require_react(), 1);

// node_modules/jerrypick/dist/jerrypick.mjs
function _iterableToArrayLimit(arr, i2) {
  var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
  if (null != _i) {
    var _s, _e, _x2, _r, _arr = [], _n = true, _d = false;
    try {
      if (_x2 = (_i = _i.call(arr)).next, 0 === i2) {
        if (Object(_i) !== _i) return;
        _n = false;
      } else for (; !(_n = (_s = _x2.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i2); _n = true) ;
    } catch (err2) {
      _d = true, _e = err2;
    } finally {
      try {
        if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _slicedToArray(arr, i2) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _unsupportedIterableToArray(o2, minLen) {
  if (!o2) return;
  if (typeof o2 === "string") return _arrayLikeToArray(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor) n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray(o2, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) arr2[i2] = arr[i2];
  return arr2;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
var omit = function omit2(obj, keys2) {
  var keySet = new Set(keys2);
  return Object.assign.apply(Object, [{}].concat(_toConsumableArray(Object.entries(obj).filter(function(_ref2) {
    var _ref3 = _slicedToArray(_ref2, 1), key = _ref3[0];
    return !keySet.has(key);
  }).map(function(_ref4) {
    var _ref5 = _slicedToArray(_ref4, 2), key = _ref5[0], val = _ref5[1];
    return _defineProperty({}, key, val);
  }))));
};

// node_modules/react-kapsule/dist/react-kapsule.mjs
function _arrayLikeToArray2(r2, a3) {
  (null == a3 || a3 > r2.length) && (a3 = r2.length);
  for (var e3 = 0, n2 = Array(a3); e3 < a3; e3++) n2[e3] = r2[e3];
  return n2;
}
function _arrayWithHoles2(r2) {
  if (Array.isArray(r2)) return r2;
}
function _arrayWithoutHoles2(r2) {
  if (Array.isArray(r2)) return _arrayLikeToArray2(r2);
}
function _iterableToArray2(r2) {
  if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"]) return Array.from(r2);
}
function _iterableToArrayLimit2(r2, l2) {
  var t5 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t5) {
    var e3, n2, i2, u2, a3 = [], f3 = true, o2 = false;
    try {
      if (i2 = (t5 = t5.call(r2)).next, 0 === l2) ;
      else for (; !(f3 = (e3 = i2.call(t5)).done) && (a3.push(e3.value), a3.length !== l2); f3 = true) ;
    } catch (r3) {
      o2 = true, n2 = r3;
    } finally {
      try {
        if (!f3 && null != t5.return && (u2 = t5.return(), Object(u2) !== u2)) return;
      } finally {
        if (o2) throw n2;
      }
    }
    return a3;
  }
}
function _nonIterableRest2() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableSpread2() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _slicedToArray2(r2, e3) {
  return _arrayWithHoles2(r2) || _iterableToArrayLimit2(r2, e3) || _unsupportedIterableToArray2(r2, e3) || _nonIterableRest2();
}
function _toConsumableArray2(r2) {
  return _arrayWithoutHoles2(r2) || _iterableToArray2(r2) || _unsupportedIterableToArray2(r2) || _nonIterableSpread2();
}
function _unsupportedIterableToArray2(r2, a3) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray2(r2, a3);
    var t5 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t5 && r2.constructor && (t5 = r2.constructor.name), "Map" === t5 || "Set" === t5 ? Array.from(r2) : "Arguments" === t5 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t5) ? _arrayLikeToArray2(r2, a3) : void 0;
  }
}
function index(kapsuleComponent) {
  var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$wrapperElementTy = _ref.wrapperElementType, wrapperElementType = _ref$wrapperElementTy === void 0 ? "div" : _ref$wrapperElementTy, _ref$nodeMapper = _ref.nodeMapper, nodeMapper = _ref$nodeMapper === void 0 ? function(node) {
    return node;
  } : _ref$nodeMapper, _ref$methodNames = _ref.methodNames, methodNames = _ref$methodNames === void 0 ? [] : _ref$methodNames, _ref$initPropNames = _ref.initPropNames, initPropNames = _ref$initPropNames === void 0 ? [] : _ref$initPropNames;
  return (0, import_react.forwardRef)(function(props, ref) {
    var domEl = (0, import_react.useRef)();
    var comp = (0, import_react.useMemo)(function() {
      var configOptions = Object.fromEntries(initPropNames.filter(function(p3) {
        return props.hasOwnProperty(p3);
      }).map(function(prop) {
        return [prop, props[prop]];
      }));
      return kapsuleComponent(configOptions);
    }, []);
    useEffectOnce(function() {
      comp(nodeMapper(domEl.current));
    }, import_react.useLayoutEffect);
    useEffectOnce(function() {
      return comp._destructor instanceof Function ? comp._destructor : void 0;
    });
    var _call = (0, import_react.useCallback)(
      function(method2) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        return comp[method2] instanceof Function ? comp[method2].apply(comp, args) : void 0;
      },
      [comp]
    );
    var prevPropsRef = (0, import_react.useRef)({});
    Object.keys(omit(props, [].concat(_toConsumableArray2(methodNames), _toConsumableArray2(initPropNames)))).filter(function(p3) {
      return prevPropsRef.current[p3] !== props[p3];
    }).forEach(function(p3) {
      return _call(p3, props[p3]);
    });
    prevPropsRef.current = props;
    (0, import_react.useImperativeHandle)(ref, function() {
      return Object.fromEntries(methodNames.map(function(method2) {
        return [method2, function() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          return _call.apply(void 0, [method2].concat(args));
        }];
      }));
    }, [_call]);
    return import_react.default.createElement(wrapperElementType, {
      ref: domEl
    });
  });
}
function useEffectOnce(effect) {
  var useEffectFn = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : import_react.useEffect;
  var destroyFunc = (0, import_react.useRef)();
  var effectCalled = (0, import_react.useRef)(false);
  var renderAfterCalled = (0, import_react.useRef)(false);
  var _useState = (0, import_react.useState)(0), _useState2 = _slicedToArray2(_useState, 2);
  _useState2[0];
  var setVal = _useState2[1];
  if (effectCalled.current) {
    renderAfterCalled.current = true;
  }
  useEffectFn(function() {
    if (!effectCalled.current) {
      destroyFunc.current = effect();
      effectCalled.current = true;
    }
    setVal(function(val) {
      return val + 1;
    });
    return function() {
      if (!renderAfterCalled.current) return;
      if (destroyFunc.current) destroyFunc.current();
    };
  }, []);
}

// node_modules/aframe-extras/src/controls/checkpoint-controls.js
var EPS = 0.1;
AFRAME.registerComponent("checkpoint-controls", {
  schema: {
    enabled: { default: true },
    mode: { default: "teleport", oneOf: ["teleport", "animate"] },
    animateSpeed: { default: 3 }
  },
  init: function() {
    this.active = true;
    this.checkpoint = null;
    this.isNavMeshConstrained = false;
    this.offset = new THREE.Vector3();
    this.position = new THREE.Vector3();
    this.targetPosition = new THREE.Vector3();
  },
  play: function() {
    this.active = true;
  },
  pause: function() {
    this.active = false;
  },
  setCheckpoint: function(checkpoint) {
    const el = this.el;
    if (!this.active) return;
    if (this.checkpoint === checkpoint) return;
    if (this.checkpoint) {
      el.emit("navigation-end", { checkpoint: this.checkpoint });
    }
    this.checkpoint = checkpoint;
    this.sync();
    if (this.position.distanceTo(this.targetPosition) < EPS) {
      this.checkpoint = null;
      return;
    }
    el.emit("navigation-start", { checkpoint });
    if (this.data.mode === "teleport") {
      this.el.setAttribute("position", this.targetPosition);
      this.checkpoint = null;
      el.emit("navigation-end", { checkpoint });
      el.components["movement-controls"].updateNavLocation();
    }
  },
  isVelocityActive: function() {
    return !!(this.active && this.checkpoint);
  },
  getVelocity: function() {
    if (!this.active) return;
    const data = this.data;
    const offset = this.offset;
    const position = this.position;
    const targetPosition = this.targetPosition;
    const checkpoint = this.checkpoint;
    this.sync();
    if (position.distanceTo(targetPosition) < EPS) {
      this.checkpoint = null;
      this.el.emit("navigation-end", { checkpoint });
      return offset.set(0, 0, 0);
    }
    offset.setLength(data.animateSpeed);
    return offset;
  },
  sync: function() {
    const offset = this.offset;
    const position = this.position;
    const targetPosition = this.targetPosition;
    position.copy(this.el.getAttribute("position"));
    this.checkpoint.object3D.getWorldPosition(targetPosition);
    targetPosition.add(this.checkpoint.components.checkpoint.getOffset());
    offset.copy(targetPosition).sub(position);
  }
});

// node_modules/aframe-extras/lib/GamepadButton.js
var GamepadButton_default = Object.assign(function GamepadButton() {
}, {
  FACE_1: 0,
  FACE_2: 1,
  FACE_3: 2,
  FACE_4: 3,
  L_SHOULDER_1: 4,
  R_SHOULDER_1: 5,
  L_SHOULDER_2: 6,
  R_SHOULDER_2: 7,
  SELECT: 8,
  START: 9,
  DPAD_UP: 12,
  DPAD_DOWN: 13,
  DPAD_LEFT: 14,
  DPAD_RIGHT: 15,
  VENDOR: 16
});

// node_modules/aframe-extras/lib/GamepadButtonEvent.js
function GamepadButtonEvent(type, index8, details) {
  this.type = type;
  this.index = index8;
  this.pressed = details.pressed;
  this.value = details.value;
}
var GamepadButtonEvent_default = GamepadButtonEvent;

// node_modules/aframe-extras/src/controls/gamepad-controls.js
var JOYSTICK_EPS = 0.2;
var Hand = {
  LEFT: "left",
  RIGHT: "right"
};
var Joystick = {
  MOVEMENT: 1,
  ROTATION: 2
};
AFRAME.registerComponent("gamepad-controls", {
  /*******************************************************************
   * Statics
   */
  GamepadButton: GamepadButton_default,
  /*******************************************************************
   * Schema
   */
  schema: {
    // Enable/disable gamepad-controls
    enabled: { default: true },
    // Rotation sensitivity
    rotationSensitivity: { default: 2 }
  },
  /*******************************************************************
   * Core
   */
  /**
   * Called once when component is attached. Generally for initial setup.
   */
  init: function() {
    const sceneEl = this.el.sceneEl;
    this.system = sceneEl.systems["tracked-controls"] || sceneEl.systems["tracked-controls-webxr"] || { controllers: [] };
    this.prevTime = window.performance.now();
    this.buttons = {};
    const rotation = this.el.object3D.rotation;
    this.pitch = new THREE.Object3D();
    this.pitch.rotation.x = rotation.x;
    this.yaw = new THREE.Object3D();
    this.yaw.position.y = 10;
    this.yaw.rotation.y = rotation.y;
    this.yaw.add(this.pitch);
    this._lookVector = new THREE.Vector2();
    this._moveVector = new THREE.Vector2();
    this._dpadVector = new THREE.Vector2();
    sceneEl.addBehavior(this);
  },
  /**
   * Called when component is attached and when component data changes.
   * Generally modifies the entity based on the data.
   */
  update: function() {
    this.tick();
  },
  /**
   * Called on each iteration of main render loop.
   */
  tick: function(t5, dt) {
    this.updateButtonState();
    this.updateRotation(dt);
  },
  /**
   * Called when a component is removed (e.g., via removeAttribute).
   * Generally undoes all modifications to the entity.
   */
  remove: function() {
  },
  /*******************************************************************
   * Movement
   */
  isVelocityActive: function() {
    if (!this.data.enabled || !this.isConnected()) return false;
    const dpad = this._dpadVector;
    const joystick = this._moveVector;
    this.getDpad(dpad);
    this.getJoystick(Joystick.MOVEMENT, joystick);
    const inputX = dpad.x || joystick.x;
    const inputY = dpad.y || joystick.y;
    return Math.abs(inputX) > JOYSTICK_EPS || Math.abs(inputY) > JOYSTICK_EPS;
  },
  getVelocityDelta: function() {
    const dpad = this._dpadVector;
    const joystick = this._moveVector;
    this.getDpad(dpad);
    this.getJoystick(Joystick.MOVEMENT, joystick);
    const inputX = dpad.x || joystick.x;
    const inputY = dpad.y || joystick.y;
    const dVelocity = new THREE.Vector3();
    if (Math.abs(inputX) > JOYSTICK_EPS) {
      dVelocity.x += inputX;
    }
    if (Math.abs(inputY) > JOYSTICK_EPS) {
      dVelocity.z += inputY;
    }
    return dVelocity;
  },
  /*******************************************************************
   * Rotation
   */
  isRotationActive: function() {
    if (!this.data.enabled || !this.isConnected()) return false;
    const joystick = this._lookVector;
    this.getJoystick(Joystick.ROTATION, joystick);
    return Math.abs(joystick.x) > JOYSTICK_EPS || Math.abs(joystick.y) > JOYSTICK_EPS;
  },
  updateRotation: function(dt) {
    if (!this.isRotationActive()) return;
    const data = this.data;
    const yaw = this.yaw;
    const pitch = this.pitch;
    yaw.rotation.y = this.el.object3D.rotation.y;
    pitch.rotation.x = this.el.object3D.rotation.x;
    const lookVector = this._lookVector;
    this.getJoystick(Joystick.ROTATION, lookVector);
    if (Math.abs(lookVector.x) <= JOYSTICK_EPS) lookVector.x = 0;
    if (Math.abs(lookVector.y) <= JOYSTICK_EPS) lookVector.y = 0;
    lookVector.multiplyScalar(data.rotationSensitivity * dt / 1e3);
    yaw.rotation.y -= lookVector.x;
    pitch.rotation.x -= lookVector.y;
    pitch.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch.rotation.x));
    this.el.object3D.rotation.set(pitch.rotation.x, yaw.rotation.y, 0);
  },
  /*******************************************************************
   * Button events
   */
  updateButtonState: function() {
    const gamepad = this.getGamepad(Hand.RIGHT);
    if (this.data.enabled && gamepad) {
      for (var i2 = 0; i2 < gamepad.buttons.length; i2++) {
        if (gamepad.buttons[i2].pressed && !this.buttons[i2]) {
          this.emit(new GamepadButtonEvent_default("gamepadbuttondown", i2, gamepad.buttons[i2]));
        } else if (!gamepad.buttons[i2].pressed && this.buttons[i2]) {
          this.emit(new GamepadButtonEvent_default("gamepadbuttonup", i2, gamepad.buttons[i2]));
        }
        this.buttons[i2] = gamepad.buttons[i2].pressed;
      }
    } else {
      for (const key in this.buttons) {
        this.buttons[key] = false;
      }
    }
  },
  emit: function(event) {
    this.el.emit(event.type, event);
    this.el.emit(
      event.type + ":" + event.index,
      new GamepadButtonEvent_default(event.type, event.index, event)
    );
  },
  /*******************************************************************
   * Gamepad state
   */
  /**
   * Returns the Gamepad instance attached to the component. If connected,
   * a proxy-controls component may provide access to Gamepad input from a
   * remote device.
   *
   * @param {string} handPreference
   * @return {Gamepad}
   */
  getGamepad: /* @__PURE__ */ (function() {
    const _xrGamepads = [];
    const _empty = [];
    return function(handPreference) {
      const proxyControls = this.el.sceneEl.components["proxy-controls"];
      const proxyGamepad = proxyControls && proxyControls.isConnected() && proxyControls.getGamepad(0);
      if (proxyGamepad) return proxyGamepad;
      _xrGamepads.length = 0;
      for (let i2 = 0; i2 < this.system.controllers.length; i2++) {
        const xrController = this.system.controllers[i2];
        const xrGamepad = xrController ? xrController.gamepad : null;
        _xrGamepads.push(xrGamepad);
        if (xrGamepad && xrController.handedness === handPreference) return xrGamepad;
      }
      const navGamepads = navigator.getGamepads ? navigator.getGamepads() : _empty;
      for (let i2 = 0; i2 < navGamepads.length; i2++) {
        const navGamepad = navGamepads[i2];
        if (navGamepad && navGamepad.hand === handPreference) return navGamepad;
      }
      return _xrGamepads[0] || navGamepads[0];
    };
  })(),
  /**
   * Returns the state of the given button.
   * @param  {number} index The button (0-N) for which to find state.
   * @return {GamepadButton}
   */
  getButton: function(index8) {
    return this.getGamepad(Hand.RIGHT).buttons[index8];
  },
  /**
   * Returns state of the given axis. Axes are labelled 0-N, where 0-1 will
   * represent X/Y on the first joystick, and 2-3 X/Y on the second.
   * @param  {number} index The axis (0-N) for which to find state.
   * @return {number} On the interval [-1,1].
   */
  getAxis: function(index8) {
    return this.getGamepad(index8 > 1 ? Hand.RIGHT : Hand.LEFT).axes[index8];
  },
  /**
   * Returns the state of the specified joystick as a THREE.Vector2.
   * @param  {Joystick} role
   * @param  {THREE.Vector2} target
   * @return {THREE.Vector2}
   */
  getJoystick: function(index8, target) {
    const gamepad = this.getGamepad(index8 === Joystick.MOVEMENT ? Hand.LEFT : Hand.RIGHT);
    if (!gamepad) {
      return target.set(0, 0);
    }
    if (gamepad.mapping === "xr-standard") {
      switch (index8) {
        case Joystick.MOVEMENT:
          return target.set(gamepad.axes[2], gamepad.axes[3]);
        case Joystick.ROTATION:
          return target.set(gamepad.axes[2], 0);
      }
    } else {
      switch (index8) {
        case Joystick.MOVEMENT:
          return target.set(gamepad.axes[0], gamepad.axes[1]);
        case Joystick.ROTATION:
          return target.set(gamepad.axes[2], gamepad.axes[3]);
      }
    }
    throw new Error('Unexpected joystick index "%d".', index8);
  },
  /**
   * Returns the state of the dpad as a THREE.Vector2.
   * @param {THREE.Vector2} target
   * @return {THREE.Vector2}
   */
  getDpad: function(target) {
    const gamepad = this.getGamepad(Hand.LEFT);
    if (!gamepad) {
      return target.set(0, 0);
    }
    if (!gamepad.buttons[GamepadButton_default.DPAD_RIGHT]) {
      return target.set(0, 0);
    }
    return target.set(
      (gamepad.buttons[GamepadButton_default.DPAD_RIGHT].pressed ? 1 : 0) + (gamepad.buttons[GamepadButton_default.DPAD_LEFT].pressed ? -1 : 0),
      (gamepad.buttons[GamepadButton_default.DPAD_UP].pressed ? -1 : 0) + (gamepad.buttons[GamepadButton_default.DPAD_DOWN].pressed ? 1 : 0)
    );
  },
  /**
   * Returns true if the gamepad is currently connected to the system.
   * @return {boolean}
   */
  isConnected: function() {
    const gamepad = this.getGamepad(Hand.LEFT);
    return !!(gamepad && gamepad.connected);
  },
  /**
   * Returns a string containing some information about the controller. Result
   * may vary across browsers, for a given controller.
   * @return {string}
   */
  getID: function() {
    return this.getGamepad(Hand.LEFT).id;
  }
});

// node_modules/aframe-extras/lib/keyboard.polyfill.js
(function(global2) {
  var nativeKeyboardEvent = "KeyboardEvent" in global2;
  if (!nativeKeyboardEvent)
    global2.KeyboardEvent = function KeyboardEvent3() {
      throw TypeError("Illegal constructor");
    };
  if (!("DOM_KEY_LOCATION_STANDARD" in global2.KeyboardEvent)) global2.KeyboardEvent.DOM_KEY_LOCATION_STANDARD = 0;
  if (!("DOM_KEY_LOCATION_LEFT" in global2.KeyboardEvent)) global2.KeyboardEvent.DOM_KEY_LOCATION_LEFT = 1;
  if (!("DOM_KEY_LOCATION_RIGHT" in global2.KeyboardEvent)) global2.KeyboardEvent.DOM_KEY_LOCATION_RIGHT = 2;
  if (!("DOM_KEY_LOCATION_NUMPAD" in global2.KeyboardEvent)) global2.KeyboardEvent.DOM_KEY_LOCATION_NUMPAD = 3;
  var STANDARD = window.KeyboardEvent.DOM_KEY_LOCATION_STANDARD, LEFT = window.KeyboardEvent.DOM_KEY_LOCATION_LEFT, RIGHT = window.KeyboardEvent.DOM_KEY_LOCATION_RIGHT, NUMPAD = window.KeyboardEvent.DOM_KEY_LOCATION_NUMPAD;
  function contains(s2, ss) {
    return String(s2).indexOf(ss) !== -1;
  }
  var os = (function() {
    if (contains(navigator.platform, "Win")) {
      return "win";
    }
    if (contains(navigator.platform, "Mac")) {
      return "mac";
    }
    if (contains(navigator.platform, "CrOS")) {
      return "cros";
    }
    if (contains(navigator.platform, "Linux")) {
      return "linux";
    }
    if (contains(navigator.userAgent, "iPad") || contains(navigator.platform, "iPod") || contains(navigator.platform, "iPhone")) {
      return "ios";
    }
    return "";
  })();
  var browser = (function() {
    if (contains(navigator.userAgent, "Chrome/")) {
      return "chrome";
    }
    if (contains(navigator.vendor, "Apple")) {
      return "safari";
    }
    if (contains(navigator.userAgent, "MSIE")) {
      return "ie";
    }
    if (contains(navigator.userAgent, "Gecko/")) {
      return "moz";
    }
    if (contains(navigator.userAgent, "Opera/")) {
      return "opera";
    }
    return "";
  })();
  var browser_os = browser + "-" + os;
  function mergeIf(baseTable, select2, table) {
    if (browser_os === select2 || browser === select2 || os === select2) {
      Object.keys(table).forEach(function(keyCode) {
        baseTable[keyCode] = table[keyCode];
      });
    }
  }
  function remap2(o2, key) {
    var r2 = {};
    Object.keys(o2).forEach(function(k2) {
      var item = o2[k2];
      if (key in item) {
        r2[item[key]] = item;
      }
    });
    return r2;
  }
  function invert2(o2) {
    var r2 = {};
    Object.keys(o2).forEach(function(k2) {
      r2[o2[k2]] = k2;
    });
    return r2;
  }
  var keyCodeToInfoTable = {
    // 0x01 - VK_LBUTTON
    // 0x02 - VK_RBUTTON
    3: { code: "Cancel" },
    // [USB: 0x9b] char \x0018 ??? (Not in D3E)
    // 0x04 - VK_MBUTTON
    // 0x05 - VK_XBUTTON1
    // 0x06 - VK_XBUTTON2
    6: { code: "Help" },
    // [USB: 0x75] ???
    // 0x07 - undefined
    8: { code: "Backspace" },
    // [USB: 0x2a] Labelled Delete on Macintosh keyboards.
    9: { code: "Tab" },
    // [USB: 0x2b]
    // 0x0A-0x0B - reserved
    12: { code: "Clear" },
    // [USB: 0x9c] NumPad Center (Not in D3E)
    13: { code: "Enter" },
    // [USB: 0x28]
    // 0x0E-0x0F - undefined
    16: { code: "Shift" },
    17: { code: "Control" },
    18: { code: "Alt" },
    19: { code: "Pause" },
    // [USB: 0x48]
    20: { code: "CapsLock" },
    // [USB: 0x39]
    21: { code: "KanaMode" },
    // [USB: 0x88] - "HangulMode" for Korean layout
    22: { code: "HangulMode" },
    // [USB: 0x90] 0x15 as well in MSDN VK table ???
    23: { code: "JunjaMode" },
    // (Not in D3E)
    24: { code: "FinalMode" },
    // (Not in D3E)
    25: { code: "KanjiMode" },
    // [USB: 0x91] - "HanjaMode" for Korean layout
    // 0x1A - undefined
    27: { code: "Escape" },
    // [USB: 0x29]
    28: { code: "Convert" },
    // [USB: 0x8a]
    29: { code: "NonConvert" },
    // [USB: 0x8b]
    30: { code: "Accept" },
    // (Not in D3E)
    31: { code: "ModeChange" },
    // (Not in D3E)
    32: { code: "Space" },
    // [USB: 0x2c]
    33: { code: "PageUp" },
    // [USB: 0x4b]
    34: { code: "PageDown" },
    // [USB: 0x4e]
    35: { code: "End" },
    // [USB: 0x4d]
    36: { code: "Home" },
    // [USB: 0x4a]
    37: { code: "ArrowLeft" },
    // [USB: 0x50]
    38: { code: "ArrowUp" },
    // [USB: 0x52]
    39: { code: "ArrowRight" },
    // [USB: 0x4f]
    40: { code: "ArrowDown" },
    // [USB: 0x51]
    41: { code: "Select" },
    // (Not in D3E)
    42: { code: "Print" },
    // (Not in D3E)
    43: { code: "Execute" },
    // [USB: 0x74] (Not in D3E)
    44: { code: "PrintScreen" },
    // [USB: 0x46]
    45: { code: "Insert" },
    // [USB: 0x49]
    46: { code: "Delete" },
    // [USB: 0x4c]
    47: { code: "Help" },
    // [USB: 0x75] ???
    48: { code: "Digit0", keyCap: "0" },
    // [USB: 0x27] 0)
    49: { code: "Digit1", keyCap: "1" },
    // [USB: 0x1e] 1!
    50: { code: "Digit2", keyCap: "2" },
    // [USB: 0x1f] 2@
    51: { code: "Digit3", keyCap: "3" },
    // [USB: 0x20] 3#
    52: { code: "Digit4", keyCap: "4" },
    // [USB: 0x21] 4$
    53: { code: "Digit5", keyCap: "5" },
    // [USB: 0x22] 5%
    54: { code: "Digit6", keyCap: "6" },
    // [USB: 0x23] 6^
    55: { code: "Digit7", keyCap: "7" },
    // [USB: 0x24] 7&
    56: { code: "Digit8", keyCap: "8" },
    // [USB: 0x25] 8*
    57: { code: "Digit9", keyCap: "9" },
    // [USB: 0x26] 9(
    // 0x3A-0x40 - undefined
    65: { code: "KeyA", keyCap: "a" },
    // [USB: 0x04]
    66: { code: "KeyB", keyCap: "b" },
    // [USB: 0x05]
    67: { code: "KeyC", keyCap: "c" },
    // [USB: 0x06]
    68: { code: "KeyD", keyCap: "d" },
    // [USB: 0x07]
    69: { code: "KeyE", keyCap: "e" },
    // [USB: 0x08]
    70: { code: "KeyF", keyCap: "f" },
    // [USB: 0x09]
    71: { code: "KeyG", keyCap: "g" },
    // [USB: 0x0a]
    72: { code: "KeyH", keyCap: "h" },
    // [USB: 0x0b]
    73: { code: "KeyI", keyCap: "i" },
    // [USB: 0x0c]
    74: { code: "KeyJ", keyCap: "j" },
    // [USB: 0x0d]
    75: { code: "KeyK", keyCap: "k" },
    // [USB: 0x0e]
    76: { code: "KeyL", keyCap: "l" },
    // [USB: 0x0f]
    77: { code: "KeyM", keyCap: "m" },
    // [USB: 0x10]
    78: { code: "KeyN", keyCap: "n" },
    // [USB: 0x11]
    79: { code: "KeyO", keyCap: "o" },
    // [USB: 0x12]
    80: { code: "KeyP", keyCap: "p" },
    // [USB: 0x13]
    81: { code: "KeyQ", keyCap: "q" },
    // [USB: 0x14]
    82: { code: "KeyR", keyCap: "r" },
    // [USB: 0x15]
    83: { code: "KeyS", keyCap: "s" },
    // [USB: 0x16]
    84: { code: "KeyT", keyCap: "t" },
    // [USB: 0x17]
    85: { code: "KeyU", keyCap: "u" },
    // [USB: 0x18]
    86: { code: "KeyV", keyCap: "v" },
    // [USB: 0x19]
    87: { code: "KeyW", keyCap: "w" },
    // [USB: 0x1a]
    88: { code: "KeyX", keyCap: "x" },
    // [USB: 0x1b]
    89: { code: "KeyY", keyCap: "y" },
    // [USB: 0x1c]
    90: { code: "KeyZ", keyCap: "z" },
    // [USB: 0x1d]
    91: { code: "OSLeft", location: LEFT },
    // [USB: 0xe3]
    92: { code: "OSRight", location: RIGHT },
    // [USB: 0xe7]
    93: { code: "ContextMenu" },
    // [USB: 0x65] Context Menu
    // 0x5E - reserved
    95: { code: "Standby" },
    // [USB: 0x82] Sleep
    96: { code: "Numpad0", keyCap: "0", location: NUMPAD },
    // [USB: 0x62]
    97: { code: "Numpad1", keyCap: "1", location: NUMPAD },
    // [USB: 0x59]
    98: { code: "Numpad2", keyCap: "2", location: NUMPAD },
    // [USB: 0x5a]
    99: { code: "Numpad3", keyCap: "3", location: NUMPAD },
    // [USB: 0x5b]
    100: { code: "Numpad4", keyCap: "4", location: NUMPAD },
    // [USB: 0x5c]
    101: { code: "Numpad5", keyCap: "5", location: NUMPAD },
    // [USB: 0x5d]
    102: { code: "Numpad6", keyCap: "6", location: NUMPAD },
    // [USB: 0x5e]
    103: { code: "Numpad7", keyCap: "7", location: NUMPAD },
    // [USB: 0x5f]
    104: { code: "Numpad8", keyCap: "8", location: NUMPAD },
    // [USB: 0x60]
    105: { code: "Numpad9", keyCap: "9", location: NUMPAD },
    // [USB: 0x61]
    106: { code: "NumpadMultiply", keyCap: "*", location: NUMPAD },
    // [USB: 0x55]
    107: { code: "NumpadAdd", keyCap: "+", location: NUMPAD },
    // [USB: 0x57]
    108: { code: "NumpadComma", keyCap: ",", location: NUMPAD },
    // [USB: 0x85]
    109: { code: "NumpadSubtract", keyCap: "-", location: NUMPAD },
    // [USB: 0x56]
    110: { code: "NumpadDecimal", keyCap: ".", location: NUMPAD },
    // [USB: 0x63]
    111: { code: "NumpadDivide", keyCap: "/", location: NUMPAD },
    // [USB: 0x54]
    112: { code: "F1" },
    // [USB: 0x3a]
    113: { code: "F2" },
    // [USB: 0x3b]
    114: { code: "F3" },
    // [USB: 0x3c]
    115: { code: "F4" },
    // [USB: 0x3d]
    116: { code: "F5" },
    // [USB: 0x3e]
    117: { code: "F6" },
    // [USB: 0x3f]
    118: { code: "F7" },
    // [USB: 0x40]
    119: { code: "F8" },
    // [USB: 0x41]
    120: { code: "F9" },
    // [USB: 0x42]
    121: { code: "F10" },
    // [USB: 0x43]
    122: { code: "F11" },
    // [USB: 0x44]
    123: { code: "F12" },
    // [USB: 0x45]
    124: { code: "F13" },
    // [USB: 0x68]
    125: { code: "F14" },
    // [USB: 0x69]
    126: { code: "F15" },
    // [USB: 0x6a]
    127: { code: "F16" },
    // [USB: 0x6b]
    128: { code: "F17" },
    // [USB: 0x6c]
    129: { code: "F18" },
    // [USB: 0x6d]
    130: { code: "F19" },
    // [USB: 0x6e]
    131: { code: "F20" },
    // [USB: 0x6f]
    132: { code: "F21" },
    // [USB: 0x70]
    133: { code: "F22" },
    // [USB: 0x71]
    134: { code: "F23" },
    // [USB: 0x72]
    135: { code: "F24" },
    // [USB: 0x73]
    // 0x88-0x8F - unassigned
    144: { code: "NumLock", location: NUMPAD },
    // [USB: 0x53]
    145: { code: "ScrollLock" },
    // [USB: 0x47]
    // 0x92-0x96 - OEM specific
    // 0x97-0x9F - unassigned
    // NOTE: 0xA0-0xA5 usually mapped to 0x10-0x12 in browsers
    160: { code: "ShiftLeft", location: LEFT },
    // [USB: 0xe1]
    161: { code: "ShiftRight", location: RIGHT },
    // [USB: 0xe5]
    162: { code: "ControlLeft", location: LEFT },
    // [USB: 0xe0]
    163: { code: "ControlRight", location: RIGHT },
    // [USB: 0xe4]
    164: { code: "AltLeft", location: LEFT },
    // [USB: 0xe2]
    165: { code: "AltRight", location: RIGHT },
    // [USB: 0xe6]
    166: { code: "BrowserBack" },
    // [USB: 0x0c/0x0224]
    167: { code: "BrowserForward" },
    // [USB: 0x0c/0x0225]
    168: { code: "BrowserRefresh" },
    // [USB: 0x0c/0x0227]
    169: { code: "BrowserStop" },
    // [USB: 0x0c/0x0226]
    170: { code: "BrowserSearch" },
    // [USB: 0x0c/0x0221]
    171: { code: "BrowserFavorites" },
    // [USB: 0x0c/0x0228]
    172: { code: "BrowserHome" },
    // [USB: 0x0c/0x0222]
    173: { code: "VolumeMute" },
    // [USB: 0x7f]
    174: { code: "VolumeDown" },
    // [USB: 0x81]
    175: { code: "VolumeUp" },
    // [USB: 0x80]
    176: { code: "MediaTrackNext" },
    // [USB: 0x0c/0x00b5]
    177: { code: "MediaTrackPrevious" },
    // [USB: 0x0c/0x00b6]
    178: { code: "MediaStop" },
    // [USB: 0x0c/0x00b7]
    179: { code: "MediaPlayPause" },
    // [USB: 0x0c/0x00cd]
    180: { code: "LaunchMail" },
    // [USB: 0x0c/0x018a]
    181: { code: "MediaSelect" },
    182: { code: "LaunchApp1" },
    183: { code: "LaunchApp2" },
    // 0xB8-0xB9 - reserved
    186: { code: "Semicolon", keyCap: ";" },
    // [USB: 0x33] ;: (US Standard 101)
    187: { code: "Equal", keyCap: "=" },
    // [USB: 0x2e] =+
    188: { code: "Comma", keyCap: "," },
    // [USB: 0x36] ,<
    189: { code: "Minus", keyCap: "-" },
    // [USB: 0x2d] -_
    190: { code: "Period", keyCap: "." },
    // [USB: 0x37] .>
    191: { code: "Slash", keyCap: "/" },
    // [USB: 0x38] /? (US Standard 101)
    192: { code: "Backquote", keyCap: "`" },
    // [USB: 0x35] `~ (US Standard 101)
    // 0xC1-0xCF - reserved
    // 0xD0-0xD7 - reserved
    // 0xD8-0xDA - unassigned
    219: { code: "BracketLeft", keyCap: "[" },
    // [USB: 0x2f] [{ (US Standard 101)
    220: { code: "Backslash", keyCap: "\\" },
    // [USB: 0x31] \| (US Standard 101)
    221: { code: "BracketRight", keyCap: "]" },
    // [USB: 0x30] ]} (US Standard 101)
    222: { code: "Quote", keyCap: "'" },
    // [USB: 0x34] '" (US Standard 101)
    // 0xDF - miscellaneous/varies
    // 0xE0 - reserved
    // 0xE1 - OEM specific
    226: { code: "IntlBackslash", keyCap: "\\" },
    // [USB: 0x64] \| (UK Standard 102)
    // 0xE3-0xE4 - OEM specific
    229: { code: "Process" },
    // (Not in D3E)
    // 0xE6 - OEM specific
    // 0xE7 - VK_PACKET
    // 0xE8 - unassigned
    // 0xE9-0xEF - OEM specific
    // 0xF0-0xF5 - OEM specific
    246: { code: "Attn" },
    // [USB: 0x9a] (Not in D3E)
    247: { code: "CrSel" },
    // [USB: 0xa3] (Not in D3E)
    248: { code: "ExSel" },
    // [USB: 0xa4] (Not in D3E)
    249: { code: "EraseEof" },
    // (Not in D3E)
    250: { code: "Play" },
    // (Not in D3E)
    251: { code: "ZoomToggle" },
    // (Not in D3E)
    // 0xFC - VK_NONAME - reserved
    // 0xFD - VK_PA1
    254: { code: "Clear" }
    // [USB: 0x9c] (Not in D3E)
  };
  mergeIf(
    keyCodeToInfoTable,
    "moz",
    {
      59: { code: "Semicolon", keyCap: ";" },
      // [USB: 0x33] ;: (US Standard 101)
      61: { code: "Equal", keyCap: "=" },
      // [USB: 0x2e] =+
      107: { code: "Equal", keyCap: "=" },
      // [USB: 0x2e] =+
      109: { code: "Minus", keyCap: "-" },
      // [USB: 0x2d] -_
      187: { code: "NumpadAdd", keyCap: "+", location: NUMPAD },
      // [USB: 0x57]
      189: { code: "NumpadSubtract", keyCap: "-", location: NUMPAD }
      // [USB: 0x56]
    }
  );
  mergeIf(
    keyCodeToInfoTable,
    "moz-mac",
    {
      12: { code: "NumLock", location: NUMPAD },
      // [USB: 0x53]
      173: { code: "Minus", keyCap: "-" }
      // [USB: 0x2d] -_
    }
  );
  mergeIf(
    keyCodeToInfoTable,
    "moz-win",
    {
      173: { code: "Minus", keyCap: "-" }
      // [USB: 0x2d] -_
    }
  );
  mergeIf(
    keyCodeToInfoTable,
    "chrome-mac",
    {
      93: { code: "OSRight", location: RIGHT }
      // [USB: 0xe7]
    }
  );
  if (0) {
    mergeIf(
      keyCodeToInfoTable,
      "chrome-win",
      {
        192: { code: "Quote", keyCap: "'" },
        // [USB: 0x34] '" (US Standard 101)
        222: { code: "Backslash", keyCap: "\\" },
        // [USB: 0x31] \| (US Standard 101)
        223: { code: "Backquote", keyCap: "`" }
        // [USB: 0x35] `~ (US Standard 101)
      }
    );
    mergeIf(
      keyCodeToInfoTable,
      "ie",
      {
        192: { code: "Quote", keyCap: "'" },
        // [USB: 0x34] '" (US Standard 101)
        222: { code: "Backslash", keyCap: "\\" },
        // [USB: 0x31] \| (US Standard 101)
        223: { code: "Backquote", keyCap: "`" }
        // [USB: 0x35] `~ (US Standard 101)
      }
    );
  }
  mergeIf(
    keyCodeToInfoTable,
    "safari",
    {
      3: { code: "Enter" },
      // [USB: 0x28] old Safari
      25: { code: "Tab" }
      // [USB: 0x2b] old Safari for Shift+Tab
    }
  );
  mergeIf(
    keyCodeToInfoTable,
    "ios",
    {
      10: { code: "Enter", location: STANDARD }
      // [USB: 0x28]
    }
  );
  mergeIf(
    keyCodeToInfoTable,
    "safari-mac",
    {
      91: { code: "OSLeft", location: LEFT },
      // [USB: 0xe3]
      93: { code: "OSRight", location: RIGHT },
      // [USB: 0xe7]
      229: { code: "KeyQ", keyCap: "Q" }
      // [USB: 0x14] On alternate presses, Ctrl+Q sends this
    }
  );
  var keyIdentifierTable = {};
  if ("cros" === os) {
    keyIdentifierTable["U+00A0"] = { code: "ShiftLeft", location: LEFT };
    keyIdentifierTable["U+00A1"] = { code: "ShiftRight", location: RIGHT };
    keyIdentifierTable["U+00A2"] = { code: "ControlLeft", location: LEFT };
    keyIdentifierTable["U+00A3"] = { code: "ControlRight", location: RIGHT };
    keyIdentifierTable["U+00A4"] = { code: "AltLeft", location: LEFT };
    keyIdentifierTable["U+00A5"] = { code: "AltRight", location: RIGHT };
  }
  if ("chrome-mac" === browser_os) {
    keyIdentifierTable["U+0010"] = { code: "ContextMenu" };
  }
  if ("safari-mac" === browser_os) {
    keyIdentifierTable["U+0010"] = { code: "ContextMenu" };
  }
  if ("ios" === os) {
    keyIdentifierTable["U+0010"] = { code: "Function" };
    keyIdentifierTable["U+001C"] = { code: "ArrowLeft" };
    keyIdentifierTable["U+001D"] = { code: "ArrowRight" };
    keyIdentifierTable["U+001E"] = { code: "ArrowUp" };
    keyIdentifierTable["U+001F"] = { code: "ArrowDown" };
    keyIdentifierTable["U+0001"] = { code: "Home" };
    keyIdentifierTable["U+0004"] = { code: "End" };
    keyIdentifierTable["U+000B"] = { code: "PageUp" };
    keyIdentifierTable["U+000C"] = { code: "PageDown" };
  }
  var locationTable = [];
  locationTable[LEFT] = {
    16: { code: "ShiftLeft", location: LEFT },
    // [USB: 0xe1]
    17: { code: "ControlLeft", location: LEFT },
    // [USB: 0xe0]
    18: { code: "AltLeft", location: LEFT }
    // [USB: 0xe2]
  };
  locationTable[RIGHT] = {
    16: { code: "ShiftRight", location: RIGHT },
    // [USB: 0xe5]
    17: { code: "ControlRight", location: RIGHT },
    // [USB: 0xe4]
    18: { code: "AltRight", location: RIGHT }
    // [USB: 0xe6]
  };
  locationTable[NUMPAD] = {
    13: { code: "NumpadEnter", location: NUMPAD }
    // [USB: 0x58]
  };
  mergeIf(locationTable[NUMPAD], "moz", {
    109: { code: "NumpadSubtract", location: NUMPAD },
    // [USB: 0x56]
    107: { code: "NumpadAdd", location: NUMPAD }
    // [USB: 0x57]
  });
  mergeIf(locationTable[LEFT], "moz-mac", {
    224: { code: "OSLeft", location: LEFT }
    // [USB: 0xe3]
  });
  mergeIf(locationTable[RIGHT], "moz-mac", {
    224: { code: "OSRight", location: RIGHT }
    // [USB: 0xe7]
  });
  mergeIf(locationTable[RIGHT], "moz-win", {
    91: { code: "OSRight", location: RIGHT }
    // [USB: 0xe7]
  });
  mergeIf(locationTable[RIGHT], "mac", {
    93: { code: "OSRight", location: RIGHT }
    // [USB: 0xe7]
  });
  mergeIf(locationTable[NUMPAD], "chrome-mac", {
    12: { code: "NumLock", location: NUMPAD }
    // [USB: 0x53]
  });
  mergeIf(locationTable[NUMPAD], "safari-mac", {
    12: { code: "NumLock", location: NUMPAD },
    // [USB: 0x53]
    187: { code: "NumpadAdd", location: NUMPAD },
    // [USB: 0x57]
    189: { code: "NumpadSubtract", location: NUMPAD },
    // [USB: 0x56]
    190: { code: "NumpadDecimal", location: NUMPAD },
    // [USB: 0x63]
    191: { code: "NumpadDivide", location: NUMPAD }
    // [USB: 0x54]
  });
  var codeToKeyTable = {
    // Modifier Keys
    ShiftLeft: { key: "Shift" },
    ShiftRight: { key: "Shift" },
    ControlLeft: { key: "Control" },
    ControlRight: { key: "Control" },
    AltLeft: { key: "Alt" },
    AltRight: { key: "Alt" },
    OSLeft: { key: "OS" },
    OSRight: { key: "OS" },
    // Whitespace Keys
    NumpadEnter: { key: "Enter" },
    Space: { key: " " },
    // Printable Keys
    Digit0: { key: "0", shiftKey: ")" },
    Digit1: { key: "1", shiftKey: "!" },
    Digit2: { key: "2", shiftKey: "@" },
    Digit3: { key: "3", shiftKey: "#" },
    Digit4: { key: "4", shiftKey: "$" },
    Digit5: { key: "5", shiftKey: "%" },
    Digit6: { key: "6", shiftKey: "^" },
    Digit7: { key: "7", shiftKey: "&" },
    Digit8: { key: "8", shiftKey: "*" },
    Digit9: { key: "9", shiftKey: "(" },
    KeyA: { key: "a", shiftKey: "A" },
    KeyB: { key: "b", shiftKey: "B" },
    KeyC: { key: "c", shiftKey: "C" },
    KeyD: { key: "d", shiftKey: "D" },
    KeyE: { key: "e", shiftKey: "E" },
    KeyF: { key: "f", shiftKey: "F" },
    KeyG: { key: "g", shiftKey: "G" },
    KeyH: { key: "h", shiftKey: "H" },
    KeyI: { key: "i", shiftKey: "I" },
    KeyJ: { key: "j", shiftKey: "J" },
    KeyK: { key: "k", shiftKey: "K" },
    KeyL: { key: "l", shiftKey: "L" },
    KeyM: { key: "m", shiftKey: "M" },
    KeyN: { key: "n", shiftKey: "N" },
    KeyO: { key: "o", shiftKey: "O" },
    KeyP: { key: "p", shiftKey: "P" },
    KeyQ: { key: "q", shiftKey: "Q" },
    KeyR: { key: "r", shiftKey: "R" },
    KeyS: { key: "s", shiftKey: "S" },
    KeyT: { key: "t", shiftKey: "T" },
    KeyU: { key: "u", shiftKey: "U" },
    KeyV: { key: "v", shiftKey: "V" },
    KeyW: { key: "w", shiftKey: "W" },
    KeyX: { key: "x", shiftKey: "X" },
    KeyY: { key: "y", shiftKey: "Y" },
    KeyZ: { key: "z", shiftKey: "Z" },
    Numpad0: { key: "0" },
    Numpad1: { key: "1" },
    Numpad2: { key: "2" },
    Numpad3: { key: "3" },
    Numpad4: { key: "4" },
    Numpad5: { key: "5" },
    Numpad6: { key: "6" },
    Numpad7: { key: "7" },
    Numpad8: { key: "8" },
    Numpad9: { key: "9" },
    NumpadMultiply: { key: "*" },
    NumpadAdd: { key: "+" },
    NumpadComma: { key: "," },
    NumpadSubtract: { key: "-" },
    NumpadDecimal: { key: "." },
    NumpadDivide: { key: "/" },
    Semicolon: { key: ";", shiftKey: ":" },
    Equal: { key: "=", shiftKey: "+" },
    Comma: { key: ",", shiftKey: "<" },
    Minus: { key: "-", shiftKey: "_" },
    Period: { key: ".", shiftKey: ">" },
    Slash: { key: "/", shiftKey: "?" },
    Backquote: { key: "`", shiftKey: "~" },
    BracketLeft: { key: "[", shiftKey: "{" },
    Backslash: { key: "\\", shiftKey: "|" },
    BracketRight: { key: "]", shiftKey: "}" },
    Quote: { key: "'", shiftKey: '"' },
    IntlBackslash: { key: "\\", shiftKey: "|" }
  };
  mergeIf(codeToKeyTable, "mac", {
    OSLeft: { key: "Meta" },
    OSRight: { key: "Meta" }
  });
  var keyFixTable = {
    Esc: "Escape",
    Nonconvert: "NonConvert",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Menu: "ContextMenu",
    MediaNextTrack: "MediaTrackNext",
    MediaPreviousTrack: "MediaTrackPrevious",
    SelectMedia: "MediaSelect",
    HalfWidth: "Hankaku",
    FullWidth: "Zenkaku",
    RomanCharacters: "Romaji",
    Crsel: "CrSel",
    Exsel: "ExSel",
    Zoom: "ZoomToggle"
  };
  var codeTable = remap2(keyCodeToInfoTable, "code");
  try {
    var nativeLocation = nativeKeyboardEvent && "location" in new KeyboardEvent("");
  } catch (_2) {
  }
  function keyInfoForEvent(event) {
    var keyCode = "keyCode" in event ? event.keyCode : "which" in event ? event.which : 0;
    var keyInfo = (function() {
      if (nativeLocation || "keyLocation" in event) {
        var location = nativeLocation ? event.location : event.keyLocation;
        if (location && keyCode in locationTable[location]) {
          return locationTable[location][keyCode];
        }
      }
      if ("keyIdentifier" in event && event.keyIdentifier in keyIdentifierTable) {
        return keyIdentifierTable[event.keyIdentifier];
      }
      if (keyCode in keyCodeToInfoTable) {
        return keyCodeToInfoTable[keyCode];
      }
      return null;
    })();
    if (0) {
      switch (event.keyIdentifier) {
        case "U+0010":
          keyInfo = { code: "Function" };
          break;
        case "U+001C":
          keyInfo = { code: "ArrowLeft" };
          break;
        case "U+001D":
          keyInfo = { code: "ArrowRight" };
          break;
        case "U+001E":
          keyInfo = { code: "ArrowUp" };
          break;
        case "U+001F":
          keyInfo = { code: "ArrowDown" };
          break;
      }
    }
    if (!keyInfo)
      return null;
    var key = (function() {
      var entry = codeToKeyTable[keyInfo.code];
      if (!entry) return keyInfo.code;
      return event.shiftKey && "shiftKey" in entry ? entry.shiftKey : entry.key;
    })();
    return {
      code: keyInfo.code,
      key,
      location: keyInfo.location,
      keyCap: keyInfo.keyCap
    };
  }
  function queryKeyCap(code2, locale3) {
    code2 = String(code2);
    if (!codeTable.hasOwnProperty(code2)) return "Undefined";
    if (locale3 && String(locale3).toLowerCase() !== "en-us") throw Error("Unsupported locale");
    var keyInfo = codeTable[code2];
    return keyInfo.keyCap || keyInfo.code || "Undefined";
  }
  if ("KeyboardEvent" in global2 && "defineProperty" in Object) {
    (function() {
      function define(o2, p3, v2) {
        if (p3 in o2) return;
        Object.defineProperty(o2, p3, v2);
      }
      define(KeyboardEvent.prototype, "code", { get: function() {
        var keyInfo = keyInfoForEvent(this);
        return keyInfo ? keyInfo.code : "";
      } });
      if ("key" in KeyboardEvent.prototype) {
        var desc = Object.getOwnPropertyDescriptor(KeyboardEvent.prototype, "key");
        Object.defineProperty(KeyboardEvent.prototype, "key", { get: function() {
          var key = desc.get.call(this);
          return keyFixTable.hasOwnProperty(key) ? keyFixTable[key] : key;
        } });
      }
      define(KeyboardEvent.prototype, "key", { get: function() {
        var keyInfo = keyInfoForEvent(this);
        return keyInfo && "key" in keyInfo ? keyInfo.key : "Unidentified";
      } });
      define(KeyboardEvent.prototype, "location", { get: function() {
        var keyInfo = keyInfoForEvent(this);
        return keyInfo && "location" in keyInfo ? keyInfo.location : STANDARD;
      } });
      define(KeyboardEvent.prototype, "locale", { get: function() {
        return "";
      } });
    })();
  }
  if (!("queryKeyCap" in global2.KeyboardEvent))
    global2.KeyboardEvent.queryKeyCap = queryKeyCap;
  global2.identifyKey = function(event) {
    if ("code" in event)
      return;
    var keyInfo = keyInfoForEvent(event);
    event.code = keyInfo ? keyInfo.code : "";
    event.key = keyInfo && "key" in keyInfo ? keyInfo.key : "Unidentified";
    event.location = "location" in event ? event.location : "keyLocation" in event ? event.keyLocation : keyInfo && "location" in keyInfo ? keyInfo.location : STANDARD;
    event.locale = "";
  };
})(window);

// node_modules/aframe-extras/src/controls/keyboard-controls.js
var PROXY_FLAG = "__keyboard-controls-proxy";
var KeyboardEvent2 = window.KeyboardEvent;
AFRAME.registerComponent("keyboard-controls", {
  schema: {
    enabled: { default: true },
    debug: { default: false }
  },
  init: function() {
    this.dVelocity = new THREE.Vector3();
    this.localKeys = {};
    this.listeners = {
      keydown: this.onKeyDown.bind(this),
      keyup: this.onKeyUp.bind(this),
      blur: this.onBlur.bind(this),
      onContextMenu: this.onContextMenu.bind(this)
    };
  },
  /*******************************************************************
  * Movement
  */
  isVelocityActive: function() {
    return this.data.enabled && !!Object.keys(this.getKeys()).length;
  },
  getVelocityDelta: function() {
    const data = this.data;
    const keys2 = this.getKeys();
    this.dVelocity.set(0, 0, 0);
    if (data.enabled) {
      if (keys2.KeyW || keys2.ArrowUp) {
        this.dVelocity.z -= 1;
      }
      if (keys2.KeyA || keys2.ArrowLeft) {
        this.dVelocity.x -= 1;
      }
      if (keys2.KeyS || keys2.ArrowDown) {
        this.dVelocity.z += 1;
      }
      if (keys2.KeyD || keys2.ArrowRight) {
        this.dVelocity.x += 1;
      }
      if (keys2.ShiftLeft) {
        this.dVelocity = this.dVelocity.multiplyScalar(2);
      }
    }
    return this.dVelocity.clone();
  },
  /*******************************************************************
  * Events
  */
  play: function() {
    this.attachEventListeners();
  },
  pause: function() {
    this.removeEventListeners();
  },
  attachEventListeners: function() {
    window.addEventListener("contextmenu", this.listeners.onContextMenu, false);
    window.addEventListener("keydown", this.listeners.keydown, false);
    window.addEventListener("keyup", this.listeners.keyup, false);
    window.addEventListener("blur", this.listeners.blur, false);
  },
  onContextMenu: function() {
    for (const code2 in this.localKeys) {
      if (this.localKeys.hasOwnProperty(code2)) {
        delete this.localKeys[code2];
      }
    }
  },
  removeEventListeners: function() {
    window.removeEventListener("keydown", this.listeners.keydown);
    window.removeEventListener("keyup", this.listeners.keyup);
    window.removeEventListener("blur", this.listeners.blur);
  },
  onKeyDown: function(event) {
    if (AFRAME.utils.shouldCaptureKeyEvent(event)) {
      this.localKeys[event.code] = true;
      this.emit(event);
    }
  },
  onKeyUp: function(event) {
    if (AFRAME.utils.shouldCaptureKeyEvent(event)) {
      delete this.localKeys[event.code];
      this.emit(event);
    }
  },
  onBlur: function() {
    for (const code2 in this.localKeys) {
      if (this.localKeys.hasOwnProperty(code2)) {
        delete this.localKeys[code2];
      }
    }
  },
  emit: function(event) {
    if (PROXY_FLAG in event) {
      this.el.emit(event.type, event);
    }
    this.el.emit(event.type + ":" + event.code, new KeyboardEvent2(event.type, event));
    if (this.data.debug) console.log(event.type + ":" + event.code);
  },
  /*******************************************************************
  * Accessors
  */
  isPressed: function(code2) {
    return code2 in this.getKeys();
  },
  getKeys: function() {
    if (this.isProxied()) {
      return this.el.sceneEl.components["proxy-controls"].getKeyboard();
    }
    return this.localKeys;
  },
  isProxied: function() {
    const proxyControls = this.el.sceneEl.components["proxy-controls"];
    return proxyControls && proxyControls.isConnected();
  }
});

// node_modules/aframe-extras/src/controls/touch-controls.js
AFRAME.registerComponent("touch-controls", {
  schema: {
    enabled: { default: true },
    reverseEnabled: { default: true }
  },
  init: function() {
    this.dVelocity = new THREE.Vector3();
    this.bindMethods();
    this.direction = 0;
  },
  play: function() {
    this.addEventListeners();
  },
  pause: function() {
    this.removeEventListeners();
    this.dVelocity.set(0, 0, 0);
  },
  remove: function() {
    this.pause();
  },
  addEventListeners: function() {
    const sceneEl = this.el.sceneEl;
    const canvasEl = sceneEl.canvas;
    if (!canvasEl) {
      sceneEl.addEventListener("render-target-loaded", this.addEventListeners.bind(this));
      return;
    }
    canvasEl.addEventListener("touchstart", this.onTouchStart, { passive: true });
    canvasEl.addEventListener("touchend", this.onTouchEnd, { passive: true });
    const vrModeUI = sceneEl.getAttribute("vr-mode-ui");
    if (vrModeUI && vrModeUI.cardboardModeEnabled) {
      sceneEl.addEventListener("enter-vr", this.onEnterVR);
    }
  },
  removeEventListeners: function() {
    const canvasEl = this.el.sceneEl && this.el.sceneEl.canvas;
    if (!canvasEl) {
      return;
    }
    canvasEl.removeEventListener("touchstart", this.onTouchStart);
    canvasEl.removeEventListener("touchend", this.onTouchEnd);
    this.el.sceneEl.removeEventListener("enter-vr", this.onEnterVR);
  },
  isVelocityActive: function() {
    return this.data.enabled && !!this.direction;
  },
  getVelocityDelta: function() {
    this.dVelocity.z = this.direction;
    return this.dVelocity.clone();
  },
  bindMethods: function() {
    this.onTouchStart = this.onTouchStart.bind(this);
    this.onTouchEnd = this.onTouchEnd.bind(this);
    this.onEnterVR = this.onEnterVR.bind(this);
  },
  onTouchStart: function(e3) {
    this.direction = -1;
    if (this.data.reverseEnabled && e3.touches && e3.touches.length === 2) {
      this.direction = 1;
    }
    e3.preventDefault();
  },
  onTouchEnd: function(e3) {
    this.direction = 0;
    e3.preventDefault();
  },
  onEnterVR: function() {
    const xrSession = this.el.sceneEl.xrSession;
    if (!xrSession) {
      return;
    }
    xrSession.addEventListener("selectstart", this.onTouchStart);
    xrSession.addEventListener("selectend", this.onTouchEnd);
  }
});

// node_modules/aframe-extras/src/controls/movement-controls.js
var COMPONENT_SUFFIX = "-controls";
var MAX_DELTA = 0.2;
var EPS2 = 1e-5;
var MOVED = "moved";
AFRAME.registerComponent("movement-controls", {
  /*******************************************************************
   * Schema
   */
  dependencies: ["rotation"],
  schema: {
    enabled: { default: true },
    controls: { default: ["gamepad", "trackpad", "keyboard", "touch"] },
    speed: { default: 0.3, min: 0 },
    fly: { default: false },
    constrainToNavMesh: { default: false },
    camera: { default: "[movement-controls] [camera]", type: "selector" }
  },
  /*******************************************************************
   * Lifecycle
   */
  init: function() {
    const el = this.el;
    if (!this.data.camera) {
      this.data.camera = el.querySelector("[camera]");
    }
    this.velocityCtrl = null;
    this.velocity = new THREE.Vector3();
    this.heading = new THREE.Quaternion();
    this.eventDetail = {};
    this.navGroup = null;
    this.navNode = null;
    if (el.sceneEl.hasLoaded) {
      this.injectControls();
    } else {
      el.sceneEl.addEventListener("loaded", this.injectControls.bind(this));
    }
  },
  update: function(prevData) {
    const el = this.el;
    const data = this.data;
    const nav = el.sceneEl.systems.nav;
    if (el.sceneEl.hasLoaded) {
      this.injectControls();
    }
    if (nav && data.constrainToNavMesh !== prevData.constrainToNavMesh) {
      data.constrainToNavMesh ? nav.addAgent(this) : nav.removeAgent(this);
    }
    if (data.enabled !== prevData.enabled) {
      for (let i2 = 0; i2 < data.controls.length; i2++) {
        const name = data.controls[i2] + COMPONENT_SUFFIX;
        this.el.setAttribute(name, { enabled: this.data.enabled });
      }
    }
  },
  injectControls: function() {
    const data = this.data;
    for (let i2 = 0; i2 < data.controls.length; i2++) {
      const name = data.controls[i2] + COMPONENT_SUFFIX;
      this.el.setAttribute(name, { enabled: this.data.enabled });
    }
  },
  updateNavLocation: function() {
    this.navGroup = null;
    this.navNode = null;
  },
  /*******************************************************************
   * Tick
   */
  tick: (function() {
    const start2 = new THREE.Vector3();
    const end = new THREE.Vector3();
    const clampedEnd = new THREE.Vector3();
    return function(t5, dt) {
      if (!dt) return;
      const el = this.el;
      const data = this.data;
      if (!data.enabled) return;
      this.updateVelocityCtrl();
      const velocityCtrl = this.velocityCtrl;
      const velocity2 = this.velocity;
      if (!velocityCtrl) return;
      if (dt / 1e3 > MAX_DELTA) {
        velocity2.set(0, 0, 0);
      } else {
        this.updateVelocity(dt);
      }
      if (data.constrainToNavMesh && velocityCtrl.isNavMeshConstrained !== false) {
        if (velocity2.lengthSq() < EPS2) return;
        start2.copy(el.object3D.position);
        end.copy(velocity2).multiplyScalar(dt / 1e3).add(start2);
        const nav = el.sceneEl.systems.nav;
        this.navGroup = this.navGroup === null ? nav.getGroup(start2) : this.navGroup;
        this.navNode = this.navNode || nav.getNode(start2, this.navGroup);
        this.navNode = nav.clampStep(start2, end, this.navGroup, this.navNode, clampedEnd);
        el.object3D.position.copy(clampedEnd);
      } else if (el.hasAttribute("velocity")) {
        el.setAttribute("velocity", velocity2);
      } else {
        el.object3D.position.x += velocity2.x * dt / 1e3;
        el.object3D.position.y += velocity2.y * dt / 1e3;
        el.object3D.position.z += velocity2.z * dt / 1e3;
      }
    };
  })(),
  /*******************************************************************
   * Movement
   */
  updateVelocityCtrl: function() {
    const data = this.data;
    if (data.enabled) {
      for (let i2 = 0, l2 = data.controls.length; i2 < l2; i2++) {
        const control = this.el.components[data.controls[i2] + COMPONENT_SUFFIX];
        if (control && control.isVelocityActive()) {
          this.velocityCtrl = control;
          return;
        }
      }
      this.velocityCtrl = null;
    }
  },
  updateVelocity: (function() {
    const vector2 = new THREE.Vector2();
    const quaternion = new THREE.Quaternion();
    return function(dt) {
      let dVelocity;
      const el = this.el;
      const control = this.velocityCtrl;
      const velocity2 = this.velocity;
      const data = this.data;
      if (control) {
        if (control.getVelocityDelta) {
          dVelocity = control.getVelocityDelta(dt);
        } else if (control.getVelocity) {
          velocity2.copy(control.getVelocity());
          return;
        } else if (control.getPositionDelta) {
          velocity2.copy(control.getPositionDelta(dt).multiplyScalar(1e3 / dt));
          return;
        } else {
          throw new Error("Incompatible movement controls: ", control);
        }
      }
      if (el.hasAttribute("velocity") && !data.constrainToNavMesh) {
        velocity2.copy(this.el.getAttribute("velocity"));
      }
      if (dVelocity && data.enabled) {
        const cameraEl = data.camera;
        quaternion.copy(cameraEl.object3D.quaternion);
        quaternion.premultiply(el.object3D.quaternion);
        dVelocity.applyQuaternion(quaternion);
        const factor = dVelocity.length();
        if (data.fly) {
          velocity2.copy(dVelocity);
          velocity2.multiplyScalar(this.data.speed * 16.66667);
        } else {
          vector2.set(dVelocity.x, dVelocity.z);
          vector2.setLength(factor * this.data.speed * 16.66667);
          velocity2.x = vector2.x;
          velocity2.y = 0;
          velocity2.z = vector2.y;
        }
        if (velocity2.x !== 0 || velocity2.y !== 0 || velocity2.z !== 0) {
          this.eventDetail.velocity = velocity2;
          this.el.emit(MOVED, this.eventDetail);
        }
      }
    };
  })()
});

// node_modules/aframe-extras/src/controls/trackpad-controls.js
AFRAME.registerComponent("trackpad-controls", {
  schema: {
    enabled: { default: true },
    enableNegX: { default: true },
    enablePosX: { default: true },
    enableNegZ: { default: true },
    enablePosZ: { default: true },
    mode: { default: "touch", oneOf: ["swipe", "touch", "press"] }
  },
  init: function() {
    this.dVelocity = new THREE.Vector3();
    this.zVel = 0;
    this.xVel = 0;
    this.bindMethods();
  },
  play: function() {
    this.addEventListeners();
  },
  pause: function() {
    this.removeEventListeners();
    this.dVelocity.set(0, 0, 0);
  },
  remove: function() {
    this.pause();
  },
  addEventListeners: function() {
    const data = this.data;
    const sceneEl = this.el.sceneEl;
    sceneEl.addEventListener("axismove", this.onAxisMove);
    switch (data.mode) {
      case "swipe":
      case "touch":
        sceneEl.addEventListener("trackpadtouchstart", this.onTouchStart);
        sceneEl.addEventListener("trackpadtouchend", this.onTouchEnd);
        break;
      case "press":
        sceneEl.addEventListener("trackpaddown", this.onTouchStart);
        sceneEl.addEventListener("trackpadup", this.onTouchEnd);
        break;
    }
  },
  removeEventListeners: function() {
    const sceneEl = this.el.sceneEl;
    sceneEl.removeEventListener("axismove", this.onAxisMove);
    sceneEl.removeEventListener("trackpadtouchstart", this.onTouchStart);
    sceneEl.removeEventListener("trackpadtouchend", this.onTouchEnd);
    sceneEl.removeEventListener("trackpaddown", this.onTouchStart);
    sceneEl.removeEventListener("trackpadup", this.onTouchEnd);
  },
  isVelocityActive: function() {
    return this.data.enabled && this.isMoving;
  },
  getVelocityDelta: function() {
    this.dVelocity.z = this.isMoving ? -this.zVel : 1;
    this.dVelocity.x = this.isMoving ? this.xVel : 1;
    return this.dVelocity.clone();
  },
  bindMethods: function() {
    this.onTouchStart = this.onTouchStart.bind(this);
    this.onTouchEnd = this.onTouchEnd.bind(this);
    this.onAxisMove = this.onAxisMove.bind(this);
  },
  onTouchStart: function(e3) {
    switch (this.data.mode) {
      case "swipe":
        this.canRecordAxis = true;
        this.startingAxisData = [];
        break;
      case "touch":
        this.isMoving = true;
        break;
      case "press":
        this.isMoving = true;
        break;
    }
    e3.preventDefault();
  },
  onTouchEnd: function(e3) {
    if (this.data.mode == "swipe") {
      this.startingAxisData = [];
    }
    this.isMoving = false;
    e3.preventDefault();
  },
  onAxisMove: function(e3) {
    switch (this.data.mode) {
      case "swipe":
        return this.handleSwipeAxis(e3);
      case "touch":
      case "press":
        return this.handleTouchAxis(e3);
    }
  },
  handleSwipeAxis: function(e3) {
    const data = this.data;
    const axisData = e3.detail.axis;
    if (this.startingAxisData.length === 0 && this.canRecordAxis) {
      this.canRecordAxis = false;
      this.startingAxisData[0] = axisData[0];
      this.startingAxisData[1] = axisData[1];
    }
    if (this.startingAxisData.length > 0) {
      let velX = 0;
      let velZ = 0;
      if (data.enableNegX && axisData[0] < this.startingAxisData[0]) {
        velX = -1;
      }
      if (data.enablePosX && axisData[0] > this.startingAxisData[0]) {
        velX = 1;
      }
      if (data.enablePosZ && axisData[1] > this.startingAxisData[1]) {
        velZ = -1;
      }
      if (data.enableNegZ && axisData[1] < this.startingAxisData[1]) {
        velZ = 1;
      }
      const absChangeZ = Math.abs(this.startingAxisData[1] - axisData[1]);
      const absChangeX = Math.abs(this.startingAxisData[0] - axisData[0]);
      if (absChangeX > absChangeZ) {
        this.zVel = 0;
        this.xVel = velX;
        this.isMoving = true;
      } else {
        this.xVel = 0;
        this.zVel = velZ;
        this.isMoving = true;
      }
    }
  },
  handleTouchAxis: function(e3) {
    const data = this.data;
    const axisData = e3.detail.axis;
    let velX = 0;
    let velZ = 0;
    if (data.enableNegX && axisData[0] < 0) {
      velX = -1;
    }
    if (data.enablePosX && axisData[0] > 0) {
      velX = 1;
    }
    if (data.enablePosZ && axisData[1] > 0) {
      velZ = -1;
    }
    if (data.enableNegZ && axisData[1] < 0) {
      velZ = 1;
    }
    if (Math.abs(axisData[0]) > Math.abs(axisData[1])) {
      this.zVel = 0;
      this.xVel = velX;
    } else {
      this.xVel = 0;
      this.zVel = velZ;
    }
  }
});

// node_modules/nipplejs/src/utils.js
var distance = (p1, p22) => {
  const dx = p22.x - p1.x;
  const dy = p22.y - p1.y;
  return Math.sqrt(dx * dx + dy * dy);
};
var angle = (p1, p22) => {
  const dx = p22.x - p1.x;
  const dy = p22.y - p1.y;
  return degrees(Math.atan2(dy, dx));
};
var findCoord = (p3, d3, a3) => {
  const b = { x: 0, y: 0 };
  a3 = radians(a3);
  b.x = p3.x - d3 * Math.cos(a3);
  b.y = p3.y - d3 * Math.sin(a3);
  return b;
};
var radians = (a3) => {
  return a3 * (Math.PI / 180);
};
var degrees = (a3) => {
  return a3 * (180 / Math.PI);
};
var isPressed = (evt) => {
  if (isNaN(evt.buttons)) {
    return evt.pressure !== 0;
  }
  return evt.buttons !== 0;
};
var timers = /* @__PURE__ */ new Map();
var throttle = (cb) => {
  if (timers.has(cb)) {
    clearTimeout(timers.get(cb));
  }
  timers.set(cb, setTimeout(cb, 100));
};
var bindEvt = (el, arg, handler) => {
  const types = arg.split(/[ ,]+/g);
  let type;
  for (let i2 = 0; i2 < types.length; i2 += 1) {
    type = types[i2];
    if (el.addEventListener) {
      el.addEventListener(type, handler, false);
    } else if (el.attachEvent) {
      el.attachEvent(type, handler);
    }
  }
};
var unbindEvt = (el, arg, handler) => {
  const types = arg.split(/[ ,]+/g);
  let type;
  for (let i2 = 0; i2 < types.length; i2 += 1) {
    type = types[i2];
    if (el.removeEventListener) {
      el.removeEventListener(type, handler);
    } else if (el.detachEvent) {
      el.detachEvent(type, handler);
    }
  }
};
var prepareEvent = (evt) => {
  evt.preventDefault();
  return evt.type.match(/^touch/) ? evt.changedTouches : evt;
};
var getScroll = () => {
  const x3 = window.pageXOffset !== void 0 ? window.pageXOffset : (document.documentElement || document.body.parentNode || document.body).scrollLeft;
  const y3 = window.pageYOffset !== void 0 ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop;
  return {
    x: x3,
    y: y3
  };
};
var applyPosition = (el, pos) => {
  if (pos.top || pos.right || pos.bottom || pos.left) {
    el.style.top = pos.top;
    el.style.right = pos.right;
    el.style.bottom = pos.bottom;
    el.style.left = pos.left;
  } else {
    el.style.left = pos.x + "px";
    el.style.top = pos.y + "px";
  }
};
var getTransitionStyle = (property3, values2, time3) => {
  const obj = configStylePropertyObject(property3);
  for (let i2 in obj) {
    if (obj.hasOwnProperty(i2)) {
      if (typeof values2 === "string") {
        obj[i2] = values2 + " " + time3;
      } else {
        let st = "";
        for (let j2 = 0, max6 = values2.length; j2 < max6; j2 += 1) {
          st += values2[j2] + " " + time3 + ", ";
        }
        obj[i2] = st.slice(0, -2);
      }
    }
  }
  return obj;
};
var getVendorStyle = (property3, value) => {
  const obj = configStylePropertyObject(property3);
  for (let i2 in obj) {
    if (obj.hasOwnProperty(i2)) {
      obj[i2] = value;
    }
  }
  return obj;
};
var configStylePropertyObject = (prop) => {
  const obj = {};
  obj[prop] = "";
  const vendors = ["webkit", "Moz", "o"];
  vendors.forEach(function(vendor) {
    obj[vendor + prop.charAt(0).toUpperCase() + prop.slice(1)] = "";
  });
  return obj;
};
var extend = (objA, objB) => {
  for (let i2 in objB) {
    if (objB.hasOwnProperty(i2)) {
      objA[i2] = objB[i2];
    }
  }
  return objA;
};
var safeExtend = (objA, objB) => {
  const obj = {};
  for (let i2 in objA) {
    if (objA.hasOwnProperty(i2) && objB.hasOwnProperty(i2)) {
      obj[i2] = objB[i2];
    } else if (objA.hasOwnProperty(i2)) {
      obj[i2] = objA[i2];
    }
  }
  return obj;
};
var map = (ar, fn) => {
  if (ar.length) {
    for (let i2 = 0, max6 = ar.length; i2 < max6; i2 += 1) {
      fn(ar[i2]);
    }
  } else {
    fn(ar);
  }
};
var clamp = (pos, nipplePos, size2) => ({
  //                          left-clamping        right-clamping
  x: Math.min(Math.max(pos.x, nipplePos.x - size2), nipplePos.x + size2),
  //                          top-clamping         bottom-clamping
  y: Math.min(Math.max(pos.y, nipplePos.y - size2), nipplePos.y + size2)
});

// node_modules/nipplejs/src/super.js
var isTouch = !!("ontouchstart" in window);
var isPointer = window.PointerEvent ? true : false;
var isMSPointer = window.MSPointerEvent ? true : false;
var events = {
  touch: {
    start: "touchstart",
    move: "touchmove",
    end: "touchend, touchcancel"
  },
  mouse: {
    start: "mousedown",
    move: "mousemove",
    end: "mouseup"
  },
  pointer: {
    start: "pointerdown",
    move: "pointermove",
    end: "pointerup, pointercancel"
  },
  MSPointer: {
    start: "MSPointerDown",
    move: "MSPointerMove",
    end: "MSPointerUp"
  }
};
var toBind;
var secondBind = {};
if (isPointer) {
  toBind = events.pointer;
} else if (isMSPointer) {
  toBind = events.MSPointer;
} else if (isTouch) {
  toBind = events.touch;
  secondBind = events.mouse;
} else {
  toBind = events.mouse;
}
function Super() {
}
Super.prototype.on = function(arg, cb) {
  var self2 = this;
  var types = arg.split(/[ ,]+/g);
  var type;
  self2._handlers_ = self2._handlers_ || {};
  for (var i2 = 0; i2 < types.length; i2 += 1) {
    type = types[i2];
    self2._handlers_[type] = self2._handlers_[type] || [];
    self2._handlers_[type].push(cb);
  }
  return self2;
};
Super.prototype.off = function(type, cb) {
  var self2 = this;
  self2._handlers_ = self2._handlers_ || {};
  if (type === void 0) {
    self2._handlers_ = {};
  } else if (cb === void 0) {
    self2._handlers_[type] = null;
  } else if (self2._handlers_[type] && self2._handlers_[type].indexOf(cb) >= 0) {
    self2._handlers_[type].splice(self2._handlers_[type].indexOf(cb), 1);
  }
  return self2;
};
Super.prototype.trigger = function(arg, data) {
  var self2 = this;
  var types = arg.split(/[ ,]+/g);
  var type;
  self2._handlers_ = self2._handlers_ || {};
  for (var i2 = 0; i2 < types.length; i2 += 1) {
    type = types[i2];
    if (self2._handlers_[type] && self2._handlers_[type].length) {
      self2._handlers_[type].forEach(function(handler) {
        handler.call(self2, {
          type,
          target: self2
        }, data);
      });
    }
  }
};
Super.prototype.config = function(options) {
  var self2 = this;
  self2.options = self2.defaults || {};
  if (options) {
    self2.options = safeExtend(self2.options, options);
  }
};
Super.prototype.bindEvt = function(el, type) {
  var self2 = this;
  self2._domHandlers_ = self2._domHandlers_ || {};
  self2._domHandlers_[type] = function() {
    if (typeof self2["on" + type] === "function") {
      self2["on" + type].apply(self2, arguments);
    } else {
      console.warn('[WARNING] : Missing "on' + type + '" handler.');
    }
  };
  bindEvt(el, toBind[type], self2._domHandlers_[type]);
  if (secondBind[type]) {
    bindEvt(el, secondBind[type], self2._domHandlers_[type]);
  }
  return self2;
};
Super.prototype.unbindEvt = function(el, type) {
  var self2 = this;
  self2._domHandlers_ = self2._domHandlers_ || {};
  unbindEvt(el, toBind[type], self2._domHandlers_[type]);
  if (secondBind[type]) {
    unbindEvt(el, secondBind[type], self2._domHandlers_[type]);
  }
  delete self2._domHandlers_[type];
  return this;
};
var super_default = Super;

// node_modules/nipplejs/src/nipple.js
function Nipple(collection, options) {
  this.identifier = options.identifier;
  this.position = options.position;
  this.frontPosition = options.frontPosition;
  this.collection = collection;
  this.defaults = {
    size: 100,
    threshold: 0.1,
    color: "white",
    fadeTime: 250,
    dataOnly: false,
    restJoystick: true,
    restOpacity: 0.5,
    mode: "dynamic",
    zone: document.body,
    lockX: false,
    lockY: false,
    shape: "circle"
  };
  this.config(options);
  if (this.options.mode === "dynamic") {
    this.options.restOpacity = 0;
  }
  this.id = Nipple.id;
  Nipple.id += 1;
  this.buildEl().stylize();
  this.instance = {
    el: this.ui.el,
    on: this.on.bind(this),
    off: this.off.bind(this),
    show: this.show.bind(this),
    hide: this.hide.bind(this),
    add: this.addToDom.bind(this),
    remove: this.removeFromDom.bind(this),
    destroy: this.destroy.bind(this),
    setPosition: this.setPosition.bind(this),
    resetDirection: this.resetDirection.bind(this),
    computeDirection: this.computeDirection.bind(this),
    trigger: this.trigger.bind(this),
    position: this.position,
    frontPosition: this.frontPosition,
    ui: this.ui,
    identifier: this.identifier,
    id: this.id,
    options: this.options
  };
  return this.instance;
}
Nipple.prototype = new super_default();
Nipple.constructor = Nipple;
Nipple.id = 0;
Nipple.prototype.buildEl = function(options) {
  this.ui = {};
  if (this.options.dataOnly) {
    return this;
  }
  this.ui.el = document.createElement("div");
  this.ui.back = document.createElement("div");
  this.ui.front = document.createElement("div");
  this.ui.el.className = "nipple collection_" + this.collection.id;
  this.ui.back.className = "back";
  this.ui.front.className = "front";
  this.ui.el.setAttribute("id", "nipple_" + this.collection.id + "_" + this.id);
  this.ui.el.appendChild(this.ui.back);
  this.ui.el.appendChild(this.ui.front);
  return this;
};
Nipple.prototype.stylize = function() {
  if (this.options.dataOnly) {
    return this;
  }
  var animTime = this.options.fadeTime + "ms";
  var borderStyle = getVendorStyle("borderRadius", "50%");
  var transitStyle = getTransitionStyle("transition", "opacity", animTime);
  var styles = {};
  styles.el = {
    position: "absolute",
    opacity: this.options.restOpacity,
    display: "block",
    "zIndex": 999
  };
  styles.back = {
    position: "absolute",
    display: "block",
    width: this.options.size + "px",
    height: this.options.size + "px",
    left: 0,
    marginLeft: -this.options.size / 2 + "px",
    marginTop: -this.options.size / 2 + "px",
    background: this.options.color,
    "opacity": ".5"
  };
  styles.front = {
    width: this.options.size / 2 + "px",
    height: this.options.size / 2 + "px",
    position: "absolute",
    display: "block",
    left: 0,
    marginLeft: -this.options.size / 4 + "px",
    marginTop: -this.options.size / 4 + "px",
    background: this.options.color,
    "opacity": ".5",
    transform: "translate(0px, 0px)"
  };
  extend(styles.el, transitStyle);
  if (this.options.shape === "circle") {
    extend(styles.back, borderStyle);
  }
  extend(styles.front, borderStyle);
  this.applyStyles(styles);
  return this;
};
Nipple.prototype.applyStyles = function(styles) {
  for (var i2 in this.ui) {
    if (this.ui.hasOwnProperty(i2)) {
      for (var j2 in styles[i2]) {
        this.ui[i2].style[j2] = styles[i2][j2];
      }
    }
  }
  return this;
};
Nipple.prototype.addToDom = function() {
  if (this.options.dataOnly || document.body.contains(this.ui.el)) {
    return this;
  }
  this.options.zone.appendChild(this.ui.el);
  return this;
};
Nipple.prototype.removeFromDom = function() {
  if (this.options.dataOnly || !document.body.contains(this.ui.el)) {
    return this;
  }
  this.options.zone.removeChild(this.ui.el);
  return this;
};
Nipple.prototype.destroy = function() {
  clearTimeout(this.removeTimeout);
  clearTimeout(this.showTimeout);
  clearTimeout(this.restTimeout);
  this.trigger("destroyed", this.instance);
  this.removeFromDom();
  this.off();
};
Nipple.prototype.show = function(cb) {
  var self2 = this;
  if (self2.options.dataOnly) {
    return self2;
  }
  clearTimeout(self2.removeTimeout);
  clearTimeout(self2.showTimeout);
  clearTimeout(self2.restTimeout);
  self2.addToDom();
  self2.restCallback();
  setTimeout(function() {
    self2.ui.el.style.opacity = 1;
  }, 0);
  self2.showTimeout = setTimeout(function() {
    self2.trigger("shown", self2.instance);
    if (typeof cb === "function") {
      cb.call(this);
    }
  }, self2.options.fadeTime);
  return self2;
};
Nipple.prototype.hide = function(cb) {
  var self2 = this;
  if (self2.options.dataOnly) {
    return self2;
  }
  self2.ui.el.style.opacity = self2.options.restOpacity;
  clearTimeout(self2.removeTimeout);
  clearTimeout(self2.showTimeout);
  clearTimeout(self2.restTimeout);
  self2.removeTimeout = setTimeout(
    function() {
      var display = self2.options.mode === "dynamic" ? "none" : "block";
      self2.ui.el.style.display = display;
      if (typeof cb === "function") {
        cb.call(self2);
      }
      self2.trigger("hidden", self2.instance);
    },
    self2.options.fadeTime
  );
  if (self2.options.restJoystick) {
    const rest2 = self2.options.restJoystick;
    const newPosition = {};
    newPosition.x = rest2 === true || rest2.x !== false ? 0 : self2.instance.frontPosition.x;
    newPosition.y = rest2 === true || rest2.y !== false ? 0 : self2.instance.frontPosition.y;
    self2.setPosition(cb, newPosition);
  }
  return self2;
};
Nipple.prototype.setPosition = function(cb, position) {
  var self2 = this;
  self2.frontPosition = {
    x: position.x,
    y: position.y
  };
  var animTime = self2.options.fadeTime + "ms";
  var transitStyle = {};
  transitStyle.front = getTransitionStyle(
    "transition",
    ["transform"],
    animTime
  );
  var styles = { front: {} };
  styles.front = {
    transform: "translate(" + self2.frontPosition.x + "px," + self2.frontPosition.y + "px)"
  };
  self2.applyStyles(transitStyle);
  self2.applyStyles(styles);
  self2.restTimeout = setTimeout(
    function() {
      if (typeof cb === "function") {
        cb.call(self2);
      }
      self2.restCallback();
    },
    self2.options.fadeTime
  );
};
Nipple.prototype.restCallback = function() {
  var self2 = this;
  var transitStyle = {};
  transitStyle.front = getTransitionStyle("transition", "none", "");
  self2.applyStyles(transitStyle);
  self2.trigger("rested", self2.instance);
};
Nipple.prototype.resetDirection = function() {
  this.direction = {
    x: false,
    y: false,
    angle: false
  };
};
Nipple.prototype.computeDirection = function(obj) {
  var rAngle = obj.angle.radian;
  var angle45 = Math.PI / 4;
  var angle90 = Math.PI / 2;
  var direction, directionX, directionY;
  if (rAngle > angle45 && rAngle < angle45 * 3 && !obj.lockX) {
    direction = "up";
  } else if (rAngle > -angle45 && rAngle <= angle45 && !obj.lockY) {
    direction = "left";
  } else if (rAngle > -angle45 * 3 && rAngle <= -angle45 && !obj.lockX) {
    direction = "down";
  } else if (!obj.lockY) {
    direction = "right";
  }
  if (!obj.lockY) {
    if (rAngle > -angle90 && rAngle < angle90) {
      directionX = "left";
    } else {
      directionX = "right";
    }
  }
  if (!obj.lockX) {
    if (rAngle > 0) {
      directionY = "up";
    } else {
      directionY = "down";
    }
  }
  if (obj.force > this.options.threshold) {
    var oldDirection = {};
    var i2;
    for (i2 in this.direction) {
      if (this.direction.hasOwnProperty(i2)) {
        oldDirection[i2] = this.direction[i2];
      }
    }
    var same = {};
    this.direction = {
      x: directionX,
      y: directionY,
      angle: direction
    };
    obj.direction = this.direction;
    for (i2 in oldDirection) {
      if (oldDirection[i2] === this.direction[i2]) {
        same[i2] = true;
      }
    }
    if (same.x && same.y && same.angle) {
      return obj;
    }
    if (!same.x || !same.y) {
      this.trigger("plain", obj);
    }
    if (!same.x) {
      this.trigger("plain:" + directionX, obj);
    }
    if (!same.y) {
      this.trigger("plain:" + directionY, obj);
    }
    if (!same.angle) {
      this.trigger("dir dir:" + direction, obj);
    }
  } else {
    this.resetDirection();
  }
  return obj;
};
var nipple_default = Nipple;

// node_modules/nipplejs/src/collection.js
function Collection(manager, options) {
  var self2 = this;
  self2.nipples = [];
  self2.idles = [];
  self2.actives = [];
  self2.ids = [];
  self2.pressureIntervals = {};
  self2.manager = manager;
  self2.id = Collection.id;
  Collection.id += 1;
  self2.defaults = {
    zone: document.body,
    multitouch: false,
    maxNumberOfNipples: 10,
    mode: "dynamic",
    position: { top: 0, left: 0 },
    catchDistance: 200,
    size: 100,
    threshold: 0.1,
    color: "white",
    fadeTime: 250,
    dataOnly: false,
    restJoystick: true,
    restOpacity: 0.5,
    lockX: false,
    lockY: false,
    shape: "circle",
    dynamicPage: false,
    follow: false
  };
  self2.config(options);
  if (self2.options.mode === "static" || self2.options.mode === "semi") {
    self2.options.multitouch = false;
  }
  if (!self2.options.multitouch) {
    self2.options.maxNumberOfNipples = 1;
  }
  const computedStyle = getComputedStyle(self2.options.zone.parentElement);
  if (computedStyle && computedStyle.display === "flex") {
    self2.parentIsFlex = true;
  }
  self2.updateBox();
  self2.prepareNipples();
  self2.bindings();
  self2.begin();
  return self2.nipples;
}
Collection.prototype = new super_default();
Collection.constructor = Collection;
Collection.id = 0;
Collection.prototype.prepareNipples = function() {
  var self2 = this;
  var nips = self2.nipples;
  nips.on = self2.on.bind(self2);
  nips.off = self2.off.bind(self2);
  nips.options = self2.options;
  nips.destroy = self2.destroy.bind(self2);
  nips.ids = self2.ids;
  nips.id = self2.id;
  nips.processOnMove = self2.processOnMove.bind(self2);
  nips.processOnEnd = self2.processOnEnd.bind(self2);
  nips.get = function(id2) {
    if (id2 === void 0) {
      return nips[0];
    }
    for (var i2 = 0, max6 = nips.length; i2 < max6; i2 += 1) {
      if (nips[i2].identifier === id2) {
        return nips[i2];
      }
    }
    return false;
  };
};
Collection.prototype.bindings = function() {
  var self2 = this;
  self2.bindEvt(self2.options.zone, "start");
  self2.options.zone.style.touchAction = "none";
  self2.options.zone.style.msTouchAction = "none";
};
Collection.prototype.begin = function() {
  var self2 = this;
  var opts = self2.options;
  if (opts.mode === "static") {
    var nipple = self2.createNipple(
      opts.position,
      self2.manager.getIdentifier()
    );
    nipple.add();
    self2.idles.push(nipple);
  }
};
Collection.prototype.createNipple = function(position, identifier) {
  var self2 = this;
  var scroll = self2.manager.scroll;
  var toPutOn = {};
  var opts = self2.options;
  var offset = {
    x: self2.parentIsFlex ? scroll.x : scroll.x + self2.box.left,
    y: self2.parentIsFlex ? scroll.y : scroll.y + self2.box.top
  };
  if (position.x && position.y) {
    toPutOn = {
      x: position.x - offset.x,
      y: position.y - offset.y
    };
  } else if (position.top || position.right || position.bottom || position.left) {
    var dumb = document.createElement("DIV");
    dumb.style.display = "hidden";
    dumb.style.top = position.top;
    dumb.style.right = position.right;
    dumb.style.bottom = position.bottom;
    dumb.style.left = position.left;
    dumb.style.position = "absolute";
    opts.zone.appendChild(dumb);
    var dumbBox = dumb.getBoundingClientRect();
    opts.zone.removeChild(dumb);
    toPutOn = position;
    position = {
      x: dumbBox.left + scroll.x,
      y: dumbBox.top + scroll.y
    };
  }
  var nipple = new nipple_default(self2, {
    color: opts.color,
    size: opts.size,
    threshold: opts.threshold,
    fadeTime: opts.fadeTime,
    dataOnly: opts.dataOnly,
    restJoystick: opts.restJoystick,
    restOpacity: opts.restOpacity,
    mode: opts.mode,
    identifier,
    position,
    zone: opts.zone,
    frontPosition: {
      x: 0,
      y: 0
    },
    shape: opts.shape
  });
  if (!opts.dataOnly) {
    applyPosition(nipple.ui.el, toPutOn);
    applyPosition(nipple.ui.front, nipple.frontPosition);
  }
  self2.nipples.push(nipple);
  self2.trigger("added " + nipple.identifier + ":added", nipple);
  self2.manager.trigger("added " + nipple.identifier + ":added", nipple);
  self2.bindNipple(nipple);
  return nipple;
};
Collection.prototype.updateBox = function() {
  var self2 = this;
  self2.box = self2.options.zone.getBoundingClientRect();
};
Collection.prototype.bindNipple = function(nipple) {
  var self2 = this;
  var type;
  var handler = function(evt, data) {
    type = evt.type + " " + data.id + ":" + evt.type;
    self2.trigger(type, data);
  };
  nipple.on("destroyed", self2.onDestroyed.bind(self2));
  nipple.on("shown hidden rested dir plain", handler);
  nipple.on("dir:up dir:right dir:down dir:left", handler);
  nipple.on("plain:up plain:right plain:down plain:left", handler);
};
Collection.prototype.pressureFn = function(touch, nipple, identifier) {
  var self2 = this;
  var previousPressure = 0;
  clearInterval(self2.pressureIntervals[identifier]);
  self2.pressureIntervals[identifier] = setInterval((function() {
    var pressure = touch.force || touch.pressure || touch.webkitForce || 0;
    if (pressure !== previousPressure) {
      nipple.trigger("pressure", pressure);
      self2.trigger("pressure " + nipple.identifier + ":pressure", pressure);
      previousPressure = pressure;
    }
  }).bind(self2), 100);
};
Collection.prototype.onstart = function(evt) {
  var self2 = this;
  var opts = self2.options;
  var origEvt = evt;
  evt = prepareEvent(evt);
  self2.updateBox();
  var process2 = function(touch) {
    if (self2.actives.length < opts.maxNumberOfNipples) {
      self2.processOnStart(touch);
    } else if (origEvt.type.match(/^touch/)) {
      Object.keys(self2.manager.ids).forEach(function(k2) {
        if (Object.values(origEvt.touches).findIndex(function(t5) {
          return t5.identifier === k2;
        }) < 0) {
          var e3 = [evt[0]];
          e3.identifier = k2;
          self2.processOnEnd(e3);
        }
      });
      if (self2.actives.length < opts.maxNumberOfNipples) {
        self2.processOnStart(touch);
      }
    }
  };
  map(evt, process2);
  self2.manager.bindDocument();
  return false;
};
Collection.prototype.processOnStart = function(evt) {
  var self2 = this;
  var opts = self2.options;
  var indexInIdles;
  var identifier = self2.manager.getIdentifier(evt);
  var pressure = evt.force || evt.pressure || evt.webkitForce || 0;
  var position = {
    x: evt.pageX,
    y: evt.pageY
  };
  var nipple = self2.getOrCreate(identifier, position);
  if (nipple.identifier !== identifier) {
    self2.manager.removeIdentifier(nipple.identifier);
  }
  nipple.identifier = identifier;
  var process2 = function(nip) {
    nip.trigger("start", nip);
    self2.trigger("start " + nip.id + ":start", nip);
    nip.show();
    if (pressure > 0) {
      self2.pressureFn(evt, nip, nip.identifier);
    }
    self2.processOnMove(evt);
  };
  if ((indexInIdles = self2.idles.indexOf(nipple)) >= 0) {
    self2.idles.splice(indexInIdles, 1);
  }
  self2.actives.push(nipple);
  self2.ids.push(nipple.identifier);
  if (opts.mode !== "semi") {
    process2(nipple);
  } else {
    var distance4 = distance(position, nipple.position);
    if (distance4 <= opts.catchDistance) {
      process2(nipple);
    } else {
      nipple.destroy();
      self2.processOnStart(evt);
      return;
    }
  }
  return nipple;
};
Collection.prototype.getOrCreate = function(identifier, position) {
  var self2 = this;
  var opts = self2.options;
  var nipple;
  if (/(semi|static)/.test(opts.mode)) {
    nipple = self2.idles[0];
    if (nipple) {
      self2.idles.splice(0, 1);
      return nipple;
    }
    if (opts.mode === "semi") {
      return self2.createNipple(position, identifier);
    }
    console.warn("Coudln't find the needed nipple.");
    return false;
  }
  nipple = self2.createNipple(position, identifier);
  return nipple;
};
Collection.prototype.processOnMove = function(evt) {
  var self2 = this;
  var opts = self2.options;
  var identifier = self2.manager.getIdentifier(evt);
  var nipple = self2.nipples.get(identifier);
  var scroll = self2.manager.scroll;
  if (!isPressed(evt)) {
    this.processOnEnd(evt);
    return;
  }
  if (!nipple) {
    console.error("Found zombie joystick with ID " + identifier);
    self2.manager.removeIdentifier(identifier);
    return;
  }
  if (opts.dynamicPage) {
    var elBox = nipple.el.getBoundingClientRect();
    nipple.position = {
      x: scroll.x + elBox.left,
      y: scroll.y + elBox.top
    };
  }
  nipple.identifier = identifier;
  var size2 = nipple.options.size / 2;
  var pos = {
    x: evt.pageX,
    y: evt.pageY
  };
  if (opts.lockX) {
    pos.y = nipple.position.y;
  }
  if (opts.lockY) {
    pos.x = nipple.position.x;
  }
  var dist = distance(pos, nipple.position);
  var angle2 = angle(pos, nipple.position);
  var rAngle = radians(angle2);
  var force = dist / size2;
  var raw = {
    distance: dist,
    position: pos
  };
  var clamped_dist;
  var clamped_pos;
  if (nipple.options.shape === "circle") {
    clamped_dist = Math.min(dist, size2);
    clamped_pos = findCoord(nipple.position, clamped_dist, angle2);
  } else {
    clamped_pos = clamp(pos, nipple.position, size2);
    clamped_dist = distance(clamped_pos, nipple.position);
  }
  if (opts.follow) {
    if (dist > size2) {
      let delta_x = pos.x - clamped_pos.x;
      let delta_y = pos.y - clamped_pos.y;
      nipple.position.x += delta_x;
      nipple.position.y += delta_y;
      nipple.el.style.top = nipple.position.y - (self2.box.top + scroll.y) + "px";
      nipple.el.style.left = nipple.position.x - (self2.box.left + scroll.x) + "px";
      dist = distance(pos, nipple.position);
    }
  } else {
    pos = clamped_pos;
    dist = clamped_dist;
  }
  var xPosition = pos.x - nipple.position.x;
  var yPosition = pos.y - nipple.position.y;
  nipple.frontPosition = {
    x: xPosition,
    y: yPosition
  };
  if (!opts.dataOnly) {
    nipple.ui.front.style.transform = "translate(" + xPosition + "px," + yPosition + "px)";
  }
  var toSend = {
    identifier: nipple.identifier,
    position: pos,
    force,
    pressure: evt.force || evt.pressure || evt.webkitForce || 0,
    distance: dist,
    angle: {
      radian: rAngle,
      degree: angle2
    },
    vector: {
      x: xPosition / size2,
      y: -yPosition / size2
    },
    raw,
    instance: nipple,
    lockX: opts.lockX,
    lockY: opts.lockY
  };
  toSend = nipple.computeDirection(toSend);
  toSend.angle = {
    radian: radians(180 - angle2),
    degree: 180 - angle2
  };
  nipple.trigger("move", toSend);
  self2.trigger("move " + nipple.id + ":move", toSend);
};
Collection.prototype.processOnEnd = function(evt) {
  var self2 = this;
  var opts = self2.options;
  var identifier = self2.manager.getIdentifier(evt);
  var nipple = self2.nipples.get(identifier);
  var removedIdentifier = self2.manager.removeIdentifier(nipple.identifier);
  if (!nipple) {
    return;
  }
  if (!opts.dataOnly) {
    nipple.hide(function() {
      if (opts.mode === "dynamic") {
        nipple.trigger("removed", nipple);
        self2.trigger("removed " + nipple.id + ":removed", nipple);
        self2.manager.trigger("removed " + nipple.id + ":removed", nipple);
        nipple.destroy();
      }
    });
  }
  clearInterval(self2.pressureIntervals[nipple.identifier]);
  nipple.resetDirection();
  nipple.trigger("end", nipple);
  self2.trigger("end " + nipple.id + ":end", nipple);
  if (self2.ids.indexOf(nipple.identifier) >= 0) {
    self2.ids.splice(self2.ids.indexOf(nipple.identifier), 1);
  }
  if (self2.actives.indexOf(nipple) >= 0) {
    self2.actives.splice(self2.actives.indexOf(nipple), 1);
  }
  if (/(semi|static)/.test(opts.mode)) {
    self2.idles.push(nipple);
  } else if (self2.nipples.indexOf(nipple) >= 0) {
    self2.nipples.splice(self2.nipples.indexOf(nipple), 1);
  }
  self2.manager.unbindDocument();
  if (/(semi|static)/.test(opts.mode)) {
    self2.manager.ids[removedIdentifier.id] = removedIdentifier.identifier;
  }
};
Collection.prototype.onDestroyed = function(evt, nipple) {
  var self2 = this;
  if (self2.nipples.indexOf(nipple) >= 0) {
    self2.nipples.splice(self2.nipples.indexOf(nipple), 1);
  }
  if (self2.actives.indexOf(nipple) >= 0) {
    self2.actives.splice(self2.actives.indexOf(nipple), 1);
  }
  if (self2.idles.indexOf(nipple) >= 0) {
    self2.idles.splice(self2.idles.indexOf(nipple), 1);
  }
  if (self2.ids.indexOf(nipple.identifier) >= 0) {
    self2.ids.splice(self2.ids.indexOf(nipple.identifier), 1);
  }
  self2.manager.removeIdentifier(nipple.identifier);
  self2.manager.unbindDocument();
};
Collection.prototype.destroy = function() {
  var self2 = this;
  self2.unbindEvt(self2.options.zone, "start");
  self2.nipples.forEach(function(nipple) {
    nipple.destroy();
  });
  for (var i2 in self2.pressureIntervals) {
    if (self2.pressureIntervals.hasOwnProperty(i2)) {
      clearInterval(self2.pressureIntervals[i2]);
    }
  }
  self2.trigger("destroyed", self2.nipples);
  self2.manager.unbindDocument();
  self2.off();
};
var collection_default = Collection;

// node_modules/nipplejs/src/manager.js
function Manager(options) {
  var self2 = this;
  self2.ids = {};
  self2.index = 0;
  self2.collections = [];
  self2.scroll = getScroll();
  self2.config(options);
  self2.prepareCollections();
  var resizeHandler = function() {
    var pos;
    self2.collections.forEach(function(collection) {
      collection.forEach(function(nipple) {
        pos = nipple.el.getBoundingClientRect();
        nipple.position = {
          x: self2.scroll.x + pos.left,
          y: self2.scroll.y + pos.top
        };
      });
    });
  };
  bindEvt(window, "resize", function() {
    throttle(resizeHandler);
  });
  var scrollHandler = function() {
    self2.scroll = getScroll();
  };
  bindEvt(window, "scroll", function() {
    throttle(scrollHandler);
  });
  return self2.collections;
}
Manager.prototype = new super_default();
Manager.constructor = Manager;
Manager.prototype.prepareCollections = function() {
  var self2 = this;
  self2.collections.create = self2.create.bind(self2);
  self2.collections.on = self2.on.bind(self2);
  self2.collections.off = self2.off.bind(self2);
  self2.collections.destroy = self2.destroy.bind(self2);
  self2.collections.get = function(id2) {
    var nipple;
    self2.collections.every(function(collection) {
      nipple = collection.get(id2);
      return nipple ? false : true;
    });
    return nipple;
  };
};
Manager.prototype.create = function(options) {
  return this.createCollection(options);
};
Manager.prototype.createCollection = function(options) {
  var self2 = this;
  var collection = new collection_default(self2, options);
  self2.bindCollection(collection);
  self2.collections.push(collection);
  return collection;
};
Manager.prototype.bindCollection = function(collection) {
  var self2 = this;
  var type;
  var handler = function(evt, data) {
    type = evt.type + " " + data.id + ":" + evt.type;
    self2.trigger(type, data);
  };
  collection.on("destroyed", self2.onDestroyed.bind(self2));
  collection.on("shown hidden rested dir plain", handler);
  collection.on("dir:up dir:right dir:down dir:left", handler);
  collection.on("plain:up plain:right plain:down plain:left", handler);
};
Manager.prototype.bindDocument = function() {
  var self2 = this;
  if (!self2.binded) {
    self2.bindEvt(document, "move").bindEvt(document, "end");
    self2.binded = true;
  }
};
Manager.prototype.unbindDocument = function(force) {
  var self2 = this;
  if (!Object.keys(self2.ids).length || force === true) {
    self2.unbindEvt(document, "move").unbindEvt(document, "end");
    self2.binded = false;
  }
};
Manager.prototype.getIdentifier = function(evt) {
  var id2;
  if (!evt) {
    id2 = this.index;
  } else {
    id2 = evt.identifier === void 0 ? evt.pointerId : evt.identifier;
    if (id2 === void 0) {
      id2 = this.latest || 0;
    }
  }
  if (this.ids[id2] === void 0) {
    this.ids[id2] = this.index;
    this.index += 1;
  }
  this.latest = id2;
  return this.ids[id2];
};
Manager.prototype.removeIdentifier = function(identifier) {
  var removed = {};
  for (var id2 in this.ids) {
    if (this.ids[id2] === identifier) {
      removed.id = id2;
      removed.identifier = this.ids[id2];
      delete this.ids[id2];
      break;
    }
  }
  return removed;
};
Manager.prototype.onmove = function(evt) {
  var self2 = this;
  self2.onAny("move", evt);
  return false;
};
Manager.prototype.onend = function(evt) {
  var self2 = this;
  self2.onAny("end", evt);
  return false;
};
Manager.prototype.oncancel = function(evt) {
  var self2 = this;
  self2.onAny("end", evt);
  return false;
};
Manager.prototype.onAny = function(which, evt) {
  var self2 = this;
  var id2;
  var processFn = "processOn" + which.charAt(0).toUpperCase() + which.slice(1);
  evt = prepareEvent(evt);
  var processColl = function(e3, id3, coll) {
    if (coll.ids.indexOf(id3) >= 0) {
      coll[processFn](e3);
      e3._found_ = true;
    }
  };
  var processEvt = function(e3) {
    id2 = self2.getIdentifier(e3);
    map(self2.collections, processColl.bind(null, e3, id2));
    if (!e3._found_) {
      self2.removeIdentifier(id2);
    }
  };
  map(evt, processEvt);
  return false;
};
Manager.prototype.destroy = function() {
  var self2 = this;
  self2.unbindDocument(true);
  self2.ids = {};
  self2.index = 0;
  self2.collections.forEach(function(collection) {
    collection.destroy();
  });
  self2.off();
};
Manager.prototype.onDestroyed = function(evt, coll) {
  var self2 = this;
  if (self2.collections.indexOf(coll) < 0) {
    return false;
  }
  self2.collections.splice(self2.collections.indexOf(coll), 1);
};
var manager_default = Manager;

// node_modules/nipplejs/src/index.js
var factory = new manager_default();
var src_default = {
  create: function(options) {
    return factory.create(options);
  },
  factory
};

// node_modules/aframe-extras/src/controls/nipple-controls.js
AFRAME.registerComponent("nipple-controls", {
  schema: {
    enabled: { default: true },
    mode: { default: "dynamic", oneOf: ["static", "semi", "dynamic"] },
    rotationSensitivity: { default: 1 },
    moveJoystickEnabled: { default: true },
    lookJoystickEnabled: { default: true },
    sideMargin: { default: "30px" },
    bottomMargin: { default: "70px" },
    moveJoystickPosition: { default: "left", oneOf: ["left", "right"] },
    lookJoystickPosition: { default: "right", oneOf: ["left", "right"] }
  },
  init() {
    this.dVelocity = new THREE.Vector3();
    this.lookVector = new THREE.Vector2();
    const lookControls = this.el.querySelector("[look-controls]").components["look-controls"];
    this.pitchObject = lookControls.pitchObject;
    this.yawObject = lookControls.yawObject;
    this.rigRotation = this.el.object3D.rotation;
    this.moveData = void 0;
    this.lookData = void 0;
    this.moving = false;
    this.rotating = false;
  },
  update(oldData) {
    if (this.data.moveJoystickPosition !== oldData.moveJoystickPosition || this.data.sideMargin !== oldData.sideMargin || this.data.bottomMargin !== oldData.bottomMargin || this.data.mode !== oldData.mode) {
      this.removeMoveJoystick();
    }
    if (this.data.lookJoystickPosition !== oldData.lookJoystickPosition || this.data.sideMargin !== oldData.sideMargin || this.data.bottomMargin !== oldData.bottomMargin || this.data.mode !== oldData.mode) {
      this.removeLookJoystick();
    }
    if (this.data.enabled && this.data.moveJoystickEnabled) {
      this.createMoveJoystick();
    } else {
      this.removeMoveJoystick();
    }
    if (this.data.enabled && this.data.lookJoystickEnabled) {
      this.createLookJoystick();
    } else {
      this.removeLookJoystick();
    }
  },
  pause() {
    this.moving = false;
    this.rotating = false;
  },
  remove() {
    this.removeMoveJoystick();
    this.removeLookJoystick();
  },
  isVelocityActive() {
    return this.data.enabled && this.moving;
  },
  getVelocityDelta() {
    this.dVelocity.set(0, 0, 0);
    if (this.isVelocityActive()) {
      const force = this.moveData.force < 1 ? this.moveData.force : 1;
      const angle2 = this.moveData.angle.radian;
      const x3 = Math.cos(angle2) * force;
      const z3 = -Math.sin(angle2) * force;
      this.dVelocity.set(x3, 0, z3);
    }
    return this.dVelocity;
  },
  isRotationActive() {
    return this.data.enabled && this.rotating;
  },
  updateRotation(dt) {
    if (!this.isRotationActive()) return;
    const force = this.lookData.force < 1 ? this.lookData.force : 1;
    const angle2 = this.lookData.angle.radian;
    const lookVector = this.lookVector;
    lookVector.x = Math.cos(angle2) * force;
    lookVector.y = Math.sin(angle2) * force;
    lookVector.multiplyScalar(this.data.rotationSensitivity * dt / 1e3);
    this.yawObject.rotation.y -= lookVector.x;
    let x3 = this.pitchObject.rotation.x + lookVector.y;
    x3 = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, x3));
    this.pitchObject.rotation.x = x3;
  },
  tick: function(t5, dt) {
    this.updateRotation(dt);
  },
  initLeftZone() {
    const leftZone = document.createElement("div");
    leftZone.setAttribute("id", "joystickLeftZone");
    leftZone.setAttribute(
      "style",
      `position:absolute;${this.data.moveJoystickPosition}:${this.data.sideMargin};bottom:${this.data.bottomMargin};z-index:1`
    );
    this.el.sceneEl.appendChild(leftZone);
    this.leftZone = leftZone;
  },
  initRightZone() {
    const rightZone = document.createElement("div");
    rightZone.setAttribute("id", "joystickRightZone");
    rightZone.setAttribute(
      "style",
      `position:absolute;${this.data.lookJoystickPosition}:${this.data.sideMargin};bottom:${this.data.bottomMargin};z-index:1`
    );
    this.el.sceneEl.appendChild(rightZone);
    this.rightZone = rightZone;
  },
  createMoveJoystick() {
    if (this.moveJoystick) return;
    this.initLeftZone();
    const options = {
      mode: this.data.mode,
      zone: this.leftZone,
      color: "white",
      fadeTime: 0
    };
    this.leftZone.style.width = "100px";
    if (this.data.mode === "static") {
      this.leftZone.style.height = "100px";
      options.position = { left: "50%", bottom: "50%" };
    } else {
      this.leftZone.style.height = "400px";
    }
    this.moveJoystick = src_default.create(options);
    this.moveJoystick.on("move", (evt, data) => {
      this.moveData = data;
      this.moving = true;
    });
    this.moveJoystick.on("end", (evt, data) => {
      this.moving = false;
    });
  },
  createLookJoystick() {
    if (this.lookJoystick) return;
    this.initRightZone();
    const options = {
      mode: this.data.mode,
      zone: this.rightZone,
      color: "white",
      fadeTime: 0
    };
    this.rightZone.style.width = "100px";
    if (this.data.mode === "static") {
      this.rightZone.style.height = "100px";
      options.position = { left: "50%", bottom: "50%" };
    } else {
      this.rightZone.style.height = "400px";
    }
    this.lookJoystick = src_default.create(options);
    this.lookJoystick.on("move", (evt, data) => {
      this.lookData = data;
      this.rotating = true;
    });
    this.lookJoystick.on("end", (evt, data) => {
      this.rotating = false;
    });
  },
  removeMoveJoystick() {
    if (this.moveJoystick) {
      this.moveJoystick.destroy();
      this.moveJoystick = void 0;
    }
    this.moveData = void 0;
    if (this.leftZone && this.leftZone.parentNode) {
      this.leftZone.remove();
      this.leftZone = void 0;
    }
  },
  removeLookJoystick() {
    if (this.lookJoystick) {
      this.lookJoystick.destroy();
      this.lookJoystick = void 0;
    }
    this.lookData = void 0;
    if (this.rightZone && this.rightZone.parentNode) {
      this.rightZone.remove();
      this.rightZone = void 0;
    }
  }
});

// node_modules/aframe-extras/src/loaders/animation-mixer.js
var LoopMode = {
  once: THREE.LoopOnce,
  repeat: THREE.LoopRepeat,
  pingpong: THREE.LoopPingPong
};
AFRAME.registerComponent("animation-mixer", {
  schema: {
    clip: { default: "*" },
    useRegExp: { default: false },
    duration: { default: 0 },
    clampWhenFinished: { default: false, type: "boolean" },
    crossFadeDuration: { default: 0 },
    loop: { default: "repeat", oneOf: Object.keys(LoopMode) },
    repetitions: { default: Infinity, min: 0 },
    timeScale: { default: 1 },
    startAt: { default: 0 }
  },
  init: function() {
    this.model = null;
    this.mixer = null;
    this.activeActions = [];
    const model = this.el.getObject3D("mesh");
    if (model) {
      this.load(model);
    } else {
      this.el.addEventListener("model-loaded", (e3) => {
        this.load(e3.detail.model);
      });
    }
  },
  load: function(model) {
    const el = this.el;
    this.model = model;
    this.mixer = new THREE.AnimationMixer(model);
    this.mixer.addEventListener("loop", (e3) => {
      el.emit("animation-loop", { action: e3.action, loopDelta: e3.loopDelta });
    });
    this.mixer.addEventListener("finished", (e3) => {
      el.emit("animation-finished", { action: e3.action, direction: e3.direction });
    });
    if (this.data.clip) this.update({});
  },
  remove: function() {
    if (this.mixer) this.mixer.stopAllAction();
  },
  update: function(prevData) {
    if (!prevData) return;
    const data = this.data;
    const changes = AFRAME.utils.diff(data, prevData);
    if ("clip" in changes) {
      this.stopAction();
      if (data.clip) this.playAction();
      return;
    }
    this.activeActions.forEach((action) => {
      if ("duration" in changes && data.duration) {
        action.setDuration(data.duration);
      }
      if ("clampWhenFinished" in changes) {
        action.clampWhenFinished = data.clampWhenFinished;
      }
      if ("loop" in changes || "repetitions" in changes) {
        action.setLoop(LoopMode[data.loop], data.repetitions);
      }
      if ("timeScale" in changes) {
        action.setEffectiveTimeScale(data.timeScale);
      }
    });
  },
  stopAction: function() {
    const data = this.data;
    for (let i2 = 0; i2 < this.activeActions.length; i2++) {
      data.crossFadeDuration ? this.activeActions[i2].fadeOut(data.crossFadeDuration) : this.activeActions[i2].stop();
    }
    this.activeActions.length = 0;
  },
  playAction: function() {
    if (!this.mixer) return;
    const model = this.model, data = this.data, clips = model.animations || (model.geometry || {}).animations || [];
    if (!clips.length) return;
    const re2 = data.useRegExp ? data.clip : wildcardToRegExp(data.clip);
    for (let clip, i2 = 0; clip = clips[i2]; i2++) {
      if (clip.name.match(re2)) {
        const action = this.mixer.clipAction(clip, model);
        action.enabled = true;
        action.clampWhenFinished = data.clampWhenFinished;
        if (data.duration) action.setDuration(data.duration);
        if (data.timeScale !== 1) action.setEffectiveTimeScale(data.timeScale);
        action.startAt(this.mixer.time - data.startAt / 1e3);
        action.setLoop(LoopMode[data.loop], data.repetitions).fadeIn(data.crossFadeDuration).play();
        this.activeActions.push(action);
      }
    }
  },
  tick: function(t5, dt) {
    if (this.mixer && !isNaN(dt)) this.mixer.update(dt / 1e3);
  }
});
function wildcardToRegExp(s2) {
  return new RegExp("^" + s2.split(/\*+/).map(regExpEscape).join(".*") + "$");
}
function regExpEscape(s2) {
  return s2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&");
}

// node_modules/aframe-extras/node_modules/three/build/three.module.js
var REVISION2 = "164";
var FrontSide2 = 0;
var BackSide2 = 1;
var DoubleSide2 = 2;
var NormalBlending2 = 1;
var AddEquation2 = 100;
var SrcAlphaFactor2 = 204;
var OneMinusSrcAlphaFactor2 = 205;
var LessEqualDepth2 = 3;
var MultiplyOperation2 = 0;
var AttachedBindMode = "attached";
var DetachedBindMode = "detached";
var UVMapping2 = 300;
var CubeReflectionMapping2 = 301;
var EquirectangularReflectionMapping2 = 303;
var RepeatWrapping2 = 1e3;
var ClampToEdgeWrapping2 = 1001;
var MirroredRepeatWrapping2 = 1002;
var NearestFilter2 = 1003;
var LinearFilter2 = 1006;
var LinearMipmapLinearFilter2 = 1008;
var UnsignedByteType2 = 1009;
var UnsignedIntType2 = 1014;
var FloatType2 = 1015;
var UnsignedInt248Type2 = 1020;
var RGBAFormat2 = 1023;
var DepthFormat2 = 1026;
var DepthStencilFormat2 = 1027;
var InterpolateDiscrete = 2300;
var InterpolateLinear = 2301;
var InterpolateSmooth = 2302;
var ZeroCurvatureEnding = 2400;
var ZeroSlopeEnding = 2401;
var WrapAroundEnding = 2402;
var NormalAnimationBlendMode = 2500;
var TangentSpaceNormalMap2 = 0;
var NoColorSpace2 = "";
var SRGBColorSpace2 = "srgb";
var LinearSRGBColorSpace2 = "srgb-linear";
var DisplayP3ColorSpace = "display-p3";
var LinearDisplayP3ColorSpace = "display-p3-linear";
var LinearTransfer2 = "linear";
var SRGBTransfer2 = "srgb";
var Rec709Primaries = "rec709";
var P3Primaries = "p3";
var KeepStencilOp2 = 7680;
var AlwaysStencilFunc2 = 519;
var LessEqualCompare2 = 515;
var StaticDrawUsage2 = 35044;
var WebGLCoordinateSystem2 = 2e3;
var WebGPUCoordinateSystem2 = 2001;
var EventDispatcher2 = class {
  addEventListener(type, listener) {
    if (this._listeners === void 0) this._listeners = {};
    const listeners = this._listeners;
    if (listeners[type] === void 0) {
      listeners[type] = [];
    }
    if (listeners[type].indexOf(listener) === -1) {
      listeners[type].push(listener);
    }
  }
  hasEventListener(type, listener) {
    if (this._listeners === void 0) return false;
    const listeners = this._listeners;
    return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
  }
  removeEventListener(type, listener) {
    if (this._listeners === void 0) return;
    const listeners = this._listeners;
    const listenerArray = listeners[type];
    if (listenerArray !== void 0) {
      const index8 = listenerArray.indexOf(listener);
      if (index8 !== -1) {
        listenerArray.splice(index8, 1);
      }
    }
  }
  dispatchEvent(event) {
    if (this._listeners === void 0) return;
    const listeners = this._listeners;
    const listenerArray = listeners[event.type];
    if (listenerArray !== void 0) {
      event.target = this;
      const array4 = listenerArray.slice(0);
      for (let i2 = 0, l2 = array4.length; i2 < l2; i2++) {
        array4[i2].call(this, event);
      }
      event.target = null;
    }
  }
};
var _lut = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
var _seed = 1234567;
var DEG2RAD = Math.PI / 180;
var RAD2DEG2 = 180 / Math.PI;
function generateUUID() {
  const d0 = Math.random() * 4294967295 | 0;
  const d1 = Math.random() * 4294967295 | 0;
  const d22 = Math.random() * 4294967295 | 0;
  const d3 = Math.random() * 4294967295 | 0;
  const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d22 & 63 | 128] + _lut[d22 >> 8 & 255] + "-" + _lut[d22 >> 16 & 255] + _lut[d22 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
  return uuid.toLowerCase();
}
function clamp2(value, min5, max6) {
  return Math.max(min5, Math.min(max6, value));
}
function euclideanModulo(n2, m3) {
  return (n2 % m3 + m3) % m3;
}
function mapLinear(x3, a1, a22, b12, b23) {
  return b12 + (x3 - a1) * (b23 - b12) / (a22 - a1);
}
function inverseLerp(x3, y3, value) {
  if (x3 !== y3) {
    return (value - x3) / (y3 - x3);
  } else {
    return 0;
  }
}
function lerp(x3, y3, t5) {
  return (1 - t5) * x3 + t5 * y3;
}
function damp(x3, y3, lambda, dt) {
  return lerp(x3, y3, 1 - Math.exp(-lambda * dt));
}
function pingpong(x3, length2 = 1) {
  return length2 - Math.abs(euclideanModulo(x3, length2 * 2) - length2);
}
function smoothstep(x3, min5, max6) {
  if (x3 <= min5) return 0;
  if (x3 >= max6) return 1;
  x3 = (x3 - min5) / (max6 - min5);
  return x3 * x3 * (3 - 2 * x3);
}
function smootherstep(x3, min5, max6) {
  if (x3 <= min5) return 0;
  if (x3 >= max6) return 1;
  x3 = (x3 - min5) / (max6 - min5);
  return x3 * x3 * x3 * (x3 * (x3 * 6 - 15) + 10);
}
function randInt(low, high) {
  return low + Math.floor(Math.random() * (high - low + 1));
}
function randFloat(low, high) {
  return low + Math.random() * (high - low);
}
function randFloatSpread(range4) {
  return range4 * (0.5 - Math.random());
}
function seededRandom(s2) {
  if (s2 !== void 0) _seed = s2;
  let t5 = _seed += 1831565813;
  t5 = Math.imul(t5 ^ t5 >>> 15, t5 | 1);
  t5 ^= t5 + Math.imul(t5 ^ t5 >>> 7, t5 | 61);
  return ((t5 ^ t5 >>> 14) >>> 0) / 4294967296;
}
function degToRad(degrees5) {
  return degrees5 * DEG2RAD;
}
function radToDeg(radians4) {
  return radians4 * RAD2DEG2;
}
function isPowerOfTwo(value) {
  return (value & value - 1) === 0 && value !== 0;
}
function ceilPowerOfTwo(value) {
  return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
}
function floorPowerOfTwo(value) {
  return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
}
function setQuaternionFromProperEuler(q2, a3, b, c5, order) {
  const cos4 = Math.cos;
  const sin4 = Math.sin;
  const c22 = cos4(b / 2);
  const s2 = sin4(b / 2);
  const c13 = cos4((a3 + c5) / 2);
  const s13 = sin4((a3 + c5) / 2);
  const c1_3 = cos4((a3 - c5) / 2);
  const s1_3 = sin4((a3 - c5) / 2);
  const c3_1 = cos4((c5 - a3) / 2);
  const s3_1 = sin4((c5 - a3) / 2);
  switch (order) {
    case "XYX":
      q2.set(c22 * s13, s2 * c1_3, s2 * s1_3, c22 * c13);
      break;
    case "YZY":
      q2.set(s2 * s1_3, c22 * s13, s2 * c1_3, c22 * c13);
      break;
    case "ZXZ":
      q2.set(s2 * c1_3, s2 * s1_3, c22 * s13, c22 * c13);
      break;
    case "XZX":
      q2.set(c22 * s13, s2 * s3_1, s2 * c3_1, c22 * c13);
      break;
    case "YXY":
      q2.set(s2 * c3_1, c22 * s13, s2 * s3_1, c22 * c13);
      break;
    case "ZYZ":
      q2.set(s2 * s3_1, s2 * c3_1, c22 * s13, c22 * c13);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + order);
  }
}
function denormalize(value, array4) {
  switch (array4.constructor) {
    case Float32Array:
      return value;
    case Uint32Array:
      return value / 4294967295;
    case Uint16Array:
      return value / 65535;
    case Uint8Array:
      return value / 255;
    case Int32Array:
      return Math.max(value / 2147483647, -1);
    case Int16Array:
      return Math.max(value / 32767, -1);
    case Int8Array:
      return Math.max(value / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function normalize(value, array4) {
  switch (array4.constructor) {
    case Float32Array:
      return value;
    case Uint32Array:
      return Math.round(value * 4294967295);
    case Uint16Array:
      return Math.round(value * 65535);
    case Uint8Array:
      return Math.round(value * 255);
    case Int32Array:
      return Math.round(value * 2147483647);
    case Int16Array:
      return Math.round(value * 32767);
    case Int8Array:
      return Math.round(value * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
var MathUtils2 = {
  DEG2RAD,
  RAD2DEG: RAD2DEG2,
  generateUUID,
  clamp: clamp2,
  euclideanModulo,
  mapLinear,
  inverseLerp,
  lerp,
  damp,
  pingpong,
  smoothstep,
  smootherstep,
  randInt,
  randFloat,
  randFloatSpread,
  seededRandom,
  degToRad,
  radToDeg,
  isPowerOfTwo,
  ceilPowerOfTwo,
  floorPowerOfTwo,
  setQuaternionFromProperEuler,
  normalize,
  denormalize
};
var Vector22 = class _Vector2 {
  constructor(x3 = 0, y3 = 0) {
    _Vector2.prototype.isVector2 = true;
    this.x = x3;
    this.y = y3;
  }
  get width() {
    return this.x;
  }
  set width(value) {
    this.x = value;
  }
  get height() {
    return this.y;
  }
  set height(value) {
    this.y = value;
  }
  set(x3, y3) {
    this.x = x3;
    this.y = y3;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    return this;
  }
  setX(x3) {
    this.x = x3;
    return this;
  }
  setY(y3) {
    this.y = y3;
    return this;
  }
  setComponent(index8, value) {
    switch (index8) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      default:
        throw new Error("index is out of range: " + index8);
    }
    return this;
  }
  getComponent(index8) {
    switch (index8) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + index8);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(v2) {
    this.x = v2.x;
    this.y = v2.y;
    return this;
  }
  add(v2) {
    this.x += v2.x;
    this.y += v2.y;
    return this;
  }
  addScalar(s2) {
    this.x += s2;
    this.y += s2;
    return this;
  }
  addVectors(a3, b) {
    this.x = a3.x + b.x;
    this.y = a3.y + b.y;
    return this;
  }
  addScaledVector(v2, s2) {
    this.x += v2.x * s2;
    this.y += v2.y * s2;
    return this;
  }
  sub(v2) {
    this.x -= v2.x;
    this.y -= v2.y;
    return this;
  }
  subScalar(s2) {
    this.x -= s2;
    this.y -= s2;
    return this;
  }
  subVectors(a3, b) {
    this.x = a3.x - b.x;
    this.y = a3.y - b.y;
    return this;
  }
  multiply(v2) {
    this.x *= v2.x;
    this.y *= v2.y;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  }
  divide(v2) {
    this.x /= v2.x;
    this.y /= v2.y;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  applyMatrix3(m3) {
    const x3 = this.x, y3 = this.y;
    const e3 = m3.elements;
    this.x = e3[0] * x3 + e3[3] * y3 + e3[6];
    this.y = e3[1] * x3 + e3[4] * y3 + e3[7];
    return this;
  }
  min(v2) {
    this.x = Math.min(this.x, v2.x);
    this.y = Math.min(this.y, v2.y);
    return this;
  }
  max(v2) {
    this.x = Math.max(this.x, v2.x);
    this.y = Math.max(this.y, v2.y);
    return this;
  }
  clamp(min5, max6) {
    this.x = Math.max(min5.x, Math.min(max6.x, this.x));
    this.y = Math.max(min5.y, Math.min(max6.y, this.y));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    return this;
  }
  clampLength(min5, max6) {
    const length2 = this.length();
    return this.divideScalar(length2 || 1).multiplyScalar(Math.max(min5, Math.min(max6, length2)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  }
  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  }
  dot(v2) {
    return this.x * v2.x + this.y * v2.y;
  }
  cross(v2) {
    return this.x * v2.y - this.y * v2.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    const angle2 = Math.atan2(-this.y, -this.x) + Math.PI;
    return angle2;
  }
  angleTo(v2) {
    const denominator = Math.sqrt(this.lengthSq() * v2.lengthSq());
    if (denominator === 0) return Math.PI / 2;
    const theta = this.dot(v2) / denominator;
    return Math.acos(clamp2(theta, -1, 1));
  }
  distanceTo(v2) {
    return Math.sqrt(this.distanceToSquared(v2));
  }
  distanceToSquared(v2) {
    const dx = this.x - v2.x, dy = this.y - v2.y;
    return dx * dx + dy * dy;
  }
  manhattanDistanceTo(v2) {
    return Math.abs(this.x - v2.x) + Math.abs(this.y - v2.y);
  }
  setLength(length2) {
    return this.normalize().multiplyScalar(length2);
  }
  lerp(v2, alpha) {
    this.x += (v2.x - this.x) * alpha;
    this.y += (v2.y - this.y) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    return this;
  }
  equals(v2) {
    return v2.x === this.x && v2.y === this.y;
  }
  fromArray(array4, offset = 0) {
    this.x = array4[offset];
    this.y = array4[offset + 1];
    return this;
  }
  toArray(array4 = [], offset = 0) {
    array4[offset] = this.x;
    array4[offset + 1] = this.y;
    return array4;
  }
  fromBufferAttribute(attribute2, index8) {
    this.x = attribute2.getX(index8);
    this.y = attribute2.getY(index8);
    return this;
  }
  rotateAround(center, angle2) {
    const c5 = Math.cos(angle2), s2 = Math.sin(angle2);
    const x3 = this.x - center.x;
    const y3 = this.y - center.y;
    this.x = x3 * c5 - y3 * s2 + center.x;
    this.y = x3 * s2 + y3 * c5 + center.y;
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
  }
};
var Matrix32 = class _Matrix3 {
  constructor(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    _Matrix3.prototype.isMatrix3 = true;
    this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ];
    if (n11 !== void 0) {
      this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);
    }
  }
  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    const te2 = this.elements;
    te2[0] = n11;
    te2[1] = n21;
    te2[2] = n31;
    te2[3] = n12;
    te2[4] = n22;
    te2[5] = n32;
    te2[6] = n13;
    te2[7] = n23;
    te2[8] = n33;
    return this;
  }
  identity() {
    this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    );
    return this;
  }
  copy(m3) {
    const te2 = this.elements;
    const me = m3.elements;
    te2[0] = me[0];
    te2[1] = me[1];
    te2[2] = me[2];
    te2[3] = me[3];
    te2[4] = me[4];
    te2[5] = me[5];
    te2[6] = me[6];
    te2[7] = me[7];
    te2[8] = me[8];
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrix3Column(this, 0);
    yAxis.setFromMatrix3Column(this, 1);
    zAxis.setFromMatrix3Column(this, 2);
    return this;
  }
  setFromMatrix4(m3) {
    const me = m3.elements;
    this.set(
      me[0],
      me[4],
      me[8],
      me[1],
      me[5],
      me[9],
      me[2],
      me[6],
      me[10]
    );
    return this;
  }
  multiply(m3) {
    return this.multiplyMatrices(this, m3);
  }
  premultiply(m3) {
    return this.multiplyMatrices(m3, this);
  }
  multiplyMatrices(a3, b) {
    const ae = a3.elements;
    const be = b.elements;
    const te2 = this.elements;
    const a11 = ae[0], a12 = ae[3], a13 = ae[6];
    const a21 = ae[1], a22 = ae[4], a23 = ae[7];
    const a31 = ae[2], a32 = ae[5], a33 = ae[8];
    const b11 = be[0], b12 = be[3], b13 = be[6];
    const b21 = be[1], b222 = be[4], b23 = be[7];
    const b31 = be[2], b32 = be[5], b33 = be[8];
    te2[0] = a11 * b11 + a12 * b21 + a13 * b31;
    te2[3] = a11 * b12 + a12 * b222 + a13 * b32;
    te2[6] = a11 * b13 + a12 * b23 + a13 * b33;
    te2[1] = a21 * b11 + a22 * b21 + a23 * b31;
    te2[4] = a21 * b12 + a22 * b222 + a23 * b32;
    te2[7] = a21 * b13 + a22 * b23 + a23 * b33;
    te2[2] = a31 * b11 + a32 * b21 + a33 * b31;
    te2[5] = a31 * b12 + a32 * b222 + a33 * b32;
    te2[8] = a31 * b13 + a32 * b23 + a33 * b33;
    return this;
  }
  multiplyScalar(s2) {
    const te2 = this.elements;
    te2[0] *= s2;
    te2[3] *= s2;
    te2[6] *= s2;
    te2[1] *= s2;
    te2[4] *= s2;
    te2[7] *= s2;
    te2[2] *= s2;
    te2[5] *= s2;
    te2[8] *= s2;
    return this;
  }
  determinant() {
    const te2 = this.elements;
    const a3 = te2[0], b = te2[1], c5 = te2[2], d3 = te2[3], e3 = te2[4], f3 = te2[5], g3 = te2[6], h2 = te2[7], i2 = te2[8];
    return a3 * e3 * i2 - a3 * f3 * h2 - b * d3 * i2 + b * f3 * g3 + c5 * d3 * h2 - c5 * e3 * g3;
  }
  invert() {
    const te2 = this.elements, n11 = te2[0], n21 = te2[1], n31 = te2[2], n12 = te2[3], n22 = te2[4], n32 = te2[5], n13 = te2[6], n23 = te2[7], n33 = te2[8], t11 = n33 * n22 - n32 * n23, t122 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det2 = n11 * t11 + n21 * t122 + n31 * t13;
    if (det2 === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det2;
    te2[0] = t11 * detInv;
    te2[1] = (n31 * n23 - n33 * n21) * detInv;
    te2[2] = (n32 * n21 - n31 * n22) * detInv;
    te2[3] = t122 * detInv;
    te2[4] = (n33 * n11 - n31 * n13) * detInv;
    te2[5] = (n31 * n12 - n32 * n11) * detInv;
    te2[6] = t13 * detInv;
    te2[7] = (n21 * n13 - n23 * n11) * detInv;
    te2[8] = (n22 * n11 - n21 * n12) * detInv;
    return this;
  }
  transpose() {
    let tmp2;
    const m3 = this.elements;
    tmp2 = m3[1];
    m3[1] = m3[3];
    m3[3] = tmp2;
    tmp2 = m3[2];
    m3[2] = m3[6];
    m3[6] = tmp2;
    tmp2 = m3[5];
    m3[5] = m3[7];
    m3[7] = tmp2;
    return this;
  }
  getNormalMatrix(matrix4) {
    return this.setFromMatrix4(matrix4).invert().transpose();
  }
  transposeIntoArray(r2) {
    const m3 = this.elements;
    r2[0] = m3[0];
    r2[1] = m3[3];
    r2[2] = m3[6];
    r2[3] = m3[1];
    r2[4] = m3[4];
    r2[5] = m3[7];
    r2[6] = m3[2];
    r2[7] = m3[5];
    r2[8] = m3[8];
    return this;
  }
  setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
    const c5 = Math.cos(rotation);
    const s2 = Math.sin(rotation);
    this.set(
      sx * c5,
      sx * s2,
      -sx * (c5 * cx + s2 * cy) + cx + tx,
      -sy * s2,
      sy * c5,
      -sy * (-s2 * cx + c5 * cy) + cy + ty,
      0,
      0,
      1
    );
    return this;
  }
  //
  scale(sx, sy) {
    this.premultiply(_m3.makeScale(sx, sy));
    return this;
  }
  rotate(theta) {
    this.premultiply(_m3.makeRotation(-theta));
    return this;
  }
  translate(tx, ty) {
    this.premultiply(_m3.makeTranslation(tx, ty));
    return this;
  }
  // for 2D Transforms
  makeTranslation(x3, y3) {
    if (x3.isVector2) {
      this.set(
        1,
        0,
        x3.x,
        0,
        1,
        x3.y,
        0,
        0,
        1
      );
    } else {
      this.set(
        1,
        0,
        x3,
        0,
        1,
        y3,
        0,
        0,
        1
      );
    }
    return this;
  }
  makeRotation(theta) {
    const c5 = Math.cos(theta);
    const s2 = Math.sin(theta);
    this.set(
      c5,
      -s2,
      0,
      s2,
      c5,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeScale(x3, y3) {
    this.set(
      x3,
      0,
      0,
      0,
      y3,
      0,
      0,
      0,
      1
    );
    return this;
  }
  //
  equals(matrix) {
    const te2 = this.elements;
    const me = matrix.elements;
    for (let i2 = 0; i2 < 9; i2++) {
      if (te2[i2] !== me[i2]) return false;
    }
    return true;
  }
  fromArray(array4, offset = 0) {
    for (let i2 = 0; i2 < 9; i2++) {
      this.elements[i2] = array4[i2 + offset];
    }
    return this;
  }
  toArray(array4 = [], offset = 0) {
    const te2 = this.elements;
    array4[offset] = te2[0];
    array4[offset + 1] = te2[1];
    array4[offset + 2] = te2[2];
    array4[offset + 3] = te2[3];
    array4[offset + 4] = te2[4];
    array4[offset + 5] = te2[5];
    array4[offset + 6] = te2[6];
    array4[offset + 7] = te2[7];
    array4[offset + 8] = te2[8];
    return array4;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
};
var _m3 = new Matrix32();
function arrayNeedsUint322(array4) {
  for (let i2 = array4.length - 1; i2 >= 0; --i2) {
    if (array4[i2] >= 65535) return true;
  }
  return false;
}
function createElementNS(name) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", name);
}
var _cache = {};
function warnOnce2(message) {
  if (message in _cache) return;
  _cache[message] = true;
  console.warn(message);
}
var LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = new Matrix32().set(
  0.8224621,
  0.177538,
  0,
  0.0331941,
  0.9668058,
  0,
  0.0170827,
  0.0723974,
  0.9105199
);
var LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = new Matrix32().set(
  1.2249401,
  -0.2249404,
  0,
  -0.0420569,
  1.0420571,
  0,
  -0.0196376,
  -0.0786361,
  1.0982735
);
var COLOR_SPACES = {
  [LinearSRGBColorSpace2]: {
    transfer: LinearTransfer2,
    primaries: Rec709Primaries,
    toReference: (color3) => color3,
    fromReference: (color3) => color3
  },
  [SRGBColorSpace2]: {
    transfer: SRGBTransfer2,
    primaries: Rec709Primaries,
    toReference: (color3) => color3.convertSRGBToLinear(),
    fromReference: (color3) => color3.convertLinearToSRGB()
  },
  [LinearDisplayP3ColorSpace]: {
    transfer: LinearTransfer2,
    primaries: P3Primaries,
    toReference: (color3) => color3.applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB),
    fromReference: (color3) => color3.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3)
  },
  [DisplayP3ColorSpace]: {
    transfer: SRGBTransfer2,
    primaries: P3Primaries,
    toReference: (color3) => color3.convertSRGBToLinear().applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB),
    fromReference: (color3) => color3.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3).convertLinearToSRGB()
  }
};
var SUPPORTED_WORKING_COLOR_SPACES = /* @__PURE__ */ new Set([LinearSRGBColorSpace2, LinearDisplayP3ColorSpace]);
var ColorManagement2 = {
  enabled: true,
  _workingColorSpace: LinearSRGBColorSpace2,
  get workingColorSpace() {
    return this._workingColorSpace;
  },
  set workingColorSpace(colorSpace) {
    if (!SUPPORTED_WORKING_COLOR_SPACES.has(colorSpace)) {
      throw new Error(`Unsupported working color space, "${colorSpace}".`);
    }
    this._workingColorSpace = colorSpace;
  },
  convert: function(color3, sourceColorSpace, targetColorSpace) {
    if (this.enabled === false || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {
      return color3;
    }
    const sourceToReference = COLOR_SPACES[sourceColorSpace].toReference;
    const targetFromReference = COLOR_SPACES[targetColorSpace].fromReference;
    return targetFromReference(sourceToReference(color3));
  },
  fromWorkingColorSpace: function(color3, targetColorSpace) {
    return this.convert(color3, this._workingColorSpace, targetColorSpace);
  },
  toWorkingColorSpace: function(color3, sourceColorSpace) {
    return this.convert(color3, sourceColorSpace, this._workingColorSpace);
  },
  getPrimaries: function(colorSpace) {
    return COLOR_SPACES[colorSpace].primaries;
  },
  getTransfer: function(colorSpace) {
    if (colorSpace === NoColorSpace2) return LinearTransfer2;
    return COLOR_SPACES[colorSpace].transfer;
  }
};
function SRGBToLinear(c5) {
  return c5 < 0.04045 ? c5 * 0.0773993808 : Math.pow(c5 * 0.9478672986 + 0.0521327014, 2.4);
}
function LinearToSRGB(c5) {
  return c5 < 31308e-7 ? c5 * 12.92 : 1.055 * Math.pow(c5, 0.41666) - 0.055;
}
var _canvas;
var ImageUtils = class {
  static getDataURL(image) {
    if (/^data:/i.test(image.src)) {
      return image.src;
    }
    if (typeof HTMLCanvasElement === "undefined") {
      return image.src;
    }
    let canvas;
    if (image instanceof HTMLCanvasElement) {
      canvas = image;
    } else {
      if (_canvas === void 0) _canvas = createElementNS("canvas");
      _canvas.width = image.width;
      _canvas.height = image.height;
      const context2 = _canvas.getContext("2d");
      if (image instanceof ImageData) {
        context2.putImageData(image, 0, 0);
      } else {
        context2.drawImage(image, 0, 0, image.width, image.height);
      }
      canvas = _canvas;
    }
    if (canvas.width > 2048 || canvas.height > 2048) {
      console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", image);
      return canvas.toDataURL("image/jpeg", 0.6);
    } else {
      return canvas.toDataURL("image/png");
    }
  }
  static sRGBToLinear(image) {
    if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
      const canvas = createElementNS("canvas");
      canvas.width = image.width;
      canvas.height = image.height;
      const context2 = canvas.getContext("2d");
      context2.drawImage(image, 0, 0, image.width, image.height);
      const imageData = context2.getImageData(0, 0, image.width, image.height);
      const data = imageData.data;
      for (let i2 = 0; i2 < data.length; i2++) {
        data[i2] = SRGBToLinear(data[i2] / 255) * 255;
      }
      context2.putImageData(imageData, 0, 0);
      return canvas;
    } else if (image.data) {
      const data = image.data.slice(0);
      for (let i2 = 0; i2 < data.length; i2++) {
        if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
          data[i2] = Math.floor(SRGBToLinear(data[i2] / 255) * 255);
        } else {
          data[i2] = SRGBToLinear(data[i2]);
        }
      }
      return {
        data,
        width: image.width,
        height: image.height
      };
    } else {
      console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.");
      return image;
    }
  }
};
var _sourceId = 0;
var Source = class {
  constructor(data = null) {
    this.isSource = true;
    Object.defineProperty(this, "id", { value: _sourceId++ });
    this.uuid = generateUUID();
    this.data = data;
    this.dataReady = true;
    this.version = 0;
  }
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (!isRootObject && meta.images[this.uuid] !== void 0) {
      return meta.images[this.uuid];
    }
    const output2 = {
      uuid: this.uuid,
      url: ""
    };
    const data = this.data;
    if (data !== null) {
      let url;
      if (Array.isArray(data)) {
        url = [];
        for (let i2 = 0, l2 = data.length; i2 < l2; i2++) {
          if (data[i2].isDataTexture) {
            url.push(serializeImage(data[i2].image));
          } else {
            url.push(serializeImage(data[i2]));
          }
        }
      } else {
        url = serializeImage(data);
      }
      output2.url = url;
    }
    if (!isRootObject) {
      meta.images[this.uuid] = output2;
    }
    return output2;
  }
};
function serializeImage(image) {
  if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
    return ImageUtils.getDataURL(image);
  } else {
    if (image.data) {
      return {
        data: Array.from(image.data),
        width: image.width,
        height: image.height,
        type: image.data.constructor.name
      };
    } else {
      console.warn("THREE.Texture: Unable to serialize Texture.");
      return {};
    }
  }
}
var _textureId = 0;
var Texture2 = class _Texture extends EventDispatcher2 {
  constructor(image = _Texture.DEFAULT_IMAGE, mapping = _Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping2, wrapT = ClampToEdgeWrapping2, magFilter = LinearFilter2, minFilter = LinearMipmapLinearFilter2, format3 = RGBAFormat2, type = UnsignedByteType2, anisotropy2 = _Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace2) {
    super();
    this.isTexture = true;
    Object.defineProperty(this, "id", { value: _textureId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.source = new Source(image);
    this.mipmaps = [];
    this.mapping = mapping;
    this.channel = 0;
    this.wrapS = wrapS;
    this.wrapT = wrapT;
    this.magFilter = magFilter;
    this.minFilter = minFilter;
    this.anisotropy = anisotropy2;
    this.format = format3;
    this.internalFormat = null;
    this.type = type;
    this.offset = new Vector22(0, 0);
    this.repeat = new Vector22(1, 1);
    this.center = new Vector22(0, 0);
    this.rotation = 0;
    this.matrixAutoUpdate = true;
    this.matrix = new Matrix32();
    this.generateMipmaps = true;
    this.premultiplyAlpha = false;
    this.flipY = true;
    this.unpackAlignment = 4;
    this.colorSpace = colorSpace;
    this.userData = {};
    this.version = 0;
    this.onUpdate = null;
    this.isRenderTargetTexture = false;
    this.pmremVersion = 0;
  }
  get image() {
    return this.source.data;
  }
  set image(value = null) {
    this.source.data = value;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.name = source.name;
    this.source = source.source;
    this.mipmaps = source.mipmaps.slice(0);
    this.mapping = source.mapping;
    this.channel = source.channel;
    this.wrapS = source.wrapS;
    this.wrapT = source.wrapT;
    this.magFilter = source.magFilter;
    this.minFilter = source.minFilter;
    this.anisotropy = source.anisotropy;
    this.format = source.format;
    this.internalFormat = source.internalFormat;
    this.type = source.type;
    this.offset.copy(source.offset);
    this.repeat.copy(source.repeat);
    this.center.copy(source.center);
    this.rotation = source.rotation;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrix.copy(source.matrix);
    this.generateMipmaps = source.generateMipmaps;
    this.premultiplyAlpha = source.premultiplyAlpha;
    this.flipY = source.flipY;
    this.unpackAlignment = source.unpackAlignment;
    this.colorSpace = source.colorSpace;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    this.needsUpdate = true;
    return this;
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (!isRootObject && meta.textures[this.uuid] !== void 0) {
      return meta.textures[this.uuid];
    }
    const output2 = {
      metadata: {
        version: 4.6,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(meta).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    if (Object.keys(this.userData).length > 0) output2.userData = this.userData;
    if (!isRootObject) {
      meta.textures[this.uuid] = output2;
    }
    return output2;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(uv2) {
    if (this.mapping !== UVMapping2) return uv2;
    uv2.applyMatrix3(this.matrix);
    if (uv2.x < 0 || uv2.x > 1) {
      switch (this.wrapS) {
        case RepeatWrapping2:
          uv2.x = uv2.x - Math.floor(uv2.x);
          break;
        case ClampToEdgeWrapping2:
          uv2.x = uv2.x < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping2:
          if (Math.abs(Math.floor(uv2.x) % 2) === 1) {
            uv2.x = Math.ceil(uv2.x) - uv2.x;
          } else {
            uv2.x = uv2.x - Math.floor(uv2.x);
          }
          break;
      }
    }
    if (uv2.y < 0 || uv2.y > 1) {
      switch (this.wrapT) {
        case RepeatWrapping2:
          uv2.y = uv2.y - Math.floor(uv2.y);
          break;
        case ClampToEdgeWrapping2:
          uv2.y = uv2.y < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping2:
          if (Math.abs(Math.floor(uv2.y) % 2) === 1) {
            uv2.y = Math.ceil(uv2.y) - uv2.y;
          } else {
            uv2.y = uv2.y - Math.floor(uv2.y);
          }
          break;
      }
    }
    if (this.flipY) {
      uv2.y = 1 - uv2.y;
    }
    return uv2;
  }
  set needsUpdate(value) {
    if (value === true) {
      this.version++;
      this.source.needsUpdate = true;
    }
  }
  set needsPMREMUpdate(value) {
    if (value === true) {
      this.pmremVersion++;
    }
  }
};
Texture2.DEFAULT_IMAGE = null;
Texture2.DEFAULT_MAPPING = UVMapping2;
Texture2.DEFAULT_ANISOTROPY = 1;
var Vector42 = class _Vector4 {
  constructor(x3 = 0, y3 = 0, z3 = 0, w4 = 1) {
    _Vector4.prototype.isVector4 = true;
    this.x = x3;
    this.y = y3;
    this.z = z3;
    this.w = w4;
  }
  get width() {
    return this.z;
  }
  set width(value) {
    this.z = value;
  }
  get height() {
    return this.w;
  }
  set height(value) {
    this.w = value;
  }
  set(x3, y3, z3, w4) {
    this.x = x3;
    this.y = y3;
    this.z = z3;
    this.w = w4;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    this.w = scalar;
    return this;
  }
  setX(x3) {
    this.x = x3;
    return this;
  }
  setY(y3) {
    this.y = y3;
    return this;
  }
  setZ(z3) {
    this.z = z3;
    return this;
  }
  setW(w4) {
    this.w = w4;
    return this;
  }
  setComponent(index8, value) {
    switch (index8) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      case 3:
        this.w = value;
        break;
      default:
        throw new Error("index is out of range: " + index8);
    }
    return this;
  }
  getComponent(index8) {
    switch (index8) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + index8);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(v2) {
    this.x = v2.x;
    this.y = v2.y;
    this.z = v2.z;
    this.w = v2.w !== void 0 ? v2.w : 1;
    return this;
  }
  add(v2) {
    this.x += v2.x;
    this.y += v2.y;
    this.z += v2.z;
    this.w += v2.w;
    return this;
  }
  addScalar(s2) {
    this.x += s2;
    this.y += s2;
    this.z += s2;
    this.w += s2;
    return this;
  }
  addVectors(a3, b) {
    this.x = a3.x + b.x;
    this.y = a3.y + b.y;
    this.z = a3.z + b.z;
    this.w = a3.w + b.w;
    return this;
  }
  addScaledVector(v2, s2) {
    this.x += v2.x * s2;
    this.y += v2.y * s2;
    this.z += v2.z * s2;
    this.w += v2.w * s2;
    return this;
  }
  sub(v2) {
    this.x -= v2.x;
    this.y -= v2.y;
    this.z -= v2.z;
    this.w -= v2.w;
    return this;
  }
  subScalar(s2) {
    this.x -= s2;
    this.y -= s2;
    this.z -= s2;
    this.w -= s2;
    return this;
  }
  subVectors(a3, b) {
    this.x = a3.x - b.x;
    this.y = a3.y - b.y;
    this.z = a3.z - b.z;
    this.w = a3.w - b.w;
    return this;
  }
  multiply(v2) {
    this.x *= v2.x;
    this.y *= v2.y;
    this.z *= v2.z;
    this.w *= v2.w;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    this.w *= scalar;
    return this;
  }
  applyMatrix4(m3) {
    const x3 = this.x, y3 = this.y, z3 = this.z, w4 = this.w;
    const e3 = m3.elements;
    this.x = e3[0] * x3 + e3[4] * y3 + e3[8] * z3 + e3[12] * w4;
    this.y = e3[1] * x3 + e3[5] * y3 + e3[9] * z3 + e3[13] * w4;
    this.z = e3[2] * x3 + e3[6] * y3 + e3[10] * z3 + e3[14] * w4;
    this.w = e3[3] * x3 + e3[7] * y3 + e3[11] * z3 + e3[15] * w4;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  setAxisAngleFromQuaternion(q2) {
    this.w = 2 * Math.acos(q2.w);
    const s2 = Math.sqrt(1 - q2.w * q2.w);
    if (s2 < 1e-4) {
      this.x = 1;
      this.y = 0;
      this.z = 0;
    } else {
      this.x = q2.x / s2;
      this.y = q2.y / s2;
      this.z = q2.z / s2;
    }
    return this;
  }
  setAxisAngleFromRotationMatrix(m3) {
    let angle2, x3, y3, z3;
    const epsilon3 = 0.01, epsilon22 = 0.1, te2 = m3.elements, m11 = te2[0], m12 = te2[4], m13 = te2[8], m21 = te2[1], m22 = te2[5], m23 = te2[9], m31 = te2[2], m32 = te2[6], m33 = te2[10];
    if (Math.abs(m12 - m21) < epsilon3 && Math.abs(m13 - m31) < epsilon3 && Math.abs(m23 - m32) < epsilon3) {
      if (Math.abs(m12 + m21) < epsilon22 && Math.abs(m13 + m31) < epsilon22 && Math.abs(m23 + m32) < epsilon22 && Math.abs(m11 + m22 + m33 - 3) < epsilon22) {
        this.set(1, 0, 0, 0);
        return this;
      }
      angle2 = Math.PI;
      const xx = (m11 + 1) / 2;
      const yy = (m22 + 1) / 2;
      const zz = (m33 + 1) / 2;
      const xy = (m12 + m21) / 4;
      const xz = (m13 + m31) / 4;
      const yz = (m23 + m32) / 4;
      if (xx > yy && xx > zz) {
        if (xx < epsilon3) {
          x3 = 0;
          y3 = 0.707106781;
          z3 = 0.707106781;
        } else {
          x3 = Math.sqrt(xx);
          y3 = xy / x3;
          z3 = xz / x3;
        }
      } else if (yy > zz) {
        if (yy < epsilon3) {
          x3 = 0.707106781;
          y3 = 0;
          z3 = 0.707106781;
        } else {
          y3 = Math.sqrt(yy);
          x3 = xy / y3;
          z3 = yz / y3;
        }
      } else {
        if (zz < epsilon3) {
          x3 = 0.707106781;
          y3 = 0.707106781;
          z3 = 0;
        } else {
          z3 = Math.sqrt(zz);
          x3 = xz / z3;
          y3 = yz / z3;
        }
      }
      this.set(x3, y3, z3, angle2);
      return this;
    }
    let s2 = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
    if (Math.abs(s2) < 1e-3) s2 = 1;
    this.x = (m32 - m23) / s2;
    this.y = (m13 - m31) / s2;
    this.z = (m21 - m12) / s2;
    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
    return this;
  }
  min(v2) {
    this.x = Math.min(this.x, v2.x);
    this.y = Math.min(this.y, v2.y);
    this.z = Math.min(this.z, v2.z);
    this.w = Math.min(this.w, v2.w);
    return this;
  }
  max(v2) {
    this.x = Math.max(this.x, v2.x);
    this.y = Math.max(this.y, v2.y);
    this.z = Math.max(this.z, v2.z);
    this.w = Math.max(this.w, v2.w);
    return this;
  }
  clamp(min5, max6) {
    this.x = Math.max(min5.x, Math.min(max6.x, this.x));
    this.y = Math.max(min5.y, Math.min(max6.y, this.y));
    this.z = Math.max(min5.z, Math.min(max6.z, this.z));
    this.w = Math.max(min5.w, Math.min(max6.w, this.w));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    this.w = Math.max(minVal, Math.min(maxVal, this.w));
    return this;
  }
  clampLength(min5, max6) {
    const length2 = this.length();
    return this.divideScalar(length2 || 1).multiplyScalar(Math.max(min5, Math.min(max6, length2)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    this.w = Math.floor(this.w);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    this.w = Math.ceil(this.w);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    this.w = Math.round(this.w);
    return this;
  }
  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    this.z = Math.trunc(this.z);
    this.w = Math.trunc(this.w);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    this.w = -this.w;
    return this;
  }
  dot(v2) {
    return this.x * v2.x + this.y * v2.y + this.z * v2.z + this.w * v2.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length2) {
    return this.normalize().multiplyScalar(length2);
  }
  lerp(v2, alpha) {
    this.x += (v2.x - this.x) * alpha;
    this.y += (v2.y - this.y) * alpha;
    this.z += (v2.z - this.z) * alpha;
    this.w += (v2.w - this.w) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    this.w = v1.w + (v2.w - v1.w) * alpha;
    return this;
  }
  equals(v2) {
    return v2.x === this.x && v2.y === this.y && v2.z === this.z && v2.w === this.w;
  }
  fromArray(array4, offset = 0) {
    this.x = array4[offset];
    this.y = array4[offset + 1];
    this.z = array4[offset + 2];
    this.w = array4[offset + 3];
    return this;
  }
  toArray(array4 = [], offset = 0) {
    array4[offset] = this.x;
    array4[offset + 1] = this.y;
    array4[offset + 2] = this.z;
    array4[offset + 3] = this.w;
    return array4;
  }
  fromBufferAttribute(attribute2, index8) {
    this.x = attribute2.getX(index8);
    this.y = attribute2.getY(index8);
    this.z = attribute2.getZ(index8);
    this.w = attribute2.getW(index8);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    this.w = Math.random();
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
    yield this.z;
    yield this.w;
  }
};
var DataArrayTexture2 = class extends Texture2 {
  constructor(data = null, width = 1, height = 1, depth2 = 1) {
    super(null);
    this.isDataArrayTexture = true;
    this.image = { data, width, height, depth: depth2 };
    this.magFilter = NearestFilter2;
    this.minFilter = NearestFilter2;
    this.wrapR = ClampToEdgeWrapping2;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
  }
};
var Data3DTexture = class extends Texture2 {
  constructor(data = null, width = 1, height = 1, depth2 = 1) {
    super(null);
    this.isData3DTexture = true;
    this.image = { data, width, height, depth: depth2 };
    this.magFilter = NearestFilter2;
    this.minFilter = NearestFilter2;
    this.wrapR = ClampToEdgeWrapping2;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
  }
};
var Quaternion2 = class {
  constructor(x3 = 0, y3 = 0, z3 = 0, w4 = 1) {
    this.isQuaternion = true;
    this._x = x3;
    this._y = y3;
    this._z = z3;
    this._w = w4;
  }
  static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t5) {
    let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w02 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w12 = src1[srcOffset1 + 3];
    if (t5 === 0) {
      dst[dstOffset + 0] = x0;
      dst[dstOffset + 1] = y0;
      dst[dstOffset + 2] = z0;
      dst[dstOffset + 3] = w02;
      return;
    }
    if (t5 === 1) {
      dst[dstOffset + 0] = x1;
      dst[dstOffset + 1] = y1;
      dst[dstOffset + 2] = z1;
      dst[dstOffset + 3] = w12;
      return;
    }
    if (w02 !== w12 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
      let s2 = 1 - t5;
      const cos4 = x0 * x1 + y0 * y1 + z0 * z1 + w02 * w12, dir = cos4 >= 0 ? 1 : -1, sqrSin = 1 - cos4 * cos4;
      if (sqrSin > Number.EPSILON) {
        const sin4 = Math.sqrt(sqrSin), len = Math.atan2(sin4, cos4 * dir);
        s2 = Math.sin(s2 * len) / sin4;
        t5 = Math.sin(t5 * len) / sin4;
      }
      const tDir = t5 * dir;
      x0 = x0 * s2 + x1 * tDir;
      y0 = y0 * s2 + y1 * tDir;
      z0 = z0 * s2 + z1 * tDir;
      w02 = w02 * s2 + w12 * tDir;
      if (s2 === 1 - t5) {
        const f3 = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w02 * w02);
        x0 *= f3;
        y0 *= f3;
        z0 *= f3;
        w02 *= f3;
      }
    }
    dst[dstOffset] = x0;
    dst[dstOffset + 1] = y0;
    dst[dstOffset + 2] = z0;
    dst[dstOffset + 3] = w02;
  }
  static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
    const x0 = src0[srcOffset0];
    const y0 = src0[srcOffset0 + 1];
    const z0 = src0[srcOffset0 + 2];
    const w02 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1];
    const y1 = src1[srcOffset1 + 1];
    const z1 = src1[srcOffset1 + 2];
    const w12 = src1[srcOffset1 + 3];
    dst[dstOffset] = x0 * w12 + w02 * x1 + y0 * z1 - z0 * y1;
    dst[dstOffset + 1] = y0 * w12 + w02 * y1 + z0 * x1 - x0 * z1;
    dst[dstOffset + 2] = z0 * w12 + w02 * z1 + x0 * y1 - y0 * x1;
    dst[dstOffset + 3] = w02 * w12 - x0 * x1 - y0 * y1 - z0 * z1;
    return dst;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(value) {
    this._w = value;
    this._onChangeCallback();
  }
  set(x3, y3, z3, w4) {
    this._x = x3;
    this._y = y3;
    this._z = z3;
    this._w = w4;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(quaternion) {
    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;
    this._onChangeCallback();
    return this;
  }
  setFromEuler(euler, update9 = true) {
    const x3 = euler._x, y3 = euler._y, z3 = euler._z, order = euler._order;
    const cos4 = Math.cos;
    const sin4 = Math.sin;
    const c1 = cos4(x3 / 2);
    const c22 = cos4(y3 / 2);
    const c32 = cos4(z3 / 2);
    const s1 = sin4(x3 / 2);
    const s2 = sin4(y3 / 2);
    const s3 = sin4(z3 / 2);
    switch (order) {
      case "XYZ":
        this._x = s1 * c22 * c32 + c1 * s2 * s3;
        this._y = c1 * s2 * c32 - s1 * c22 * s3;
        this._z = c1 * c22 * s3 + s1 * s2 * c32;
        this._w = c1 * c22 * c32 - s1 * s2 * s3;
        break;
      case "YXZ":
        this._x = s1 * c22 * c32 + c1 * s2 * s3;
        this._y = c1 * s2 * c32 - s1 * c22 * s3;
        this._z = c1 * c22 * s3 - s1 * s2 * c32;
        this._w = c1 * c22 * c32 + s1 * s2 * s3;
        break;
      case "ZXY":
        this._x = s1 * c22 * c32 - c1 * s2 * s3;
        this._y = c1 * s2 * c32 + s1 * c22 * s3;
        this._z = c1 * c22 * s3 + s1 * s2 * c32;
        this._w = c1 * c22 * c32 - s1 * s2 * s3;
        break;
      case "ZYX":
        this._x = s1 * c22 * c32 - c1 * s2 * s3;
        this._y = c1 * s2 * c32 + s1 * c22 * s3;
        this._z = c1 * c22 * s3 - s1 * s2 * c32;
        this._w = c1 * c22 * c32 + s1 * s2 * s3;
        break;
      case "YZX":
        this._x = s1 * c22 * c32 + c1 * s2 * s3;
        this._y = c1 * s2 * c32 + s1 * c22 * s3;
        this._z = c1 * c22 * s3 - s1 * s2 * c32;
        this._w = c1 * c22 * c32 - s1 * s2 * s3;
        break;
      case "XZY":
        this._x = s1 * c22 * c32 - c1 * s2 * s3;
        this._y = c1 * s2 * c32 - s1 * c22 * s3;
        this._z = c1 * c22 * s3 + s1 * s2 * c32;
        this._w = c1 * c22 * c32 + s1 * s2 * s3;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);
    }
    if (update9 === true) this._onChangeCallback();
    return this;
  }
  setFromAxisAngle(axis, angle2) {
    const halfAngle = angle2 / 2, s2 = Math.sin(halfAngle);
    this._x = axis.x * s2;
    this._y = axis.y * s2;
    this._z = axis.z * s2;
    this._w = Math.cos(halfAngle);
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m3) {
    const te2 = m3.elements, m11 = te2[0], m12 = te2[4], m13 = te2[8], m21 = te2[1], m22 = te2[5], m23 = te2[9], m31 = te2[2], m32 = te2[6], m33 = te2[10], trace = m11 + m22 + m33;
    if (trace > 0) {
      const s2 = 0.5 / Math.sqrt(trace + 1);
      this._w = 0.25 / s2;
      this._x = (m32 - m23) * s2;
      this._y = (m13 - m31) * s2;
      this._z = (m21 - m12) * s2;
    } else if (m11 > m22 && m11 > m33) {
      const s2 = 2 * Math.sqrt(1 + m11 - m22 - m33);
      this._w = (m32 - m23) / s2;
      this._x = 0.25 * s2;
      this._y = (m12 + m21) / s2;
      this._z = (m13 + m31) / s2;
    } else if (m22 > m33) {
      const s2 = 2 * Math.sqrt(1 + m22 - m11 - m33);
      this._w = (m13 - m31) / s2;
      this._x = (m12 + m21) / s2;
      this._y = 0.25 * s2;
      this._z = (m23 + m32) / s2;
    } else {
      const s2 = 2 * Math.sqrt(1 + m33 - m11 - m22);
      this._w = (m21 - m12) / s2;
      this._x = (m13 + m31) / s2;
      this._y = (m23 + m32) / s2;
      this._z = 0.25 * s2;
    }
    this._onChangeCallback();
    return this;
  }
  setFromUnitVectors(vFrom, vTo) {
    let r2 = vFrom.dot(vTo) + 1;
    if (r2 < Number.EPSILON) {
      r2 = 0;
      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
        this._x = -vFrom.y;
        this._y = vFrom.x;
        this._z = 0;
        this._w = r2;
      } else {
        this._x = 0;
        this._y = -vFrom.z;
        this._z = vFrom.y;
        this._w = r2;
      }
    } else {
      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
      this._w = r2;
    }
    return this.normalize();
  }
  angleTo(q2) {
    return 2 * Math.acos(Math.abs(clamp2(this.dot(q2), -1, 1)));
  }
  rotateTowards(q2, step2) {
    const angle2 = this.angleTo(q2);
    if (angle2 === 0) return this;
    const t5 = Math.min(1, step2 / angle2);
    this.slerp(q2, t5);
    return this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this._onChangeCallback();
    return this;
  }
  dot(v2) {
    return this._x * v2._x + this._y * v2._y + this._z * v2._z + this._w * v2._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let l2 = this.length();
    if (l2 === 0) {
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;
    } else {
      l2 = 1 / l2;
      this._x = this._x * l2;
      this._y = this._y * l2;
      this._z = this._z * l2;
      this._w = this._w * l2;
    }
    this._onChangeCallback();
    return this;
  }
  multiply(q2) {
    return this.multiplyQuaternions(this, q2);
  }
  premultiply(q2) {
    return this.multiplyQuaternions(q2, this);
  }
  multiplyQuaternions(a3, b) {
    const qax = a3._x, qay = a3._y, qaz = a3._z, qaw = a3._w;
    const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
    this._onChangeCallback();
    return this;
  }
  slerp(qb, t5) {
    if (t5 === 0) return this;
    if (t5 === 1) return this.copy(qb);
    const x3 = this._x, y3 = this._y, z3 = this._z, w4 = this._w;
    let cosHalfTheta = w4 * qb._w + x3 * qb._x + y3 * qb._y + z3 * qb._z;
    if (cosHalfTheta < 0) {
      this._w = -qb._w;
      this._x = -qb._x;
      this._y = -qb._y;
      this._z = -qb._z;
      cosHalfTheta = -cosHalfTheta;
    } else {
      this.copy(qb);
    }
    if (cosHalfTheta >= 1) {
      this._w = w4;
      this._x = x3;
      this._y = y3;
      this._z = z3;
      return this;
    }
    const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
    if (sqrSinHalfTheta <= Number.EPSILON) {
      const s2 = 1 - t5;
      this._w = s2 * w4 + t5 * this._w;
      this._x = s2 * x3 + t5 * this._x;
      this._y = s2 * y3 + t5 * this._y;
      this._z = s2 * z3 + t5 * this._z;
      this.normalize();
      return this;
    }
    const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
    const ratioA = Math.sin((1 - t5) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t5 * halfTheta) / sinHalfTheta;
    this._w = w4 * ratioA + this._w * ratioB;
    this._x = x3 * ratioA + this._x * ratioB;
    this._y = y3 * ratioA + this._y * ratioB;
    this._z = z3 * ratioA + this._z * ratioB;
    this._onChangeCallback();
    return this;
  }
  slerpQuaternions(qa, qb, t5) {
    return this.copy(qa).slerp(qb, t5);
  }
  random() {
    const theta1 = 2 * Math.PI * Math.random();
    const theta2 = 2 * Math.PI * Math.random();
    const x0 = Math.random();
    const r1 = Math.sqrt(1 - x0);
    const r2 = Math.sqrt(x0);
    return this.set(
      r1 * Math.sin(theta1),
      r1 * Math.cos(theta1),
      r2 * Math.sin(theta2),
      r2 * Math.cos(theta2)
    );
  }
  equals(quaternion) {
    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
  }
  fromArray(array4, offset = 0) {
    this._x = array4[offset];
    this._y = array4[offset + 1];
    this._z = array4[offset + 2];
    this._w = array4[offset + 3];
    this._onChangeCallback();
    return this;
  }
  toArray(array4 = [], offset = 0) {
    array4[offset] = this._x;
    array4[offset + 1] = this._y;
    array4[offset + 2] = this._z;
    array4[offset + 3] = this._w;
    return array4;
  }
  fromBufferAttribute(attribute2, index8) {
    this._x = attribute2.getX(index8);
    this._y = attribute2.getY(index8);
    this._z = attribute2.getZ(index8);
    this._w = attribute2.getW(index8);
    this._onChangeCallback();
    return this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x;
    yield this._y;
    yield this._z;
    yield this._w;
  }
};
var Vector32 = class _Vector3 {
  constructor(x3 = 0, y3 = 0, z3 = 0) {
    _Vector3.prototype.isVector3 = true;
    this.x = x3;
    this.y = y3;
    this.z = z3;
  }
  set(x3, y3, z3) {
    if (z3 === void 0) z3 = this.z;
    this.x = x3;
    this.y = y3;
    this.z = z3;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    return this;
  }
  setX(x3) {
    this.x = x3;
    return this;
  }
  setY(y3) {
    this.y = y3;
    return this;
  }
  setZ(z3) {
    this.z = z3;
    return this;
  }
  setComponent(index8, value) {
    switch (index8) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      default:
        throw new Error("index is out of range: " + index8);
    }
    return this;
  }
  getComponent(index8) {
    switch (index8) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + index8);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(v2) {
    this.x = v2.x;
    this.y = v2.y;
    this.z = v2.z;
    return this;
  }
  add(v2) {
    this.x += v2.x;
    this.y += v2.y;
    this.z += v2.z;
    return this;
  }
  addScalar(s2) {
    this.x += s2;
    this.y += s2;
    this.z += s2;
    return this;
  }
  addVectors(a3, b) {
    this.x = a3.x + b.x;
    this.y = a3.y + b.y;
    this.z = a3.z + b.z;
    return this;
  }
  addScaledVector(v2, s2) {
    this.x += v2.x * s2;
    this.y += v2.y * s2;
    this.z += v2.z * s2;
    return this;
  }
  sub(v2) {
    this.x -= v2.x;
    this.y -= v2.y;
    this.z -= v2.z;
    return this;
  }
  subScalar(s2) {
    this.x -= s2;
    this.y -= s2;
    this.z -= s2;
    return this;
  }
  subVectors(a3, b) {
    this.x = a3.x - b.x;
    this.y = a3.y - b.y;
    this.z = a3.z - b.z;
    return this;
  }
  multiply(v2) {
    this.x *= v2.x;
    this.y *= v2.y;
    this.z *= v2.z;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  }
  multiplyVectors(a3, b) {
    this.x = a3.x * b.x;
    this.y = a3.y * b.y;
    this.z = a3.z * b.z;
    return this;
  }
  applyEuler(euler) {
    return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
  }
  applyAxisAngle(axis, angle2) {
    return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle2));
  }
  applyMatrix3(m3) {
    const x3 = this.x, y3 = this.y, z3 = this.z;
    const e3 = m3.elements;
    this.x = e3[0] * x3 + e3[3] * y3 + e3[6] * z3;
    this.y = e3[1] * x3 + e3[4] * y3 + e3[7] * z3;
    this.z = e3[2] * x3 + e3[5] * y3 + e3[8] * z3;
    return this;
  }
  applyNormalMatrix(m3) {
    return this.applyMatrix3(m3).normalize();
  }
  applyMatrix4(m3) {
    const x3 = this.x, y3 = this.y, z3 = this.z;
    const e3 = m3.elements;
    const w4 = 1 / (e3[3] * x3 + e3[7] * y3 + e3[11] * z3 + e3[15]);
    this.x = (e3[0] * x3 + e3[4] * y3 + e3[8] * z3 + e3[12]) * w4;
    this.y = (e3[1] * x3 + e3[5] * y3 + e3[9] * z3 + e3[13]) * w4;
    this.z = (e3[2] * x3 + e3[6] * y3 + e3[10] * z3 + e3[14]) * w4;
    return this;
  }
  applyQuaternion(q2) {
    const vx = this.x, vy = this.y, vz = this.z;
    const qx = q2.x, qy = q2.y, qz = q2.z, qw = q2.w;
    const tx = 2 * (qy * vz - qz * vy);
    const ty = 2 * (qz * vx - qx * vz);
    const tz = 2 * (qx * vy - qy * vx);
    this.x = vx + qw * tx + qy * tz - qz * ty;
    this.y = vy + qw * ty + qz * tx - qx * tz;
    this.z = vz + qw * tz + qx * ty - qy * tx;
    return this;
  }
  project(camera3) {
    return this.applyMatrix4(camera3.matrixWorldInverse).applyMatrix4(camera3.projectionMatrix);
  }
  unproject(camera3) {
    return this.applyMatrix4(camera3.projectionMatrixInverse).applyMatrix4(camera3.matrixWorld);
  }
  transformDirection(m3) {
    const x3 = this.x, y3 = this.y, z3 = this.z;
    const e3 = m3.elements;
    this.x = e3[0] * x3 + e3[4] * y3 + e3[8] * z3;
    this.y = e3[1] * x3 + e3[5] * y3 + e3[9] * z3;
    this.z = e3[2] * x3 + e3[6] * y3 + e3[10] * z3;
    return this.normalize();
  }
  divide(v2) {
    this.x /= v2.x;
    this.y /= v2.y;
    this.z /= v2.z;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  min(v2) {
    this.x = Math.min(this.x, v2.x);
    this.y = Math.min(this.y, v2.y);
    this.z = Math.min(this.z, v2.z);
    return this;
  }
  max(v2) {
    this.x = Math.max(this.x, v2.x);
    this.y = Math.max(this.y, v2.y);
    this.z = Math.max(this.z, v2.z);
    return this;
  }
  clamp(min5, max6) {
    this.x = Math.max(min5.x, Math.min(max6.x, this.x));
    this.y = Math.max(min5.y, Math.min(max6.y, this.y));
    this.z = Math.max(min5.z, Math.min(max6.z, this.z));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    return this;
  }
  clampLength(min5, max6) {
    const length2 = this.length();
    return this.divideScalar(length2 || 1).multiplyScalar(Math.max(min5, Math.min(max6, length2)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  }
  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    this.z = Math.trunc(this.z);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  }
  dot(v2) {
    return this.x * v2.x + this.y * v2.y + this.z * v2.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length2) {
    return this.normalize().multiplyScalar(length2);
  }
  lerp(v2, alpha) {
    this.x += (v2.x - this.x) * alpha;
    this.y += (v2.y - this.y) * alpha;
    this.z += (v2.z - this.z) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    return this;
  }
  cross(v2) {
    return this.crossVectors(this, v2);
  }
  crossVectors(a3, b) {
    const ax = a3.x, ay = a3.y, az = a3.z;
    const bx = b.x, by = b.y, bz = b.z;
    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;
    return this;
  }
  projectOnVector(v2) {
    const denominator = v2.lengthSq();
    if (denominator === 0) return this.set(0, 0, 0);
    const scalar = v2.dot(this) / denominator;
    return this.copy(v2).multiplyScalar(scalar);
  }
  projectOnPlane(planeNormal) {
    _vector$c.copy(this).projectOnVector(planeNormal);
    return this.sub(_vector$c);
  }
  reflect(normal2) {
    return this.sub(_vector$c.copy(normal2).multiplyScalar(2 * this.dot(normal2)));
  }
  angleTo(v2) {
    const denominator = Math.sqrt(this.lengthSq() * v2.lengthSq());
    if (denominator === 0) return Math.PI / 2;
    const theta = this.dot(v2) / denominator;
    return Math.acos(clamp2(theta, -1, 1));
  }
  distanceTo(v2) {
    return Math.sqrt(this.distanceToSquared(v2));
  }
  distanceToSquared(v2) {
    const dx = this.x - v2.x, dy = this.y - v2.y, dz = this.z - v2.z;
    return dx * dx + dy * dy + dz * dz;
  }
  manhattanDistanceTo(v2) {
    return Math.abs(this.x - v2.x) + Math.abs(this.y - v2.y) + Math.abs(this.z - v2.z);
  }
  setFromSpherical(s2) {
    return this.setFromSphericalCoords(s2.radius, s2.phi, s2.theta);
  }
  setFromSphericalCoords(radius, phi, theta) {
    const sinPhiRadius = Math.sin(phi) * radius;
    this.x = sinPhiRadius * Math.sin(theta);
    this.y = Math.cos(phi) * radius;
    this.z = sinPhiRadius * Math.cos(theta);
    return this;
  }
  setFromCylindrical(c5) {
    return this.setFromCylindricalCoords(c5.radius, c5.theta, c5.y);
  }
  setFromCylindricalCoords(radius, theta, y3) {
    this.x = radius * Math.sin(theta);
    this.y = y3;
    this.z = radius * Math.cos(theta);
    return this;
  }
  setFromMatrixPosition(m3) {
    const e3 = m3.elements;
    this.x = e3[12];
    this.y = e3[13];
    this.z = e3[14];
    return this;
  }
  setFromMatrixScale(m3) {
    const sx = this.setFromMatrixColumn(m3, 0).length();
    const sy = this.setFromMatrixColumn(m3, 1).length();
    const sz = this.setFromMatrixColumn(m3, 2).length();
    this.x = sx;
    this.y = sy;
    this.z = sz;
    return this;
  }
  setFromMatrixColumn(m3, index8) {
    return this.fromArray(m3.elements, index8 * 4);
  }
  setFromMatrix3Column(m3, index8) {
    return this.fromArray(m3.elements, index8 * 3);
  }
  setFromEuler(e3) {
    this.x = e3._x;
    this.y = e3._y;
    this.z = e3._z;
    return this;
  }
  setFromColor(c5) {
    this.x = c5.r;
    this.y = c5.g;
    this.z = c5.b;
    return this;
  }
  equals(v2) {
    return v2.x === this.x && v2.y === this.y && v2.z === this.z;
  }
  fromArray(array4, offset = 0) {
    this.x = array4[offset];
    this.y = array4[offset + 1];
    this.z = array4[offset + 2];
    return this;
  }
  toArray(array4 = [], offset = 0) {
    array4[offset] = this.x;
    array4[offset + 1] = this.y;
    array4[offset + 2] = this.z;
    return array4;
  }
  fromBufferAttribute(attribute2, index8) {
    this.x = attribute2.getX(index8);
    this.y = attribute2.getY(index8);
    this.z = attribute2.getZ(index8);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    return this;
  }
  randomDirection() {
    const theta = Math.random() * Math.PI * 2;
    const u2 = Math.random() * 2 - 1;
    const c5 = Math.sqrt(1 - u2 * u2);
    this.x = c5 * Math.cos(theta);
    this.y = u2;
    this.z = c5 * Math.sin(theta);
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
    yield this.z;
  }
};
var _vector$c = new Vector32();
var _quaternion$4 = new Quaternion2();
var Box32 = class {
  constructor(min5 = new Vector32(Infinity, Infinity, Infinity), max6 = new Vector32(-Infinity, -Infinity, -Infinity)) {
    this.isBox3 = true;
    this.min = min5;
    this.max = max6;
  }
  set(min5, max6) {
    this.min.copy(min5);
    this.max.copy(max6);
    return this;
  }
  setFromArray(array4) {
    this.makeEmpty();
    for (let i2 = 0, il = array4.length; i2 < il; i2 += 3) {
      this.expandByPoint(_vector$b.fromArray(array4, i2));
    }
    return this;
  }
  setFromBufferAttribute(attribute2) {
    this.makeEmpty();
    for (let i2 = 0, il = attribute2.count; i2 < il; i2++) {
      this.expandByPoint(_vector$b.fromBufferAttribute(attribute2, i2));
    }
    return this;
  }
  setFromPoints(points) {
    this.makeEmpty();
    for (let i2 = 0, il = points.length; i2 < il; i2++) {
      this.expandByPoint(points[i2]);
    }
    return this;
  }
  setFromCenterAndSize(center, size2) {
    const halfSize = _vector$b.copy(size2).multiplyScalar(0.5);
    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  }
  setFromObject(object, precise = false) {
    this.makeEmpty();
    return this.expandByObject(object, precise);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  }
  makeEmpty() {
    this.min.x = this.min.y = this.min.z = Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(target) {
    return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(target) {
    return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
  }
  expandByPoint(point2) {
    this.min.min(point2);
    this.max.max(point2);
    return this;
  }
  expandByVector(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  }
  expandByScalar(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  }
  expandByObject(object, precise = false) {
    object.updateWorldMatrix(false, false);
    const geometry = object.geometry;
    if (geometry !== void 0) {
      const positionAttribute = geometry.getAttribute("position");
      if (precise === true && positionAttribute !== void 0 && object.isInstancedMesh !== true) {
        for (let i2 = 0, l2 = positionAttribute.count; i2 < l2; i2++) {
          if (object.isMesh === true) {
            object.getVertexPosition(i2, _vector$b);
          } else {
            _vector$b.fromBufferAttribute(positionAttribute, i2);
          }
          _vector$b.applyMatrix4(object.matrixWorld);
          this.expandByPoint(_vector$b);
        }
      } else {
        if (object.boundingBox !== void 0) {
          if (object.boundingBox === null) {
            object.computeBoundingBox();
          }
          _box$4.copy(object.boundingBox);
        } else {
          if (geometry.boundingBox === null) {
            geometry.computeBoundingBox();
          }
          _box$4.copy(geometry.boundingBox);
        }
        _box$4.applyMatrix4(object.matrixWorld);
        this.union(_box$4);
      }
    }
    const children2 = object.children;
    for (let i2 = 0, l2 = children2.length; i2 < l2; i2++) {
      this.expandByObject(children2[i2], precise);
    }
    return this;
  }
  containsPoint(point2) {
    return point2.x < this.min.x || point2.x > this.max.x || point2.y < this.min.y || point2.y > this.max.y || point2.z < this.min.z || point2.z > this.max.z ? false : true;
  }
  containsBox(box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
  }
  getParameter(point2, target) {
    return target.set(
      (point2.x - this.min.x) / (this.max.x - this.min.x),
      (point2.y - this.min.y) / (this.max.y - this.min.y),
      (point2.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(box) {
    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
  }
  intersectsSphere(sphere) {
    this.clampPoint(sphere.center, _vector$b);
    return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
  }
  intersectsPlane(plane) {
    let min5, max6;
    if (plane.normal.x > 0) {
      min5 = plane.normal.x * this.min.x;
      max6 = plane.normal.x * this.max.x;
    } else {
      min5 = plane.normal.x * this.max.x;
      max6 = plane.normal.x * this.min.x;
    }
    if (plane.normal.y > 0) {
      min5 += plane.normal.y * this.min.y;
      max6 += plane.normal.y * this.max.y;
    } else {
      min5 += plane.normal.y * this.max.y;
      max6 += plane.normal.y * this.min.y;
    }
    if (plane.normal.z > 0) {
      min5 += plane.normal.z * this.min.z;
      max6 += plane.normal.z * this.max.z;
    } else {
      min5 += plane.normal.z * this.max.z;
      max6 += plane.normal.z * this.min.z;
    }
    return min5 <= -plane.constant && max6 >= -plane.constant;
  }
  intersectsTriangle(triangle) {
    if (this.isEmpty()) {
      return false;
    }
    this.getCenter(_center);
    _extents.subVectors(this.max, _center);
    _v0$2.subVectors(triangle.a, _center);
    _v1$7.subVectors(triangle.b, _center);
    _v2$4.subVectors(triangle.c, _center);
    _f0.subVectors(_v1$7, _v0$2);
    _f1.subVectors(_v2$4, _v1$7);
    _f2.subVectors(_v0$2, _v2$4);
    let axes = [
      0,
      -_f0.z,
      _f0.y,
      0,
      -_f1.z,
      _f1.y,
      0,
      -_f2.z,
      _f2.y,
      _f0.z,
      0,
      -_f0.x,
      _f1.z,
      0,
      -_f1.x,
      _f2.z,
      0,
      -_f2.x,
      -_f0.y,
      _f0.x,
      0,
      -_f1.y,
      _f1.x,
      0,
      -_f2.y,
      _f2.x,
      0
    ];
    if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {
      return false;
    }
    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {
      return false;
    }
    _triangleNormal.crossVectors(_f0, _f1);
    axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
    return satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents);
  }
  clampPoint(point2, target) {
    return target.copy(point2).clamp(this.min, this.max);
  }
  distanceToPoint(point2) {
    return this.clampPoint(point2, _vector$b).distanceTo(point2);
  }
  getBoundingSphere(target) {
    if (this.isEmpty()) {
      target.makeEmpty();
    } else {
      this.getCenter(target.center);
      target.radius = this.getSize(_vector$b).length() * 0.5;
    }
    return target;
  }
  intersect(box) {
    this.min.max(box.min);
    this.max.min(box.max);
    if (this.isEmpty()) this.makeEmpty();
    return this;
  }
  union(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  }
  applyMatrix4(matrix) {
    if (this.isEmpty()) return this;
    _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
    _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
    this.setFromPoints(_points);
    return this;
  }
  translate(offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  }
  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
};
var _points = [
  new Vector32(),
  new Vector32(),
  new Vector32(),
  new Vector32(),
  new Vector32(),
  new Vector32(),
  new Vector32(),
  new Vector32()
];
var _vector$b = new Vector32();
var _box$4 = new Box32();
var _v0$2 = new Vector32();
var _v1$7 = new Vector32();
var _v2$4 = new Vector32();
var _f0 = new Vector32();
var _f1 = new Vector32();
var _f2 = new Vector32();
var _center = new Vector32();
var _extents = new Vector32();
var _triangleNormal = new Vector32();
var _testAxis = new Vector32();
function satForAxes(axes, v0, v1, v2, extents) {
  for (let i2 = 0, j2 = axes.length - 3; i2 <= j2; i2 += 3) {
    _testAxis.fromArray(axes, i2);
    const r2 = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
    const p0 = v0.dot(_testAxis);
    const p1 = v1.dot(_testAxis);
    const p22 = v2.dot(_testAxis);
    if (Math.max(-Math.max(p0, p1, p22), Math.min(p0, p1, p22)) > r2) {
      return false;
    }
  }
  return true;
}
var _box$3 = new Box32();
var _v1$6 = new Vector32();
var _v2$3 = new Vector32();
var Sphere2 = class {
  constructor(center = new Vector32(), radius = -1) {
    this.isSphere = true;
    this.center = center;
    this.radius = radius;
  }
  set(center, radius) {
    this.center.copy(center);
    this.radius = radius;
    return this;
  }
  setFromPoints(points, optionalCenter) {
    const center = this.center;
    if (optionalCenter !== void 0) {
      center.copy(optionalCenter);
    } else {
      _box$3.setFromPoints(points).getCenter(center);
    }
    let maxRadiusSq = 0;
    for (let i2 = 0, il = points.length; i2 < il; i2++) {
      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i2]));
    }
    this.radius = Math.sqrt(maxRadiusSq);
    return this;
  }
  copy(sphere) {
    this.center.copy(sphere.center);
    this.radius = sphere.radius;
    return this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    this.center.set(0, 0, 0);
    this.radius = -1;
    return this;
  }
  containsPoint(point2) {
    return point2.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(point2) {
    return point2.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(sphere) {
    const radiusSum = this.radius + sphere.radius;
    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
  }
  intersectsBox(box) {
    return box.intersectsSphere(this);
  }
  intersectsPlane(plane) {
    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(point2, target) {
    const deltaLengthSq = this.center.distanceToSquared(point2);
    target.copy(point2);
    if (deltaLengthSq > this.radius * this.radius) {
      target.sub(this.center).normalize();
      target.multiplyScalar(this.radius).add(this.center);
    }
    return target;
  }
  getBoundingBox(target) {
    if (this.isEmpty()) {
      target.makeEmpty();
      return target;
    }
    target.set(this.center, this.center);
    target.expandByScalar(this.radius);
    return target;
  }
  applyMatrix4(matrix) {
    this.center.applyMatrix4(matrix);
    this.radius = this.radius * matrix.getMaxScaleOnAxis();
    return this;
  }
  translate(offset) {
    this.center.add(offset);
    return this;
  }
  expandByPoint(point2) {
    if (this.isEmpty()) {
      this.center.copy(point2);
      this.radius = 0;
      return this;
    }
    _v1$6.subVectors(point2, this.center);
    const lengthSq2 = _v1$6.lengthSq();
    if (lengthSq2 > this.radius * this.radius) {
      const length2 = Math.sqrt(lengthSq2);
      const delta = (length2 - this.radius) * 0.5;
      this.center.addScaledVector(_v1$6, delta / length2);
      this.radius += delta;
    }
    return this;
  }
  union(sphere) {
    if (sphere.isEmpty()) {
      return this;
    }
    if (this.isEmpty()) {
      this.copy(sphere);
      return this;
    }
    if (this.center.equals(sphere.center) === true) {
      this.radius = Math.max(this.radius, sphere.radius);
    } else {
      _v2$3.subVectors(sphere.center, this.center).setLength(sphere.radius);
      this.expandByPoint(_v1$6.copy(sphere.center).add(_v2$3));
      this.expandByPoint(_v1$6.copy(sphere.center).sub(_v2$3));
    }
    return this;
  }
  equals(sphere) {
    return sphere.center.equals(this.center) && sphere.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var _vector$a = new Vector32();
var _segCenter = new Vector32();
var _segDir = new Vector32();
var _diff = new Vector32();
var _edge1 = new Vector32();
var _edge2 = new Vector32();
var _normal$1 = new Vector32();
var Ray2 = class {
  constructor(origin = new Vector32(), direction = new Vector32(0, 0, -1)) {
    this.origin = origin;
    this.direction = direction;
  }
  set(origin, direction) {
    this.origin.copy(origin);
    this.direction.copy(direction);
    return this;
  }
  copy(ray) {
    this.origin.copy(ray.origin);
    this.direction.copy(ray.direction);
    return this;
  }
  at(t5, target) {
    return target.copy(this.origin).addScaledVector(this.direction, t5);
  }
  lookAt(v2) {
    this.direction.copy(v2).sub(this.origin).normalize();
    return this;
  }
  recast(t5) {
    this.origin.copy(this.at(t5, _vector$a));
    return this;
  }
  closestPointToPoint(point2, target) {
    target.subVectors(point2, this.origin);
    const directionDistance = target.dot(this.direction);
    if (directionDistance < 0) {
      return target.copy(this.origin);
    }
    return target.copy(this.origin).addScaledVector(this.direction, directionDistance);
  }
  distanceToPoint(point2) {
    return Math.sqrt(this.distanceSqToPoint(point2));
  }
  distanceSqToPoint(point2) {
    const directionDistance = _vector$a.subVectors(point2, this.origin).dot(this.direction);
    if (directionDistance < 0) {
      return this.origin.distanceToSquared(point2);
    }
    _vector$a.copy(this.origin).addScaledVector(this.direction, directionDistance);
    return _vector$a.distanceToSquared(point2);
  }
  distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
    _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
    _segDir.copy(v1).sub(v0).normalize();
    _diff.copy(this.origin).sub(_segCenter);
    const segExtent = v0.distanceTo(v1) * 0.5;
    const a01 = -this.direction.dot(_segDir);
    const b02 = _diff.dot(this.direction);
    const b12 = -_diff.dot(_segDir);
    const c5 = _diff.lengthSq();
    const det2 = Math.abs(1 - a01 * a01);
    let s0, s1, sqrDist, extDet;
    if (det2 > 0) {
      s0 = a01 * b12 - b02;
      s1 = a01 * b02 - b12;
      extDet = segExtent * det2;
      if (s0 >= 0) {
        if (s1 >= -extDet) {
          if (s1 <= extDet) {
            const invDet = 1 / det2;
            s0 *= invDet;
            s1 *= invDet;
            sqrDist = s0 * (s0 + a01 * s1 + 2 * b02) + s1 * (a01 * s0 + s1 + 2 * b12) + c5;
          } else {
            s1 = segExtent;
            s0 = Math.max(0, -(a01 * s1 + b02));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b12) + c5;
          }
        } else {
          s1 = -segExtent;
          s0 = Math.max(0, -(a01 * s1 + b02));
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b12) + c5;
        }
      } else {
        if (s1 <= -extDet) {
          s0 = Math.max(0, -(-a01 * segExtent + b02));
          s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b12), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b12) + c5;
        } else if (s1 <= extDet) {
          s0 = 0;
          s1 = Math.min(Math.max(-segExtent, -b12), segExtent);
          sqrDist = s1 * (s1 + 2 * b12) + c5;
        } else {
          s0 = Math.max(0, -(a01 * segExtent + b02));
          s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b12), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b12) + c5;
        }
      }
    } else {
      s1 = a01 > 0 ? -segExtent : segExtent;
      s0 = Math.max(0, -(a01 * s1 + b02));
      sqrDist = -s0 * s0 + s1 * (s1 + 2 * b12) + c5;
    }
    if (optionalPointOnRay) {
      optionalPointOnRay.copy(this.origin).addScaledVector(this.direction, s0);
    }
    if (optionalPointOnSegment) {
      optionalPointOnSegment.copy(_segCenter).addScaledVector(_segDir, s1);
    }
    return sqrDist;
  }
  intersectSphere(sphere, target) {
    _vector$a.subVectors(sphere.center, this.origin);
    const tca = _vector$a.dot(this.direction);
    const d22 = _vector$a.dot(_vector$a) - tca * tca;
    const radius2 = sphere.radius * sphere.radius;
    if (d22 > radius2) return null;
    const thc = Math.sqrt(radius2 - d22);
    const t03 = tca - thc;
    const t13 = tca + thc;
    if (t13 < 0) return null;
    if (t03 < 0) return this.at(t13, target);
    return this.at(t03, target);
  }
  intersectsSphere(sphere) {
    return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
  }
  distanceToPlane(plane) {
    const denominator = plane.normal.dot(this.direction);
    if (denominator === 0) {
      if (plane.distanceToPoint(this.origin) === 0) {
        return 0;
      }
      return null;
    }
    const t5 = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
    return t5 >= 0 ? t5 : null;
  }
  intersectPlane(plane, target) {
    const t5 = this.distanceToPlane(plane);
    if (t5 === null) {
      return null;
    }
    return this.at(t5, target);
  }
  intersectsPlane(plane) {
    const distToPoint = plane.distanceToPoint(this.origin);
    if (distToPoint === 0) {
      return true;
    }
    const denominator = plane.normal.dot(this.direction);
    if (denominator * distToPoint < 0) {
      return true;
    }
    return false;
  }
  intersectBox(box, target) {
    let tmin, tmax, tymin, tymax, tzmin, tzmax;
    const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
    const origin = this.origin;
    if (invdirx >= 0) {
      tmin = (box.min.x - origin.x) * invdirx;
      tmax = (box.max.x - origin.x) * invdirx;
    } else {
      tmin = (box.max.x - origin.x) * invdirx;
      tmax = (box.min.x - origin.x) * invdirx;
    }
    if (invdiry >= 0) {
      tymin = (box.min.y - origin.y) * invdiry;
      tymax = (box.max.y - origin.y) * invdiry;
    } else {
      tymin = (box.max.y - origin.y) * invdiry;
      tymax = (box.min.y - origin.y) * invdiry;
    }
    if (tmin > tymax || tymin > tmax) return null;
    if (tymin > tmin || isNaN(tmin)) tmin = tymin;
    if (tymax < tmax || isNaN(tmax)) tmax = tymax;
    if (invdirz >= 0) {
      tzmin = (box.min.z - origin.z) * invdirz;
      tzmax = (box.max.z - origin.z) * invdirz;
    } else {
      tzmin = (box.max.z - origin.z) * invdirz;
      tzmax = (box.min.z - origin.z) * invdirz;
    }
    if (tmin > tzmax || tzmin > tmax) return null;
    if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
    if (tzmax < tmax || tmax !== tmax) tmax = tzmax;
    if (tmax < 0) return null;
    return this.at(tmin >= 0 ? tmin : tmax, target);
  }
  intersectsBox(box) {
    return this.intersectBox(box, _vector$a) !== null;
  }
  intersectTriangle(a3, b, c5, backfaceCulling, target) {
    _edge1.subVectors(b, a3);
    _edge2.subVectors(c5, a3);
    _normal$1.crossVectors(_edge1, _edge2);
    let DdN = this.direction.dot(_normal$1);
    let sign3;
    if (DdN > 0) {
      if (backfaceCulling) return null;
      sign3 = 1;
    } else if (DdN < 0) {
      sign3 = -1;
      DdN = -DdN;
    } else {
      return null;
    }
    _diff.subVectors(this.origin, a3);
    const DdQxE2 = sign3 * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
    if (DdQxE2 < 0) {
      return null;
    }
    const DdE1xQ = sign3 * this.direction.dot(_edge1.cross(_diff));
    if (DdE1xQ < 0) {
      return null;
    }
    if (DdQxE2 + DdE1xQ > DdN) {
      return null;
    }
    const QdN = -sign3 * _diff.dot(_normal$1);
    if (QdN < 0) {
      return null;
    }
    return this.at(QdN / DdN, target);
  }
  applyMatrix4(matrix4) {
    this.origin.applyMatrix4(matrix4);
    this.direction.transformDirection(matrix4);
    return this;
  }
  equals(ray) {
    return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var Matrix42 = class _Matrix4 {
  constructor(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    _Matrix4.prototype.isMatrix4 = true;
    this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
    if (n11 !== void 0) {
      this.set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44);
    }
  }
  set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    const te2 = this.elements;
    te2[0] = n11;
    te2[4] = n12;
    te2[8] = n13;
    te2[12] = n14;
    te2[1] = n21;
    te2[5] = n22;
    te2[9] = n23;
    te2[13] = n24;
    te2[2] = n31;
    te2[6] = n32;
    te2[10] = n33;
    te2[14] = n34;
    te2[3] = n41;
    te2[7] = n42;
    te2[11] = n43;
    te2[15] = n44;
    return this;
  }
  identity() {
    this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  clone() {
    return new _Matrix4().fromArray(this.elements);
  }
  copy(m3) {
    const te2 = this.elements;
    const me = m3.elements;
    te2[0] = me[0];
    te2[1] = me[1];
    te2[2] = me[2];
    te2[3] = me[3];
    te2[4] = me[4];
    te2[5] = me[5];
    te2[6] = me[6];
    te2[7] = me[7];
    te2[8] = me[8];
    te2[9] = me[9];
    te2[10] = me[10];
    te2[11] = me[11];
    te2[12] = me[12];
    te2[13] = me[13];
    te2[14] = me[14];
    te2[15] = me[15];
    return this;
  }
  copyPosition(m3) {
    const te2 = this.elements, me = m3.elements;
    te2[12] = me[12];
    te2[13] = me[13];
    te2[14] = me[14];
    return this;
  }
  setFromMatrix3(m3) {
    const me = m3.elements;
    this.set(
      me[0],
      me[3],
      me[6],
      0,
      me[1],
      me[4],
      me[7],
      0,
      me[2],
      me[5],
      me[8],
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrixColumn(this, 0);
    yAxis.setFromMatrixColumn(this, 1);
    zAxis.setFromMatrixColumn(this, 2);
    return this;
  }
  makeBasis(xAxis, yAxis, zAxis) {
    this.set(
      xAxis.x,
      yAxis.x,
      zAxis.x,
      0,
      xAxis.y,
      yAxis.y,
      zAxis.y,
      0,
      xAxis.z,
      yAxis.z,
      zAxis.z,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  extractRotation(m3) {
    const te2 = this.elements;
    const me = m3.elements;
    const scaleX = 1 / _v1$5.setFromMatrixColumn(m3, 0).length();
    const scaleY = 1 / _v1$5.setFromMatrixColumn(m3, 1).length();
    const scaleZ = 1 / _v1$5.setFromMatrixColumn(m3, 2).length();
    te2[0] = me[0] * scaleX;
    te2[1] = me[1] * scaleX;
    te2[2] = me[2] * scaleX;
    te2[3] = 0;
    te2[4] = me[4] * scaleY;
    te2[5] = me[5] * scaleY;
    te2[6] = me[6] * scaleY;
    te2[7] = 0;
    te2[8] = me[8] * scaleZ;
    te2[9] = me[9] * scaleZ;
    te2[10] = me[10] * scaleZ;
    te2[11] = 0;
    te2[12] = 0;
    te2[13] = 0;
    te2[14] = 0;
    te2[15] = 1;
    return this;
  }
  makeRotationFromEuler(euler) {
    const te2 = this.elements;
    const x3 = euler.x, y3 = euler.y, z3 = euler.z;
    const a3 = Math.cos(x3), b = Math.sin(x3);
    const c5 = Math.cos(y3), d3 = Math.sin(y3);
    const e3 = Math.cos(z3), f3 = Math.sin(z3);
    if (euler.order === "XYZ") {
      const ae = a3 * e3, af = a3 * f3, be = b * e3, bf = b * f3;
      te2[0] = c5 * e3;
      te2[4] = -c5 * f3;
      te2[8] = d3;
      te2[1] = af + be * d3;
      te2[5] = ae - bf * d3;
      te2[9] = -b * c5;
      te2[2] = bf - ae * d3;
      te2[6] = be + af * d3;
      te2[10] = a3 * c5;
    } else if (euler.order === "YXZ") {
      const ce = c5 * e3, cf = c5 * f3, de = d3 * e3, df = d3 * f3;
      te2[0] = ce + df * b;
      te2[4] = de * b - cf;
      te2[8] = a3 * d3;
      te2[1] = a3 * f3;
      te2[5] = a3 * e3;
      te2[9] = -b;
      te2[2] = cf * b - de;
      te2[6] = df + ce * b;
      te2[10] = a3 * c5;
    } else if (euler.order === "ZXY") {
      const ce = c5 * e3, cf = c5 * f3, de = d3 * e3, df = d3 * f3;
      te2[0] = ce - df * b;
      te2[4] = -a3 * f3;
      te2[8] = de + cf * b;
      te2[1] = cf + de * b;
      te2[5] = a3 * e3;
      te2[9] = df - ce * b;
      te2[2] = -a3 * d3;
      te2[6] = b;
      te2[10] = a3 * c5;
    } else if (euler.order === "ZYX") {
      const ae = a3 * e3, af = a3 * f3, be = b * e3, bf = b * f3;
      te2[0] = c5 * e3;
      te2[4] = be * d3 - af;
      te2[8] = ae * d3 + bf;
      te2[1] = c5 * f3;
      te2[5] = bf * d3 + ae;
      te2[9] = af * d3 - be;
      te2[2] = -d3;
      te2[6] = b * c5;
      te2[10] = a3 * c5;
    } else if (euler.order === "YZX") {
      const ac = a3 * c5, ad = a3 * d3, bc = b * c5, bd = b * d3;
      te2[0] = c5 * e3;
      te2[4] = bd - ac * f3;
      te2[8] = bc * f3 + ad;
      te2[1] = f3;
      te2[5] = a3 * e3;
      te2[9] = -b * e3;
      te2[2] = -d3 * e3;
      te2[6] = ad * f3 + bc;
      te2[10] = ac - bd * f3;
    } else if (euler.order === "XZY") {
      const ac = a3 * c5, ad = a3 * d3, bc = b * c5, bd = b * d3;
      te2[0] = c5 * e3;
      te2[4] = -f3;
      te2[8] = d3 * e3;
      te2[1] = ac * f3 + bd;
      te2[5] = a3 * e3;
      te2[9] = ad * f3 - bc;
      te2[2] = bc * f3 - ad;
      te2[6] = b * e3;
      te2[10] = bd * f3 + ac;
    }
    te2[3] = 0;
    te2[7] = 0;
    te2[11] = 0;
    te2[12] = 0;
    te2[13] = 0;
    te2[14] = 0;
    te2[15] = 1;
    return this;
  }
  makeRotationFromQuaternion(q2) {
    return this.compose(_zero, q2, _one);
  }
  lookAt(eye, target, up) {
    const te2 = this.elements;
    _z.subVectors(eye, target);
    if (_z.lengthSq() === 0) {
      _z.z = 1;
    }
    _z.normalize();
    _x.crossVectors(up, _z);
    if (_x.lengthSq() === 0) {
      if (Math.abs(up.z) === 1) {
        _z.x += 1e-4;
      } else {
        _z.z += 1e-4;
      }
      _z.normalize();
      _x.crossVectors(up, _z);
    }
    _x.normalize();
    _y.crossVectors(_z, _x);
    te2[0] = _x.x;
    te2[4] = _y.x;
    te2[8] = _z.x;
    te2[1] = _x.y;
    te2[5] = _y.y;
    te2[9] = _z.y;
    te2[2] = _x.z;
    te2[6] = _y.z;
    te2[10] = _z.z;
    return this;
  }
  multiply(m3) {
    return this.multiplyMatrices(this, m3);
  }
  premultiply(m3) {
    return this.multiplyMatrices(m3, this);
  }
  multiplyMatrices(a3, b) {
    const ae = a3.elements;
    const be = b.elements;
    const te2 = this.elements;
    const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
    const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
    const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
    const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
    const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
    const b21 = be[1], b222 = be[5], b23 = be[9], b24 = be[13];
    const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
    const b41 = be[3], b422 = be[7], b43 = be[11], b44 = be[15];
    te2[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te2[4] = a11 * b12 + a12 * b222 + a13 * b32 + a14 * b422;
    te2[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te2[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te2[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te2[5] = a21 * b12 + a22 * b222 + a23 * b32 + a24 * b422;
    te2[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te2[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te2[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te2[6] = a31 * b12 + a32 * b222 + a33 * b32 + a34 * b422;
    te2[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te2[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te2[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te2[7] = a41 * b12 + a42 * b222 + a43 * b32 + a44 * b422;
    te2[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te2[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  }
  multiplyScalar(s2) {
    const te2 = this.elements;
    te2[0] *= s2;
    te2[4] *= s2;
    te2[8] *= s2;
    te2[12] *= s2;
    te2[1] *= s2;
    te2[5] *= s2;
    te2[9] *= s2;
    te2[13] *= s2;
    te2[2] *= s2;
    te2[6] *= s2;
    te2[10] *= s2;
    te2[14] *= s2;
    te2[3] *= s2;
    te2[7] *= s2;
    te2[11] *= s2;
    te2[15] *= s2;
    return this;
  }
  determinant() {
    const te2 = this.elements;
    const n11 = te2[0], n12 = te2[4], n13 = te2[8], n14 = te2[12];
    const n21 = te2[1], n22 = te2[5], n23 = te2[9], n24 = te2[13];
    const n31 = te2[2], n32 = te2[6], n33 = te2[10], n34 = te2[14];
    const n41 = te2[3], n42 = te2[7], n43 = te2[11], n44 = te2[15];
    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
  }
  transpose() {
    const te2 = this.elements;
    let tmp2;
    tmp2 = te2[1];
    te2[1] = te2[4];
    te2[4] = tmp2;
    tmp2 = te2[2];
    te2[2] = te2[8];
    te2[8] = tmp2;
    tmp2 = te2[6];
    te2[6] = te2[9];
    te2[9] = tmp2;
    tmp2 = te2[3];
    te2[3] = te2[12];
    te2[12] = tmp2;
    tmp2 = te2[7];
    te2[7] = te2[13];
    te2[13] = tmp2;
    tmp2 = te2[11];
    te2[11] = te2[14];
    te2[14] = tmp2;
    return this;
  }
  setPosition(x3, y3, z3) {
    const te2 = this.elements;
    if (x3.isVector3) {
      te2[12] = x3.x;
      te2[13] = x3.y;
      te2[14] = x3.z;
    } else {
      te2[12] = x3;
      te2[13] = y3;
      te2[14] = z3;
    }
    return this;
  }
  invert() {
    const te2 = this.elements, n11 = te2[0], n21 = te2[1], n31 = te2[2], n41 = te2[3], n12 = te2[4], n22 = te2[5], n32 = te2[6], n42 = te2[7], n13 = te2[8], n23 = te2[9], n33 = te2[10], n43 = te2[11], n14 = te2[12], n24 = te2[13], n34 = te2[14], n44 = te2[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t122 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    const det2 = n11 * t11 + n21 * t122 + n31 * t13 + n41 * t14;
    if (det2 === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det2;
    te2[0] = t11 * detInv;
    te2[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
    te2[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
    te2[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
    te2[4] = t122 * detInv;
    te2[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
    te2[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
    te2[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
    te2[8] = t13 * detInv;
    te2[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
    te2[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
    te2[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
    te2[12] = t14 * detInv;
    te2[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
    te2[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
    te2[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
    return this;
  }
  scale(v2) {
    const te2 = this.elements;
    const x3 = v2.x, y3 = v2.y, z3 = v2.z;
    te2[0] *= x3;
    te2[4] *= y3;
    te2[8] *= z3;
    te2[1] *= x3;
    te2[5] *= y3;
    te2[9] *= z3;
    te2[2] *= x3;
    te2[6] *= y3;
    te2[10] *= z3;
    te2[3] *= x3;
    te2[7] *= y3;
    te2[11] *= z3;
    return this;
  }
  getMaxScaleOnAxis() {
    const te2 = this.elements;
    const scaleXSq = te2[0] * te2[0] + te2[1] * te2[1] + te2[2] * te2[2];
    const scaleYSq = te2[4] * te2[4] + te2[5] * te2[5] + te2[6] * te2[6];
    const scaleZSq = te2[8] * te2[8] + te2[9] * te2[9] + te2[10] * te2[10];
    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
  }
  makeTranslation(x3, y3, z3) {
    if (x3.isVector3) {
      this.set(
        1,
        0,
        0,
        x3.x,
        0,
        1,
        0,
        x3.y,
        0,
        0,
        1,
        x3.z,
        0,
        0,
        0,
        1
      );
    } else {
      this.set(
        1,
        0,
        0,
        x3,
        0,
        1,
        0,
        y3,
        0,
        0,
        1,
        z3,
        0,
        0,
        0,
        1
      );
    }
    return this;
  }
  makeRotationX(theta) {
    const c5 = Math.cos(theta), s2 = Math.sin(theta);
    this.set(
      1,
      0,
      0,
      0,
      0,
      c5,
      -s2,
      0,
      0,
      s2,
      c5,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeRotationY(theta) {
    const c5 = Math.cos(theta), s2 = Math.sin(theta);
    this.set(
      c5,
      0,
      s2,
      0,
      0,
      1,
      0,
      0,
      -s2,
      0,
      c5,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeRotationZ(theta) {
    const c5 = Math.cos(theta), s2 = Math.sin(theta);
    this.set(
      c5,
      -s2,
      0,
      0,
      s2,
      c5,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeRotationAxis(axis, angle2) {
    const c5 = Math.cos(angle2);
    const s2 = Math.sin(angle2);
    const t5 = 1 - c5;
    const x3 = axis.x, y3 = axis.y, z3 = axis.z;
    const tx = t5 * x3, ty = t5 * y3;
    this.set(
      tx * x3 + c5,
      tx * y3 - s2 * z3,
      tx * z3 + s2 * y3,
      0,
      tx * y3 + s2 * z3,
      ty * y3 + c5,
      ty * z3 - s2 * x3,
      0,
      tx * z3 - s2 * y3,
      ty * z3 + s2 * x3,
      t5 * z3 * z3 + c5,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeScale(x3, y3, z3) {
    this.set(
      x3,
      0,
      0,
      0,
      0,
      y3,
      0,
      0,
      0,
      0,
      z3,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeShear(xy, xz, yx, yz, zx, zy) {
    this.set(
      1,
      yx,
      zx,
      0,
      xy,
      1,
      zy,
      0,
      xz,
      yz,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  compose(position, quaternion, scale2) {
    const te2 = this.elements;
    const x3 = quaternion._x, y3 = quaternion._y, z3 = quaternion._z, w4 = quaternion._w;
    const x22 = x3 + x3, y22 = y3 + y3, z22 = z3 + z3;
    const xx = x3 * x22, xy = x3 * y22, xz = x3 * z22;
    const yy = y3 * y22, yz = y3 * z22, zz = z3 * z22;
    const wx = w4 * x22, wy = w4 * y22, wz = w4 * z22;
    const sx = scale2.x, sy = scale2.y, sz = scale2.z;
    te2[0] = (1 - (yy + zz)) * sx;
    te2[1] = (xy + wz) * sx;
    te2[2] = (xz - wy) * sx;
    te2[3] = 0;
    te2[4] = (xy - wz) * sy;
    te2[5] = (1 - (xx + zz)) * sy;
    te2[6] = (yz + wx) * sy;
    te2[7] = 0;
    te2[8] = (xz + wy) * sz;
    te2[9] = (yz - wx) * sz;
    te2[10] = (1 - (xx + yy)) * sz;
    te2[11] = 0;
    te2[12] = position.x;
    te2[13] = position.y;
    te2[14] = position.z;
    te2[15] = 1;
    return this;
  }
  decompose(position, quaternion, scale2) {
    const te2 = this.elements;
    let sx = _v1$5.set(te2[0], te2[1], te2[2]).length();
    const sy = _v1$5.set(te2[4], te2[5], te2[6]).length();
    const sz = _v1$5.set(te2[8], te2[9], te2[10]).length();
    const det2 = this.determinant();
    if (det2 < 0) sx = -sx;
    position.x = te2[12];
    position.y = te2[13];
    position.z = te2[14];
    _m1$4.copy(this);
    const invSX = 1 / sx;
    const invSY = 1 / sy;
    const invSZ = 1 / sz;
    _m1$4.elements[0] *= invSX;
    _m1$4.elements[1] *= invSX;
    _m1$4.elements[2] *= invSX;
    _m1$4.elements[4] *= invSY;
    _m1$4.elements[5] *= invSY;
    _m1$4.elements[6] *= invSY;
    _m1$4.elements[8] *= invSZ;
    _m1$4.elements[9] *= invSZ;
    _m1$4.elements[10] *= invSZ;
    quaternion.setFromRotationMatrix(_m1$4);
    scale2.x = sx;
    scale2.y = sy;
    scale2.z = sz;
    return this;
  }
  makePerspective(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem2) {
    const te2 = this.elements;
    const x3 = 2 * near / (right - left);
    const y3 = 2 * near / (top - bottom);
    const a3 = (right + left) / (right - left);
    const b = (top + bottom) / (top - bottom);
    let c5, d3;
    if (coordinateSystem === WebGLCoordinateSystem2) {
      c5 = -(far + near) / (far - near);
      d3 = -2 * far * near / (far - near);
    } else if (coordinateSystem === WebGPUCoordinateSystem2) {
      c5 = -far / (far - near);
      d3 = -far * near / (far - near);
    } else {
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + coordinateSystem);
    }
    te2[0] = x3;
    te2[4] = 0;
    te2[8] = a3;
    te2[12] = 0;
    te2[1] = 0;
    te2[5] = y3;
    te2[9] = b;
    te2[13] = 0;
    te2[2] = 0;
    te2[6] = 0;
    te2[10] = c5;
    te2[14] = d3;
    te2[3] = 0;
    te2[7] = 0;
    te2[11] = -1;
    te2[15] = 0;
    return this;
  }
  makeOrthographic(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem2) {
    const te2 = this.elements;
    const w4 = 1 / (right - left);
    const h2 = 1 / (top - bottom);
    const p3 = 1 / (far - near);
    const x3 = (right + left) * w4;
    const y3 = (top + bottom) * h2;
    let z3, zInv;
    if (coordinateSystem === WebGLCoordinateSystem2) {
      z3 = (far + near) * p3;
      zInv = -2 * p3;
    } else if (coordinateSystem === WebGPUCoordinateSystem2) {
      z3 = near * p3;
      zInv = -1 * p3;
    } else {
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + coordinateSystem);
    }
    te2[0] = 2 * w4;
    te2[4] = 0;
    te2[8] = 0;
    te2[12] = -x3;
    te2[1] = 0;
    te2[5] = 2 * h2;
    te2[9] = 0;
    te2[13] = -y3;
    te2[2] = 0;
    te2[6] = 0;
    te2[10] = zInv;
    te2[14] = -z3;
    te2[3] = 0;
    te2[7] = 0;
    te2[11] = 0;
    te2[15] = 1;
    return this;
  }
  equals(matrix) {
    const te2 = this.elements;
    const me = matrix.elements;
    for (let i2 = 0; i2 < 16; i2++) {
      if (te2[i2] !== me[i2]) return false;
    }
    return true;
  }
  fromArray(array4, offset = 0) {
    for (let i2 = 0; i2 < 16; i2++) {
      this.elements[i2] = array4[i2 + offset];
    }
    return this;
  }
  toArray(array4 = [], offset = 0) {
    const te2 = this.elements;
    array4[offset] = te2[0];
    array4[offset + 1] = te2[1];
    array4[offset + 2] = te2[2];
    array4[offset + 3] = te2[3];
    array4[offset + 4] = te2[4];
    array4[offset + 5] = te2[5];
    array4[offset + 6] = te2[6];
    array4[offset + 7] = te2[7];
    array4[offset + 8] = te2[8];
    array4[offset + 9] = te2[9];
    array4[offset + 10] = te2[10];
    array4[offset + 11] = te2[11];
    array4[offset + 12] = te2[12];
    array4[offset + 13] = te2[13];
    array4[offset + 14] = te2[14];
    array4[offset + 15] = te2[15];
    return array4;
  }
};
var _v1$5 = new Vector32();
var _m1$4 = new Matrix42();
var _zero = new Vector32(0, 0, 0);
var _one = new Vector32(1, 1, 1);
var _x = new Vector32();
var _y = new Vector32();
var _z = new Vector32();
var _matrix$2 = new Matrix42();
var _quaternion$3 = new Quaternion2();
var Euler2 = class _Euler {
  constructor(x3 = 0, y3 = 0, z3 = 0, order = _Euler.DEFAULT_ORDER) {
    this.isEuler = true;
    this._x = x3;
    this._y = y3;
    this._z = z3;
    this._order = order;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(value) {
    this._order = value;
    this._onChangeCallback();
  }
  set(x3, y3, z3, order = this._order) {
    this._x = x3;
    this._y = y3;
    this._z = z3;
    this._order = order;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(euler) {
    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m3, order = this._order, update9 = true) {
    const te2 = m3.elements;
    const m11 = te2[0], m12 = te2[4], m13 = te2[8];
    const m21 = te2[1], m22 = te2[5], m23 = te2[9];
    const m31 = te2[2], m32 = te2[6], m33 = te2[10];
    switch (order) {
      case "XYZ":
        this._y = Math.asin(clamp2(m13, -1, 1));
        if (Math.abs(m13) < 0.9999999) {
          this._x = Math.atan2(-m23, m33);
          this._z = Math.atan2(-m12, m11);
        } else {
          this._x = Math.atan2(m32, m22);
          this._z = 0;
        }
        break;
      case "YXZ":
        this._x = Math.asin(-clamp2(m23, -1, 1));
        if (Math.abs(m23) < 0.9999999) {
          this._y = Math.atan2(m13, m33);
          this._z = Math.atan2(m21, m22);
        } else {
          this._y = Math.atan2(-m31, m11);
          this._z = 0;
        }
        break;
      case "ZXY":
        this._x = Math.asin(clamp2(m32, -1, 1));
        if (Math.abs(m32) < 0.9999999) {
          this._y = Math.atan2(-m31, m33);
          this._z = Math.atan2(-m12, m22);
        } else {
          this._y = 0;
          this._z = Math.atan2(m21, m11);
        }
        break;
      case "ZYX":
        this._y = Math.asin(-clamp2(m31, -1, 1));
        if (Math.abs(m31) < 0.9999999) {
          this._x = Math.atan2(m32, m33);
          this._z = Math.atan2(m21, m11);
        } else {
          this._x = 0;
          this._z = Math.atan2(-m12, m22);
        }
        break;
      case "YZX":
        this._z = Math.asin(clamp2(m21, -1, 1));
        if (Math.abs(m21) < 0.9999999) {
          this._x = Math.atan2(-m23, m22);
          this._y = Math.atan2(-m31, m11);
        } else {
          this._x = 0;
          this._y = Math.atan2(m13, m33);
        }
        break;
      case "XZY":
        this._z = Math.asin(-clamp2(m12, -1, 1));
        if (Math.abs(m12) < 0.9999999) {
          this._x = Math.atan2(m32, m22);
          this._y = Math.atan2(m13, m11);
        } else {
          this._x = Math.atan2(-m23, m33);
          this._y = 0;
        }
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
    }
    this._order = order;
    if (update9 === true) this._onChangeCallback();
    return this;
  }
  setFromQuaternion(q2, order, update9) {
    _matrix$2.makeRotationFromQuaternion(q2);
    return this.setFromRotationMatrix(_matrix$2, order, update9);
  }
  setFromVector3(v2, order = this._order) {
    return this.set(v2.x, v2.y, v2.z, order);
  }
  reorder(newOrder) {
    _quaternion$3.setFromEuler(this);
    return this.setFromQuaternion(_quaternion$3, newOrder);
  }
  equals(euler) {
    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
  }
  fromArray(array4) {
    this._x = array4[0];
    this._y = array4[1];
    this._z = array4[2];
    if (array4[3] !== void 0) this._order = array4[3];
    this._onChangeCallback();
    return this;
  }
  toArray(array4 = [], offset = 0) {
    array4[offset] = this._x;
    array4[offset + 1] = this._y;
    array4[offset + 2] = this._z;
    array4[offset + 3] = this._order;
    return array4;
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x;
    yield this._y;
    yield this._z;
    yield this._order;
  }
};
Euler2.DEFAULT_ORDER = "XYZ";
var Layers = class {
  constructor() {
    this.mask = 1 | 0;
  }
  set(channel) {
    this.mask = (1 << channel | 0) >>> 0;
  }
  enable(channel) {
    this.mask |= 1 << channel | 0;
  }
  enableAll() {
    this.mask = 4294967295 | 0;
  }
  toggle(channel) {
    this.mask ^= 1 << channel | 0;
  }
  disable(channel) {
    this.mask &= ~(1 << channel | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(layers) {
    return (this.mask & layers.mask) !== 0;
  }
  isEnabled(channel) {
    return (this.mask & (1 << channel | 0)) !== 0;
  }
};
var _object3DId = 0;
var _v1$4 = new Vector32();
var _q1 = new Quaternion2();
var _m1$3 = new Matrix42();
var _target = new Vector32();
var _position$3 = new Vector32();
var _scale$2 = new Vector32();
var _quaternion$2 = new Quaternion2();
var _xAxis = new Vector32(1, 0, 0);
var _yAxis = new Vector32(0, 1, 0);
var _zAxis = new Vector32(0, 0, 1);
var _addedEvent = { type: "added" };
var _removedEvent = { type: "removed" };
var _childaddedEvent = { type: "childadded", child: null };
var _childremovedEvent = { type: "childremoved", child: null };
var Object3D2 = class _Object3D extends EventDispatcher2 {
  constructor() {
    super();
    this.isObject3D = true;
    Object.defineProperty(this, "id", { value: _object3DId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "Object3D";
    this.parent = null;
    this.children = [];
    this.up = _Object3D.DEFAULT_UP.clone();
    const position = new Vector32();
    const rotation = new Euler2();
    const quaternion = new Quaternion2();
    const scale2 = new Vector32(1, 1, 1);
    function onRotationChange() {
      quaternion.setFromEuler(rotation, false);
    }
    function onQuaternionChange() {
      rotation.setFromQuaternion(quaternion, void 0, false);
    }
    rotation._onChange(onRotationChange);
    quaternion._onChange(onQuaternionChange);
    Object.defineProperties(this, {
      position: {
        configurable: true,
        enumerable: true,
        value: position
      },
      rotation: {
        configurable: true,
        enumerable: true,
        value: rotation
      },
      quaternion: {
        configurable: true,
        enumerable: true,
        value: quaternion
      },
      scale: {
        configurable: true,
        enumerable: true,
        value: scale2
      },
      modelViewMatrix: {
        value: new Matrix42()
      },
      normalMatrix: {
        value: new Matrix32()
      }
    });
    this.matrix = new Matrix42();
    this.matrixWorld = new Matrix42();
    this.matrixAutoUpdate = _Object3D.DEFAULT_MATRIX_AUTO_UPDATE;
    this.matrixWorldAutoUpdate = _Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE;
    this.matrixWorldNeedsUpdate = false;
    this.layers = new Layers();
    this.visible = true;
    this.castShadow = false;
    this.receiveShadow = false;
    this.frustumCulled = true;
    this.renderOrder = 0;
    this.animations = [];
    this.userData = {};
  }
  onBeforeShadow() {
  }
  onAfterShadow() {
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(matrix) {
    if (this.matrixAutoUpdate) this.updateMatrix();
    this.matrix.premultiply(matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(q2) {
    this.quaternion.premultiply(q2);
    return this;
  }
  setRotationFromAxisAngle(axis, angle2) {
    this.quaternion.setFromAxisAngle(axis, angle2);
  }
  setRotationFromEuler(euler) {
    this.quaternion.setFromEuler(euler, true);
  }
  setRotationFromMatrix(m3) {
    this.quaternion.setFromRotationMatrix(m3);
  }
  setRotationFromQuaternion(q2) {
    this.quaternion.copy(q2);
  }
  rotateOnAxis(axis, angle2) {
    _q1.setFromAxisAngle(axis, angle2);
    this.quaternion.multiply(_q1);
    return this;
  }
  rotateOnWorldAxis(axis, angle2) {
    _q1.setFromAxisAngle(axis, angle2);
    this.quaternion.premultiply(_q1);
    return this;
  }
  rotateX(angle2) {
    return this.rotateOnAxis(_xAxis, angle2);
  }
  rotateY(angle2) {
    return this.rotateOnAxis(_yAxis, angle2);
  }
  rotateZ(angle2) {
    return this.rotateOnAxis(_zAxis, angle2);
  }
  translateOnAxis(axis, distance4) {
    _v1$4.copy(axis).applyQuaternion(this.quaternion);
    this.position.add(_v1$4.multiplyScalar(distance4));
    return this;
  }
  translateX(distance4) {
    return this.translateOnAxis(_xAxis, distance4);
  }
  translateY(distance4) {
    return this.translateOnAxis(_yAxis, distance4);
  }
  translateZ(distance4) {
    return this.translateOnAxis(_zAxis, distance4);
  }
  localToWorld(vector) {
    this.updateWorldMatrix(true, false);
    return vector.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(vector) {
    this.updateWorldMatrix(true, false);
    return vector.applyMatrix4(_m1$3.copy(this.matrixWorld).invert());
  }
  lookAt(x3, y3, z3) {
    if (x3.isVector3) {
      _target.copy(x3);
    } else {
      _target.set(x3, y3, z3);
    }
    const parent2 = this.parent;
    this.updateWorldMatrix(true, false);
    _position$3.setFromMatrixPosition(this.matrixWorld);
    if (this.isCamera || this.isLight) {
      _m1$3.lookAt(_position$3, _target, this.up);
    } else {
      _m1$3.lookAt(_target, _position$3, this.up);
    }
    this.quaternion.setFromRotationMatrix(_m1$3);
    if (parent2) {
      _m1$3.extractRotation(parent2.matrixWorld);
      _q1.setFromRotationMatrix(_m1$3);
      this.quaternion.premultiply(_q1.invert());
    }
  }
  add(object) {
    if (arguments.length > 1) {
      for (let i2 = 0; i2 < arguments.length; i2++) {
        this.add(arguments[i2]);
      }
      return this;
    }
    if (object === this) {
      console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
      return this;
    }
    if (object && object.isObject3D) {
      object.removeFromParent();
      object.parent = this;
      this.children.push(object);
      object.dispatchEvent(_addedEvent);
      _childaddedEvent.child = object;
      this.dispatchEvent(_childaddedEvent);
      _childaddedEvent.child = null;
    } else {
      console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
    }
    return this;
  }
  remove(object) {
    if (arguments.length > 1) {
      for (let i2 = 0; i2 < arguments.length; i2++) {
        this.remove(arguments[i2]);
      }
      return this;
    }
    const index8 = this.children.indexOf(object);
    if (index8 !== -1) {
      object.parent = null;
      this.children.splice(index8, 1);
      object.dispatchEvent(_removedEvent);
      _childremovedEvent.child = object;
      this.dispatchEvent(_childremovedEvent);
      _childremovedEvent.child = null;
    }
    return this;
  }
  removeFromParent() {
    const parent2 = this.parent;
    if (parent2 !== null) {
      parent2.remove(this);
    }
    return this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(object) {
    this.updateWorldMatrix(true, false);
    _m1$3.copy(this.matrixWorld).invert();
    if (object.parent !== null) {
      object.parent.updateWorldMatrix(true, false);
      _m1$3.multiply(object.parent.matrixWorld);
    }
    object.applyMatrix4(_m1$3);
    object.removeFromParent();
    object.parent = this;
    this.children.push(object);
    object.updateWorldMatrix(false, true);
    object.dispatchEvent(_addedEvent);
    _childaddedEvent.child = object;
    this.dispatchEvent(_childaddedEvent);
    _childaddedEvent.child = null;
    return this;
  }
  getObjectById(id2) {
    return this.getObjectByProperty("id", id2);
  }
  getObjectByName(name) {
    return this.getObjectByProperty("name", name);
  }
  getObjectByProperty(name, value) {
    if (this[name] === value) return this;
    for (let i2 = 0, l2 = this.children.length; i2 < l2; i2++) {
      const child = this.children[i2];
      const object = child.getObjectByProperty(name, value);
      if (object !== void 0) {
        return object;
      }
    }
    return void 0;
  }
  getObjectsByProperty(name, value, result2 = []) {
    if (this[name] === value) result2.push(this);
    const children2 = this.children;
    for (let i2 = 0, l2 = children2.length; i2 < l2; i2++) {
      children2[i2].getObjectsByProperty(name, value, result2);
    }
    return result2;
  }
  getWorldPosition(target) {
    this.updateWorldMatrix(true, false);
    return target.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position$3, target, _scale$2);
    return target;
  }
  getWorldScale(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position$3, _quaternion$2, target);
    return target;
  }
  getWorldDirection(target) {
    this.updateWorldMatrix(true, false);
    const e3 = this.matrixWorld.elements;
    return target.set(e3[8], e3[9], e3[10]).normalize();
  }
  raycast() {
  }
  traverse(callback) {
    callback(this);
    const children2 = this.children;
    for (let i2 = 0, l2 = children2.length; i2 < l2; i2++) {
      children2[i2].traverse(callback);
    }
  }
  traverseVisible(callback) {
    if (this.visible === false) return;
    callback(this);
    const children2 = this.children;
    for (let i2 = 0, l2 = children2.length; i2 < l2; i2++) {
      children2[i2].traverseVisible(callback);
    }
  }
  traverseAncestors(callback) {
    const parent2 = this.parent;
    if (parent2 !== null) {
      callback(parent2);
      parent2.traverseAncestors(callback);
    }
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = true;
  }
  updateMatrixWorld(force) {
    if (this.matrixAutoUpdate) this.updateMatrix();
    if (this.matrixWorldNeedsUpdate || force) {
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }
      this.matrixWorldNeedsUpdate = false;
      force = true;
    }
    const children2 = this.children;
    for (let i2 = 0, l2 = children2.length; i2 < l2; i2++) {
      const child = children2[i2];
      if (child.matrixWorldAutoUpdate === true || force === true) {
        child.updateMatrixWorld(force);
      }
    }
  }
  updateWorldMatrix(updateParents, updateChildren) {
    const parent2 = this.parent;
    if (updateParents === true && parent2 !== null && parent2.matrixWorldAutoUpdate === true) {
      parent2.updateWorldMatrix(true, false);
    }
    if (this.matrixAutoUpdate) this.updateMatrix();
    if (this.parent === null) {
      this.matrixWorld.copy(this.matrix);
    } else {
      this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
    }
    if (updateChildren === true) {
      const children2 = this.children;
      for (let i2 = 0, l2 = children2.length; i2 < l2; i2++) {
        const child = children2[i2];
        if (child.matrixWorldAutoUpdate === true) {
          child.updateWorldMatrix(false, true);
        }
      }
    }
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    const output2 = {};
    if (isRootObject) {
      meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {}
      };
      output2.metadata = {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON"
      };
    }
    const object = {};
    object.uuid = this.uuid;
    object.type = this.type;
    if (this.name !== "") object.name = this.name;
    if (this.castShadow === true) object.castShadow = true;
    if (this.receiveShadow === true) object.receiveShadow = true;
    if (this.visible === false) object.visible = false;
    if (this.frustumCulled === false) object.frustumCulled = false;
    if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
    if (Object.keys(this.userData).length > 0) object.userData = this.userData;
    object.layers = this.layers.mask;
    object.matrix = this.matrix.toArray();
    object.up = this.up.toArray();
    if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;
    if (this.isInstancedMesh) {
      object.type = "InstancedMesh";
      object.count = this.count;
      object.instanceMatrix = this.instanceMatrix.toJSON();
      if (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();
    }
    if (this.isBatchedMesh) {
      object.type = "BatchedMesh";
      object.perObjectFrustumCulled = this.perObjectFrustumCulled;
      object.sortObjects = this.sortObjects;
      object.drawRanges = this._drawRanges;
      object.reservedRanges = this._reservedRanges;
      object.visibility = this._visibility;
      object.active = this._active;
      object.bounds = this._bounds.map((bound) => ({
        boxInitialized: bound.boxInitialized,
        boxMin: bound.box.min.toArray(),
        boxMax: bound.box.max.toArray(),
        sphereInitialized: bound.sphereInitialized,
        sphereRadius: bound.sphere.radius,
        sphereCenter: bound.sphere.center.toArray()
      }));
      object.maxGeometryCount = this._maxGeometryCount;
      object.maxVertexCount = this._maxVertexCount;
      object.maxIndexCount = this._maxIndexCount;
      object.geometryInitialized = this._geometryInitialized;
      object.geometryCount = this._geometryCount;
      object.matricesTexture = this._matricesTexture.toJSON(meta);
      if (this.boundingSphere !== null) {
        object.boundingSphere = {
          center: object.boundingSphere.center.toArray(),
          radius: object.boundingSphere.radius
        };
      }
      if (this.boundingBox !== null) {
        object.boundingBox = {
          min: object.boundingBox.min.toArray(),
          max: object.boundingBox.max.toArray()
        };
      }
    }
    function serialize(library, element2) {
      if (library[element2.uuid] === void 0) {
        library[element2.uuid] = element2.toJSON(meta);
      }
      return element2.uuid;
    }
    if (this.isScene) {
      if (this.background) {
        if (this.background.isColor) {
          object.background = this.background.toJSON();
        } else if (this.background.isTexture) {
          object.background = this.background.toJSON(meta).uuid;
        }
      }
      if (this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true) {
        object.environment = this.environment.toJSON(meta).uuid;
      }
    } else if (this.isMesh || this.isLine || this.isPoints) {
      object.geometry = serialize(meta.geometries, this.geometry);
      const parameters = this.geometry.parameters;
      if (parameters !== void 0 && parameters.shapes !== void 0) {
        const shapes = parameters.shapes;
        if (Array.isArray(shapes)) {
          for (let i2 = 0, l2 = shapes.length; i2 < l2; i2++) {
            const shape = shapes[i2];
            serialize(meta.shapes, shape);
          }
        } else {
          serialize(meta.shapes, shapes);
        }
      }
    }
    if (this.isSkinnedMesh) {
      object.bindMode = this.bindMode;
      object.bindMatrix = this.bindMatrix.toArray();
      if (this.skeleton !== void 0) {
        serialize(meta.skeletons, this.skeleton);
        object.skeleton = this.skeleton.uuid;
      }
    }
    if (this.material !== void 0) {
      if (Array.isArray(this.material)) {
        const uuids = [];
        for (let i2 = 0, l2 = this.material.length; i2 < l2; i2++) {
          uuids.push(serialize(meta.materials, this.material[i2]));
        }
        object.material = uuids;
      } else {
        object.material = serialize(meta.materials, this.material);
      }
    }
    if (this.children.length > 0) {
      object.children = [];
      for (let i2 = 0; i2 < this.children.length; i2++) {
        object.children.push(this.children[i2].toJSON(meta).object);
      }
    }
    if (this.animations.length > 0) {
      object.animations = [];
      for (let i2 = 0; i2 < this.animations.length; i2++) {
        const animation = this.animations[i2];
        object.animations.push(serialize(meta.animations, animation));
      }
    }
    if (isRootObject) {
      const geometries = extractFromCache(meta.geometries);
      const materials = extractFromCache(meta.materials);
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const shapes = extractFromCache(meta.shapes);
      const skeletons = extractFromCache(meta.skeletons);
      const animations = extractFromCache(meta.animations);
      const nodes = extractFromCache(meta.nodes);
      if (geometries.length > 0) output2.geometries = geometries;
      if (materials.length > 0) output2.materials = materials;
      if (textures.length > 0) output2.textures = textures;
      if (images.length > 0) output2.images = images;
      if (shapes.length > 0) output2.shapes = shapes;
      if (skeletons.length > 0) output2.skeletons = skeletons;
      if (animations.length > 0) output2.animations = animations;
      if (nodes.length > 0) output2.nodes = nodes;
    }
    output2.object = object;
    return output2;
    function extractFromCache(cache2) {
      const values2 = [];
      for (const key in cache2) {
        const data = cache2[key];
        delete data.metadata;
        values2.push(data);
      }
      return values2;
    }
  }
  clone(recursive) {
    return new this.constructor().copy(this, recursive);
  }
  copy(source, recursive = true) {
    this.name = source.name;
    this.up.copy(source.up);
    this.position.copy(source.position);
    this.rotation.order = source.rotation.order;
    this.quaternion.copy(source.quaternion);
    this.scale.copy(source.scale);
    this.matrix.copy(source.matrix);
    this.matrixWorld.copy(source.matrixWorld);
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;
    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
    this.layers.mask = source.layers.mask;
    this.visible = source.visible;
    this.castShadow = source.castShadow;
    this.receiveShadow = source.receiveShadow;
    this.frustumCulled = source.frustumCulled;
    this.renderOrder = source.renderOrder;
    this.animations = source.animations.slice();
    this.userData = JSON.parse(JSON.stringify(source.userData));
    if (recursive === true) {
      for (let i2 = 0; i2 < source.children.length; i2++) {
        const child = source.children[i2];
        this.add(child.clone());
      }
    }
    return this;
  }
};
Object3D2.DEFAULT_UP = new Vector32(0, 1, 0);
Object3D2.DEFAULT_MATRIX_AUTO_UPDATE = true;
Object3D2.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;
var _v0$1 = new Vector32();
var _v1$3 = new Vector32();
var _v2$2 = new Vector32();
var _v3$2 = new Vector32();
var _vab = new Vector32();
var _vac = new Vector32();
var _vbc = new Vector32();
var _vap = new Vector32();
var _vbp = new Vector32();
var _vcp = new Vector32();
var Triangle2 = class _Triangle {
  constructor(a3 = new Vector32(), b = new Vector32(), c5 = new Vector32()) {
    this.a = a3;
    this.b = b;
    this.c = c5;
  }
  static getNormal(a3, b, c5, target) {
    target.subVectors(c5, b);
    _v0$1.subVectors(a3, b);
    target.cross(_v0$1);
    const targetLengthSq = target.lengthSq();
    if (targetLengthSq > 0) {
      return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
    }
    return target.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(point2, a3, b, c5, target) {
    _v0$1.subVectors(c5, a3);
    _v1$3.subVectors(b, a3);
    _v2$2.subVectors(point2, a3);
    const dot00 = _v0$1.dot(_v0$1);
    const dot01 = _v0$1.dot(_v1$3);
    const dot02 = _v0$1.dot(_v2$2);
    const dot11 = _v1$3.dot(_v1$3);
    const dot12 = _v1$3.dot(_v2$2);
    const denom = dot00 * dot11 - dot01 * dot01;
    if (denom === 0) {
      target.set(0, 0, 0);
      return null;
    }
    const invDenom = 1 / denom;
    const u2 = (dot11 * dot02 - dot01 * dot12) * invDenom;
    const v2 = (dot00 * dot12 - dot01 * dot02) * invDenom;
    return target.set(1 - u2 - v2, v2, u2);
  }
  static containsPoint(point2, a3, b, c5) {
    if (this.getBarycoord(point2, a3, b, c5, _v3$2) === null) {
      return false;
    }
    return _v3$2.x >= 0 && _v3$2.y >= 0 && _v3$2.x + _v3$2.y <= 1;
  }
  static getInterpolation(point2, p1, p22, p3, v1, v2, v3, target) {
    if (this.getBarycoord(point2, p1, p22, p3, _v3$2) === null) {
      target.x = 0;
      target.y = 0;
      if ("z" in target) target.z = 0;
      if ("w" in target) target.w = 0;
      return null;
    }
    target.setScalar(0);
    target.addScaledVector(v1, _v3$2.x);
    target.addScaledVector(v2, _v3$2.y);
    target.addScaledVector(v3, _v3$2.z);
    return target;
  }
  static isFrontFacing(a3, b, c5, direction) {
    _v0$1.subVectors(c5, b);
    _v1$3.subVectors(a3, b);
    return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
  }
  set(a3, b, c5) {
    this.a.copy(a3);
    this.b.copy(b);
    this.c.copy(c5);
    return this;
  }
  setFromPointsAndIndices(points, i0, i1, i2) {
    this.a.copy(points[i0]);
    this.b.copy(points[i1]);
    this.c.copy(points[i2]);
    return this;
  }
  setFromAttributeAndIndices(attribute2, i0, i1, i2) {
    this.a.fromBufferAttribute(attribute2, i0);
    this.b.fromBufferAttribute(attribute2, i1);
    this.c.fromBufferAttribute(attribute2, i2);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(triangle) {
    this.a.copy(triangle.a);
    this.b.copy(triangle.b);
    this.c.copy(triangle.c);
    return this;
  }
  getArea() {
    _v0$1.subVectors(this.c, this.b);
    _v1$3.subVectors(this.a, this.b);
    return _v0$1.cross(_v1$3).length() * 0.5;
  }
  getMidpoint(target) {
    return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(target) {
    return _Triangle.getNormal(this.a, this.b, this.c, target);
  }
  getPlane(target) {
    return target.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(point2, target) {
    return _Triangle.getBarycoord(point2, this.a, this.b, this.c, target);
  }
  getInterpolation(point2, v1, v2, v3, target) {
    return _Triangle.getInterpolation(point2, this.a, this.b, this.c, v1, v2, v3, target);
  }
  containsPoint(point2) {
    return _Triangle.containsPoint(point2, this.a, this.b, this.c);
  }
  isFrontFacing(direction) {
    return _Triangle.isFrontFacing(this.a, this.b, this.c, direction);
  }
  intersectsBox(box) {
    return box.intersectsTriangle(this);
  }
  closestPointToPoint(p3, target) {
    const a3 = this.a, b = this.b, c5 = this.c;
    let v2, w4;
    _vab.subVectors(b, a3);
    _vac.subVectors(c5, a3);
    _vap.subVectors(p3, a3);
    const d1 = _vab.dot(_vap);
    const d22 = _vac.dot(_vap);
    if (d1 <= 0 && d22 <= 0) {
      return target.copy(a3);
    }
    _vbp.subVectors(p3, b);
    const d3 = _vab.dot(_vbp);
    const d4 = _vac.dot(_vbp);
    if (d3 >= 0 && d4 <= d3) {
      return target.copy(b);
    }
    const vc = d1 * d4 - d3 * d22;
    if (vc <= 0 && d1 >= 0 && d3 <= 0) {
      v2 = d1 / (d1 - d3);
      return target.copy(a3).addScaledVector(_vab, v2);
    }
    _vcp.subVectors(p3, c5);
    const d5 = _vab.dot(_vcp);
    const d6 = _vac.dot(_vcp);
    if (d6 >= 0 && d5 <= d6) {
      return target.copy(c5);
    }
    const vb = d5 * d22 - d1 * d6;
    if (vb <= 0 && d22 >= 0 && d6 <= 0) {
      w4 = d22 / (d22 - d6);
      return target.copy(a3).addScaledVector(_vac, w4);
    }
    const va = d3 * d6 - d5 * d4;
    if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
      _vbc.subVectors(c5, b);
      w4 = (d4 - d3) / (d4 - d3 + (d5 - d6));
      return target.copy(b).addScaledVector(_vbc, w4);
    }
    const denom = 1 / (va + vb + vc);
    v2 = vb * denom;
    w4 = vc * denom;
    return target.copy(a3).addScaledVector(_vab, v2).addScaledVector(_vac, w4);
  }
  equals(triangle) {
    return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
  }
};
var _colorKeywords = {
  "aliceblue": 15792383,
  "antiquewhite": 16444375,
  "aqua": 65535,
  "aquamarine": 8388564,
  "azure": 15794175,
  "beige": 16119260,
  "bisque": 16770244,
  "black": 0,
  "blanchedalmond": 16772045,
  "blue": 255,
  "blueviolet": 9055202,
  "brown": 10824234,
  "burlywood": 14596231,
  "cadetblue": 6266528,
  "chartreuse": 8388352,
  "chocolate": 13789470,
  "coral": 16744272,
  "cornflowerblue": 6591981,
  "cornsilk": 16775388,
  "crimson": 14423100,
  "cyan": 65535,
  "darkblue": 139,
  "darkcyan": 35723,
  "darkgoldenrod": 12092939,
  "darkgray": 11119017,
  "darkgreen": 25600,
  "darkgrey": 11119017,
  "darkkhaki": 12433259,
  "darkmagenta": 9109643,
  "darkolivegreen": 5597999,
  "darkorange": 16747520,
  "darkorchid": 10040012,
  "darkred": 9109504,
  "darksalmon": 15308410,
  "darkseagreen": 9419919,
  "darkslateblue": 4734347,
  "darkslategray": 3100495,
  "darkslategrey": 3100495,
  "darkturquoise": 52945,
  "darkviolet": 9699539,
  "deeppink": 16716947,
  "deepskyblue": 49151,
  "dimgray": 6908265,
  "dimgrey": 6908265,
  "dodgerblue": 2003199,
  "firebrick": 11674146,
  "floralwhite": 16775920,
  "forestgreen": 2263842,
  "fuchsia": 16711935,
  "gainsboro": 14474460,
  "ghostwhite": 16316671,
  "gold": 16766720,
  "goldenrod": 14329120,
  "gray": 8421504,
  "green": 32768,
  "greenyellow": 11403055,
  "grey": 8421504,
  "honeydew": 15794160,
  "hotpink": 16738740,
  "indianred": 13458524,
  "indigo": 4915330,
  "ivory": 16777200,
  "khaki": 15787660,
  "lavender": 15132410,
  "lavenderblush": 16773365,
  "lawngreen": 8190976,
  "lemonchiffon": 16775885,
  "lightblue": 11393254,
  "lightcoral": 15761536,
  "lightcyan": 14745599,
  "lightgoldenrodyellow": 16448210,
  "lightgray": 13882323,
  "lightgreen": 9498256,
  "lightgrey": 13882323,
  "lightpink": 16758465,
  "lightsalmon": 16752762,
  "lightseagreen": 2142890,
  "lightskyblue": 8900346,
  "lightslategray": 7833753,
  "lightslategrey": 7833753,
  "lightsteelblue": 11584734,
  "lightyellow": 16777184,
  "lime": 65280,
  "limegreen": 3329330,
  "linen": 16445670,
  "magenta": 16711935,
  "maroon": 8388608,
  "mediumaquamarine": 6737322,
  "mediumblue": 205,
  "mediumorchid": 12211667,
  "mediumpurple": 9662683,
  "mediumseagreen": 3978097,
  "mediumslateblue": 8087790,
  "mediumspringgreen": 64154,
  "mediumturquoise": 4772300,
  "mediumvioletred": 13047173,
  "midnightblue": 1644912,
  "mintcream": 16121850,
  "mistyrose": 16770273,
  "moccasin": 16770229,
  "navajowhite": 16768685,
  "navy": 128,
  "oldlace": 16643558,
  "olive": 8421376,
  "olivedrab": 7048739,
  "orange": 16753920,
  "orangered": 16729344,
  "orchid": 14315734,
  "palegoldenrod": 15657130,
  "palegreen": 10025880,
  "paleturquoise": 11529966,
  "palevioletred": 14381203,
  "papayawhip": 16773077,
  "peachpuff": 16767673,
  "peru": 13468991,
  "pink": 16761035,
  "plum": 14524637,
  "powderblue": 11591910,
  "purple": 8388736,
  "rebeccapurple": 6697881,
  "red": 16711680,
  "rosybrown": 12357519,
  "royalblue": 4286945,
  "saddlebrown": 9127187,
  "salmon": 16416882,
  "sandybrown": 16032864,
  "seagreen": 3050327,
  "seashell": 16774638,
  "sienna": 10506797,
  "silver": 12632256,
  "skyblue": 8900331,
  "slateblue": 6970061,
  "slategray": 7372944,
  "slategrey": 7372944,
  "snow": 16775930,
  "springgreen": 65407,
  "steelblue": 4620980,
  "tan": 13808780,
  "teal": 32896,
  "thistle": 14204888,
  "tomato": 16737095,
  "turquoise": 4251856,
  "violet": 15631086,
  "wheat": 16113331,
  "white": 16777215,
  "whitesmoke": 16119285,
  "yellow": 16776960,
  "yellowgreen": 10145074
};
var _hslA = { h: 0, s: 0, l: 0 };
var _hslB = { h: 0, s: 0, l: 0 };
function hue2rgb(p3, q2, t5) {
  if (t5 < 0) t5 += 1;
  if (t5 > 1) t5 -= 1;
  if (t5 < 1 / 6) return p3 + (q2 - p3) * 6 * t5;
  if (t5 < 1 / 2) return q2;
  if (t5 < 2 / 3) return p3 + (q2 - p3) * 6 * (2 / 3 - t5);
  return p3;
}
var Color2 = class {
  constructor(r2, g3, b) {
    this.isColor = true;
    this.r = 1;
    this.g = 1;
    this.b = 1;
    return this.set(r2, g3, b);
  }
  set(r2, g3, b) {
    if (g3 === void 0 && b === void 0) {
      const value = r2;
      if (value && value.isColor) {
        this.copy(value);
      } else if (typeof value === "number") {
        this.setHex(value);
      } else if (typeof value === "string") {
        this.setStyle(value);
      }
    } else {
      this.setRGB(r2, g3, b);
    }
    return this;
  }
  setScalar(scalar) {
    this.r = scalar;
    this.g = scalar;
    this.b = scalar;
    return this;
  }
  setHex(hex2, colorSpace = SRGBColorSpace2) {
    hex2 = Math.floor(hex2);
    this.r = (hex2 >> 16 & 255) / 255;
    this.g = (hex2 >> 8 & 255) / 255;
    this.b = (hex2 & 255) / 255;
    ColorManagement2.toWorkingColorSpace(this, colorSpace);
    return this;
  }
  setRGB(r2, g3, b, colorSpace = ColorManagement2.workingColorSpace) {
    this.r = r2;
    this.g = g3;
    this.b = b;
    ColorManagement2.toWorkingColorSpace(this, colorSpace);
    return this;
  }
  setHSL(h2, s2, l2, colorSpace = ColorManagement2.workingColorSpace) {
    h2 = euclideanModulo(h2, 1);
    s2 = clamp2(s2, 0, 1);
    l2 = clamp2(l2, 0, 1);
    if (s2 === 0) {
      this.r = this.g = this.b = l2;
    } else {
      const p3 = l2 <= 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
      const q2 = 2 * l2 - p3;
      this.r = hue2rgb(q2, p3, h2 + 1 / 3);
      this.g = hue2rgb(q2, p3, h2);
      this.b = hue2rgb(q2, p3, h2 - 1 / 3);
    }
    ColorManagement2.toWorkingColorSpace(this, colorSpace);
    return this;
  }
  setStyle(style, colorSpace = SRGBColorSpace2) {
    function handleAlpha(string2) {
      if (string2 === void 0) return;
      if (parseFloat(string2) < 1) {
        console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
      }
    }
    let m3;
    if (m3 = /^(\w+)\(([^\)]*)\)/.exec(style)) {
      let color3;
      const name = m3[1];
      const components = m3[2];
      switch (name) {
        case "rgb":
        case "rgba":
          if (color3 = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            handleAlpha(color3[4]);
            return this.setRGB(
              Math.min(255, parseInt(color3[1], 10)) / 255,
              Math.min(255, parseInt(color3[2], 10)) / 255,
              Math.min(255, parseInt(color3[3], 10)) / 255,
              colorSpace
            );
          }
          if (color3 = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            handleAlpha(color3[4]);
            return this.setRGB(
              Math.min(100, parseInt(color3[1], 10)) / 100,
              Math.min(100, parseInt(color3[2], 10)) / 100,
              Math.min(100, parseInt(color3[3], 10)) / 100,
              colorSpace
            );
          }
          break;
        case "hsl":
        case "hsla":
          if (color3 = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            handleAlpha(color3[4]);
            return this.setHSL(
              parseFloat(color3[1]) / 360,
              parseFloat(color3[2]) / 100,
              parseFloat(color3[3]) / 100,
              colorSpace
            );
          }
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + style);
      }
    } else if (m3 = /^\#([A-Fa-f\d]+)$/.exec(style)) {
      const hex2 = m3[1];
      const size2 = hex2.length;
      if (size2 === 3) {
        return this.setRGB(
          parseInt(hex2.charAt(0), 16) / 15,
          parseInt(hex2.charAt(1), 16) / 15,
          parseInt(hex2.charAt(2), 16) / 15,
          colorSpace
        );
      } else if (size2 === 6) {
        return this.setHex(parseInt(hex2, 16), colorSpace);
      } else {
        console.warn("THREE.Color: Invalid hex color " + style);
      }
    } else if (style && style.length > 0) {
      return this.setColorName(style, colorSpace);
    }
    return this;
  }
  setColorName(style, colorSpace = SRGBColorSpace2) {
    const hex2 = _colorKeywords[style.toLowerCase()];
    if (hex2 !== void 0) {
      this.setHex(hex2, colorSpace);
    } else {
      console.warn("THREE.Color: Unknown color " + style);
    }
    return this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(color3) {
    this.r = color3.r;
    this.g = color3.g;
    this.b = color3.b;
    return this;
  }
  copySRGBToLinear(color3) {
    this.r = SRGBToLinear(color3.r);
    this.g = SRGBToLinear(color3.g);
    this.b = SRGBToLinear(color3.b);
    return this;
  }
  copyLinearToSRGB(color3) {
    this.r = LinearToSRGB(color3.r);
    this.g = LinearToSRGB(color3.g);
    this.b = LinearToSRGB(color3.b);
    return this;
  }
  convertSRGBToLinear() {
    this.copySRGBToLinear(this);
    return this;
  }
  convertLinearToSRGB() {
    this.copyLinearToSRGB(this);
    return this;
  }
  getHex(colorSpace = SRGBColorSpace2) {
    ColorManagement2.fromWorkingColorSpace(_color.copy(this), colorSpace);
    return Math.round(clamp2(_color.r * 255, 0, 255)) * 65536 + Math.round(clamp2(_color.g * 255, 0, 255)) * 256 + Math.round(clamp2(_color.b * 255, 0, 255));
  }
  getHexString(colorSpace = SRGBColorSpace2) {
    return ("000000" + this.getHex(colorSpace).toString(16)).slice(-6);
  }
  getHSL(target, colorSpace = ColorManagement2.workingColorSpace) {
    ColorManagement2.fromWorkingColorSpace(_color.copy(this), colorSpace);
    const r2 = _color.r, g3 = _color.g, b = _color.b;
    const max6 = Math.max(r2, g3, b);
    const min5 = Math.min(r2, g3, b);
    let hue3, saturation2;
    const lightness = (min5 + max6) / 2;
    if (min5 === max6) {
      hue3 = 0;
      saturation2 = 0;
    } else {
      const delta = max6 - min5;
      saturation2 = lightness <= 0.5 ? delta / (max6 + min5) : delta / (2 - max6 - min5);
      switch (max6) {
        case r2:
          hue3 = (g3 - b) / delta + (g3 < b ? 6 : 0);
          break;
        case g3:
          hue3 = (b - r2) / delta + 2;
          break;
        case b:
          hue3 = (r2 - g3) / delta + 4;
          break;
      }
      hue3 /= 6;
    }
    target.h = hue3;
    target.s = saturation2;
    target.l = lightness;
    return target;
  }
  getRGB(target, colorSpace = ColorManagement2.workingColorSpace) {
    ColorManagement2.fromWorkingColorSpace(_color.copy(this), colorSpace);
    target.r = _color.r;
    target.g = _color.g;
    target.b = _color.b;
    return target;
  }
  getStyle(colorSpace = SRGBColorSpace2) {
    ColorManagement2.fromWorkingColorSpace(_color.copy(this), colorSpace);
    const r2 = _color.r, g3 = _color.g, b = _color.b;
    if (colorSpace !== SRGBColorSpace2) {
      return `color(${colorSpace} ${r2.toFixed(3)} ${g3.toFixed(3)} ${b.toFixed(3)})`;
    }
    return `rgb(${Math.round(r2 * 255)},${Math.round(g3 * 255)},${Math.round(b * 255)})`;
  }
  offsetHSL(h2, s2, l2) {
    this.getHSL(_hslA);
    return this.setHSL(_hslA.h + h2, _hslA.s + s2, _hslA.l + l2);
  }
  add(color3) {
    this.r += color3.r;
    this.g += color3.g;
    this.b += color3.b;
    return this;
  }
  addColors(color1, color22) {
    this.r = color1.r + color22.r;
    this.g = color1.g + color22.g;
    this.b = color1.b + color22.b;
    return this;
  }
  addScalar(s2) {
    this.r += s2;
    this.g += s2;
    this.b += s2;
    return this;
  }
  sub(color3) {
    this.r = Math.max(0, this.r - color3.r);
    this.g = Math.max(0, this.g - color3.g);
    this.b = Math.max(0, this.b - color3.b);
    return this;
  }
  multiply(color3) {
    this.r *= color3.r;
    this.g *= color3.g;
    this.b *= color3.b;
    return this;
  }
  multiplyScalar(s2) {
    this.r *= s2;
    this.g *= s2;
    this.b *= s2;
    return this;
  }
  lerp(color3, alpha) {
    this.r += (color3.r - this.r) * alpha;
    this.g += (color3.g - this.g) * alpha;
    this.b += (color3.b - this.b) * alpha;
    return this;
  }
  lerpColors(color1, color22, alpha) {
    this.r = color1.r + (color22.r - color1.r) * alpha;
    this.g = color1.g + (color22.g - color1.g) * alpha;
    this.b = color1.b + (color22.b - color1.b) * alpha;
    return this;
  }
  lerpHSL(color3, alpha) {
    this.getHSL(_hslA);
    color3.getHSL(_hslB);
    const h2 = lerp(_hslA.h, _hslB.h, alpha);
    const s2 = lerp(_hslA.s, _hslB.s, alpha);
    const l2 = lerp(_hslA.l, _hslB.l, alpha);
    this.setHSL(h2, s2, l2);
    return this;
  }
  setFromVector3(v2) {
    this.r = v2.x;
    this.g = v2.y;
    this.b = v2.z;
    return this;
  }
  applyMatrix3(m3) {
    const r2 = this.r, g3 = this.g, b = this.b;
    const e3 = m3.elements;
    this.r = e3[0] * r2 + e3[3] * g3 + e3[6] * b;
    this.g = e3[1] * r2 + e3[4] * g3 + e3[7] * b;
    this.b = e3[2] * r2 + e3[5] * g3 + e3[8] * b;
    return this;
  }
  equals(c5) {
    return c5.r === this.r && c5.g === this.g && c5.b === this.b;
  }
  fromArray(array4, offset = 0) {
    this.r = array4[offset];
    this.g = array4[offset + 1];
    this.b = array4[offset + 2];
    return this;
  }
  toArray(array4 = [], offset = 0) {
    array4[offset] = this.r;
    array4[offset + 1] = this.g;
    array4[offset + 2] = this.b;
    return array4;
  }
  fromBufferAttribute(attribute2, index8) {
    this.r = attribute2.getX(index8);
    this.g = attribute2.getY(index8);
    this.b = attribute2.getZ(index8);
    return this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r;
    yield this.g;
    yield this.b;
  }
};
var _color = new Color2();
Color2.NAMES = _colorKeywords;
var _materialId = 0;
var Material2 = class extends EventDispatcher2 {
  constructor() {
    super();
    this.isMaterial = true;
    Object.defineProperty(this, "id", { value: _materialId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "Material";
    this.blending = NormalBlending2;
    this.side = FrontSide2;
    this.vertexColors = false;
    this.opacity = 1;
    this.transparent = false;
    this.alphaHash = false;
    this.blendSrc = SrcAlphaFactor2;
    this.blendDst = OneMinusSrcAlphaFactor2;
    this.blendEquation = AddEquation2;
    this.blendSrcAlpha = null;
    this.blendDstAlpha = null;
    this.blendEquationAlpha = null;
    this.blendColor = new Color2(0, 0, 0);
    this.blendAlpha = 0;
    this.depthFunc = LessEqualDepth2;
    this.depthTest = true;
    this.depthWrite = true;
    this.stencilWriteMask = 255;
    this.stencilFunc = AlwaysStencilFunc2;
    this.stencilRef = 0;
    this.stencilFuncMask = 255;
    this.stencilFail = KeepStencilOp2;
    this.stencilZFail = KeepStencilOp2;
    this.stencilZPass = KeepStencilOp2;
    this.stencilWrite = false;
    this.clippingPlanes = null;
    this.clipIntersection = false;
    this.clipShadows = false;
    this.shadowSide = null;
    this.colorWrite = true;
    this.precision = null;
    this.polygonOffset = false;
    this.polygonOffsetFactor = 0;
    this.polygonOffsetUnits = 0;
    this.dithering = false;
    this.alphaToCoverage = false;
    this.premultipliedAlpha = false;
    this.forceSinglePass = false;
    this.visible = true;
    this.toneMapped = true;
    this.userData = {};
    this.version = 0;
    this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(value) {
    if (this._alphaTest > 0 !== value > 0) {
      this.version++;
    }
    this._alphaTest = value;
  }
  onBuild() {
  }
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(values2) {
    if (values2 === void 0) return;
    for (const key in values2) {
      const newValue = values2[key];
      if (newValue === void 0) {
        console.warn(`THREE.Material: parameter '${key}' has value of undefined.`);
        continue;
      }
      const currentValue = this[key];
      if (currentValue === void 0) {
        console.warn(`THREE.Material: '${key}' is not a property of THREE.${this.type}.`);
        continue;
      }
      if (currentValue && currentValue.isColor) {
        currentValue.set(newValue);
      } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
        currentValue.copy(newValue);
      } else {
        this[key] = newValue;
      }
    }
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (isRootObject) {
      meta = {
        textures: {},
        images: {}
      };
    }
    const data = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "") data.name = this.name;
    if (this.color && this.color.isColor) data.color = this.color.getHex();
    if (this.roughness !== void 0) data.roughness = this.roughness;
    if (this.metalness !== void 0) data.metalness = this.metalness;
    if (this.sheen !== void 0) data.sheen = this.sheen;
    if (this.sheenColor && this.sheenColor.isColor) data.sheenColor = this.sheenColor.getHex();
    if (this.sheenRoughness !== void 0) data.sheenRoughness = this.sheenRoughness;
    if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
    if (this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;
    if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
    if (this.specularIntensity !== void 0) data.specularIntensity = this.specularIntensity;
    if (this.specularColor && this.specularColor.isColor) data.specularColor = this.specularColor.getHex();
    if (this.shininess !== void 0) data.shininess = this.shininess;
    if (this.clearcoat !== void 0) data.clearcoat = this.clearcoat;
    if (this.clearcoatRoughness !== void 0) data.clearcoatRoughness = this.clearcoatRoughness;
    if (this.clearcoatMap && this.clearcoatMap.isTexture) {
      data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
    }
    if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
      data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
    }
    if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
      data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
      data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
    }
    if (this.dispersion !== void 0) data.dispersion = this.dispersion;
    if (this.iridescence !== void 0) data.iridescence = this.iridescence;
    if (this.iridescenceIOR !== void 0) data.iridescenceIOR = this.iridescenceIOR;
    if (this.iridescenceThicknessRange !== void 0) data.iridescenceThicknessRange = this.iridescenceThicknessRange;
    if (this.iridescenceMap && this.iridescenceMap.isTexture) {
      data.iridescenceMap = this.iridescenceMap.toJSON(meta).uuid;
    }
    if (this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture) {
      data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(meta).uuid;
    }
    if (this.anisotropy !== void 0) data.anisotropy = this.anisotropy;
    if (this.anisotropyRotation !== void 0) data.anisotropyRotation = this.anisotropyRotation;
    if (this.anisotropyMap && this.anisotropyMap.isTexture) {
      data.anisotropyMap = this.anisotropyMap.toJSON(meta).uuid;
    }
    if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
    if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;
    if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;
    if (this.lightMap && this.lightMap.isTexture) {
      data.lightMap = this.lightMap.toJSON(meta).uuid;
      data.lightMapIntensity = this.lightMapIntensity;
    }
    if (this.aoMap && this.aoMap.isTexture) {
      data.aoMap = this.aoMap.toJSON(meta).uuid;
      data.aoMapIntensity = this.aoMapIntensity;
    }
    if (this.bumpMap && this.bumpMap.isTexture) {
      data.bumpMap = this.bumpMap.toJSON(meta).uuid;
      data.bumpScale = this.bumpScale;
    }
    if (this.normalMap && this.normalMap.isTexture) {
      data.normalMap = this.normalMap.toJSON(meta).uuid;
      data.normalMapType = this.normalMapType;
      data.normalScale = this.normalScale.toArray();
    }
    if (this.displacementMap && this.displacementMap.isTexture) {
      data.displacementMap = this.displacementMap.toJSON(meta).uuid;
      data.displacementScale = this.displacementScale;
      data.displacementBias = this.displacementBias;
    }
    if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
    if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
    if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
    if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;
    if (this.specularIntensityMap && this.specularIntensityMap.isTexture) data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
    if (this.specularColorMap && this.specularColorMap.isTexture) data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;
    if (this.envMap && this.envMap.isTexture) {
      data.envMap = this.envMap.toJSON(meta).uuid;
      if (this.combine !== void 0) data.combine = this.combine;
    }
    if (this.envMapRotation !== void 0) data.envMapRotation = this.envMapRotation.toArray();
    if (this.envMapIntensity !== void 0) data.envMapIntensity = this.envMapIntensity;
    if (this.reflectivity !== void 0) data.reflectivity = this.reflectivity;
    if (this.refractionRatio !== void 0) data.refractionRatio = this.refractionRatio;
    if (this.gradientMap && this.gradientMap.isTexture) {
      data.gradientMap = this.gradientMap.toJSON(meta).uuid;
    }
    if (this.transmission !== void 0) data.transmission = this.transmission;
    if (this.transmissionMap && this.transmissionMap.isTexture) data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
    if (this.thickness !== void 0) data.thickness = this.thickness;
    if (this.thicknessMap && this.thicknessMap.isTexture) data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
    if (this.attenuationDistance !== void 0 && this.attenuationDistance !== Infinity) data.attenuationDistance = this.attenuationDistance;
    if (this.attenuationColor !== void 0) data.attenuationColor = this.attenuationColor.getHex();
    if (this.size !== void 0) data.size = this.size;
    if (this.shadowSide !== null) data.shadowSide = this.shadowSide;
    if (this.sizeAttenuation !== void 0) data.sizeAttenuation = this.sizeAttenuation;
    if (this.blending !== NormalBlending2) data.blending = this.blending;
    if (this.side !== FrontSide2) data.side = this.side;
    if (this.vertexColors === true) data.vertexColors = true;
    if (this.opacity < 1) data.opacity = this.opacity;
    if (this.transparent === true) data.transparent = true;
    if (this.blendSrc !== SrcAlphaFactor2) data.blendSrc = this.blendSrc;
    if (this.blendDst !== OneMinusSrcAlphaFactor2) data.blendDst = this.blendDst;
    if (this.blendEquation !== AddEquation2) data.blendEquation = this.blendEquation;
    if (this.blendSrcAlpha !== null) data.blendSrcAlpha = this.blendSrcAlpha;
    if (this.blendDstAlpha !== null) data.blendDstAlpha = this.blendDstAlpha;
    if (this.blendEquationAlpha !== null) data.blendEquationAlpha = this.blendEquationAlpha;
    if (this.blendColor && this.blendColor.isColor) data.blendColor = this.blendColor.getHex();
    if (this.blendAlpha !== 0) data.blendAlpha = this.blendAlpha;
    if (this.depthFunc !== LessEqualDepth2) data.depthFunc = this.depthFunc;
    if (this.depthTest === false) data.depthTest = this.depthTest;
    if (this.depthWrite === false) data.depthWrite = this.depthWrite;
    if (this.colorWrite === false) data.colorWrite = this.colorWrite;
    if (this.stencilWriteMask !== 255) data.stencilWriteMask = this.stencilWriteMask;
    if (this.stencilFunc !== AlwaysStencilFunc2) data.stencilFunc = this.stencilFunc;
    if (this.stencilRef !== 0) data.stencilRef = this.stencilRef;
    if (this.stencilFuncMask !== 255) data.stencilFuncMask = this.stencilFuncMask;
    if (this.stencilFail !== KeepStencilOp2) data.stencilFail = this.stencilFail;
    if (this.stencilZFail !== KeepStencilOp2) data.stencilZFail = this.stencilZFail;
    if (this.stencilZPass !== KeepStencilOp2) data.stencilZPass = this.stencilZPass;
    if (this.stencilWrite === true) data.stencilWrite = this.stencilWrite;
    if (this.rotation !== void 0 && this.rotation !== 0) data.rotation = this.rotation;
    if (this.polygonOffset === true) data.polygonOffset = true;
    if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;
    if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;
    if (this.linewidth !== void 0 && this.linewidth !== 1) data.linewidth = this.linewidth;
    if (this.dashSize !== void 0) data.dashSize = this.dashSize;
    if (this.gapSize !== void 0) data.gapSize = this.gapSize;
    if (this.scale !== void 0) data.scale = this.scale;
    if (this.dithering === true) data.dithering = true;
    if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
    if (this.alphaHash === true) data.alphaHash = true;
    if (this.alphaToCoverage === true) data.alphaToCoverage = true;
    if (this.premultipliedAlpha === true) data.premultipliedAlpha = true;
    if (this.forceSinglePass === true) data.forceSinglePass = true;
    if (this.wireframe === true) data.wireframe = true;
    if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
    if (this.wireframeLinecap !== "round") data.wireframeLinecap = this.wireframeLinecap;
    if (this.wireframeLinejoin !== "round") data.wireframeLinejoin = this.wireframeLinejoin;
    if (this.flatShading === true) data.flatShading = true;
    if (this.visible === false) data.visible = false;
    if (this.toneMapped === false) data.toneMapped = false;
    if (this.fog === false) data.fog = false;
    if (Object.keys(this.userData).length > 0) data.userData = this.userData;
    function extractFromCache(cache2) {
      const values2 = [];
      for (const key in cache2) {
        const data2 = cache2[key];
        delete data2.metadata;
        values2.push(data2);
      }
      return values2;
    }
    if (isRootObject) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      if (textures.length > 0) data.textures = textures;
      if (images.length > 0) data.images = images;
    }
    return data;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.name = source.name;
    this.blending = source.blending;
    this.side = source.side;
    this.vertexColors = source.vertexColors;
    this.opacity = source.opacity;
    this.transparent = source.transparent;
    this.blendSrc = source.blendSrc;
    this.blendDst = source.blendDst;
    this.blendEquation = source.blendEquation;
    this.blendSrcAlpha = source.blendSrcAlpha;
    this.blendDstAlpha = source.blendDstAlpha;
    this.blendEquationAlpha = source.blendEquationAlpha;
    this.blendColor.copy(source.blendColor);
    this.blendAlpha = source.blendAlpha;
    this.depthFunc = source.depthFunc;
    this.depthTest = source.depthTest;
    this.depthWrite = source.depthWrite;
    this.stencilWriteMask = source.stencilWriteMask;
    this.stencilFunc = source.stencilFunc;
    this.stencilRef = source.stencilRef;
    this.stencilFuncMask = source.stencilFuncMask;
    this.stencilFail = source.stencilFail;
    this.stencilZFail = source.stencilZFail;
    this.stencilZPass = source.stencilZPass;
    this.stencilWrite = source.stencilWrite;
    const srcPlanes = source.clippingPlanes;
    let dstPlanes = null;
    if (srcPlanes !== null) {
      const n2 = srcPlanes.length;
      dstPlanes = new Array(n2);
      for (let i2 = 0; i2 !== n2; ++i2) {
        dstPlanes[i2] = srcPlanes[i2].clone();
      }
    }
    this.clippingPlanes = dstPlanes;
    this.clipIntersection = source.clipIntersection;
    this.clipShadows = source.clipShadows;
    this.shadowSide = source.shadowSide;
    this.colorWrite = source.colorWrite;
    this.precision = source.precision;
    this.polygonOffset = source.polygonOffset;
    this.polygonOffsetFactor = source.polygonOffsetFactor;
    this.polygonOffsetUnits = source.polygonOffsetUnits;
    this.dithering = source.dithering;
    this.alphaTest = source.alphaTest;
    this.alphaHash = source.alphaHash;
    this.alphaToCoverage = source.alphaToCoverage;
    this.premultipliedAlpha = source.premultipliedAlpha;
    this.forceSinglePass = source.forceSinglePass;
    this.visible = source.visible;
    this.toneMapped = source.toneMapped;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
};
var MeshBasicMaterial2 = class extends Material2 {
  constructor(parameters) {
    super();
    this.isMeshBasicMaterial = true;
    this.type = "MeshBasicMaterial";
    this.color = new Color2(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.envMapRotation = new Euler2();
    this.combine = MultiplyOperation2;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.envMapRotation.copy(source.envMapRotation);
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.fog = source.fog;
    return this;
  }
};
var _tables = _generateTables();
function _generateTables() {
  const buffer2 = new ArrayBuffer(4);
  const floatView = new Float32Array(buffer2);
  const uint32View = new Uint32Array(buffer2);
  const baseTable = new Uint32Array(512);
  const shiftTable = new Uint32Array(512);
  for (let i2 = 0; i2 < 256; ++i2) {
    const e3 = i2 - 127;
    if (e3 < -27) {
      baseTable[i2] = 0;
      baseTable[i2 | 256] = 32768;
      shiftTable[i2] = 24;
      shiftTable[i2 | 256] = 24;
    } else if (e3 < -14) {
      baseTable[i2] = 1024 >> -e3 - 14;
      baseTable[i2 | 256] = 1024 >> -e3 - 14 | 32768;
      shiftTable[i2] = -e3 - 1;
      shiftTable[i2 | 256] = -e3 - 1;
    } else if (e3 <= 15) {
      baseTable[i2] = e3 + 15 << 10;
      baseTable[i2 | 256] = e3 + 15 << 10 | 32768;
      shiftTable[i2] = 13;
      shiftTable[i2 | 256] = 13;
    } else if (e3 < 128) {
      baseTable[i2] = 31744;
      baseTable[i2 | 256] = 64512;
      shiftTable[i2] = 24;
      shiftTable[i2 | 256] = 24;
    } else {
      baseTable[i2] = 31744;
      baseTable[i2 | 256] = 64512;
      shiftTable[i2] = 13;
      shiftTable[i2 | 256] = 13;
    }
  }
  const mantissaTable = new Uint32Array(2048);
  const exponentTable = new Uint32Array(64);
  const offsetTable = new Uint32Array(64);
  for (let i2 = 1; i2 < 1024; ++i2) {
    let m3 = i2 << 13;
    let e3 = 0;
    while ((m3 & 8388608) === 0) {
      m3 <<= 1;
      e3 -= 8388608;
    }
    m3 &= ~8388608;
    e3 += 947912704;
    mantissaTable[i2] = m3 | e3;
  }
  for (let i2 = 1024; i2 < 2048; ++i2) {
    mantissaTable[i2] = 939524096 + (i2 - 1024 << 13);
  }
  for (let i2 = 1; i2 < 31; ++i2) {
    exponentTable[i2] = i2 << 23;
  }
  exponentTable[31] = 1199570944;
  exponentTable[32] = 2147483648;
  for (let i2 = 33; i2 < 63; ++i2) {
    exponentTable[i2] = 2147483648 + (i2 - 32 << 23);
  }
  exponentTable[63] = 3347054592;
  for (let i2 = 1; i2 < 64; ++i2) {
    if (i2 !== 32) {
      offsetTable[i2] = 1024;
    }
  }
  return {
    floatView,
    uint32View,
    baseTable,
    shiftTable,
    mantissaTable,
    exponentTable,
    offsetTable
  };
}
var _vector$9 = new Vector32();
var _vector2$1 = new Vector22();
var BufferAttribute2 = class {
  constructor(array4, itemSize, normalized = false) {
    if (Array.isArray(array4)) {
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    }
    this.isBufferAttribute = true;
    this.name = "";
    this.array = array4;
    this.itemSize = itemSize;
    this.count = array4 !== void 0 ? array4.length / itemSize : 0;
    this.normalized = normalized;
    this.usage = StaticDrawUsage2;
    this._updateRange = { offset: 0, count: -1 };
    this.updateRanges = [];
    this.gpuType = FloatType2;
    this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
  get updateRange() {
    warnOnce2("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead.");
    return this._updateRange;
  }
  setUsage(value) {
    this.usage = value;
    return this;
  }
  addUpdateRange(start2, count2) {
    this.updateRanges.push({ start: start2, count: count2 });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(source) {
    this.name = source.name;
    this.array = new source.array.constructor(source.array);
    this.itemSize = source.itemSize;
    this.count = source.count;
    this.normalized = source.normalized;
    this.usage = source.usage;
    this.gpuType = source.gpuType;
    return this;
  }
  copyAt(index1, attribute2, index22) {
    index1 *= this.itemSize;
    index22 *= attribute2.itemSize;
    for (let i2 = 0, l2 = this.itemSize; i2 < l2; i2++) {
      this.array[index1 + i2] = attribute2.array[index22 + i2];
    }
    return this;
  }
  copyArray(array4) {
    this.array.set(array4);
    return this;
  }
  applyMatrix3(m3) {
    if (this.itemSize === 2) {
      for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
        _vector2$1.fromBufferAttribute(this, i2);
        _vector2$1.applyMatrix3(m3);
        this.setXY(i2, _vector2$1.x, _vector2$1.y);
      }
    } else if (this.itemSize === 3) {
      for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
        _vector$9.fromBufferAttribute(this, i2);
        _vector$9.applyMatrix3(m3);
        this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
      }
    }
    return this;
  }
  applyMatrix4(m3) {
    for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
      _vector$9.fromBufferAttribute(this, i2);
      _vector$9.applyMatrix4(m3);
      this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  applyNormalMatrix(m3) {
    for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
      _vector$9.fromBufferAttribute(this, i2);
      _vector$9.applyNormalMatrix(m3);
      this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  transformDirection(m3) {
    for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
      _vector$9.fromBufferAttribute(this, i2);
      _vector$9.transformDirection(m3);
      this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  set(value, offset = 0) {
    this.array.set(value, offset);
    return this;
  }
  getComponent(index8, component) {
    let value = this.array[index8 * this.itemSize + component];
    if (this.normalized) value = denormalize(value, this.array);
    return value;
  }
  setComponent(index8, component, value) {
    if (this.normalized) value = normalize(value, this.array);
    this.array[index8 * this.itemSize + component] = value;
    return this;
  }
  getX(index8) {
    let x3 = this.array[index8 * this.itemSize];
    if (this.normalized) x3 = denormalize(x3, this.array);
    return x3;
  }
  setX(index8, x3) {
    if (this.normalized) x3 = normalize(x3, this.array);
    this.array[index8 * this.itemSize] = x3;
    return this;
  }
  getY(index8) {
    let y3 = this.array[index8 * this.itemSize + 1];
    if (this.normalized) y3 = denormalize(y3, this.array);
    return y3;
  }
  setY(index8, y3) {
    if (this.normalized) y3 = normalize(y3, this.array);
    this.array[index8 * this.itemSize + 1] = y3;
    return this;
  }
  getZ(index8) {
    let z3 = this.array[index8 * this.itemSize + 2];
    if (this.normalized) z3 = denormalize(z3, this.array);
    return z3;
  }
  setZ(index8, z3) {
    if (this.normalized) z3 = normalize(z3, this.array);
    this.array[index8 * this.itemSize + 2] = z3;
    return this;
  }
  getW(index8) {
    let w4 = this.array[index8 * this.itemSize + 3];
    if (this.normalized) w4 = denormalize(w4, this.array);
    return w4;
  }
  setW(index8, w4) {
    if (this.normalized) w4 = normalize(w4, this.array);
    this.array[index8 * this.itemSize + 3] = w4;
    return this;
  }
  setXY(index8, x3, y3) {
    index8 *= this.itemSize;
    if (this.normalized) {
      x3 = normalize(x3, this.array);
      y3 = normalize(y3, this.array);
    }
    this.array[index8 + 0] = x3;
    this.array[index8 + 1] = y3;
    return this;
  }
  setXYZ(index8, x3, y3, z3) {
    index8 *= this.itemSize;
    if (this.normalized) {
      x3 = normalize(x3, this.array);
      y3 = normalize(y3, this.array);
      z3 = normalize(z3, this.array);
    }
    this.array[index8 + 0] = x3;
    this.array[index8 + 1] = y3;
    this.array[index8 + 2] = z3;
    return this;
  }
  setXYZW(index8, x3, y3, z3, w4) {
    index8 *= this.itemSize;
    if (this.normalized) {
      x3 = normalize(x3, this.array);
      y3 = normalize(y3, this.array);
      z3 = normalize(z3, this.array);
      w4 = normalize(w4, this.array);
    }
    this.array[index8 + 0] = x3;
    this.array[index8 + 1] = y3;
    this.array[index8 + 2] = z3;
    this.array[index8 + 3] = w4;
    return this;
  }
  onUpload(callback) {
    this.onUploadCallback = callback;
    return this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const data = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    if (this.name !== "") data.name = this.name;
    if (this.usage !== StaticDrawUsage2) data.usage = this.usage;
    return data;
  }
};
var Uint16BufferAttribute2 = class extends BufferAttribute2 {
  constructor(array4, itemSize, normalized) {
    super(new Uint16Array(array4), itemSize, normalized);
  }
};
var Uint32BufferAttribute2 = class extends BufferAttribute2 {
  constructor(array4, itemSize, normalized) {
    super(new Uint32Array(array4), itemSize, normalized);
  }
};
var Float32BufferAttribute2 = class extends BufferAttribute2 {
  constructor(array4, itemSize, normalized) {
    super(new Float32Array(array4), itemSize, normalized);
  }
};
var _id$2 = 0;
var _m1$2 = new Matrix42();
var _obj = new Object3D2();
var _offset = new Vector32();
var _box$2 = new Box32();
var _boxMorphTargets = new Box32();
var _vector$8 = new Vector32();
var BufferGeometry2 = class _BufferGeometry extends EventDispatcher2 {
  constructor() {
    super();
    this.isBufferGeometry = true;
    Object.defineProperty(this, "id", { value: _id$2++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "BufferGeometry";
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.morphTargetsRelative = false;
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.drawRange = { start: 0, count: Infinity };
    this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(index8) {
    if (Array.isArray(index8)) {
      this.index = new (arrayNeedsUint322(index8) ? Uint32BufferAttribute2 : Uint16BufferAttribute2)(index8, 1);
    } else {
      this.index = index8;
    }
    return this;
  }
  getAttribute(name) {
    return this.attributes[name];
  }
  setAttribute(name, attribute2) {
    this.attributes[name] = attribute2;
    return this;
  }
  deleteAttribute(name) {
    delete this.attributes[name];
    return this;
  }
  hasAttribute(name) {
    return this.attributes[name] !== void 0;
  }
  addGroup(start2, count2, materialIndex = 0) {
    this.groups.push({
      start: start2,
      count: count2,
      materialIndex
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(start2, count2) {
    this.drawRange.start = start2;
    this.drawRange.count = count2;
  }
  applyMatrix4(matrix) {
    const position = this.attributes.position;
    if (position !== void 0) {
      position.applyMatrix4(matrix);
      position.needsUpdate = true;
    }
    const normal2 = this.attributes.normal;
    if (normal2 !== void 0) {
      const normalMatrix = new Matrix32().getNormalMatrix(matrix);
      normal2.applyNormalMatrix(normalMatrix);
      normal2.needsUpdate = true;
    }
    const tangent = this.attributes.tangent;
    if (tangent !== void 0) {
      tangent.transformDirection(matrix);
      tangent.needsUpdate = true;
    }
    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }
    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }
    return this;
  }
  applyQuaternion(q2) {
    _m1$2.makeRotationFromQuaternion(q2);
    this.applyMatrix4(_m1$2);
    return this;
  }
  rotateX(angle2) {
    _m1$2.makeRotationX(angle2);
    this.applyMatrix4(_m1$2);
    return this;
  }
  rotateY(angle2) {
    _m1$2.makeRotationY(angle2);
    this.applyMatrix4(_m1$2);
    return this;
  }
  rotateZ(angle2) {
    _m1$2.makeRotationZ(angle2);
    this.applyMatrix4(_m1$2);
    return this;
  }
  translate(x3, y3, z3) {
    _m1$2.makeTranslation(x3, y3, z3);
    this.applyMatrix4(_m1$2);
    return this;
  }
  scale(x3, y3, z3) {
    _m1$2.makeScale(x3, y3, z3);
    this.applyMatrix4(_m1$2);
    return this;
  }
  lookAt(vector) {
    _obj.lookAt(vector);
    _obj.updateMatrix();
    this.applyMatrix4(_obj.matrix);
    return this;
  }
  center() {
    this.computeBoundingBox();
    this.boundingBox.getCenter(_offset).negate();
    this.translate(_offset.x, _offset.y, _offset.z);
    return this;
  }
  setFromPoints(points) {
    const position = [];
    for (let i2 = 0, l2 = points.length; i2 < l2; i2++) {
      const point2 = points[i2];
      position.push(point2.x, point2.y, point2.z || 0);
    }
    this.setAttribute("position", new Float32BufferAttribute2(position, 3));
    return this;
  }
  computeBoundingBox() {
    if (this.boundingBox === null) {
      this.boundingBox = new Box32();
    }
    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position && position.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this);
      this.boundingBox.set(
        new Vector32(-Infinity, -Infinity, -Infinity),
        new Vector32(Infinity, Infinity, Infinity)
      );
      return;
    }
    if (position !== void 0) {
      this.boundingBox.setFromBufferAttribute(position);
      if (morphAttributesPosition) {
        for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
          const morphAttribute = morphAttributesPosition[i2];
          _box$2.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$8.addVectors(this.boundingBox.min, _box$2.min);
            this.boundingBox.expandByPoint(_vector$8);
            _vector$8.addVectors(this.boundingBox.max, _box$2.max);
            this.boundingBox.expandByPoint(_vector$8);
          } else {
            this.boundingBox.expandByPoint(_box$2.min);
            this.boundingBox.expandByPoint(_box$2.max);
          }
        }
      }
    } else {
      this.boundingBox.makeEmpty();
    }
    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeBoundingSphere() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere2();
    }
    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position && position.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this);
      this.boundingSphere.set(new Vector32(), Infinity);
      return;
    }
    if (position) {
      const center = this.boundingSphere.center;
      _box$2.setFromBufferAttribute(position);
      if (morphAttributesPosition) {
        for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
          const morphAttribute = morphAttributesPosition[i2];
          _boxMorphTargets.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$8.addVectors(_box$2.min, _boxMorphTargets.min);
            _box$2.expandByPoint(_vector$8);
            _vector$8.addVectors(_box$2.max, _boxMorphTargets.max);
            _box$2.expandByPoint(_vector$8);
          } else {
            _box$2.expandByPoint(_boxMorphTargets.min);
            _box$2.expandByPoint(_boxMorphTargets.max);
          }
        }
      }
      _box$2.getCenter(center);
      let maxRadiusSq = 0;
      for (let i2 = 0, il = position.count; i2 < il; i2++) {
        _vector$8.fromBufferAttribute(position, i2);
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
      }
      if (morphAttributesPosition) {
        for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
          const morphAttribute = morphAttributesPosition[i2];
          const morphTargetsRelative = this.morphTargetsRelative;
          for (let j2 = 0, jl = morphAttribute.count; j2 < jl; j2++) {
            _vector$8.fromBufferAttribute(morphAttribute, j2);
            if (morphTargetsRelative) {
              _offset.fromBufferAttribute(position, j2);
              _vector$8.add(_offset);
            }
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
          }
        }
      }
      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
      if (isNaN(this.boundingSphere.radius)) {
        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    }
  }
  computeTangents() {
    const index8 = this.index;
    const attributes = this.attributes;
    if (index8 === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const positionAttribute = attributes.position;
    const normalAttribute = attributes.normal;
    const uvAttribute = attributes.uv;
    if (this.hasAttribute("tangent") === false) {
      this.setAttribute("tangent", new BufferAttribute2(new Float32Array(4 * positionAttribute.count), 4));
    }
    const tangentAttribute = this.getAttribute("tangent");
    const tan1 = [], tan2 = [];
    for (let i2 = 0; i2 < positionAttribute.count; i2++) {
      tan1[i2] = new Vector32();
      tan2[i2] = new Vector32();
    }
    const vA = new Vector32(), vB = new Vector32(), vC = new Vector32(), uvA = new Vector22(), uvB = new Vector22(), uvC = new Vector22(), sdir = new Vector32(), tdir = new Vector32();
    function handleTriangle(a3, b, c5) {
      vA.fromBufferAttribute(positionAttribute, a3);
      vB.fromBufferAttribute(positionAttribute, b);
      vC.fromBufferAttribute(positionAttribute, c5);
      uvA.fromBufferAttribute(uvAttribute, a3);
      uvB.fromBufferAttribute(uvAttribute, b);
      uvC.fromBufferAttribute(uvAttribute, c5);
      vB.sub(vA);
      vC.sub(vA);
      uvB.sub(uvA);
      uvC.sub(uvA);
      const r2 = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
      if (!isFinite(r2)) return;
      sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r2);
      tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r2);
      tan1[a3].add(sdir);
      tan1[b].add(sdir);
      tan1[c5].add(sdir);
      tan2[a3].add(tdir);
      tan2[b].add(tdir);
      tan2[c5].add(tdir);
    }
    let groups2 = this.groups;
    if (groups2.length === 0) {
      groups2 = [{
        start: 0,
        count: index8.count
      }];
    }
    for (let i2 = 0, il = groups2.length; i2 < il; ++i2) {
      const group2 = groups2[i2];
      const start2 = group2.start;
      const count2 = group2.count;
      for (let j2 = start2, jl = start2 + count2; j2 < jl; j2 += 3) {
        handleTriangle(
          index8.getX(j2 + 0),
          index8.getX(j2 + 1),
          index8.getX(j2 + 2)
        );
      }
    }
    const tmp2 = new Vector32(), tmp22 = new Vector32();
    const n2 = new Vector32(), n22 = new Vector32();
    function handleVertex(v2) {
      n2.fromBufferAttribute(normalAttribute, v2);
      n22.copy(n2);
      const t5 = tan1[v2];
      tmp2.copy(t5);
      tmp2.sub(n2.multiplyScalar(n2.dot(t5))).normalize();
      tmp22.crossVectors(n22, t5);
      const test = tmp22.dot(tan2[v2]);
      const w4 = test < 0 ? -1 : 1;
      tangentAttribute.setXYZW(v2, tmp2.x, tmp2.y, tmp2.z, w4);
    }
    for (let i2 = 0, il = groups2.length; i2 < il; ++i2) {
      const group2 = groups2[i2];
      const start2 = group2.start;
      const count2 = group2.count;
      for (let j2 = start2, jl = start2 + count2; j2 < jl; j2 += 3) {
        handleVertex(index8.getX(j2 + 0));
        handleVertex(index8.getX(j2 + 1));
        handleVertex(index8.getX(j2 + 2));
      }
    }
  }
  computeVertexNormals() {
    const index8 = this.index;
    const positionAttribute = this.getAttribute("position");
    if (positionAttribute !== void 0) {
      let normalAttribute = this.getAttribute("normal");
      if (normalAttribute === void 0) {
        normalAttribute = new BufferAttribute2(new Float32Array(positionAttribute.count * 3), 3);
        this.setAttribute("normal", normalAttribute);
      } else {
        for (let i2 = 0, il = normalAttribute.count; i2 < il; i2++) {
          normalAttribute.setXYZ(i2, 0, 0, 0);
        }
      }
      const pA = new Vector32(), pB = new Vector32(), pC = new Vector32();
      const nA = new Vector32(), nB = new Vector32(), nC = new Vector32();
      const cb = new Vector32(), ab = new Vector32();
      if (index8) {
        for (let i2 = 0, il = index8.count; i2 < il; i2 += 3) {
          const vA = index8.getX(i2 + 0);
          const vB = index8.getX(i2 + 1);
          const vC = index8.getX(i2 + 2);
          pA.fromBufferAttribute(positionAttribute, vA);
          pB.fromBufferAttribute(positionAttribute, vB);
          pC.fromBufferAttribute(positionAttribute, vC);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          nA.fromBufferAttribute(normalAttribute, vA);
          nB.fromBufferAttribute(normalAttribute, vB);
          nC.fromBufferAttribute(normalAttribute, vC);
          nA.add(cb);
          nB.add(cb);
          nC.add(cb);
          normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
          normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
          normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
        }
      } else {
        for (let i2 = 0, il = positionAttribute.count; i2 < il; i2 += 3) {
          pA.fromBufferAttribute(positionAttribute, i2 + 0);
          pB.fromBufferAttribute(positionAttribute, i2 + 1);
          pC.fromBufferAttribute(positionAttribute, i2 + 2);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          normalAttribute.setXYZ(i2 + 0, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i2 + 1, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i2 + 2, cb.x, cb.y, cb.z);
        }
      }
      this.normalizeNormals();
      normalAttribute.needsUpdate = true;
    }
  }
  normalizeNormals() {
    const normals = this.attributes.normal;
    for (let i2 = 0, il = normals.count; i2 < il; i2++) {
      _vector$8.fromBufferAttribute(normals, i2);
      _vector$8.normalize();
      normals.setXYZ(i2, _vector$8.x, _vector$8.y, _vector$8.z);
    }
  }
  toNonIndexed() {
    function convertBufferAttribute(attribute2, indices2) {
      const array4 = attribute2.array;
      const itemSize = attribute2.itemSize;
      const normalized = attribute2.normalized;
      const array22 = new array4.constructor(indices2.length * itemSize);
      let index8 = 0, index22 = 0;
      for (let i2 = 0, l2 = indices2.length; i2 < l2; i2++) {
        if (attribute2.isInterleavedBufferAttribute) {
          index8 = indices2[i2] * attribute2.data.stride + attribute2.offset;
        } else {
          index8 = indices2[i2] * itemSize;
        }
        for (let j2 = 0; j2 < itemSize; j2++) {
          array22[index22++] = array4[index8++];
        }
      }
      return new BufferAttribute2(array22, itemSize, normalized);
    }
    if (this.index === null) {
      console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");
      return this;
    }
    const geometry2 = new _BufferGeometry();
    const indices = this.index.array;
    const attributes = this.attributes;
    for (const name in attributes) {
      const attribute2 = attributes[name];
      const newAttribute = convertBufferAttribute(attribute2, indices);
      geometry2.setAttribute(name, newAttribute);
    }
    const morphAttributes = this.morphAttributes;
    for (const name in morphAttributes) {
      const morphArray = [];
      const morphAttribute = morphAttributes[name];
      for (let i2 = 0, il = morphAttribute.length; i2 < il; i2++) {
        const attribute2 = morphAttribute[i2];
        const newAttribute = convertBufferAttribute(attribute2, indices);
        morphArray.push(newAttribute);
      }
      geometry2.morphAttributes[name] = morphArray;
    }
    geometry2.morphTargetsRelative = this.morphTargetsRelative;
    const groups2 = this.groups;
    for (let i2 = 0, l2 = groups2.length; i2 < l2; i2++) {
      const group2 = groups2[i2];
      geometry2.addGroup(group2.start, group2.count, group2.materialIndex);
    }
    return geometry2;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "") data.name = this.name;
    if (Object.keys(this.userData).length > 0) data.userData = this.userData;
    if (this.parameters !== void 0) {
      const parameters = this.parameters;
      for (const key in parameters) {
        if (parameters[key] !== void 0) data[key] = parameters[key];
      }
      return data;
    }
    data.data = { attributes: {} };
    const index8 = this.index;
    if (index8 !== null) {
      data.data.index = {
        type: index8.array.constructor.name,
        array: Array.prototype.slice.call(index8.array)
      };
    }
    const attributes = this.attributes;
    for (const key in attributes) {
      const attribute2 = attributes[key];
      data.data.attributes[key] = attribute2.toJSON(data.data);
    }
    const morphAttributes = {};
    let hasMorphAttributes = false;
    for (const key in this.morphAttributes) {
      const attributeArray2 = this.morphAttributes[key];
      const array4 = [];
      for (let i2 = 0, il = attributeArray2.length; i2 < il; i2++) {
        const attribute2 = attributeArray2[i2];
        array4.push(attribute2.toJSON(data.data));
      }
      if (array4.length > 0) {
        morphAttributes[key] = array4;
        hasMorphAttributes = true;
      }
    }
    if (hasMorphAttributes) {
      data.data.morphAttributes = morphAttributes;
      data.data.morphTargetsRelative = this.morphTargetsRelative;
    }
    const groups2 = this.groups;
    if (groups2.length > 0) {
      data.data.groups = JSON.parse(JSON.stringify(groups2));
    }
    const boundingSphere = this.boundingSphere;
    if (boundingSphere !== null) {
      data.data.boundingSphere = {
        center: boundingSphere.center.toArray(),
        radius: boundingSphere.radius
      };
    }
    return data;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    const data = {};
    this.name = source.name;
    const index8 = source.index;
    if (index8 !== null) {
      this.setIndex(index8.clone(data));
    }
    const attributes = source.attributes;
    for (const name in attributes) {
      const attribute2 = attributes[name];
      this.setAttribute(name, attribute2.clone(data));
    }
    const morphAttributes = source.morphAttributes;
    for (const name in morphAttributes) {
      const array4 = [];
      const morphAttribute = morphAttributes[name];
      for (let i2 = 0, l2 = morphAttribute.length; i2 < l2; i2++) {
        array4.push(morphAttribute[i2].clone(data));
      }
      this.morphAttributes[name] = array4;
    }
    this.morphTargetsRelative = source.morphTargetsRelative;
    const groups2 = source.groups;
    for (let i2 = 0, l2 = groups2.length; i2 < l2; i2++) {
      const group2 = groups2[i2];
      this.addGroup(group2.start, group2.count, group2.materialIndex);
    }
    const boundingBox = source.boundingBox;
    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone();
    }
    const boundingSphere = source.boundingSphere;
    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    }
    this.drawRange.start = source.drawRange.start;
    this.drawRange.count = source.drawRange.count;
    this.userData = source.userData;
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
};
var _inverseMatrix$3 = new Matrix42();
var _ray$3 = new Ray2();
var _sphere$6 = new Sphere2();
var _sphereHitAt = new Vector32();
var _vA$1 = new Vector32();
var _vB$1 = new Vector32();
var _vC$1 = new Vector32();
var _tempA = new Vector32();
var _morphA = new Vector32();
var _uvA$1 = new Vector22();
var _uvB$1 = new Vector22();
var _uvC$1 = new Vector22();
var _normalA = new Vector32();
var _normalB = new Vector32();
var _normalC = new Vector32();
var _intersectionPoint = new Vector32();
var _intersectionPointWorld = new Vector32();
var Mesh2 = class extends Object3D2 {
  constructor(geometry = new BufferGeometry2(), material = new MeshBasicMaterial2()) {
    super();
    this.isMesh = true;
    this.type = "Mesh";
    this.geometry = geometry;
    this.material = material;
    this.updateMorphTargets();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    if (source.morphTargetInfluences !== void 0) {
      this.morphTargetInfluences = source.morphTargetInfluences.slice();
    }
    if (source.morphTargetDictionary !== void 0) {
      this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
    }
    this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
    this.geometry = source.geometry;
    return this;
  }
  updateMorphTargets() {
    const geometry = this.geometry;
    const morphAttributes = geometry.morphAttributes;
    const keys2 = Object.keys(morphAttributes);
    if (keys2.length > 0) {
      const morphAttribute = morphAttributes[keys2[0]];
      if (morphAttribute !== void 0) {
        this.morphTargetInfluences = [];
        this.morphTargetDictionary = {};
        for (let m3 = 0, ml = morphAttribute.length; m3 < ml; m3++) {
          const name = morphAttribute[m3].name || String(m3);
          this.morphTargetInfluences.push(0);
          this.morphTargetDictionary[name] = m3;
        }
      }
    }
  }
  getVertexPosition(index8, target) {
    const geometry = this.geometry;
    const position = geometry.attributes.position;
    const morphPosition = geometry.morphAttributes.position;
    const morphTargetsRelative = geometry.morphTargetsRelative;
    target.fromBufferAttribute(position, index8);
    const morphInfluences = this.morphTargetInfluences;
    if (morphPosition && morphInfluences) {
      _morphA.set(0, 0, 0);
      for (let i2 = 0, il = morphPosition.length; i2 < il; i2++) {
        const influence = morphInfluences[i2];
        const morphAttribute = morphPosition[i2];
        if (influence === 0) continue;
        _tempA.fromBufferAttribute(morphAttribute, index8);
        if (morphTargetsRelative) {
          _morphA.addScaledVector(_tempA, influence);
        } else {
          _morphA.addScaledVector(_tempA.sub(target), influence);
        }
      }
      target.add(_morphA);
    }
    return target;
  }
  raycast(raycaster, intersects2) {
    const geometry = this.geometry;
    const material = this.material;
    const matrixWorld = this.matrixWorld;
    if (material === void 0) return;
    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
    _sphere$6.copy(geometry.boundingSphere);
    _sphere$6.applyMatrix4(matrixWorld);
    _ray$3.copy(raycaster.ray).recast(raycaster.near);
    if (_sphere$6.containsPoint(_ray$3.origin) === false) {
      if (_ray$3.intersectSphere(_sphere$6, _sphereHitAt) === null) return;
      if (_ray$3.origin.distanceToSquared(_sphereHitAt) > (raycaster.far - raycaster.near) ** 2) return;
    }
    _inverseMatrix$3.copy(matrixWorld).invert();
    _ray$3.copy(raycaster.ray).applyMatrix4(_inverseMatrix$3);
    if (geometry.boundingBox !== null) {
      if (_ray$3.intersectsBox(geometry.boundingBox) === false) return;
    }
    this._computeIntersections(raycaster, intersects2, _ray$3);
  }
  _computeIntersections(raycaster, intersects2, rayLocalSpace) {
    let intersection3;
    const geometry = this.geometry;
    const material = this.material;
    const index8 = geometry.index;
    const position = geometry.attributes.position;
    const uv2 = geometry.attributes.uv;
    const uv1 = geometry.attributes.uv1;
    const normal2 = geometry.attributes.normal;
    const groups2 = geometry.groups;
    const drawRange = geometry.drawRange;
    if (index8 !== null) {
      if (Array.isArray(material)) {
        for (let i2 = 0, il = groups2.length; i2 < il; i2++) {
          const group2 = groups2[i2];
          const groupMaterial = material[group2.materialIndex];
          const start2 = Math.max(group2.start, drawRange.start);
          const end = Math.min(index8.count, Math.min(group2.start + group2.count, drawRange.start + drawRange.count));
          for (let j2 = start2, jl = end; j2 < jl; j2 += 3) {
            const a3 = index8.getX(j2);
            const b = index8.getX(j2 + 1);
            const c5 = index8.getX(j2 + 2);
            intersection3 = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv2, uv1, normal2, a3, b, c5);
            if (intersection3) {
              intersection3.faceIndex = Math.floor(j2 / 3);
              intersection3.face.materialIndex = group2.materialIndex;
              intersects2.push(intersection3);
            }
          }
        }
      } else {
        const start2 = Math.max(0, drawRange.start);
        const end = Math.min(index8.count, drawRange.start + drawRange.count);
        for (let i2 = start2, il = end; i2 < il; i2 += 3) {
          const a3 = index8.getX(i2);
          const b = index8.getX(i2 + 1);
          const c5 = index8.getX(i2 + 2);
          intersection3 = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv2, uv1, normal2, a3, b, c5);
          if (intersection3) {
            intersection3.faceIndex = Math.floor(i2 / 3);
            intersects2.push(intersection3);
          }
        }
      }
    } else if (position !== void 0) {
      if (Array.isArray(material)) {
        for (let i2 = 0, il = groups2.length; i2 < il; i2++) {
          const group2 = groups2[i2];
          const groupMaterial = material[group2.materialIndex];
          const start2 = Math.max(group2.start, drawRange.start);
          const end = Math.min(position.count, Math.min(group2.start + group2.count, drawRange.start + drawRange.count));
          for (let j2 = start2, jl = end; j2 < jl; j2 += 3) {
            const a3 = j2;
            const b = j2 + 1;
            const c5 = j2 + 2;
            intersection3 = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv2, uv1, normal2, a3, b, c5);
            if (intersection3) {
              intersection3.faceIndex = Math.floor(j2 / 3);
              intersection3.face.materialIndex = group2.materialIndex;
              intersects2.push(intersection3);
            }
          }
        }
      } else {
        const start2 = Math.max(0, drawRange.start);
        const end = Math.min(position.count, drawRange.start + drawRange.count);
        for (let i2 = start2, il = end; i2 < il; i2 += 3) {
          const a3 = i2;
          const b = i2 + 1;
          const c5 = i2 + 2;
          intersection3 = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv2, uv1, normal2, a3, b, c5);
          if (intersection3) {
            intersection3.faceIndex = Math.floor(i2 / 3);
            intersects2.push(intersection3);
          }
        }
      }
    }
  }
};
function checkIntersection$1(object, material, raycaster, ray, pA, pB, pC, point2) {
  let intersect;
  if (material.side === BackSide2) {
    intersect = ray.intersectTriangle(pC, pB, pA, true, point2);
  } else {
    intersect = ray.intersectTriangle(pA, pB, pC, material.side === FrontSide2, point2);
  }
  if (intersect === null) return null;
  _intersectionPointWorld.copy(point2);
  _intersectionPointWorld.applyMatrix4(object.matrixWorld);
  const distance4 = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
  if (distance4 < raycaster.near || distance4 > raycaster.far) return null;
  return {
    distance: distance4,
    point: _intersectionPointWorld.clone(),
    object
  };
}
function checkGeometryIntersection(object, material, raycaster, ray, uv2, uv1, normal2, a3, b, c5) {
  object.getVertexPosition(a3, _vA$1);
  object.getVertexPosition(b, _vB$1);
  object.getVertexPosition(c5, _vC$1);
  const intersection3 = checkIntersection$1(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
  if (intersection3) {
    if (uv2) {
      _uvA$1.fromBufferAttribute(uv2, a3);
      _uvB$1.fromBufferAttribute(uv2, b);
      _uvC$1.fromBufferAttribute(uv2, c5);
      intersection3.uv = Triangle2.getInterpolation(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector22());
    }
    if (uv1) {
      _uvA$1.fromBufferAttribute(uv1, a3);
      _uvB$1.fromBufferAttribute(uv1, b);
      _uvC$1.fromBufferAttribute(uv1, c5);
      intersection3.uv1 = Triangle2.getInterpolation(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector22());
    }
    if (normal2) {
      _normalA.fromBufferAttribute(normal2, a3);
      _normalB.fromBufferAttribute(normal2, b);
      _normalC.fromBufferAttribute(normal2, c5);
      intersection3.normal = Triangle2.getInterpolation(_intersectionPoint, _vA$1, _vB$1, _vC$1, _normalA, _normalB, _normalC, new Vector32());
      if (intersection3.normal.dot(ray.direction) > 0) {
        intersection3.normal.multiplyScalar(-1);
      }
    }
    const face = {
      a: a3,
      b,
      c: c5,
      normal: new Vector32(),
      materialIndex: 0
    };
    Triangle2.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
    intersection3.face = face;
  }
  return intersection3;
}
var BoxGeometry2 = class _BoxGeometry extends BufferGeometry2 {
  constructor(width = 1, height = 1, depth2 = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
    super();
    this.type = "BoxGeometry";
    this.parameters = {
      width,
      height,
      depth: depth2,
      widthSegments,
      heightSegments,
      depthSegments
    };
    const scope = this;
    widthSegments = Math.floor(widthSegments);
    heightSegments = Math.floor(heightSegments);
    depthSegments = Math.floor(depthSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let numberOfVertices = 0;
    let groupStart = 0;
    buildPlane("z", "y", "x", -1, -1, depth2, height, width, depthSegments, heightSegments, 0);
    buildPlane("z", "y", "x", 1, -1, depth2, height, -width, depthSegments, heightSegments, 1);
    buildPlane("x", "z", "y", 1, 1, width, depth2, height, widthSegments, depthSegments, 2);
    buildPlane("x", "z", "y", 1, -1, width, depth2, -height, widthSegments, depthSegments, 3);
    buildPlane("x", "y", "z", 1, -1, width, height, depth2, widthSegments, heightSegments, 4);
    buildPlane("x", "y", "z", -1, -1, width, height, -depth2, widthSegments, heightSegments, 5);
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
    function buildPlane(u2, v2, w4, udir, vdir, width2, height2, depth3, gridX, gridY, materialIndex) {
      const segmentWidth = width2 / gridX;
      const segmentHeight = height2 / gridY;
      const widthHalf = width2 / 2;
      const heightHalf = height2 / 2;
      const depthHalf = depth3 / 2;
      const gridX1 = gridX + 1;
      const gridY1 = gridY + 1;
      let vertexCounter = 0;
      let groupCount = 0;
      const vector = new Vector32();
      for (let iy = 0; iy < gridY1; iy++) {
        const y3 = iy * segmentHeight - heightHalf;
        for (let ix = 0; ix < gridX1; ix++) {
          const x3 = ix * segmentWidth - widthHalf;
          vector[u2] = x3 * udir;
          vector[v2] = y3 * vdir;
          vector[w4] = depthHalf;
          vertices.push(vector.x, vector.y, vector.z);
          vector[u2] = 0;
          vector[v2] = 0;
          vector[w4] = depth3 > 0 ? 1 : -1;
          normals.push(vector.x, vector.y, vector.z);
          uvs.push(ix / gridX);
          uvs.push(1 - iy / gridY);
          vertexCounter += 1;
        }
      }
      for (let iy = 0; iy < gridY; iy++) {
        for (let ix = 0; ix < gridX; ix++) {
          const a3 = numberOfVertices + ix + gridX1 * iy;
          const b = numberOfVertices + ix + gridX1 * (iy + 1);
          const c5 = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
          const d3 = numberOfVertices + (ix + 1) + gridX1 * iy;
          indices.push(a3, b, d3);
          indices.push(b, c5, d3);
          groupCount += 6;
        }
      }
      scope.addGroup(groupStart, groupCount, materialIndex);
      groupStart += groupCount;
      numberOfVertices += vertexCounter;
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new _BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
  }
};
function cloneUniforms(src) {
  const dst = {};
  for (const u2 in src) {
    dst[u2] = {};
    for (const p3 in src[u2]) {
      const property3 = src[u2][p3];
      if (property3 && (property3.isColor || property3.isMatrix3 || property3.isMatrix4 || property3.isVector2 || property3.isVector3 || property3.isVector4 || property3.isTexture || property3.isQuaternion)) {
        if (property3.isRenderTargetTexture) {
          console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().");
          dst[u2][p3] = null;
        } else {
          dst[u2][p3] = property3.clone();
        }
      } else if (Array.isArray(property3)) {
        dst[u2][p3] = property3.slice();
      } else {
        dst[u2][p3] = property3;
      }
    }
  }
  return dst;
}
function mergeUniforms(uniforms) {
  const merged = {};
  for (let u2 = 0; u2 < uniforms.length; u2++) {
    const tmp2 = cloneUniforms(uniforms[u2]);
    for (const p3 in tmp2) {
      merged[p3] = tmp2[p3];
    }
  }
  return merged;
}
var Camera2 = class extends Object3D2 {
  constructor() {
    super();
    this.isCamera = true;
    this.type = "Camera";
    this.matrixWorldInverse = new Matrix42();
    this.projectionMatrix = new Matrix42();
    this.projectionMatrixInverse = new Matrix42();
    this.coordinateSystem = WebGLCoordinateSystem2;
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.matrixWorldInverse.copy(source.matrixWorldInverse);
    this.projectionMatrix.copy(source.projectionMatrix);
    this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
    this.coordinateSystem = source.coordinateSystem;
    return this;
  }
  getWorldDirection(target) {
    return super.getWorldDirection(target).negate();
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(updateParents, updateChildren) {
    super.updateWorldMatrix(updateParents, updateChildren);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var _v3$1 = new Vector32();
var _minTarget = new Vector22();
var _maxTarget = new Vector22();
var PerspectiveCamera2 = class extends Camera2 {
  constructor(fov = 50, aspect = 1, near = 0.1, far = 2e3) {
    super();
    this.isPerspectiveCamera = true;
    this.type = "PerspectiveCamera";
    this.fov = fov;
    this.zoom = 1;
    this.near = near;
    this.far = far;
    this.focus = 10;
    this.aspect = aspect;
    this.view = null;
    this.filmGauge = 35;
    this.filmOffset = 0;
    this.updateProjectionMatrix();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.fov = source.fov;
    this.zoom = source.zoom;
    this.near = source.near;
    this.far = source.far;
    this.focus = source.focus;
    this.aspect = source.aspect;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    this.filmGauge = source.filmGauge;
    this.filmOffset = source.filmOffset;
    return this;
  }
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(focalLength) {
    const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
    this.fov = RAD2DEG2 * 2 * Math.atan(vExtentSlope);
    this.updateProjectionMatrix();
  }
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength() {
    const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / vExtentSlope;
  }
  getEffectiveFOV() {
    return RAD2DEG2 * 2 * Math.atan(
      Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
   * Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle.
   */
  getViewBounds(distance4, minTarget, maxTarget) {
    _v3$1.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse);
    minTarget.set(_v3$1.x, _v3$1.y).multiplyScalar(-distance4 / _v3$1.z);
    _v3$1.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse);
    maxTarget.set(_v3$1.x, _v3$1.y).multiplyScalar(-distance4 / _v3$1.z);
  }
  /**
   * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
   * Copies the result into the target Vector2, where x is width and y is height.
   */
  getViewSize(distance4, target) {
    this.getViewBounds(distance4, _minTarget, _maxTarget);
    return target.subVectors(_maxTarget, _minTarget);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset(fullWidth, fullHeight, x3, y3, width, height) {
    this.aspect = fullWidth / fullHeight;
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x3;
    this.view.offsetY = y3;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  }
  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const near = this.near;
    let top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
    let height = 2 * top;
    let width = this.aspect * height;
    let left = -0.5 * width;
    const view = this.view;
    if (this.view !== null && this.view.enabled) {
      const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
      left += view.offsetX * width / fullWidth;
      top -= view.offsetY * height / fullHeight;
      width *= view.width / fullWidth;
      height *= view.height / fullHeight;
    }
    const skew = this.filmOffset;
    if (skew !== 0) left += near * skew / this.getFilmWidth();
    this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far, this.coordinateSystem);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.fov = this.fov;
    data.object.zoom = this.zoom;
    data.object.near = this.near;
    data.object.far = this.far;
    data.object.focus = this.focus;
    data.object.aspect = this.aspect;
    if (this.view !== null) data.object.view = Object.assign({}, this.view);
    data.object.filmGauge = this.filmGauge;
    data.object.filmOffset = this.filmOffset;
    return data;
  }
};
var CubeTexture2 = class extends Texture2 {
  constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format3, type, anisotropy2, colorSpace) {
    images = images !== void 0 ? images : [];
    mapping = mapping !== void 0 ? mapping : CubeReflectionMapping2;
    super(images, mapping, wrapS, wrapT, magFilter, minFilter, format3, type, anisotropy2, colorSpace);
    this.isCubeTexture = true;
    this.flipY = false;
  }
  get images() {
    return this.image;
  }
  set images(value) {
    this.image = value;
  }
};
var _vector1 = new Vector32();
var _vector2 = new Vector32();
var _normalMatrix = new Matrix32();
var Plane2 = class {
  constructor(normal2 = new Vector32(1, 0, 0), constant3 = 0) {
    this.isPlane = true;
    this.normal = normal2;
    this.constant = constant3;
  }
  set(normal2, constant3) {
    this.normal.copy(normal2);
    this.constant = constant3;
    return this;
  }
  setComponents(x3, y3, z3, w4) {
    this.normal.set(x3, y3, z3);
    this.constant = w4;
    return this;
  }
  setFromNormalAndCoplanarPoint(normal2, point2) {
    this.normal.copy(normal2);
    this.constant = -point2.dot(this.normal);
    return this;
  }
  setFromCoplanarPoints(a3, b, c5) {
    const normal2 = _vector1.subVectors(c5, b).cross(_vector2.subVectors(a3, b)).normalize();
    this.setFromNormalAndCoplanarPoint(normal2, a3);
    return this;
  }
  copy(plane) {
    this.normal.copy(plane.normal);
    this.constant = plane.constant;
    return this;
  }
  normalize() {
    const inverseNormalLength = 1 / this.normal.length();
    this.normal.multiplyScalar(inverseNormalLength);
    this.constant *= inverseNormalLength;
    return this;
  }
  negate() {
    this.constant *= -1;
    this.normal.negate();
    return this;
  }
  distanceToPoint(point2) {
    return this.normal.dot(point2) + this.constant;
  }
  distanceToSphere(sphere) {
    return this.distanceToPoint(sphere.center) - sphere.radius;
  }
  projectPoint(point2, target) {
    return target.copy(point2).addScaledVector(this.normal, -this.distanceToPoint(point2));
  }
  intersectLine(line, target) {
    const direction = line.delta(_vector1);
    const denominator = this.normal.dot(direction);
    if (denominator === 0) {
      if (this.distanceToPoint(line.start) === 0) {
        return target.copy(line.start);
      }
      return null;
    }
    const t5 = -(line.start.dot(this.normal) + this.constant) / denominator;
    if (t5 < 0 || t5 > 1) {
      return null;
    }
    return target.copy(line.start).addScaledVector(direction, t5);
  }
  intersectsLine(line) {
    const startSign = this.distanceToPoint(line.start);
    const endSign = this.distanceToPoint(line.end);
    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
  }
  intersectsBox(box) {
    return box.intersectsPlane(this);
  }
  intersectsSphere(sphere) {
    return sphere.intersectsPlane(this);
  }
  coplanarPoint(target) {
    return target.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(matrix, optionalNormalMatrix) {
    const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
    const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
    const normal2 = this.normal.applyMatrix3(normalMatrix).normalize();
    this.constant = -referencePoint.dot(normal2);
    return this;
  }
  translate(offset) {
    this.constant -= offset.dot(this.normal);
    return this;
  }
  equals(plane) {
    return plane.normal.equals(this.normal) && plane.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var _sphere$5 = new Sphere2();
var _vector$7 = new Vector32();
var Frustum2 = class {
  constructor(p0 = new Plane2(), p1 = new Plane2(), p22 = new Plane2(), p3 = new Plane2(), p4 = new Plane2(), p5 = new Plane2()) {
    this.planes = [p0, p1, p22, p3, p4, p5];
  }
  set(p0, p1, p22, p3, p4, p5) {
    const planes = this.planes;
    planes[0].copy(p0);
    planes[1].copy(p1);
    planes[2].copy(p22);
    planes[3].copy(p3);
    planes[4].copy(p4);
    planes[5].copy(p5);
    return this;
  }
  copy(frustum) {
    const planes = this.planes;
    for (let i2 = 0; i2 < 6; i2++) {
      planes[i2].copy(frustum.planes[i2]);
    }
    return this;
  }
  setFromProjectionMatrix(m3, coordinateSystem = WebGLCoordinateSystem2) {
    const planes = this.planes;
    const me = m3.elements;
    const me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
    const me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
    const me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
    const me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
    planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
    planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
    planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
    planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
    planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
    if (coordinateSystem === WebGLCoordinateSystem2) {
      planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
    } else if (coordinateSystem === WebGPUCoordinateSystem2) {
      planes[5].setComponents(me2, me6, me10, me14).normalize();
    } else {
      throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + coordinateSystem);
    }
    return this;
  }
  intersectsObject(object) {
    if (object.boundingSphere !== void 0) {
      if (object.boundingSphere === null) object.computeBoundingSphere();
      _sphere$5.copy(object.boundingSphere).applyMatrix4(object.matrixWorld);
    } else {
      const geometry = object.geometry;
      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
      _sphere$5.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
    }
    return this.intersectsSphere(_sphere$5);
  }
  intersectsSprite(sprite) {
    _sphere$5.center.set(0, 0, 0);
    _sphere$5.radius = 0.7071067811865476;
    _sphere$5.applyMatrix4(sprite.matrixWorld);
    return this.intersectsSphere(_sphere$5);
  }
  intersectsSphere(sphere) {
    const planes = this.planes;
    const center = sphere.center;
    const negRadius = -sphere.radius;
    for (let i2 = 0; i2 < 6; i2++) {
      const distance4 = planes[i2].distanceToPoint(center);
      if (distance4 < negRadius) {
        return false;
      }
    }
    return true;
  }
  intersectsBox(box) {
    const planes = this.planes;
    for (let i2 = 0; i2 < 6; i2++) {
      const plane = planes[i2];
      _vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
      _vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
      _vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;
      if (plane.distanceToPoint(_vector$7) < 0) {
        return false;
      }
    }
    return true;
  }
  containsPoint(point2) {
    const planes = this.planes;
    for (let i2 = 0; i2 < 6; i2++) {
      if (planes[i2].distanceToPoint(point2) < 0) {
        return false;
      }
    }
    return true;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var PlaneGeometry2 = class _PlaneGeometry extends BufferGeometry2 {
  constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
    super();
    this.type = "PlaneGeometry";
    this.parameters = {
      width,
      height,
      widthSegments,
      heightSegments
    };
    const width_half = width / 2;
    const height_half = height / 2;
    const gridX = Math.floor(widthSegments);
    const gridY = Math.floor(heightSegments);
    const gridX1 = gridX + 1;
    const gridY1 = gridY + 1;
    const segment_width = width / gridX;
    const segment_height = height / gridY;
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy = 0; iy < gridY1; iy++) {
      const y3 = iy * segment_height - height_half;
      for (let ix = 0; ix < gridX1; ix++) {
        const x3 = ix * segment_width - width_half;
        vertices.push(x3, -y3, 0);
        normals.push(0, 0, 1);
        uvs.push(ix / gridX);
        uvs.push(1 - iy / gridY);
      }
    }
    for (let iy = 0; iy < gridY; iy++) {
      for (let ix = 0; ix < gridX; ix++) {
        const a3 = ix + gridX1 * iy;
        const b = ix + gridX1 * (iy + 1);
        const c5 = ix + 1 + gridX1 * (iy + 1);
        const d3 = ix + 1 + gridX1 * iy;
        indices.push(a3, b, d3);
        indices.push(b, c5, d3);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new _PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
  }
};
var alphahash_fragment = "#ifdef USE_ALPHAHASH\n	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif";
var alphahash_pars_fragment = "#ifdef USE_ALPHAHASH\n	const float ALPHA_HASH_SCALE = 0.05;\n	float hash2D( vec2 value ) {\n		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n	}\n	float hash3D( vec3 value ) {\n		return hash2D( vec2( hash2D( value.xy ), value.z ) );\n	}\n	float getAlphaHashThreshold( vec3 position ) {\n		float maxDeriv = max(\n			length( dFdx( position.xyz ) ),\n			length( dFdy( position.xyz ) )\n		);\n		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n		vec2 pixScales = vec2(\n			exp2( floor( log2( pixScale ) ) ),\n			exp2( ceil( log2( pixScale ) ) )\n		);\n		vec2 alpha = vec2(\n			hash3D( floor( pixScales.x * position.xyz ) ),\n			hash3D( floor( pixScales.y * position.xyz ) )\n		);\n		float lerpFactor = fract( log2( pixScale ) );\n		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n		float a = min( lerpFactor, 1.0 - lerpFactor );\n		vec3 cases = vec3(\n			x * x / ( 2.0 * a * ( 1.0 - a ) ),\n			( x - 0.5 * a ) / ( 1.0 - a ),\n			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n		);\n		float threshold = ( x < ( 1.0 - a ) )\n			? ( ( x < a ) ? cases.x : cases.y )\n			: cases.z;\n		return clamp( threshold , 1.0e-6, 1.0 );\n	}\n#endif";
var alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif";
var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var alphatest_fragment = "#ifdef USE_ALPHATEST\n	#ifdef ALPHA_TO_COVERAGE\n	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n	if ( diffuseColor.a == 0.0 ) discard;\n	#else\n	if ( diffuseColor.a < alphaTest ) discard;\n	#endif\n#endif";
var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif";
var aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_CLEARCOAT ) \n		clearcoatSpecularIndirect *= ambientOcclusion;\n	#endif\n	#if defined( USE_SHEEN ) \n		sheenSpecularIndirect *= ambientOcclusion;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif";
var aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
var batching_pars_vertex = "#ifdef USE_BATCHING\n	attribute float batchId;\n	uniform highp sampler2D batchingTexture;\n	mat4 getBatchingMatrix( const in float i ) {\n		int size = textureSize( batchingTexture, 0 ).x;\n		int j = int( i ) * 4;\n		int x = j % size;\n		int y = j / size;\n		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n		return mat4( v1, v2, v3, v4 );\n	}\n#endif";
var batching_vertex = "#ifdef USE_BATCHING\n	mat4 batchingMatrix = getBatchingMatrix( batchId );\n#endif";
var begin_vertex = "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n	vPosition = vec3( position );\n#endif";
var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif";
var bsdfs = "float G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n} // validated";
var iridescence_fragment = "#ifdef USE_IRIDESCENCE\n	const mat3 XYZ_TO_REC709 = mat3(\n		 3.2404542, -0.9692660,  0.0556434,\n		-1.5371385,  1.8760108, -0.2040259,\n		-0.4985314,  0.0415560,  1.0572252\n	);\n	vec3 Fresnel0ToIor( vec3 fresnel0 ) {\n		vec3 sqrtF0 = sqrt( fresnel0 );\n		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n	}\n	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n	}\n	float IorToFresnel0( float transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n	}\n	vec3 evalSensitivity( float OPD, vec3 shift ) {\n		float phase = 2.0 * PI * OPD * 1.0e-9;\n		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n		xyz /= 1.0685e-7;\n		vec3 rgb = XYZ_TO_REC709 * xyz;\n		return rgb;\n	}\n	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n		vec3 I;\n		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n		float cosTheta2Sq = 1.0 - sinTheta2Sq;\n		if ( cosTheta2Sq < 0.0 ) {\n			return vec3( 1.0 );\n		}\n		float cosTheta2 = sqrt( cosTheta2Sq );\n		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n		float R12 = F_Schlick( R0, 1.0, cosTheta1 );\n		float T121 = 1.0 - R12;\n		float phi12 = 0.0;\n		if ( iridescenceIOR < outsideIOR ) phi12 = PI;\n		float phi21 = PI - phi12;\n		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n		vec3 phi23 = vec3( 0.0 );\n		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n		vec3 phi = vec3( phi21 ) + phi23;\n		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n		vec3 r123 = sqrt( R123 );\n		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n		vec3 C0 = R12 + Rs;\n		I = C0;\n		vec3 Cm = Rs - T121;\n		for ( int m = 1; m <= 2; ++ m ) {\n			Cm *= r123;\n			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n			I += Cm * Sm;\n		}\n		return max( I, vec3( 0.0 ) );\n	}\n#endif";
var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vBumpMapUv );\n		vec2 dSTdy = dFdy( vBumpMapUv );\n		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif";
var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#ifdef ALPHA_TO_COVERAGE\n		float distanceToPlane, distanceGradient;\n		float clipOpacity = 1.0;\n		#pragma unroll_loop_start\n		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n			distanceGradient = fwidth( distanceToPlane ) / 2.0;\n			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n			if ( clipOpacity == 0.0 ) discard;\n		}\n		#pragma unroll_loop_end\n		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n			float unionClipOpacity = 1.0;\n			#pragma unroll_loop_start\n			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n				plane = clippingPlanes[ i ];\n				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n				distanceGradient = fwidth( distanceToPlane ) / 2.0;\n				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n			}\n			#pragma unroll_loop_end\n			clipOpacity *= 1.0 - unionClipOpacity;\n		#endif\n		diffuseColor.a *= clipOpacity;\n		if ( diffuseColor.a == 0.0 ) discard;\n	#else\n		#pragma unroll_loop_start\n		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n		}\n		#pragma unroll_loop_end\n		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n			bool clipped = true;\n			#pragma unroll_loop_start\n			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n				plane = clippingPlanes[ i ];\n				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n			}\n			#pragma unroll_loop_end\n			if ( clipped ) discard;\n		#endif\n	#endif\n#endif";
var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif";
var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif";
var color_fragment = "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif";
var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif";
var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif";
var color_vertex = "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif";
var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n	varying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n	return dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated";
var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		uv.x += filterInt * 3.0 * cubeUV_minTileSize;\n		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n		uv.x *= CUBEUV_TEXEL_WIDTH;\n		uv.y *= CUBEUV_TEXEL_HEIGHT;\n		#ifdef texture2DGradEXT\n			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n		#else\n			return texture2D( envMap, uv ).rgb;\n		#endif\n	}\n	#define cubeUV_r0 1.0\n	#define cubeUV_m0 - 2.0\n	#define cubeUV_r1 0.8\n	#define cubeUV_m1 - 1.0\n	#define cubeUV_r4 0.4\n	#define cubeUV_m4 2.0\n	#define cubeUV_r5 0.305\n	#define cubeUV_m5 3.0\n	#define cubeUV_r6 0.21\n	#define cubeUV_m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= cubeUV_r1 ) {\n			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n		} else if ( roughness >= cubeUV_r4 ) {\n			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n		} else if ( roughness >= cubeUV_r5 ) {\n			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n		} else if ( roughness >= cubeUV_r6 ) {\n			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif";
var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n	vec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n	mat3 bm = mat3( batchingMatrix );\n	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n	transformedNormal = bm * transformedNormal;\n	#ifdef USE_TANGENT\n		transformedTangent = bm * transformedTangent;\n	#endif\n#endif\n#ifdef USE_INSTANCING\n	mat3 im = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n	transformedNormal = im * transformedNormal;\n	#ifdef USE_TANGENT\n		transformedTangent = im * transformedTangent;\n	#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif";
var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif";
var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif";
var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif";
var colorspace_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
var colorspace_pars_fragment = "\nconst mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(\n	vec3( 0.8224621, 0.177538, 0.0 ),\n	vec3( 0.0331941, 0.9668058, 0.0 ),\n	vec3( 0.0170827, 0.0723974, 0.9105199 )\n);\nconst mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(\n	vec3( 1.2249401, - 0.2249404, 0.0 ),\n	vec3( - 0.0420569, 1.0420571, 0.0 ),\n	vec3( - 0.0196376, - 0.0786361, 1.0982735 )\n);\nvec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {\n	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );\n}\nvec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {\n	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );\n}\nvec4 LinearTransferOETF( in vec4 value ) {\n	return value;\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return sRGBTransferOETF( value );\n}";
var envmap_fragment = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif";
var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform mat3 envMapRotation;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif";
var envmap_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif";
var envmap_pars_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif";
var envmap_vertex = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif";
var fog_vertex = "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif";
var fog_pars_vertex = "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif";
var fog_fragment = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
var fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return vec3( texture2D( gradientMap, coord ).r );\n	#else\n		vec2 fw = fwidth( coord ) * 0.5;\n		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n	#endif\n}";
var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
var lights_lambert_fragment = "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;";
var lights_lambert_pars_fragment = "varying vec3 vViewPosition;\nstruct LambertMaterial {\n	vec3 diffuseColor;\n	float specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Lambert\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert";
var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n	uniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	#if defined ( LEGACY_LIGHTS )\n		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n		}\n		return 1.0;\n	#else\n		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n		if ( cutoffDistance > 0.0 ) {\n			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n		}\n		return distanceFalloff;\n	#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometryPosition;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometryPosition;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif";
var envmap_physical_pars_fragment = "#ifdef USE_ENVMAP\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#ifdef ENVMAP_TYPE_CUBE_UV\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#ifdef ENVMAP_TYPE_CUBE_UV\n			vec3 reflectVec = reflect( - viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	#ifdef USE_ANISOTROPY\n		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n			#ifdef ENVMAP_TYPE_CUBE_UV\n				vec3 bentNormal = cross( bitangent, viewDir );\n				bentNormal = normalize( cross( bentNormal, bitangent ) );\n				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n				return getIBLRadiance( viewDir, bentNormal, roughness );\n			#else\n				return vec3( 0.0 );\n			#endif\n		}\n	#endif\n#endif";
var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon";
var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong";
var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	material.ior = ior;\n	#ifdef USE_SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULAR_COLORMAP\n			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n		#endif\n		#ifdef USE_SPECULAR_INTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n	material.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n	material.iridescence = iridescence;\n	material.iridescenceIOR = iridescenceIOR;\n	#ifdef USE_IRIDESCENCEMAP\n		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n	#endif\n	#ifdef USE_IRIDESCENCE_THICKNESSMAP\n		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n	#else\n		material.iridescenceThickness = iridescenceThicknessMaximum;\n	#endif\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEEN_COLORMAP\n		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	#ifdef USE_ANISOTROPYMAP\n		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n	#else\n		vec2 anisotropyV = anisotropyVector;\n	#endif\n	material.anisotropy = length( anisotropyV );\n	if( material.anisotropy == 0.0 ) {\n		anisotropyV = vec2( 1.0, 0.0 );\n	} else {\n		anisotropyV /= material.anisotropy;\n		material.anisotropy = saturate( material.anisotropy );\n	}\n	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif";
var lights_physical_pars_fragment = "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	float dispersion;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_IRIDESCENCE\n		float iridescence;\n		float iridescenceIOR;\n		float iridescenceThickness;\n		vec3 iridescenceFresnel;\n		vec3 iridescenceF0;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n	#ifdef IOR\n		float ior;\n	#endif\n	#ifdef USE_TRANSMISSION\n		float transmission;\n		float transmissionAlpha;\n		float thickness;\n		float attenuationDistance;\n		vec3 attenuationColor;\n	#endif\n	#ifdef USE_ANISOTROPY\n		float anisotropy;\n		float alphaT;\n		vec3 anisotropyT;\n		vec3 anisotropyB;\n	#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n		float v = 0.5 / ( gv + gl );\n		return saturate(v);\n	}\n	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n		float a2 = alphaT * alphaB;\n		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n		highp float v2 = dot( v, v );\n		float w2 = a2 / v2;\n		return RECIPROCAL_PI * a2 * pow2 ( w2 );\n	}\n#endif\n#ifdef USE_CLEARCOAT\n	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n		vec3 f0 = material.clearcoatF0;\n		float f90 = material.clearcoatF90;\n		float roughness = material.clearcoatRoughness;\n		float alpha = pow2( roughness );\n		vec3 halfDir = normalize( lightDir + viewDir );\n		float dotNL = saturate( dot( normal, lightDir ) );\n		float dotNV = saturate( dot( normal, viewDir ) );\n		float dotNH = saturate( dot( normal, halfDir ) );\n		float dotVH = saturate( dot( viewDir, halfDir ) );\n		vec3 F = F_Schlick( f0, f90, dotVH );\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n		return F * ( V * D );\n	}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n	vec3 f0 = material.specularColor;\n	float f90 = material.specularF90;\n	float roughness = material.roughness;\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	#ifdef USE_IRIDESCENCE\n		F = mix( F, material.iridescenceFresnel, material.iridescence );\n	#endif\n	#ifdef USE_ANISOTROPY\n		float dotTL = dot( material.anisotropyT, lightDir );\n		float dotTV = dot( material.anisotropyT, viewDir );\n		float dotTH = dot( material.anisotropyT, halfDir );\n		float dotBL = dot( material.anisotropyB, lightDir );\n		float dotBV = dot( material.anisotropyB, viewDir );\n		float dotBH = dot( material.anisotropyB, halfDir );\n		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n	#else\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n	#endif\n	return F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float r2 = roughness * roughness;\n	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n	return saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	#ifdef USE_IRIDESCENCE\n		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n	#else\n		vec3 Fr = specularColor;\n	#endif\n	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometryNormal;\n		vec3 viewDir = geometryViewDir;\n		vec3 position = geometryPosition;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n	#endif\n	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	#ifdef USE_IRIDESCENCE\n		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n	#else\n		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	#endif\n	vec3 totalScattering = singleScattering + multiScattering;\n	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
var lights_fragment_begin = "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n	geometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n	float dotNVi = saturate( dot( normal, geometryViewDir ) );\n	if ( material.iridescenceThickness == 0.0 ) {\n		material.iridescence = 0.0;\n	} else {\n		material.iridescence = saturate( material.iridescence );\n	}\n	if ( material.iridescence > 0.0 ) {\n		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n	}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometryPosition, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	vec4 spotColor;\n	vec3 spotLightCoord;\n	bool inSpotLightMap;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometryPosition, directLight );\n		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n		#else\n		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#endif\n		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n		#endif\n		#undef SPOT_LIGHT_MAP_INDEX\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	#if defined( USE_LIGHT_PROBES )\n		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n	#endif\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometryNormal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	#ifdef USE_ANISOTROPY\n		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n	#else\n		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n	#endif\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif";
var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif";
var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF )\n	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	vFragDepth = 1.0 + gl_Position.w;\n	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif";
var map_fragment = "#ifdef USE_MAP\n	vec4 sampledDiffuseColor = texture2D( map, vMapUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n	\n	#endif\n	diffuseColor *= sampledDiffuseColor;\n#endif";
var map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif";
var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	#if defined( USE_POINTS_UV )\n		vec2 uv = vUv;\n	#else\n		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n	#endif\n#endif\n#ifdef USE_MAP\n	diffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
var map_particle_pars_fragment = "#if defined( USE_POINTS_UV )\n	varying vec2 vUv;\n#else\n	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n		uniform mat3 uvTransform;\n	#endif\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n	metalnessFactor *= texelMetalness.b;\n#endif";
var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
var morphinstance_vertex = "#ifdef USE_INSTANCING_MORPH\n	float morphTargetInfluences[MORPHTARGETS_COUNT];\n	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n	}\n#endif";
var morphcolor_vertex = "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n	vColor *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		#if defined( USE_COLOR_ALPHA )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n		#elif defined( USE_COLOR )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n		#endif\n	}\n#endif";
var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n	#endif\n#endif";
var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	#ifndef USE_INSTANCING_MORPH\n		uniform float morphTargetBaseInfluence;\n	#endif\n	#ifdef MORPHTARGETS_TEXTURE\n		#ifndef USE_INSTANCING_MORPH\n			uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n		#endif\n		uniform sampler2DArray morphTargetsTexture;\n		uniform ivec2 morphTargetsTextureSize;\n		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n			int y = texelIndex / morphTargetsTextureSize.x;\n			int x = texelIndex - y * morphTargetsTextureSize.x;\n			ivec3 morphUV = ivec3( x, y, morphTargetIndex );\n			return texelFetch( morphTargetsTexture, morphUV, 0 );\n		}\n	#else\n		#ifndef USE_MORPHNORMALS\n			uniform float morphTargetInfluences[ 8 ];\n		#else\n			uniform float morphTargetInfluences[ 4 ];\n		#endif\n	#endif\n#endif";
var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n		transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n		transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n		transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n		#ifndef USE_MORPHNORMALS\n			transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n			transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n			transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n			transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n		#endif\n	#endif\n#endif";
var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal *= faceDirection;\n	#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n	#ifdef USE_TANGENT\n		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn = getTangentFrame( - vViewPosition, normal,\n		#if defined( USE_NORMALMAP )\n			vNormalMapUv\n		#elif defined( USE_CLEARCOAT_NORMALMAP )\n			vClearcoatNormalMapUv\n		#else\n			vUv\n		#endif\n		);\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn[0] *= faceDirection;\n		tbn[1] *= faceDirection;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	#ifdef USE_TANGENT\n		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn2[0] *= faceDirection;\n		tbn2[1] *= faceDirection;\n	#endif\n#endif\nvec3 nonPerturbedNormal = normal;";
var normal_fragment_maps = "#ifdef USE_NORMALMAP_OBJECTSPACE\n	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	normal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
var normal_pars_fragment = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
var normal_pars_vertex = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
var normal_vertex = "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif";
var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( uv.st );\n		vec2 st1 = dFdy( uv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n		return mat3( T * scale, B * scale, N );\n	}\n#endif";
var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = nonPerturbedNormal;\n#endif";
var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	clearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif";
var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif";
var iridescence_pars_fragment = "#ifdef USE_IRIDESCENCEMAP\n	uniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform sampler2D iridescenceThicknessMap;\n#endif";
var opaque_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";
var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n	return packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * depth - far );\n}";
var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif";
var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n	mvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
var dithering_fragment = "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
var dithering_pars_fragment = "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif";
var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n	roughnessFactor *= texelRoughness.g;\n#endif";
var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
var shadowmap_pars_fragment = "#if NUM_SPOT_LIGHT_COORDS > 0\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		float shadow = 1.0;\n		vec3 lightToPosition = shadowCoord.xyz;\n		\n		float lightToPositionLength = length( lightToPosition );\n		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;\n			vec3 bd3D = normalize( lightToPosition );\n			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n				shadow = (\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n				) * ( 1.0 / 9.0 );\n			#else\n				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n			#endif\n		}\n		return shadow;\n	}\n#endif";
var shadowmap_pars_vertex = "#if NUM_SPOT_LIGHT_COORDS > 0\n	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif";
var shadowmap_vertex = "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n	vec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n		shadowWorldPosition = worldPosition;\n		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n		#endif\n		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n#endif";
var shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}";
var skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
var skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	uniform highp sampler2D boneTexture;\n	mat4 getBoneMatrix( const in float i ) {\n		int size = textureSize( boneTexture, 0 ).x;\n		int j = int( i ) * 4;\n		int x = j % size;\n		int y = j / size;\n		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n		return mat4( v1, v2, v3, v4 );\n	}\n#endif";
var skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
var skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif";
var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
var tonemapping_fragment = "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n	vec3( 1.6605, - 0.1246, - 0.0182 ),\n	vec3( - 0.5876, 1.1329, - 0.1006 ),\n	vec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n	vec3( 0.6274, 0.0691, 0.0164 ),\n	vec3( 0.3293, 0.9195, 0.0880 ),\n	vec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n	vec3 x2 = x * x;\n	vec3 x4 = x2 * x2;\n	return + 15.5 * x4 * x2\n		- 40.14 * x4 * x\n		+ 31.96 * x4\n		- 6.868 * x2 * x\n		+ 0.4298 * x2\n		+ 0.1191 * x\n		- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n	const mat3 AgXInsetMatrix = mat3(\n		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n	);\n	const mat3 AgXOutsetMatrix = mat3(\n		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n	);\n	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;\n	color *= toneMappingExposure;\n	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n	color = AgXInsetMatrix * color;\n	color = max( color, 1e-10 );	color = log2( color );\n	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n	color = clamp( color, 0.0, 1.0 );\n	color = agxDefaultContrastApprox( color );\n	color = AgXOutsetMatrix * color;\n	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n	color = clamp( color, 0.0, 1.0 );\n	return color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n	const float StartCompression = 0.8 - 0.04;\n	const float Desaturation = 0.15;\n	color *= toneMappingExposure;\n	float x = min( color.r, min( color.g, color.b ) );\n	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n	color -= offset;\n	float peak = max( color.r, max( color.g, color.b ) );\n	if ( peak < StartCompression ) return color;\n	float d = 1. - StartCompression;\n	float newPeak = 1. - d * d / ( peak + d - StartCompression );\n	color *= newPeak / peak;\n	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n	return mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
var transmission_fragment = "#ifdef USE_TRANSMISSION\n	material.transmission = transmission;\n	material.transmissionAlpha = 1.0;\n	material.thickness = thickness;\n	material.attenuationDistance = attenuationDistance;\n	material.attenuationColor = attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmitted = getIBLVolumeRefraction(\n		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n		material.attenuationColor, material.attenuationDistance );\n	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif";
var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	float w0( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n	}\n	float w1( float a ) {\n		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n	}\n	float w2( float a ){\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n	}\n	float w3( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * a * a );\n	}\n	float g0( float a ) {\n		return w0( a ) + w1( a );\n	}\n	float g1( float a ) {\n		return w2( a ) + w3( a );\n	}\n	float h0( float a ) {\n		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n	}\n	float h1( float a ) {\n		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n	}\n	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n		uv = uv * texelSize.zw + 0.5;\n		vec2 iuv = floor( uv );\n		vec2 fuv = fract( uv );\n		float g0x = g0( fuv.x );\n		float g1x = g1( fuv.x );\n		float h0x = h0( fuv.x );\n		float h1x = h1( fuv.x );\n		float h0y = h0( fuv.y );\n		float h1y = h1( fuv.y );\n		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n	}\n	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n		vec2 fLodSizeInv = 1.0 / fLodSize;\n		vec2 cLodSizeInv = 1.0 / cLodSize;\n		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n		return mix( fSample, cSample, fract( lod ) );\n	}\n	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( const in float roughness, const in float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n	}\n	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n		if ( isinf( attenuationDistance ) ) {\n			return vec3( 1.0 );\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n		const in vec3 attenuationColor, const in float attenuationDistance ) {\n		vec4 transmittedLight;\n		vec3 transmittance;\n		#ifdef USE_DISPERSION\n			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n			for ( int i = 0; i < 3; i ++ ) {\n				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n				vec3 refractedRayExit = position + transmissionRay;\n		\n				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n				vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n				refractionCoords += 1.0;\n				refractionCoords /= 2.0;\n		\n				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n				transmittedLight[ i ] = transmissionSample[ i ];\n				transmittedLight.a += transmissionSample.a;\n				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n			}\n			transmittedLight.a /= 3.0;\n		\n		#else\n		\n			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n			vec3 refractedRayExit = position + transmissionRay;\n			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n			vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n			refractionCoords += 1.0;\n			refractionCoords /= 2.0;\n			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n		\n		#endif\n		vec3 attenuatedColor = transmittance * transmittedLight.rgb;\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n	}\n#endif";
var uv_pars_fragment = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	varying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif";
var uv_pars_vertex = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	uniform mat3 mapTransform;\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform mat3 alphaMapTransform;\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	uniform mat3 lightMapTransform;\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	uniform mat3 aoMapTransform;\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	uniform mat3 bumpMapTransform;\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	uniform mat3 normalMapTransform;\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	uniform mat3 displacementMapTransform;\n	varying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	uniform mat3 emissiveMapTransform;\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	uniform mat3 metalnessMapTransform;\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	uniform mat3 roughnessMapTransform;\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	uniform mat3 anisotropyMapTransform;\n	varying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	uniform mat3 clearcoatMapTransform;\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform mat3 clearcoatNormalMapTransform;\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform mat3 clearcoatRoughnessMapTransform;\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	uniform mat3 sheenColorMapTransform;\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	uniform mat3 sheenRoughnessMapTransform;\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	uniform mat3 iridescenceMapTransform;\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform mat3 iridescenceThicknessMapTransform;\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	uniform mat3 specularMapTransform;\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	uniform mat3 specularColorMapTransform;\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	uniform mat3 specularIntensityMapTransform;\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif";
var uv_vertex = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	vUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif";
var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_BATCHING\n		worldPosition = batchingMatrix * worldPosition;\n	#endif\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif";
var vertex$h = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
var fragment$h = "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
var vertex$g = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
var fragment$g = "#ifdef ENVMAP_TYPE_CUBE\n	uniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n	uniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n	#else\n		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
var vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
var fragment$f = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n	gl_FragColor = texColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
var vertex$e = "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <skinbase_vertex>\n	#include <morphinstance_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}";
var fragment$e = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <clipping_planes_fragment>\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}";
var vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <skinbase_vertex>\n	#include <morphinstance_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}";
var fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <clipping_planes_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}";
var vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}";
var fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
var vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
var fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
var vertex$a = "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}";
var fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var vertex$9 = "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var fragment$9 = "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_lambert_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}";
var fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n	#else\n		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}";
var fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n	#ifdef OPAQUE\n		gl_FragColor.a = 1.0;\n	#endif\n}";
var vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}";
var fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef USE_SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULAR_COLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n	#ifdef USE_SPECULAR_INTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n	uniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n	uniform float iridescence;\n	uniform float iridescenceIOR;\n	uniform float iridescenceThicknessMinimum;\n	uniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEEN_COLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	uniform vec2 anisotropyVector;\n	#ifdef USE_ANISOTROPYMAP\n		uniform sampler2D anisotropyMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_SHEEN\n		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n	#endif\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n	#endif\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n	varying vec2 vUv;\n	uniform mat3 uvTransform;\n#endif\nvoid main() {\n	#ifdef USE_POINTS_UV\n		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	#endif\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}";
var fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
var vertex$2 = "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	#include <logdepthbuf_fragment>\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n}";
var vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
var fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n}";
var ShaderChunk = {
  alphahash_fragment,
  alphahash_pars_fragment,
  alphamap_fragment,
  alphamap_pars_fragment,
  alphatest_fragment,
  alphatest_pars_fragment,
  aomap_fragment,
  aomap_pars_fragment,
  batching_pars_vertex,
  batching_vertex,
  begin_vertex,
  beginnormal_vertex,
  bsdfs,
  iridescence_fragment,
  bumpmap_pars_fragment,
  clipping_planes_fragment,
  clipping_planes_pars_fragment,
  clipping_planes_pars_vertex,
  clipping_planes_vertex,
  color_fragment,
  color_pars_fragment,
  color_pars_vertex,
  color_vertex,
  common,
  cube_uv_reflection_fragment,
  defaultnormal_vertex,
  displacementmap_pars_vertex,
  displacementmap_vertex,
  emissivemap_fragment,
  emissivemap_pars_fragment,
  colorspace_fragment,
  colorspace_pars_fragment,
  envmap_fragment,
  envmap_common_pars_fragment,
  envmap_pars_fragment,
  envmap_pars_vertex,
  envmap_physical_pars_fragment,
  envmap_vertex,
  fog_vertex,
  fog_pars_vertex,
  fog_fragment,
  fog_pars_fragment,
  gradientmap_pars_fragment,
  lightmap_pars_fragment,
  lights_lambert_fragment,
  lights_lambert_pars_fragment,
  lights_pars_begin,
  lights_toon_fragment,
  lights_toon_pars_fragment,
  lights_phong_fragment,
  lights_phong_pars_fragment,
  lights_physical_fragment,
  lights_physical_pars_fragment,
  lights_fragment_begin,
  lights_fragment_maps,
  lights_fragment_end,
  logdepthbuf_fragment,
  logdepthbuf_pars_fragment,
  logdepthbuf_pars_vertex,
  logdepthbuf_vertex,
  map_fragment,
  map_pars_fragment,
  map_particle_fragment,
  map_particle_pars_fragment,
  metalnessmap_fragment,
  metalnessmap_pars_fragment,
  morphinstance_vertex,
  morphcolor_vertex,
  morphnormal_vertex,
  morphtarget_pars_vertex,
  morphtarget_vertex,
  normal_fragment_begin,
  normal_fragment_maps,
  normal_pars_fragment,
  normal_pars_vertex,
  normal_vertex,
  normalmap_pars_fragment,
  clearcoat_normal_fragment_begin,
  clearcoat_normal_fragment_maps,
  clearcoat_pars_fragment,
  iridescence_pars_fragment,
  opaque_fragment,
  packing,
  premultiplied_alpha_fragment,
  project_vertex,
  dithering_fragment,
  dithering_pars_fragment,
  roughnessmap_fragment,
  roughnessmap_pars_fragment,
  shadowmap_pars_fragment,
  shadowmap_pars_vertex,
  shadowmap_vertex,
  shadowmask_pars_fragment,
  skinbase_vertex,
  skinning_pars_vertex,
  skinning_vertex,
  skinnormal_vertex,
  specularmap_fragment,
  specularmap_pars_fragment,
  tonemapping_fragment,
  tonemapping_pars_fragment,
  transmission_fragment,
  transmission_pars_fragment,
  uv_pars_fragment,
  uv_pars_vertex,
  uv_vertex,
  worldpos_vertex,
  background_vert: vertex$h,
  background_frag: fragment$h,
  backgroundCube_vert: vertex$g,
  backgroundCube_frag: fragment$g,
  cube_vert: vertex$f,
  cube_frag: fragment$f,
  depth_vert: vertex$e,
  depth_frag: fragment$e,
  distanceRGBA_vert: vertex$d,
  distanceRGBA_frag: fragment$d,
  equirect_vert: vertex$c,
  equirect_frag: fragment$c,
  linedashed_vert: vertex$b,
  linedashed_frag: fragment$b,
  meshbasic_vert: vertex$a,
  meshbasic_frag: fragment$a,
  meshlambert_vert: vertex$9,
  meshlambert_frag: fragment$9,
  meshmatcap_vert: vertex$8,
  meshmatcap_frag: fragment$8,
  meshnormal_vert: vertex$7,
  meshnormal_frag: fragment$7,
  meshphong_vert: vertex$6,
  meshphong_frag: fragment$6,
  meshphysical_vert: vertex$5,
  meshphysical_frag: fragment$5,
  meshtoon_vert: vertex$4,
  meshtoon_frag: fragment$4,
  points_vert: vertex$3,
  points_frag: fragment$3,
  shadow_vert: vertex$2,
  shadow_frag: fragment$2,
  sprite_vert: vertex$1,
  sprite_frag: fragment$1
};
var UniformsLib = {
  common: {
    diffuse: { value: new Color2(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    mapTransform: { value: new Matrix32() },
    alphaMap: { value: null },
    alphaMapTransform: { value: new Matrix32() },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null },
    specularMapTransform: { value: new Matrix32() }
  },
  envmap: {
    envMap: { value: null },
    envMapRotation: { value: new Matrix32() },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    // basic, lambert, phong
    ior: { value: 1.5 },
    // physical
    refractionRatio: { value: 0.98 }
    // basic, lambert, phong
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 },
    aoMapTransform: { value: new Matrix32() }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 },
    lightMapTransform: { value: new Matrix32() }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpMapTransform: { value: new Matrix32() },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalMapTransform: { value: new Matrix32() },
    normalScale: { value: new Vector22(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementMapTransform: { value: new Matrix32() },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  emissivemap: {
    emissiveMap: { value: null },
    emissiveMapTransform: { value: new Matrix32() }
  },
  metalnessmap: {
    metalnessMap: { value: null },
    metalnessMapTransform: { value: new Matrix32() }
  },
  roughnessmap: {
    roughnessMap: { value: null },
    roughnessMapTransform: { value: new Matrix32() }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: new Color2(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotLightMap: { value: [] },
    spotShadowMap: { value: [] },
    spotLightMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: new Color2(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaMapTransform: { value: new Matrix32() },
    alphaTest: { value: 0 },
    uvTransform: { value: new Matrix32() }
  },
  sprite: {
    diffuse: { value: new Color2(16777215) },
    opacity: { value: 1 },
    center: { value: new Vector22(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    mapTransform: { value: new Matrix32() },
    alphaMap: { value: null },
    alphaMapTransform: { value: new Matrix32() },
    alphaTest: { value: 0 }
  }
};
var ShaderLib = {
  basic: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.meshbasic_vert,
    fragmentShader: ShaderChunk.meshbasic_frag
  },
  lambert: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color2(0) }
      }
    ]),
    vertexShader: ShaderChunk.meshlambert_vert,
    fragmentShader: ShaderChunk.meshlambert_frag
  },
  phong: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color2(0) },
        specular: { value: new Color2(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: ShaderChunk.meshphong_vert,
    fragmentShader: ShaderChunk.meshphong_frag
  },
  standard: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.roughnessmap,
      UniformsLib.metalnessmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color2(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
  },
  toon: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.gradientmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color2(0) }
      }
    ]),
    vertexShader: ShaderChunk.meshtoon_vert,
    fragmentShader: ShaderChunk.meshtoon_frag
  },
  matcap: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: ShaderChunk.meshmatcap_vert,
    fragmentShader: ShaderChunk.meshmatcap_frag
  },
  points: {
    uniforms: mergeUniforms([
      UniformsLib.points,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.points_vert,
    fragmentShader: ShaderChunk.points_frag
  },
  dashed: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: ShaderChunk.linedashed_vert,
    fragmentShader: ShaderChunk.linedashed_frag
  },
  depth: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap
    ]),
    vertexShader: ShaderChunk.depth_vert,
    fragmentShader: ShaderChunk.depth_frag
  },
  normal: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.meshnormal_vert,
    fragmentShader: ShaderChunk.meshnormal_frag
  },
  sprite: {
    uniforms: mergeUniforms([
      UniformsLib.sprite,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.sprite_vert,
    fragmentShader: ShaderChunk.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: new Matrix32() },
      t2D: { value: null },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: ShaderChunk.background_vert,
    fragmentShader: ShaderChunk.background_frag
  },
  backgroundCube: {
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      backgroundBlurriness: { value: 0 },
      backgroundIntensity: { value: 1 },
      backgroundRotation: { value: new Matrix32() }
    },
    vertexShader: ShaderChunk.backgroundCube_vert,
    fragmentShader: ShaderChunk.backgroundCube_frag
  },
  cube: {
    uniforms: {
      tCube: { value: null },
      tFlip: { value: -1 },
      opacity: { value: 1 }
    },
    vertexShader: ShaderChunk.cube_vert,
    fragmentShader: ShaderChunk.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: ShaderChunk.equirect_vert,
    fragmentShader: ShaderChunk.equirect_frag
  },
  distanceRGBA: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap,
      {
        referencePosition: { value: new Vector32() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: ShaderChunk.distanceRGBA_vert,
    fragmentShader: ShaderChunk.distanceRGBA_frag
  },
  shadow: {
    uniforms: mergeUniforms([
      UniformsLib.lights,
      UniformsLib.fog,
      {
        color: { value: new Color2(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.shadow_vert,
    fragmentShader: ShaderChunk.shadow_frag
  }
};
ShaderLib.physical = {
  uniforms: mergeUniforms([
    ShaderLib.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: new Matrix32() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: new Matrix32() },
      clearcoatNormalScale: { value: new Vector22(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: new Matrix32() },
      dispersion: { value: 0 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: new Matrix32() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: new Matrix32() },
      sheen: { value: 0 },
      sheenColor: { value: new Color2(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: new Matrix32() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: new Matrix32() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: new Matrix32() },
      transmissionSamplerSize: { value: new Vector22() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: new Matrix32() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new Color2(0) },
      specularColor: { value: new Color2(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: new Matrix32() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: new Matrix32() },
      anisotropyVector: { value: new Vector22() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: new Matrix32() }
    }
  ]),
  vertexShader: ShaderChunk.meshphysical_vert,
  fragmentShader: ShaderChunk.meshphysical_frag
};
var _e1$1 = new Euler2();
var _m1$1 = new Matrix42();
var OrthographicCamera2 = class extends Camera2 {
  constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2e3) {
    super();
    this.isOrthographicCamera = true;
    this.type = "OrthographicCamera";
    this.zoom = 1;
    this.view = null;
    this.left = left;
    this.right = right;
    this.top = top;
    this.bottom = bottom;
    this.near = near;
    this.far = far;
    this.updateProjectionMatrix();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.left = source.left;
    this.right = source.right;
    this.top = source.top;
    this.bottom = source.bottom;
    this.near = source.near;
    this.far = source.far;
    this.zoom = source.zoom;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    return this;
  }
  setViewOffset(fullWidth, fullHeight, x3, y3, width, height) {
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x3;
    this.view.offsetY = y3;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  }
  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const dx = (this.right - this.left) / (2 * this.zoom);
    const dy = (this.top - this.bottom) / (2 * this.zoom);
    const cx = (this.right + this.left) / 2;
    const cy = (this.top + this.bottom) / 2;
    let left = cx - dx;
    let right = cx + dx;
    let top = cy + dy;
    let bottom = cy - dy;
    if (this.view !== null && this.view.enabled) {
      const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
      const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      left += scaleW * this.view.offsetX;
      right = left + scaleW * this.view.width;
      top -= scaleH * this.view.offsetY;
      bottom = top - scaleH * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far, this.coordinateSystem);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.zoom = this.zoom;
    data.object.left = this.left;
    data.object.right = this.right;
    data.object.top = this.top;
    data.object.bottom = this.bottom;
    data.object.near = this.near;
    data.object.far = this.far;
    if (this.view !== null) data.object.view = Object.assign({}, this.view);
    return data;
  }
};
var _flatCamera = new OrthographicCamera2();
var _clearColor = new Color2();
var PHI = (1 + Math.sqrt(5)) / 2;
var INV_PHI = 1 / PHI;
var _axisDirections = [
  new Vector32(-PHI, INV_PHI, 0),
  new Vector32(PHI, INV_PHI, 0),
  new Vector32(-INV_PHI, 0, PHI),
  new Vector32(INV_PHI, 0, PHI),
  new Vector32(0, PHI, -INV_PHI),
  new Vector32(0, PHI, INV_PHI),
  new Vector32(-1, 1, -1),
  new Vector32(1, 1, -1),
  new Vector32(-1, 1, 1),
  new Vector32(1, 1, 1)
];
var DepthTexture2 = class extends Texture2 {
  constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy2, format3) {
    format3 = format3 !== void 0 ? format3 : DepthFormat2;
    if (format3 !== DepthFormat2 && format3 !== DepthStencilFormat2) {
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    }
    if (type === void 0 && format3 === DepthFormat2) type = UnsignedIntType2;
    if (type === void 0 && format3 === DepthStencilFormat2) type = UnsignedInt248Type2;
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format3, type, anisotropy2);
    this.isDepthTexture = true;
    this.image = { width, height };
    this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter2;
    this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter2;
    this.flipY = false;
    this.generateMipmaps = false;
    this.compareFunction = null;
  }
  copy(source) {
    super.copy(source);
    this.compareFunction = source.compareFunction;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    if (this.compareFunction !== null) data.compareFunction = this.compareFunction;
    return data;
  }
};
var emptyTexture = new Texture2();
var emptyShadowTexture = new DepthTexture2(1, 1);
emptyShadowTexture.compareFunction = LessEqualCompare2;
var emptyArrayTexture = new DataArrayTexture2();
var empty3dTexture = new Data3DTexture();
var emptyCubeTexture = new CubeTexture2();
var mat4array = new Float32Array(16);
var mat3array = new Float32Array(9);
var mat2array = new Float32Array(4);
var Group2 = class extends Object3D2 {
  constructor() {
    super();
    this.isGroup = true;
    this.type = "Group";
  }
};
var _e1 = new Euler2();
var _m1 = new Matrix42();
var Scene2 = class extends Object3D2 {
  constructor() {
    super();
    this.isScene = true;
    this.type = "Scene";
    this.background = null;
    this.environment = null;
    this.fog = null;
    this.backgroundBlurriness = 0;
    this.backgroundIntensity = 1;
    this.backgroundRotation = new Euler2();
    this.environmentIntensity = 1;
    this.environmentRotation = new Euler2();
    this.overrideMaterial = null;
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
    }
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    if (source.background !== null) this.background = source.background.clone();
    if (source.environment !== null) this.environment = source.environment.clone();
    if (source.fog !== null) this.fog = source.fog.clone();
    this.backgroundBlurriness = source.backgroundBlurriness;
    this.backgroundIntensity = source.backgroundIntensity;
    this.backgroundRotation.copy(source.backgroundRotation);
    this.environmentIntensity = source.environmentIntensity;
    this.environmentRotation.copy(source.environmentRotation);
    if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    if (this.fog !== null) data.object.fog = this.fog.toJSON();
    if (this.backgroundBlurriness > 0) data.object.backgroundBlurriness = this.backgroundBlurriness;
    if (this.backgroundIntensity !== 1) data.object.backgroundIntensity = this.backgroundIntensity;
    data.object.backgroundRotation = this.backgroundRotation.toArray();
    if (this.environmentIntensity !== 1) data.object.environmentIntensity = this.environmentIntensity;
    data.object.environmentRotation = this.environmentRotation.toArray();
    return data;
  }
};
var _vector$6 = new Vector32();
var _intersectPoint = new Vector32();
var _worldScale = new Vector32();
var _mvPosition = new Vector32();
var _alignedPosition = new Vector22();
var _rotatedPosition = new Vector22();
var _viewWorldMatrix = new Matrix42();
var _vA = new Vector32();
var _vB = new Vector32();
var _vC = new Vector32();
var _uvA = new Vector22();
var _uvB = new Vector22();
var _uvC = new Vector22();
var _v1$2 = new Vector32();
var _v2$1 = new Vector32();
var _basePosition = new Vector32();
var _skinIndex = new Vector42();
var _skinWeight = new Vector42();
var _vector3 = new Vector32();
var _matrix4 = new Matrix42();
var _vertex = new Vector32();
var _sphere$4 = new Sphere2();
var _inverseMatrix$2 = new Matrix42();
var _ray$2 = new Ray2();
var SkinnedMesh = class extends Mesh2 {
  constructor(geometry, material) {
    super(geometry, material);
    this.isSkinnedMesh = true;
    this.type = "SkinnedMesh";
    this.bindMode = AttachedBindMode;
    this.bindMatrix = new Matrix42();
    this.bindMatrixInverse = new Matrix42();
    this.boundingBox = null;
    this.boundingSphere = null;
  }
  computeBoundingBox() {
    const geometry = this.geometry;
    if (this.boundingBox === null) {
      this.boundingBox = new Box32();
    }
    this.boundingBox.makeEmpty();
    const positionAttribute = geometry.getAttribute("position");
    for (let i2 = 0; i2 < positionAttribute.count; i2++) {
      this.getVertexPosition(i2, _vertex);
      this.boundingBox.expandByPoint(_vertex);
    }
  }
  computeBoundingSphere() {
    const geometry = this.geometry;
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere2();
    }
    this.boundingSphere.makeEmpty();
    const positionAttribute = geometry.getAttribute("position");
    for (let i2 = 0; i2 < positionAttribute.count; i2++) {
      this.getVertexPosition(i2, _vertex);
      this.boundingSphere.expandByPoint(_vertex);
    }
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.bindMode = source.bindMode;
    this.bindMatrix.copy(source.bindMatrix);
    this.bindMatrixInverse.copy(source.bindMatrixInverse);
    this.skeleton = source.skeleton;
    if (source.boundingBox !== null) this.boundingBox = source.boundingBox.clone();
    if (source.boundingSphere !== null) this.boundingSphere = source.boundingSphere.clone();
    return this;
  }
  raycast(raycaster, intersects2) {
    const material = this.material;
    const matrixWorld = this.matrixWorld;
    if (material === void 0) return;
    if (this.boundingSphere === null) this.computeBoundingSphere();
    _sphere$4.copy(this.boundingSphere);
    _sphere$4.applyMatrix4(matrixWorld);
    if (raycaster.ray.intersectsSphere(_sphere$4) === false) return;
    _inverseMatrix$2.copy(matrixWorld).invert();
    _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);
    if (this.boundingBox !== null) {
      if (_ray$2.intersectsBox(this.boundingBox) === false) return;
    }
    this._computeIntersections(raycaster, intersects2, _ray$2);
  }
  getVertexPosition(index8, target) {
    super.getVertexPosition(index8, target);
    this.applyBoneTransform(index8, target);
    return target;
  }
  bind(skeleton, bindMatrix) {
    this.skeleton = skeleton;
    if (bindMatrix === void 0) {
      this.updateMatrixWorld(true);
      this.skeleton.calculateInverses();
      bindMatrix = this.matrixWorld;
    }
    this.bindMatrix.copy(bindMatrix);
    this.bindMatrixInverse.copy(bindMatrix).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const vector = new Vector42();
    const skinWeight = this.geometry.attributes.skinWeight;
    for (let i2 = 0, l2 = skinWeight.count; i2 < l2; i2++) {
      vector.fromBufferAttribute(skinWeight, i2);
      const scale2 = 1 / vector.manhattanLength();
      if (scale2 !== Infinity) {
        vector.multiplyScalar(scale2);
      } else {
        vector.set(1, 0, 0, 0);
      }
      skinWeight.setXYZW(i2, vector.x, vector.y, vector.z, vector.w);
    }
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    if (this.bindMode === AttachedBindMode) {
      this.bindMatrixInverse.copy(this.matrixWorld).invert();
    } else if (this.bindMode === DetachedBindMode) {
      this.bindMatrixInverse.copy(this.bindMatrix).invert();
    } else {
      console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
    }
  }
  applyBoneTransform(index8, vector) {
    const skeleton = this.skeleton;
    const geometry = this.geometry;
    _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index8);
    _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index8);
    _basePosition.copy(vector).applyMatrix4(this.bindMatrix);
    vector.set(0, 0, 0);
    for (let i2 = 0; i2 < 4; i2++) {
      const weight = _skinWeight.getComponent(i2);
      if (weight !== 0) {
        const boneIndex = _skinIndex.getComponent(i2);
        _matrix4.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
        vector.addScaledVector(_vector3.copy(_basePosition).applyMatrix4(_matrix4), weight);
      }
    }
    return vector.applyMatrix4(this.bindMatrixInverse);
  }
};
var Bone = class extends Object3D2 {
  constructor() {
    super();
    this.isBone = true;
    this.type = "Bone";
  }
};
var DataTexture2 = class extends Texture2 {
  constructor(data = null, width = 1, height = 1, format3, type, mapping, wrapS, wrapT, magFilter = NearestFilter2, minFilter = NearestFilter2, anisotropy2, colorSpace) {
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format3, type, anisotropy2, colorSpace);
    this.isDataTexture = true;
    this.image = { data, width, height };
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
  }
};
var _offsetMatrix = new Matrix42();
var _identityMatrix$1 = new Matrix42();
var Skeleton = class _Skeleton {
  constructor(bones = [], boneInverses = []) {
    this.uuid = generateUUID();
    this.bones = bones.slice(0);
    this.boneInverses = boneInverses;
    this.boneMatrices = null;
    this.boneTexture = null;
    this.init();
  }
  init() {
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    this.boneMatrices = new Float32Array(bones.length * 16);
    if (boneInverses.length === 0) {
      this.calculateInverses();
    } else {
      if (bones.length !== boneInverses.length) {
        console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.");
        this.boneInverses = [];
        for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
          this.boneInverses.push(new Matrix42());
        }
      }
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
      const inverse2 = new Matrix42();
      if (this.bones[i2]) {
        inverse2.copy(this.bones[i2].matrixWorld).invert();
      }
      this.boneInverses.push(inverse2);
    }
  }
  pose() {
    for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
      const bone = this.bones[i2];
      if (bone) {
        bone.matrixWorld.copy(this.boneInverses[i2]).invert();
      }
    }
    for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
      const bone = this.bones[i2];
      if (bone) {
        if (bone.parent && bone.parent.isBone) {
          bone.matrix.copy(bone.parent.matrixWorld).invert();
          bone.matrix.multiply(bone.matrixWorld);
        } else {
          bone.matrix.copy(bone.matrixWorld);
        }
        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
      }
    }
  }
  update() {
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    const boneMatrices = this.boneMatrices;
    const boneTexture = this.boneTexture;
    for (let i2 = 0, il = bones.length; i2 < il; i2++) {
      const matrix = bones[i2] ? bones[i2].matrixWorld : _identityMatrix$1;
      _offsetMatrix.multiplyMatrices(matrix, boneInverses[i2]);
      _offsetMatrix.toArray(boneMatrices, i2 * 16);
    }
    if (boneTexture !== null) {
      boneTexture.needsUpdate = true;
    }
  }
  clone() {
    return new _Skeleton(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let size2 = Math.sqrt(this.bones.length * 4);
    size2 = Math.ceil(size2 / 4) * 4;
    size2 = Math.max(size2, 4);
    const boneMatrices = new Float32Array(size2 * size2 * 4);
    boneMatrices.set(this.boneMatrices);
    const boneTexture = new DataTexture2(boneMatrices, size2, size2, RGBAFormat2, FloatType2);
    boneTexture.needsUpdate = true;
    this.boneMatrices = boneMatrices;
    this.boneTexture = boneTexture;
    return this;
  }
  getBoneByName(name) {
    for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
      const bone = this.bones[i2];
      if (bone.name === name) {
        return bone;
      }
    }
    return void 0;
  }
  dispose() {
    if (this.boneTexture !== null) {
      this.boneTexture.dispose();
      this.boneTexture = null;
    }
  }
  fromJSON(json, bones) {
    this.uuid = json.uuid;
    for (let i2 = 0, l2 = json.bones.length; i2 < l2; i2++) {
      const uuid = json.bones[i2];
      let bone = bones[uuid];
      if (bone === void 0) {
        console.warn("THREE.Skeleton: No bone found with UUID:", uuid);
        bone = new Bone();
      }
      this.bones.push(bone);
      this.boneInverses.push(new Matrix42().fromArray(json.boneInverses[i2]));
    }
    this.init();
    return this;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.6,
        type: "Skeleton",
        generator: "Skeleton.toJSON"
      },
      bones: [],
      boneInverses: []
    };
    data.uuid = this.uuid;
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    for (let i2 = 0, l2 = bones.length; i2 < l2; i2++) {
      const bone = bones[i2];
      data.bones.push(bone.uuid);
      const boneInverse = boneInverses[i2];
      data.boneInverses.push(boneInverse.toArray());
    }
    return data;
  }
};
var _instanceLocalMatrix = new Matrix42();
var _instanceWorldMatrix = new Matrix42();
var _box3 = new Box32();
var _identity = new Matrix42();
var _mesh$1 = new Mesh2();
var _sphere$3 = new Sphere2();
var MultiDrawRenderList = class {
  constructor() {
    this.index = 0;
    this.pool = [];
    this.list = [];
  }
  push(drawRange, z3) {
    const pool = this.pool;
    const list = this.list;
    if (this.index >= pool.length) {
      pool.push({
        start: -1,
        count: -1,
        z: -1
      });
    }
    const item = pool[this.index];
    list.push(item);
    this.index++;
    item.start = drawRange.start;
    item.count = drawRange.count;
    item.z = z3;
  }
  reset() {
    this.list.length = 0;
    this.index = 0;
  }
};
var _matrix$1 = new Matrix42();
var _invMatrixWorld = new Matrix42();
var _identityMatrix = new Matrix42();
var _projScreenMatrix$2 = new Matrix42();
var _frustum = new Frustum2();
var _box$1 = new Box32();
var _sphere$2 = new Sphere2();
var _vector$5 = new Vector32();
var _renderList = new MultiDrawRenderList();
var _mesh = new Mesh2();
var LineBasicMaterial2 = class extends Material2 {
  constructor(parameters) {
    super();
    this.isLineBasicMaterial = true;
    this.type = "LineBasicMaterial";
    this.color = new Color2(16777215);
    this.map = null;
    this.linewidth = 1;
    this.linecap = "round";
    this.linejoin = "round";
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.linewidth = source.linewidth;
    this.linecap = source.linecap;
    this.linejoin = source.linejoin;
    this.fog = source.fog;
    return this;
  }
};
var _vStart = new Vector32();
var _vEnd = new Vector32();
var _inverseMatrix$1 = new Matrix42();
var _ray$1 = new Ray2();
var _sphere$1 = new Sphere2();
var _intersectPointOnRay = new Vector32();
var _intersectPointOnSegment = new Vector32();
var Line2 = class extends Object3D2 {
  constructor(geometry = new BufferGeometry2(), material = new LineBasicMaterial2()) {
    super();
    this.isLine = true;
    this.type = "Line";
    this.geometry = geometry;
    this.material = material;
    this.updateMorphTargets();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
    this.geometry = source.geometry;
    return this;
  }
  computeLineDistances() {
    const geometry = this.geometry;
    if (geometry.index === null) {
      const positionAttribute = geometry.attributes.position;
      const lineDistances = [0];
      for (let i2 = 1, l2 = positionAttribute.count; i2 < l2; i2++) {
        _vStart.fromBufferAttribute(positionAttribute, i2 - 1);
        _vEnd.fromBufferAttribute(positionAttribute, i2);
        lineDistances[i2] = lineDistances[i2 - 1];
        lineDistances[i2] += _vStart.distanceTo(_vEnd);
      }
      geometry.setAttribute("lineDistance", new Float32BufferAttribute2(lineDistances, 1));
    } else {
      console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    }
    return this;
  }
  raycast(raycaster, intersects2) {
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold2 = raycaster.params.Line.threshold;
    const drawRange = geometry.drawRange;
    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
    _sphere$1.copy(geometry.boundingSphere);
    _sphere$1.applyMatrix4(matrixWorld);
    _sphere$1.radius += threshold2;
    if (raycaster.ray.intersectsSphere(_sphere$1) === false) return;
    _inverseMatrix$1.copy(matrixWorld).invert();
    _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
    const localThreshold = threshold2 / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;
    const step2 = this.isLineSegments ? 2 : 1;
    const index8 = geometry.index;
    const attributes = geometry.attributes;
    const positionAttribute = attributes.position;
    if (index8 !== null) {
      const start2 = Math.max(0, drawRange.start);
      const end = Math.min(index8.count, drawRange.start + drawRange.count);
      for (let i2 = start2, l2 = end - 1; i2 < l2; i2 += step2) {
        const a3 = index8.getX(i2);
        const b = index8.getX(i2 + 1);
        const intersect = checkIntersection(this, raycaster, _ray$1, localThresholdSq, a3, b);
        if (intersect) {
          intersects2.push(intersect);
        }
      }
      if (this.isLineLoop) {
        const a3 = index8.getX(end - 1);
        const b = index8.getX(start2);
        const intersect = checkIntersection(this, raycaster, _ray$1, localThresholdSq, a3, b);
        if (intersect) {
          intersects2.push(intersect);
        }
      }
    } else {
      const start2 = Math.max(0, drawRange.start);
      const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
      for (let i2 = start2, l2 = end - 1; i2 < l2; i2 += step2) {
        const intersect = checkIntersection(this, raycaster, _ray$1, localThresholdSq, i2, i2 + 1);
        if (intersect) {
          intersects2.push(intersect);
        }
      }
      if (this.isLineLoop) {
        const intersect = checkIntersection(this, raycaster, _ray$1, localThresholdSq, end - 1, start2);
        if (intersect) {
          intersects2.push(intersect);
        }
      }
    }
  }
  updateMorphTargets() {
    const geometry = this.geometry;
    const morphAttributes = geometry.morphAttributes;
    const keys2 = Object.keys(morphAttributes);
    if (keys2.length > 0) {
      const morphAttribute = morphAttributes[keys2[0]];
      if (morphAttribute !== void 0) {
        this.morphTargetInfluences = [];
        this.morphTargetDictionary = {};
        for (let m3 = 0, ml = morphAttribute.length; m3 < ml; m3++) {
          const name = morphAttribute[m3].name || String(m3);
          this.morphTargetInfluences.push(0);
          this.morphTargetDictionary[name] = m3;
        }
      }
    }
  }
};
function checkIntersection(object, raycaster, ray, thresholdSq, a3, b) {
  const positionAttribute = object.geometry.attributes.position;
  _vStart.fromBufferAttribute(positionAttribute, a3);
  _vEnd.fromBufferAttribute(positionAttribute, b);
  const distSq = ray.distanceSqToSegment(_vStart, _vEnd, _intersectPointOnRay, _intersectPointOnSegment);
  if (distSq > thresholdSq) return;
  _intersectPointOnRay.applyMatrix4(object.matrixWorld);
  const distance4 = raycaster.ray.origin.distanceTo(_intersectPointOnRay);
  if (distance4 < raycaster.near || distance4 > raycaster.far) return;
  return {
    distance: distance4,
    // What do we want? intersection point on the ray or on the segment??
    // point: raycaster.ray.at( distance ),
    point: _intersectPointOnSegment.clone().applyMatrix4(object.matrixWorld),
    index: a3,
    face: null,
    faceIndex: null,
    object
  };
}
var _start = new Vector32();
var _end = new Vector32();
var LineSegments = class extends Line2 {
  constructor(geometry, material) {
    super(geometry, material);
    this.isLineSegments = true;
    this.type = "LineSegments";
  }
  computeLineDistances() {
    const geometry = this.geometry;
    if (geometry.index === null) {
      const positionAttribute = geometry.attributes.position;
      const lineDistances = [];
      for (let i2 = 0, l2 = positionAttribute.count; i2 < l2; i2 += 2) {
        _start.fromBufferAttribute(positionAttribute, i2);
        _end.fromBufferAttribute(positionAttribute, i2 + 1);
        lineDistances[i2] = i2 === 0 ? 0 : lineDistances[i2 - 1];
        lineDistances[i2 + 1] = lineDistances[i2] + _start.distanceTo(_end);
      }
      geometry.setAttribute("lineDistance", new Float32BufferAttribute2(lineDistances, 1));
    } else {
      console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    }
    return this;
  }
};
var _inverseMatrix = new Matrix42();
var _ray = new Ray2();
var _sphere = new Sphere2();
var _position$2 = new Vector32();
var Curve = class {
  constructor() {
    this.type = "Curve";
    this.arcLengthDivisions = 200;
  }
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint() {
    console.warn("THREE.Curve: .getPoint() not implemented.");
    return null;
  }
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt(u2, optionalTarget) {
    const t5 = this.getUtoTmapping(u2);
    return this.getPoint(t5, optionalTarget);
  }
  // Get sequence of points using getPoint( t )
  getPoints(divisions = 5) {
    const points = [];
    for (let d3 = 0; d3 <= divisions; d3++) {
      points.push(this.getPoint(d3 / divisions));
    }
    return points;
  }
  // Get sequence of points using getPointAt( u )
  getSpacedPoints(divisions = 5) {
    const points = [];
    for (let d3 = 0; d3 <= divisions; d3++) {
      points.push(this.getPointAt(d3 / divisions));
    }
    return points;
  }
  // Get total curve arc length
  getLength() {
    const lengths = this.getLengths();
    return lengths[lengths.length - 1];
  }
  // Get list of cumulative segment lengths
  getLengths(divisions = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
      return this.cacheArcLengths;
    }
    this.needsUpdate = false;
    const cache2 = [];
    let current, last2 = this.getPoint(0);
    let sum3 = 0;
    cache2.push(0);
    for (let p3 = 1; p3 <= divisions; p3++) {
      current = this.getPoint(p3 / divisions);
      sum3 += current.distanceTo(last2);
      cache2.push(sum3);
      last2 = current;
    }
    this.cacheArcLengths = cache2;
    return cache2;
  }
  updateArcLengths() {
    this.needsUpdate = true;
    this.getLengths();
  }
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping(u2, distance4) {
    const arcLengths = this.getLengths();
    let i2 = 0;
    const il = arcLengths.length;
    let targetArcLength;
    if (distance4) {
      targetArcLength = distance4;
    } else {
      targetArcLength = u2 * arcLengths[il - 1];
    }
    let low = 0, high = il - 1, comparison;
    while (low <= high) {
      i2 = Math.floor(low + (high - low) / 2);
      comparison = arcLengths[i2] - targetArcLength;
      if (comparison < 0) {
        low = i2 + 1;
      } else if (comparison > 0) {
        high = i2 - 1;
      } else {
        high = i2;
        break;
      }
    }
    i2 = high;
    if (arcLengths[i2] === targetArcLength) {
      return i2 / (il - 1);
    }
    const lengthBefore = arcLengths[i2];
    const lengthAfter = arcLengths[i2 + 1];
    const segmentLength = lengthAfter - lengthBefore;
    const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
    const t5 = (i2 + segmentFraction) / (il - 1);
    return t5;
  }
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent(t5, optionalTarget) {
    const delta = 1e-4;
    let t13 = t5 - delta;
    let t22 = t5 + delta;
    if (t13 < 0) t13 = 0;
    if (t22 > 1) t22 = 1;
    const pt1 = this.getPoint(t13);
    const pt2 = this.getPoint(t22);
    const tangent = optionalTarget || (pt1.isVector2 ? new Vector22() : new Vector32());
    tangent.copy(pt2).sub(pt1).normalize();
    return tangent;
  }
  getTangentAt(u2, optionalTarget) {
    const t5 = this.getUtoTmapping(u2);
    return this.getTangent(t5, optionalTarget);
  }
  computeFrenetFrames(segments, closed) {
    const normal2 = new Vector32();
    const tangents = [];
    const normals = [];
    const binormals = [];
    const vec = new Vector32();
    const mat = new Matrix42();
    for (let i2 = 0; i2 <= segments; i2++) {
      const u2 = i2 / segments;
      tangents[i2] = this.getTangentAt(u2, new Vector32());
    }
    normals[0] = new Vector32();
    binormals[0] = new Vector32();
    let min5 = Number.MAX_VALUE;
    const tx = Math.abs(tangents[0].x);
    const ty = Math.abs(tangents[0].y);
    const tz = Math.abs(tangents[0].z);
    if (tx <= min5) {
      min5 = tx;
      normal2.set(1, 0, 0);
    }
    if (ty <= min5) {
      min5 = ty;
      normal2.set(0, 1, 0);
    }
    if (tz <= min5) {
      normal2.set(0, 0, 1);
    }
    vec.crossVectors(tangents[0], normal2).normalize();
    normals[0].crossVectors(tangents[0], vec);
    binormals[0].crossVectors(tangents[0], normals[0]);
    for (let i2 = 1; i2 <= segments; i2++) {
      normals[i2] = normals[i2 - 1].clone();
      binormals[i2] = binormals[i2 - 1].clone();
      vec.crossVectors(tangents[i2 - 1], tangents[i2]);
      if (vec.length() > Number.EPSILON) {
        vec.normalize();
        const theta = Math.acos(clamp2(tangents[i2 - 1].dot(tangents[i2]), -1, 1));
        normals[i2].applyMatrix4(mat.makeRotationAxis(vec, theta));
      }
      binormals[i2].crossVectors(tangents[i2], normals[i2]);
    }
    if (closed === true) {
      let theta = Math.acos(clamp2(normals[0].dot(normals[segments]), -1, 1));
      theta /= segments;
      if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
        theta = -theta;
      }
      for (let i2 = 1; i2 <= segments; i2++) {
        normals[i2].applyMatrix4(mat.makeRotationAxis(tangents[i2], theta * i2));
        binormals[i2].crossVectors(tangents[i2], normals[i2]);
      }
    }
    return {
      tangents,
      normals,
      binormals
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.arcLengthDivisions = source.arcLengthDivisions;
    return this;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.6,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    data.arcLengthDivisions = this.arcLengthDivisions;
    data.type = this.type;
    return data;
  }
  fromJSON(json) {
    this.arcLengthDivisions = json.arcLengthDivisions;
    return this;
  }
};
var EllipseCurve = class extends Curve {
  constructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0) {
    super();
    this.isEllipseCurve = true;
    this.type = "EllipseCurve";
    this.aX = aX;
    this.aY = aY;
    this.xRadius = xRadius;
    this.yRadius = yRadius;
    this.aStartAngle = aStartAngle;
    this.aEndAngle = aEndAngle;
    this.aClockwise = aClockwise;
    this.aRotation = aRotation;
  }
  getPoint(t5, optionalTarget = new Vector22()) {
    const point2 = optionalTarget;
    const twoPi = Math.PI * 2;
    let deltaAngle = this.aEndAngle - this.aStartAngle;
    const samePoints = Math.abs(deltaAngle) < Number.EPSILON;
    while (deltaAngle < 0) deltaAngle += twoPi;
    while (deltaAngle > twoPi) deltaAngle -= twoPi;
    if (deltaAngle < Number.EPSILON) {
      if (samePoints) {
        deltaAngle = 0;
      } else {
        deltaAngle = twoPi;
      }
    }
    if (this.aClockwise === true && !samePoints) {
      if (deltaAngle === twoPi) {
        deltaAngle = -twoPi;
      } else {
        deltaAngle = deltaAngle - twoPi;
      }
    }
    const angle2 = this.aStartAngle + t5 * deltaAngle;
    let x3 = this.aX + this.xRadius * Math.cos(angle2);
    let y3 = this.aY + this.yRadius * Math.sin(angle2);
    if (this.aRotation !== 0) {
      const cos4 = Math.cos(this.aRotation);
      const sin4 = Math.sin(this.aRotation);
      const tx = x3 - this.aX;
      const ty = y3 - this.aY;
      x3 = tx * cos4 - ty * sin4 + this.aX;
      y3 = tx * sin4 + ty * cos4 + this.aY;
    }
    return point2.set(x3, y3);
  }
  copy(source) {
    super.copy(source);
    this.aX = source.aX;
    this.aY = source.aY;
    this.xRadius = source.xRadius;
    this.yRadius = source.yRadius;
    this.aStartAngle = source.aStartAngle;
    this.aEndAngle = source.aEndAngle;
    this.aClockwise = source.aClockwise;
    this.aRotation = source.aRotation;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.aX = this.aX;
    data.aY = this.aY;
    data.xRadius = this.xRadius;
    data.yRadius = this.yRadius;
    data.aStartAngle = this.aStartAngle;
    data.aEndAngle = this.aEndAngle;
    data.aClockwise = this.aClockwise;
    data.aRotation = this.aRotation;
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.aX = json.aX;
    this.aY = json.aY;
    this.xRadius = json.xRadius;
    this.yRadius = json.yRadius;
    this.aStartAngle = json.aStartAngle;
    this.aEndAngle = json.aEndAngle;
    this.aClockwise = json.aClockwise;
    this.aRotation = json.aRotation;
    return this;
  }
};
var ArcCurve = class extends EllipseCurve {
  constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    this.isArcCurve = true;
    this.type = "ArcCurve";
  }
};
function CubicPoly() {
  let c0 = 0, c1 = 0, c22 = 0, c32 = 0;
  function init10(x0, x1, t03, t13) {
    c0 = x0;
    c1 = t03;
    c22 = -3 * x0 + 3 * x1 - 2 * t03 - t13;
    c32 = 2 * x0 - 2 * x1 + t03 + t13;
  }
  return {
    initCatmullRom: function(x0, x1, x22, x3, tension) {
      init10(x1, x22, tension * (x22 - x0), tension * (x3 - x1));
    },
    initNonuniformCatmullRom: function(x0, x1, x22, x3, dt0, dt1, dt2) {
      let t13 = (x1 - x0) / dt0 - (x22 - x0) / (dt0 + dt1) + (x22 - x1) / dt1;
      let t22 = (x22 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x22) / dt2;
      t13 *= dt1;
      t22 *= dt1;
      init10(x1, x22, t13, t22);
    },
    calc: function(t5) {
      const t22 = t5 * t5;
      const t32 = t22 * t5;
      return c0 + c1 * t5 + c22 * t22 + c32 * t32;
    }
  };
}
var tmp = new Vector32();
var px = new CubicPoly();
var py = new CubicPoly();
var pz = new CubicPoly();
var CatmullRomCurve3 = class extends Curve {
  constructor(points = [], closed = false, curveType = "centripetal", tension = 0.5) {
    super();
    this.isCatmullRomCurve3 = true;
    this.type = "CatmullRomCurve3";
    this.points = points;
    this.closed = closed;
    this.curveType = curveType;
    this.tension = tension;
  }
  getPoint(t5, optionalTarget = new Vector32()) {
    const point2 = optionalTarget;
    const points = this.points;
    const l2 = points.length;
    const p3 = (l2 - (this.closed ? 0 : 1)) * t5;
    let intPoint = Math.floor(p3);
    let weight = p3 - intPoint;
    if (this.closed) {
      intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l2) + 1) * l2;
    } else if (weight === 0 && intPoint === l2 - 1) {
      intPoint = l2 - 2;
      weight = 1;
    }
    let p0, p32;
    if (this.closed || intPoint > 0) {
      p0 = points[(intPoint - 1) % l2];
    } else {
      tmp.subVectors(points[0], points[1]).add(points[0]);
      p0 = tmp;
    }
    const p1 = points[intPoint % l2];
    const p22 = points[(intPoint + 1) % l2];
    if (this.closed || intPoint + 2 < l2) {
      p32 = points[(intPoint + 2) % l2];
    } else {
      tmp.subVectors(points[l2 - 1], points[l2 - 2]).add(points[l2 - 1]);
      p32 = tmp;
    }
    if (this.curveType === "centripetal" || this.curveType === "chordal") {
      const pow6 = this.curveType === "chordal" ? 0.5 : 0.25;
      let dt0 = Math.pow(p0.distanceToSquared(p1), pow6);
      let dt1 = Math.pow(p1.distanceToSquared(p22), pow6);
      let dt2 = Math.pow(p22.distanceToSquared(p32), pow6);
      if (dt1 < 1e-4) dt1 = 1;
      if (dt0 < 1e-4) dt0 = dt1;
      if (dt2 < 1e-4) dt2 = dt1;
      px.initNonuniformCatmullRom(p0.x, p1.x, p22.x, p32.x, dt0, dt1, dt2);
      py.initNonuniformCatmullRom(p0.y, p1.y, p22.y, p32.y, dt0, dt1, dt2);
      pz.initNonuniformCatmullRom(p0.z, p1.z, p22.z, p32.z, dt0, dt1, dt2);
    } else if (this.curveType === "catmullrom") {
      px.initCatmullRom(p0.x, p1.x, p22.x, p32.x, this.tension);
      py.initCatmullRom(p0.y, p1.y, p22.y, p32.y, this.tension);
      pz.initCatmullRom(p0.z, p1.z, p22.z, p32.z, this.tension);
    }
    point2.set(
      px.calc(weight),
      py.calc(weight),
      pz.calc(weight)
    );
    return point2;
  }
  copy(source) {
    super.copy(source);
    this.points = [];
    for (let i2 = 0, l2 = source.points.length; i2 < l2; i2++) {
      const point2 = source.points[i2];
      this.points.push(point2.clone());
    }
    this.closed = source.closed;
    this.curveType = source.curveType;
    this.tension = source.tension;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.points = [];
    for (let i2 = 0, l2 = this.points.length; i2 < l2; i2++) {
      const point2 = this.points[i2];
      data.points.push(point2.toArray());
    }
    data.closed = this.closed;
    data.curveType = this.curveType;
    data.tension = this.tension;
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.points = [];
    for (let i2 = 0, l2 = json.points.length; i2 < l2; i2++) {
      const point2 = json.points[i2];
      this.points.push(new Vector32().fromArray(point2));
    }
    this.closed = json.closed;
    this.curveType = json.curveType;
    this.tension = json.tension;
    return this;
  }
};
function CatmullRom(t5, p0, p1, p22, p3) {
  const v0 = (p22 - p0) * 0.5;
  const v1 = (p3 - p1) * 0.5;
  const t22 = t5 * t5;
  const t32 = t5 * t22;
  return (2 * p1 - 2 * p22 + v0 + v1) * t32 + (-3 * p1 + 3 * p22 - 2 * v0 - v1) * t22 + v0 * t5 + p1;
}
function QuadraticBezierP0(t5, p3) {
  const k2 = 1 - t5;
  return k2 * k2 * p3;
}
function QuadraticBezierP1(t5, p3) {
  return 2 * (1 - t5) * t5 * p3;
}
function QuadraticBezierP2(t5, p3) {
  return t5 * t5 * p3;
}
function QuadraticBezier(t5, p0, p1, p22) {
  return QuadraticBezierP0(t5, p0) + QuadraticBezierP1(t5, p1) + QuadraticBezierP2(t5, p22);
}
function CubicBezierP0(t5, p3) {
  const k2 = 1 - t5;
  return k2 * k2 * k2 * p3;
}
function CubicBezierP1(t5, p3) {
  const k2 = 1 - t5;
  return 3 * k2 * k2 * t5 * p3;
}
function CubicBezierP2(t5, p3) {
  return 3 * (1 - t5) * t5 * t5 * p3;
}
function CubicBezierP3(t5, p3) {
  return t5 * t5 * t5 * p3;
}
function CubicBezier(t5, p0, p1, p22, p3) {
  return CubicBezierP0(t5, p0) + CubicBezierP1(t5, p1) + CubicBezierP2(t5, p22) + CubicBezierP3(t5, p3);
}
var CubicBezierCurve = class extends Curve {
  constructor(v0 = new Vector22(), v1 = new Vector22(), v2 = new Vector22(), v3 = new Vector22()) {
    super();
    this.isCubicBezierCurve = true;
    this.type = "CubicBezierCurve";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
  }
  getPoint(t5, optionalTarget = new Vector22()) {
    const point2 = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
    point2.set(
      CubicBezier(t5, v0.x, v1.x, v2.x, v3.x),
      CubicBezier(t5, v0.y, v1.y, v2.y, v3.y)
    );
    return point2;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
  }
};
var CubicBezierCurve32 = class extends Curve {
  constructor(v0 = new Vector32(), v1 = new Vector32(), v2 = new Vector32(), v3 = new Vector32()) {
    super();
    this.isCubicBezierCurve3 = true;
    this.type = "CubicBezierCurve3";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
  }
  getPoint(t5, optionalTarget = new Vector32()) {
    const point2 = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
    point2.set(
      CubicBezier(t5, v0.x, v1.x, v2.x, v3.x),
      CubicBezier(t5, v0.y, v1.y, v2.y, v3.y),
      CubicBezier(t5, v0.z, v1.z, v2.z, v3.z)
    );
    return point2;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
  }
};
var LineCurve = class extends Curve {
  constructor(v1 = new Vector22(), v2 = new Vector22()) {
    super();
    this.isLineCurve = true;
    this.type = "LineCurve";
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t5, optionalTarget = new Vector22()) {
    const point2 = optionalTarget;
    if (t5 === 1) {
      point2.copy(this.v2);
    } else {
      point2.copy(this.v2).sub(this.v1);
      point2.multiplyScalar(t5).add(this.v1);
    }
    return point2;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(u2, optionalTarget) {
    return this.getPoint(u2, optionalTarget);
  }
  getTangent(t5, optionalTarget = new Vector22()) {
    return optionalTarget.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(u2, optionalTarget) {
    return this.getTangent(u2, optionalTarget);
  }
  copy(source) {
    super.copy(source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
};
var LineCurve3 = class extends Curve {
  constructor(v1 = new Vector32(), v2 = new Vector32()) {
    super();
    this.isLineCurve3 = true;
    this.type = "LineCurve3";
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t5, optionalTarget = new Vector32()) {
    const point2 = optionalTarget;
    if (t5 === 1) {
      point2.copy(this.v2);
    } else {
      point2.copy(this.v2).sub(this.v1);
      point2.multiplyScalar(t5).add(this.v1);
    }
    return point2;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(u2, optionalTarget) {
    return this.getPoint(u2, optionalTarget);
  }
  getTangent(t5, optionalTarget = new Vector32()) {
    return optionalTarget.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(u2, optionalTarget) {
    return this.getTangent(u2, optionalTarget);
  }
  copy(source) {
    super.copy(source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
};
var QuadraticBezierCurve = class extends Curve {
  constructor(v0 = new Vector22(), v1 = new Vector22(), v2 = new Vector22()) {
    super();
    this.isQuadraticBezierCurve = true;
    this.type = "QuadraticBezierCurve";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t5, optionalTarget = new Vector22()) {
    const point2 = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2;
    point2.set(
      QuadraticBezier(t5, v0.x, v1.x, v2.x),
      QuadraticBezier(t5, v0.y, v1.y, v2.y)
    );
    return point2;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
};
var QuadraticBezierCurve32 = class extends Curve {
  constructor(v0 = new Vector32(), v1 = new Vector32(), v2 = new Vector32()) {
    super();
    this.isQuadraticBezierCurve3 = true;
    this.type = "QuadraticBezierCurve3";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t5, optionalTarget = new Vector32()) {
    const point2 = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2;
    point2.set(
      QuadraticBezier(t5, v0.x, v1.x, v2.x),
      QuadraticBezier(t5, v0.y, v1.y, v2.y),
      QuadraticBezier(t5, v0.z, v1.z, v2.z)
    );
    return point2;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
};
var SplineCurve = class extends Curve {
  constructor(points = []) {
    super();
    this.isSplineCurve = true;
    this.type = "SplineCurve";
    this.points = points;
  }
  getPoint(t5, optionalTarget = new Vector22()) {
    const point2 = optionalTarget;
    const points = this.points;
    const p3 = (points.length - 1) * t5;
    const intPoint = Math.floor(p3);
    const weight = p3 - intPoint;
    const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
    const p1 = points[intPoint];
    const p22 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
    const p32 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
    point2.set(
      CatmullRom(weight, p0.x, p1.x, p22.x, p32.x),
      CatmullRom(weight, p0.y, p1.y, p22.y, p32.y)
    );
    return point2;
  }
  copy(source) {
    super.copy(source);
    this.points = [];
    for (let i2 = 0, l2 = source.points.length; i2 < l2; i2++) {
      const point2 = source.points[i2];
      this.points.push(point2.clone());
    }
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.points = [];
    for (let i2 = 0, l2 = this.points.length; i2 < l2; i2++) {
      const point2 = this.points[i2];
      data.points.push(point2.toArray());
    }
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.points = [];
    for (let i2 = 0, l2 = json.points.length; i2 < l2; i2++) {
      const point2 = json.points[i2];
      this.points.push(new Vector22().fromArray(point2));
    }
    return this;
  }
};
var Curves = Object.freeze({
  __proto__: null,
  ArcCurve,
  CatmullRomCurve3,
  CubicBezierCurve,
  CubicBezierCurve3: CubicBezierCurve32,
  EllipseCurve,
  LineCurve,
  LineCurve3,
  QuadraticBezierCurve,
  QuadraticBezierCurve3: QuadraticBezierCurve32,
  SplineCurve
});
var CurvePath = class extends Curve {
  constructor() {
    super();
    this.type = "CurvePath";
    this.curves = [];
    this.autoClose = false;
  }
  add(curve) {
    this.curves.push(curve);
  }
  closePath() {
    const startPoint = this.curves[0].getPoint(0);
    const endPoint = this.curves[this.curves.length - 1].getPoint(1);
    if (!startPoint.equals(endPoint)) {
      const lineType = startPoint.isVector2 === true ? "LineCurve" : "LineCurve3";
      this.curves.push(new Curves[lineType](endPoint, startPoint));
    }
    return this;
  }
  // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  getPoint(t5, optionalTarget) {
    const d3 = t5 * this.getLength();
    const curveLengths = this.getCurveLengths();
    let i2 = 0;
    while (i2 < curveLengths.length) {
      if (curveLengths[i2] >= d3) {
        const diff = curveLengths[i2] - d3;
        const curve = this.curves[i2];
        const segmentLength = curve.getLength();
        const u2 = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
        return curve.getPointAt(u2, optionalTarget);
      }
      i2++;
    }
    return null;
  }
  // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  getLength() {
    const lens = this.getCurveLengths();
    return lens[lens.length - 1];
  }
  // cacheLengths must be recalculated.
  updateArcLengths() {
    this.needsUpdate = true;
    this.cacheLengths = null;
    this.getCurveLengths();
  }
  // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
      return this.cacheLengths;
    }
    const lengths = [];
    let sums = 0;
    for (let i2 = 0, l2 = this.curves.length; i2 < l2; i2++) {
      sums += this.curves[i2].getLength();
      lengths.push(sums);
    }
    this.cacheLengths = lengths;
    return lengths;
  }
  getSpacedPoints(divisions = 40) {
    const points = [];
    for (let i2 = 0; i2 <= divisions; i2++) {
      points.push(this.getPoint(i2 / divisions));
    }
    if (this.autoClose) {
      points.push(points[0]);
    }
    return points;
  }
  getPoints(divisions = 12) {
    const points = [];
    let last2;
    for (let i2 = 0, curves = this.curves; i2 < curves.length; i2++) {
      const curve = curves[i2];
      const resolution = curve.isEllipseCurve ? divisions * 2 : curve.isLineCurve || curve.isLineCurve3 ? 1 : curve.isSplineCurve ? divisions * curve.points.length : divisions;
      const pts = curve.getPoints(resolution);
      for (let j2 = 0; j2 < pts.length; j2++) {
        const point2 = pts[j2];
        if (last2 && last2.equals(point2)) continue;
        points.push(point2);
        last2 = point2;
      }
    }
    if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
      points.push(points[0]);
    }
    return points;
  }
  copy(source) {
    super.copy(source);
    this.curves = [];
    for (let i2 = 0, l2 = source.curves.length; i2 < l2; i2++) {
      const curve = source.curves[i2];
      this.curves.push(curve.clone());
    }
    this.autoClose = source.autoClose;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.autoClose = this.autoClose;
    data.curves = [];
    for (let i2 = 0, l2 = this.curves.length; i2 < l2; i2++) {
      const curve = this.curves[i2];
      data.curves.push(curve.toJSON());
    }
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.autoClose = json.autoClose;
    this.curves = [];
    for (let i2 = 0, l2 = json.curves.length; i2 < l2; i2++) {
      const curve = json.curves[i2];
      this.curves.push(new Curves[curve.type]().fromJSON(curve));
    }
    return this;
  }
};
var Path = class extends CurvePath {
  constructor(points) {
    super();
    this.type = "Path";
    this.currentPoint = new Vector22();
    if (points) {
      this.setFromPoints(points);
    }
  }
  setFromPoints(points) {
    this.moveTo(points[0].x, points[0].y);
    for (let i2 = 1, l2 = points.length; i2 < l2; i2++) {
      this.lineTo(points[i2].x, points[i2].y);
    }
    return this;
  }
  moveTo(x3, y3) {
    this.currentPoint.set(x3, y3);
    return this;
  }
  lineTo(x3, y3) {
    const curve = new LineCurve(this.currentPoint.clone(), new Vector22(x3, y3));
    this.curves.push(curve);
    this.currentPoint.set(x3, y3);
    return this;
  }
  quadraticCurveTo(aCPx, aCPy, aX, aY) {
    const curve = new QuadraticBezierCurve(
      this.currentPoint.clone(),
      new Vector22(aCPx, aCPy),
      new Vector22(aX, aY)
    );
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
    return this;
  }
  bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    const curve = new CubicBezierCurve(
      this.currentPoint.clone(),
      new Vector22(aCP1x, aCP1y),
      new Vector22(aCP2x, aCP2y),
      new Vector22(aX, aY)
    );
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
    return this;
  }
  splineThru(pts) {
    const npts = [this.currentPoint.clone()].concat(pts);
    const curve = new SplineCurve(npts);
    this.curves.push(curve);
    this.currentPoint.copy(pts[pts.length - 1]);
    return this;
  }
  arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    const x0 = this.currentPoint.x;
    const y0 = this.currentPoint.y;
    this.absarc(
      aX + x0,
      aY + y0,
      aRadius,
      aStartAngle,
      aEndAngle,
      aClockwise
    );
    return this;
  }
  absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    return this;
  }
  ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    const x0 = this.currentPoint.x;
    const y0 = this.currentPoint.y;
    this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    return this;
  }
  absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    if (this.curves.length > 0) {
      const firstPoint = curve.getPoint(0);
      if (!firstPoint.equals(this.currentPoint)) {
        this.lineTo(firstPoint.x, firstPoint.y);
      }
    }
    this.curves.push(curve);
    const lastPoint = curve.getPoint(1);
    this.currentPoint.copy(lastPoint);
    return this;
  }
  copy(source) {
    super.copy(source);
    this.currentPoint.copy(source.currentPoint);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.currentPoint = this.currentPoint.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.currentPoint.fromArray(json.currentPoint);
    return this;
  }
};
var LatheGeometry = class _LatheGeometry extends BufferGeometry2 {
  constructor(points = [new Vector22(0, -0.5), new Vector22(0.5, 0), new Vector22(0, 0.5)], segments = 12, phiStart = 0, phiLength = Math.PI * 2) {
    super();
    this.type = "LatheGeometry";
    this.parameters = {
      points,
      segments,
      phiStart,
      phiLength
    };
    segments = Math.floor(segments);
    phiLength = clamp2(phiLength, 0, Math.PI * 2);
    const indices = [];
    const vertices = [];
    const uvs = [];
    const initNormals = [];
    const normals = [];
    const inverseSegments = 1 / segments;
    const vertex = new Vector32();
    const uv2 = new Vector22();
    const normal2 = new Vector32();
    const curNormal = new Vector32();
    const prevNormal = new Vector32();
    let dx = 0;
    let dy = 0;
    for (let j2 = 0; j2 <= points.length - 1; j2++) {
      switch (j2) {
        case 0:
          dx = points[j2 + 1].x - points[j2].x;
          dy = points[j2 + 1].y - points[j2].y;
          normal2.x = dy * 1;
          normal2.y = -dx;
          normal2.z = dy * 0;
          prevNormal.copy(normal2);
          normal2.normalize();
          initNormals.push(normal2.x, normal2.y, normal2.z);
          break;
        case points.length - 1:
          initNormals.push(prevNormal.x, prevNormal.y, prevNormal.z);
          break;
        default:
          dx = points[j2 + 1].x - points[j2].x;
          dy = points[j2 + 1].y - points[j2].y;
          normal2.x = dy * 1;
          normal2.y = -dx;
          normal2.z = dy * 0;
          curNormal.copy(normal2);
          normal2.x += prevNormal.x;
          normal2.y += prevNormal.y;
          normal2.z += prevNormal.z;
          normal2.normalize();
          initNormals.push(normal2.x, normal2.y, normal2.z);
          prevNormal.copy(curNormal);
      }
    }
    for (let i2 = 0; i2 <= segments; i2++) {
      const phi = phiStart + i2 * inverseSegments * phiLength;
      const sin4 = Math.sin(phi);
      const cos4 = Math.cos(phi);
      for (let j2 = 0; j2 <= points.length - 1; j2++) {
        vertex.x = points[j2].x * sin4;
        vertex.y = points[j2].y;
        vertex.z = points[j2].x * cos4;
        vertices.push(vertex.x, vertex.y, vertex.z);
        uv2.x = i2 / segments;
        uv2.y = j2 / (points.length - 1);
        uvs.push(uv2.x, uv2.y);
        const x3 = initNormals[3 * j2 + 0] * sin4;
        const y3 = initNormals[3 * j2 + 1];
        const z3 = initNormals[3 * j2 + 0] * cos4;
        normals.push(x3, y3, z3);
      }
    }
    for (let i2 = 0; i2 < segments; i2++) {
      for (let j2 = 0; j2 < points.length - 1; j2++) {
        const base = j2 + i2 * points.length;
        const a3 = base;
        const b = base + points.length;
        const c5 = base + points.length + 1;
        const d3 = base + 1;
        indices.push(a3, b, d3);
        indices.push(c5, d3, b);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
    this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
    this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new _LatheGeometry(data.points, data.segments, data.phiStart, data.phiLength);
  }
};
var CapsuleGeometry = class _CapsuleGeometry extends LatheGeometry {
  constructor(radius = 1, length2 = 1, capSegments = 4, radialSegments = 8) {
    const path = new Path();
    path.absarc(0, -length2 / 2, radius, Math.PI * 1.5, 0);
    path.absarc(0, length2 / 2, radius, 0, Math.PI * 0.5);
    super(path.getPoints(capSegments), radialSegments);
    this.type = "CapsuleGeometry";
    this.parameters = {
      radius,
      length: length2,
      capSegments,
      radialSegments
    };
  }
  static fromJSON(data) {
    return new _CapsuleGeometry(data.radius, data.length, data.capSegments, data.radialSegments);
  }
};
var CircleGeometry = class _CircleGeometry extends BufferGeometry2 {
  constructor(radius = 1, segments = 32, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = "CircleGeometry";
    this.parameters = {
      radius,
      segments,
      thetaStart,
      thetaLength
    };
    segments = Math.max(3, segments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    const vertex = new Vector32();
    const uv2 = new Vector22();
    vertices.push(0, 0, 0);
    normals.push(0, 0, 1);
    uvs.push(0.5, 0.5);
    for (let s2 = 0, i2 = 3; s2 <= segments; s2++, i2 += 3) {
      const segment = thetaStart + s2 / segments * thetaLength;
      vertex.x = radius * Math.cos(segment);
      vertex.y = radius * Math.sin(segment);
      vertices.push(vertex.x, vertex.y, vertex.z);
      normals.push(0, 0, 1);
      uv2.x = (vertices[i2] / radius + 1) / 2;
      uv2.y = (vertices[i2 + 1] / radius + 1) / 2;
      uvs.push(uv2.x, uv2.y);
    }
    for (let i2 = 1; i2 <= segments; i2++) {
      indices.push(i2, i2 + 1, 0);
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new _CircleGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength);
  }
};
var CylinderGeometry2 = class _CylinderGeometry extends BufferGeometry2 {
  constructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = "CylinderGeometry";
    this.parameters = {
      radiusTop,
      radiusBottom,
      height,
      radialSegments,
      heightSegments,
      openEnded,
      thetaStart,
      thetaLength
    };
    const scope = this;
    radialSegments = Math.floor(radialSegments);
    heightSegments = Math.floor(heightSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let index8 = 0;
    const indexArray = [];
    const halfHeight = height / 2;
    let groupStart = 0;
    generateTorso();
    if (openEnded === false) {
      if (radiusTop > 0) generateCap(true);
      if (radiusBottom > 0) generateCap(false);
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
    function generateTorso() {
      const normal2 = new Vector32();
      const vertex = new Vector32();
      let groupCount = 0;
      const slope = (radiusBottom - radiusTop) / height;
      for (let y3 = 0; y3 <= heightSegments; y3++) {
        const indexRow = [];
        const v2 = y3 / heightSegments;
        const radius = v2 * (radiusBottom - radiusTop) + radiusTop;
        for (let x3 = 0; x3 <= radialSegments; x3++) {
          const u2 = x3 / radialSegments;
          const theta = u2 * thetaLength + thetaStart;
          const sinTheta = Math.sin(theta);
          const cosTheta = Math.cos(theta);
          vertex.x = radius * sinTheta;
          vertex.y = -v2 * height + halfHeight;
          vertex.z = radius * cosTheta;
          vertices.push(vertex.x, vertex.y, vertex.z);
          normal2.set(sinTheta, slope, cosTheta).normalize();
          normals.push(normal2.x, normal2.y, normal2.z);
          uvs.push(u2, 1 - v2);
          indexRow.push(index8++);
        }
        indexArray.push(indexRow);
      }
      for (let x3 = 0; x3 < radialSegments; x3++) {
        for (let y3 = 0; y3 < heightSegments; y3++) {
          const a3 = indexArray[y3][x3];
          const b = indexArray[y3 + 1][x3];
          const c5 = indexArray[y3 + 1][x3 + 1];
          const d3 = indexArray[y3][x3 + 1];
          indices.push(a3, b, d3);
          indices.push(b, c5, d3);
          groupCount += 6;
        }
      }
      scope.addGroup(groupStart, groupCount, 0);
      groupStart += groupCount;
    }
    function generateCap(top) {
      const centerIndexStart = index8;
      const uv2 = new Vector22();
      const vertex = new Vector32();
      let groupCount = 0;
      const radius = top === true ? radiusTop : radiusBottom;
      const sign3 = top === true ? 1 : -1;
      for (let x3 = 1; x3 <= radialSegments; x3++) {
        vertices.push(0, halfHeight * sign3, 0);
        normals.push(0, sign3, 0);
        uvs.push(0.5, 0.5);
        index8++;
      }
      const centerIndexEnd = index8;
      for (let x3 = 0; x3 <= radialSegments; x3++) {
        const u2 = x3 / radialSegments;
        const theta = u2 * thetaLength + thetaStart;
        const cosTheta = Math.cos(theta);
        const sinTheta = Math.sin(theta);
        vertex.x = radius * sinTheta;
        vertex.y = halfHeight * sign3;
        vertex.z = radius * cosTheta;
        vertices.push(vertex.x, vertex.y, vertex.z);
        normals.push(0, sign3, 0);
        uv2.x = cosTheta * 0.5 + 0.5;
        uv2.y = sinTheta * 0.5 * sign3 + 0.5;
        uvs.push(uv2.x, uv2.y);
        index8++;
      }
      for (let x3 = 0; x3 < radialSegments; x3++) {
        const c5 = centerIndexStart + x3;
        const i2 = centerIndexEnd + x3;
        if (top === true) {
          indices.push(i2, i2 + 1, c5);
        } else {
          indices.push(i2 + 1, i2, c5);
        }
        groupCount += 3;
      }
      scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
      groupStart += groupCount;
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new _CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
  }
};
var ConeGeometry2 = class _ConeGeometry extends CylinderGeometry2 {
  constructor(radius = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
    super(0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
    this.type = "ConeGeometry";
    this.parameters = {
      radius,
      height,
      radialSegments,
      heightSegments,
      openEnded,
      thetaStart,
      thetaLength
    };
  }
  static fromJSON(data) {
    return new _ConeGeometry(data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
  }
};
var PolyhedronGeometry = class _PolyhedronGeometry extends BufferGeometry2 {
  constructor(vertices = [], indices = [], radius = 1, detail = 0) {
    super();
    this.type = "PolyhedronGeometry";
    this.parameters = {
      vertices,
      indices,
      radius,
      detail
    };
    const vertexBuffer = [];
    const uvBuffer = [];
    subdivide(detail);
    applyRadius(radius);
    generateUVs();
    this.setAttribute("position", new Float32BufferAttribute2(vertexBuffer, 3));
    this.setAttribute("normal", new Float32BufferAttribute2(vertexBuffer.slice(), 3));
    this.setAttribute("uv", new Float32BufferAttribute2(uvBuffer, 2));
    if (detail === 0) {
      this.computeVertexNormals();
    } else {
      this.normalizeNormals();
    }
    function subdivide(detail2) {
      const a3 = new Vector32();
      const b = new Vector32();
      const c5 = new Vector32();
      for (let i2 = 0; i2 < indices.length; i2 += 3) {
        getVertexByIndex(indices[i2 + 0], a3);
        getVertexByIndex(indices[i2 + 1], b);
        getVertexByIndex(indices[i2 + 2], c5);
        subdivideFace(a3, b, c5, detail2);
      }
    }
    function subdivideFace(a3, b, c5, detail2) {
      const cols = detail2 + 1;
      const v2 = [];
      for (let i2 = 0; i2 <= cols; i2++) {
        v2[i2] = [];
        const aj = a3.clone().lerp(c5, i2 / cols);
        const bj = b.clone().lerp(c5, i2 / cols);
        const rows = cols - i2;
        for (let j2 = 0; j2 <= rows; j2++) {
          if (j2 === 0 && i2 === cols) {
            v2[i2][j2] = aj;
          } else {
            v2[i2][j2] = aj.clone().lerp(bj, j2 / rows);
          }
        }
      }
      for (let i2 = 0; i2 < cols; i2++) {
        for (let j2 = 0; j2 < 2 * (cols - i2) - 1; j2++) {
          const k2 = Math.floor(j2 / 2);
          if (j2 % 2 === 0) {
            pushVertex(v2[i2][k2 + 1]);
            pushVertex(v2[i2 + 1][k2]);
            pushVertex(v2[i2][k2]);
          } else {
            pushVertex(v2[i2][k2 + 1]);
            pushVertex(v2[i2 + 1][k2 + 1]);
            pushVertex(v2[i2 + 1][k2]);
          }
        }
      }
    }
    function applyRadius(radius2) {
      const vertex = new Vector32();
      for (let i2 = 0; i2 < vertexBuffer.length; i2 += 3) {
        vertex.x = vertexBuffer[i2 + 0];
        vertex.y = vertexBuffer[i2 + 1];
        vertex.z = vertexBuffer[i2 + 2];
        vertex.normalize().multiplyScalar(radius2);
        vertexBuffer[i2 + 0] = vertex.x;
        vertexBuffer[i2 + 1] = vertex.y;
        vertexBuffer[i2 + 2] = vertex.z;
      }
    }
    function generateUVs() {
      const vertex = new Vector32();
      for (let i2 = 0; i2 < vertexBuffer.length; i2 += 3) {
        vertex.x = vertexBuffer[i2 + 0];
        vertex.y = vertexBuffer[i2 + 1];
        vertex.z = vertexBuffer[i2 + 2];
        const u2 = azimuth(vertex) / 2 / Math.PI + 0.5;
        const v2 = inclination(vertex) / Math.PI + 0.5;
        uvBuffer.push(u2, 1 - v2);
      }
      correctUVs();
      correctSeam();
    }
    function correctSeam() {
      for (let i2 = 0; i2 < uvBuffer.length; i2 += 6) {
        const x0 = uvBuffer[i2 + 0];
        const x1 = uvBuffer[i2 + 2];
        const x22 = uvBuffer[i2 + 4];
        const max6 = Math.max(x0, x1, x22);
        const min5 = Math.min(x0, x1, x22);
        if (max6 > 0.9 && min5 < 0.1) {
          if (x0 < 0.2) uvBuffer[i2 + 0] += 1;
          if (x1 < 0.2) uvBuffer[i2 + 2] += 1;
          if (x22 < 0.2) uvBuffer[i2 + 4] += 1;
        }
      }
    }
    function pushVertex(vertex) {
      vertexBuffer.push(vertex.x, vertex.y, vertex.z);
    }
    function getVertexByIndex(index8, vertex) {
      const stride = index8 * 3;
      vertex.x = vertices[stride + 0];
      vertex.y = vertices[stride + 1];
      vertex.z = vertices[stride + 2];
    }
    function correctUVs() {
      const a3 = new Vector32();
      const b = new Vector32();
      const c5 = new Vector32();
      const centroid = new Vector32();
      const uvA = new Vector22();
      const uvB = new Vector22();
      const uvC = new Vector22();
      for (let i2 = 0, j2 = 0; i2 < vertexBuffer.length; i2 += 9, j2 += 6) {
        a3.set(vertexBuffer[i2 + 0], vertexBuffer[i2 + 1], vertexBuffer[i2 + 2]);
        b.set(vertexBuffer[i2 + 3], vertexBuffer[i2 + 4], vertexBuffer[i2 + 5]);
        c5.set(vertexBuffer[i2 + 6], vertexBuffer[i2 + 7], vertexBuffer[i2 + 8]);
        uvA.set(uvBuffer[j2 + 0], uvBuffer[j2 + 1]);
        uvB.set(uvBuffer[j2 + 2], uvBuffer[j2 + 3]);
        uvC.set(uvBuffer[j2 + 4], uvBuffer[j2 + 5]);
        centroid.copy(a3).add(b).add(c5).divideScalar(3);
        const azi = azimuth(centroid);
        correctUV(uvA, j2 + 0, a3, azi);
        correctUV(uvB, j2 + 2, b, azi);
        correctUV(uvC, j2 + 4, c5, azi);
      }
    }
    function correctUV(uv2, stride, vector, azimuth2) {
      if (azimuth2 < 0 && uv2.x === 1) {
        uvBuffer[stride] = uv2.x - 1;
      }
      if (vector.x === 0 && vector.z === 0) {
        uvBuffer[stride] = azimuth2 / 2 / Math.PI + 0.5;
      }
    }
    function azimuth(vector) {
      return Math.atan2(vector.z, -vector.x);
    }
    function inclination(vector) {
      return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new _PolyhedronGeometry(data.vertices, data.indices, data.radius, data.details);
  }
};
var DodecahedronGeometry = class _DodecahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const t5 = (1 + Math.sqrt(5)) / 2;
    const r2 = 1 / t5;
    const vertices = [
      // (Â±1, Â±1, Â±1)
      -1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      1,
      -1,
      1,
      1,
      1,
      // (0, Â±1/Ï, Â±Ï)
      0,
      -r2,
      -t5,
      0,
      -r2,
      t5,
      0,
      r2,
      -t5,
      0,
      r2,
      t5,
      // (Â±1/Ï, Â±Ï, 0)
      -r2,
      -t5,
      0,
      -r2,
      t5,
      0,
      r2,
      -t5,
      0,
      r2,
      t5,
      0,
      // (Â±Ï, 0, Â±1/Ï)
      -t5,
      0,
      -r2,
      t5,
      0,
      -r2,
      -t5,
      0,
      r2,
      t5,
      0,
      r2
    ];
    const indices = [
      3,
      11,
      7,
      3,
      7,
      15,
      3,
      15,
      13,
      7,
      19,
      17,
      7,
      17,
      6,
      7,
      6,
      15,
      17,
      4,
      8,
      17,
      8,
      10,
      17,
      10,
      6,
      8,
      0,
      16,
      8,
      16,
      2,
      8,
      2,
      10,
      0,
      12,
      1,
      0,
      1,
      18,
      0,
      18,
      16,
      6,
      10,
      2,
      6,
      2,
      13,
      6,
      13,
      15,
      2,
      16,
      18,
      2,
      18,
      3,
      2,
      3,
      13,
      18,
      1,
      9,
      18,
      9,
      11,
      18,
      11,
      3,
      4,
      14,
      12,
      4,
      12,
      0,
      4,
      0,
      8,
      11,
      9,
      5,
      11,
      5,
      19,
      11,
      19,
      7,
      19,
      5,
      14,
      19,
      14,
      4,
      19,
      4,
      17,
      1,
      12,
      14,
      1,
      14,
      5,
      1,
      5,
      9
    ];
    super(vertices, indices, radius, detail);
    this.type = "DodecahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
  static fromJSON(data) {
    return new _DodecahedronGeometry(data.radius, data.detail);
  }
};
var _v0 = new Vector32();
var _v1$1 = new Vector32();
var _normal = new Vector32();
var _triangle = new Triangle2();
var EdgesGeometry = class extends BufferGeometry2 {
  constructor(geometry = null, thresholdAngle = 1) {
    super();
    this.type = "EdgesGeometry";
    this.parameters = {
      geometry,
      thresholdAngle
    };
    if (geometry !== null) {
      const precisionPoints = 4;
      const precision = Math.pow(10, precisionPoints);
      const thresholdDot = Math.cos(DEG2RAD * thresholdAngle);
      const indexAttr = geometry.getIndex();
      const positionAttr = geometry.getAttribute("position");
      const indexCount = indexAttr ? indexAttr.count : positionAttr.count;
      const indexArr = [0, 0, 0];
      const vertKeys = ["a", "b", "c"];
      const hashes = new Array(3);
      const edgeData = {};
      const vertices = [];
      for (let i2 = 0; i2 < indexCount; i2 += 3) {
        if (indexAttr) {
          indexArr[0] = indexAttr.getX(i2);
          indexArr[1] = indexAttr.getX(i2 + 1);
          indexArr[2] = indexAttr.getX(i2 + 2);
        } else {
          indexArr[0] = i2;
          indexArr[1] = i2 + 1;
          indexArr[2] = i2 + 2;
        }
        const { a: a3, b, c: c5 } = _triangle;
        a3.fromBufferAttribute(positionAttr, indexArr[0]);
        b.fromBufferAttribute(positionAttr, indexArr[1]);
        c5.fromBufferAttribute(positionAttr, indexArr[2]);
        _triangle.getNormal(_normal);
        hashes[0] = `${Math.round(a3.x * precision)},${Math.round(a3.y * precision)},${Math.round(a3.z * precision)}`;
        hashes[1] = `${Math.round(b.x * precision)},${Math.round(b.y * precision)},${Math.round(b.z * precision)}`;
        hashes[2] = `${Math.round(c5.x * precision)},${Math.round(c5.y * precision)},${Math.round(c5.z * precision)}`;
        if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {
          continue;
        }
        for (let j2 = 0; j2 < 3; j2++) {
          const jNext = (j2 + 1) % 3;
          const vecHash0 = hashes[j2];
          const vecHash1 = hashes[jNext];
          const v0 = _triangle[vertKeys[j2]];
          const v1 = _triangle[vertKeys[jNext]];
          const hash2 = `${vecHash0}_${vecHash1}`;
          const reverseHash = `${vecHash1}_${vecHash0}`;
          if (reverseHash in edgeData && edgeData[reverseHash]) {
            if (_normal.dot(edgeData[reverseHash].normal) <= thresholdDot) {
              vertices.push(v0.x, v0.y, v0.z);
              vertices.push(v1.x, v1.y, v1.z);
            }
            edgeData[reverseHash] = null;
          } else if (!(hash2 in edgeData)) {
            edgeData[hash2] = {
              index0: indexArr[j2],
              index1: indexArr[jNext],
              normal: _normal.clone()
            };
          }
        }
      }
      for (const key in edgeData) {
        if (edgeData[key]) {
          const { index0, index1 } = edgeData[key];
          _v0.fromBufferAttribute(positionAttr, index0);
          _v1$1.fromBufferAttribute(positionAttr, index1);
          vertices.push(_v0.x, _v0.y, _v0.z);
          vertices.push(_v1$1.x, _v1$1.y, _v1$1.z);
        }
      }
      this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
};
var Shape = class extends Path {
  constructor(points) {
    super(points);
    this.uuid = generateUUID();
    this.type = "Shape";
    this.holes = [];
  }
  getPointsHoles(divisions) {
    const holesPts = [];
    for (let i2 = 0, l2 = this.holes.length; i2 < l2; i2++) {
      holesPts[i2] = this.holes[i2].getPoints(divisions);
    }
    return holesPts;
  }
  // get points of shape and holes (keypoints based on segments parameter)
  extractPoints(divisions) {
    return {
      shape: this.getPoints(divisions),
      holes: this.getPointsHoles(divisions)
    };
  }
  copy(source) {
    super.copy(source);
    this.holes = [];
    for (let i2 = 0, l2 = source.holes.length; i2 < l2; i2++) {
      const hole = source.holes[i2];
      this.holes.push(hole.clone());
    }
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.uuid = this.uuid;
    data.holes = [];
    for (let i2 = 0, l2 = this.holes.length; i2 < l2; i2++) {
      const hole = this.holes[i2];
      data.holes.push(hole.toJSON());
    }
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.uuid = json.uuid;
    this.holes = [];
    for (let i2 = 0, l2 = json.holes.length; i2 < l2; i2++) {
      const hole = json.holes[i2];
      this.holes.push(new Path().fromJSON(hole));
    }
    return this;
  }
};
var Earcut = {
  triangulate: function(data, holeIndices, dim = 2) {
    const hasHoles = holeIndices && holeIndices.length;
    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
    let outerNode = linkedList(data, 0, outerLen, dim, true);
    const triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev) return triangles;
    let minX, minY, maxX, maxY, x3, y3, invSize;
    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
    if (data.length > 80 * dim) {
      minX = maxX = data[0];
      minY = maxY = data[1];
      for (let i2 = dim; i2 < outerLen; i2 += dim) {
        x3 = data[i2];
        y3 = data[i2 + 1];
        if (x3 < minX) minX = x3;
        if (y3 < minY) minY = y3;
        if (x3 > maxX) maxX = x3;
        if (y3 > maxY) maxY = y3;
      }
      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 32767 / invSize : 0;
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
    return triangles;
  }
};
function linkedList(data, start2, end, dim, clockwise) {
  let i2, last2;
  if (clockwise === signedArea(data, start2, end, dim) > 0) {
    for (i2 = start2; i2 < end; i2 += dim) last2 = insertNode(i2, data[i2], data[i2 + 1], last2);
  } else {
    for (i2 = end - dim; i2 >= start2; i2 -= dim) last2 = insertNode(i2, data[i2], data[i2 + 1], last2);
  }
  if (last2 && equals(last2, last2.next)) {
    removeNode(last2);
    last2 = last2.next;
  }
  return last2;
}
function filterPoints(start2, end) {
  if (!start2) return start2;
  if (!end) end = start2;
  let p3 = start2, again;
  do {
    again = false;
    if (!p3.steiner && (equals(p3, p3.next) || area(p3.prev, p3, p3.next) === 0)) {
      removeNode(p3);
      p3 = end = p3.prev;
      if (p3 === p3.next) break;
      again = true;
    } else {
      p3 = p3.next;
    }
  } while (again || p3 !== end);
  return end;
}
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass2) {
  if (!ear) return;
  if (!pass2 && invSize) indexCurve(ear, minX, minY, invSize);
  let stop = ear, prev, next;
  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next = ear.next;
    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      triangles.push(prev.i / dim | 0);
      triangles.push(ear.i / dim | 0);
      triangles.push(next.i / dim | 0);
      removeNode(ear);
      ear = next.next;
      stop = next.next;
      continue;
    }
    ear = next;
    if (ear === stop) {
      if (!pass2) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
      } else if (pass2 === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
      } else if (pass2 === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }
      break;
    }
  }
}
function isEar(ear) {
  const a3 = ear.prev, b = ear, c5 = ear.next;
  if (area(a3, b, c5) >= 0) return false;
  const ax = a3.x, bx = b.x, cx = c5.x, ay = a3.y, by = b.y, cy = c5.y;
  const x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
  let p3 = c5.next;
  while (p3 !== a3) {
    if (p3.x >= x0 && p3.x <= x1 && p3.y >= y0 && p3.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p3.x, p3.y) && area(p3.prev, p3, p3.next) >= 0) return false;
    p3 = p3.next;
  }
  return true;
}
function isEarHashed(ear, minX, minY, invSize) {
  const a3 = ear.prev, b = ear, c5 = ear.next;
  if (area(a3, b, c5) >= 0) return false;
  const ax = a3.x, bx = b.x, cx = c5.x, ay = a3.y, by = b.y, cy = c5.y;
  const x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
  const minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
  let p3 = ear.prevZ, n2 = ear.nextZ;
  while (p3 && p3.z >= minZ && n2 && n2.z <= maxZ) {
    if (p3.x >= x0 && p3.x <= x1 && p3.y >= y0 && p3.y <= y1 && p3 !== a3 && p3 !== c5 && pointInTriangle(ax, ay, bx, by, cx, cy, p3.x, p3.y) && area(p3.prev, p3, p3.next) >= 0) return false;
    p3 = p3.prevZ;
    if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a3 && n2 !== c5 && pointInTriangle(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0) return false;
    n2 = n2.nextZ;
  }
  while (p3 && p3.z >= minZ) {
    if (p3.x >= x0 && p3.x <= x1 && p3.y >= y0 && p3.y <= y1 && p3 !== a3 && p3 !== c5 && pointInTriangle(ax, ay, bx, by, cx, cy, p3.x, p3.y) && area(p3.prev, p3, p3.next) >= 0) return false;
    p3 = p3.prevZ;
  }
  while (n2 && n2.z <= maxZ) {
    if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a3 && n2 !== c5 && pointInTriangle(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0) return false;
    n2 = n2.nextZ;
  }
  return true;
}
function cureLocalIntersections(start2, triangles, dim) {
  let p3 = start2;
  do {
    const a3 = p3.prev, b = p3.next.next;
    if (!equals(a3, b) && intersects(a3, p3, p3.next, b) && locallyInside(a3, b) && locallyInside(b, a3)) {
      triangles.push(a3.i / dim | 0);
      triangles.push(p3.i / dim | 0);
      triangles.push(b.i / dim | 0);
      removeNode(p3);
      removeNode(p3.next);
      p3 = start2 = b;
    }
    p3 = p3.next;
  } while (p3 !== start2);
  return filterPoints(p3);
}
function splitEarcut(start2, triangles, dim, minX, minY, invSize) {
  let a3 = start2;
  do {
    let b = a3.next.next;
    while (b !== a3.prev) {
      if (a3.i !== b.i && isValidDiagonal(a3, b)) {
        let c5 = splitPolygon(a3, b);
        a3 = filterPoints(a3, a3.next);
        c5 = filterPoints(c5, c5.next);
        earcutLinked(a3, triangles, dim, minX, minY, invSize, 0);
        earcutLinked(c5, triangles, dim, minX, minY, invSize, 0);
        return;
      }
      b = b.next;
    }
    a3 = a3.next;
  } while (a3 !== start2);
}
function eliminateHoles(data, holeIndices, outerNode, dim) {
  const queue = [];
  let i2, len, start2, end, list;
  for (i2 = 0, len = holeIndices.length; i2 < len; i2++) {
    start2 = holeIndices[i2] * dim;
    end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
    list = linkedList(data, start2, end, dim, false);
    if (list === list.next) list.steiner = true;
    queue.push(getLeftmost(list));
  }
  queue.sort(compareX);
  for (i2 = 0; i2 < queue.length; i2++) {
    outerNode = eliminateHole(queue[i2], outerNode);
  }
  return outerNode;
}
function compareX(a3, b) {
  return a3.x - b.x;
}
function eliminateHole(hole, outerNode) {
  const bridge = findHoleBridge(hole, outerNode);
  if (!bridge) {
    return outerNode;
  }
  const bridgeReverse = splitPolygon(bridge, hole);
  filterPoints(bridgeReverse, bridgeReverse.next);
  return filterPoints(bridge, bridge.next);
}
function findHoleBridge(hole, outerNode) {
  let p3 = outerNode, qx = -Infinity, m3;
  const hx = hole.x, hy = hole.y;
  do {
    if (hy <= p3.y && hy >= p3.next.y && p3.next.y !== p3.y) {
      const x3 = p3.x + (hy - p3.y) * (p3.next.x - p3.x) / (p3.next.y - p3.y);
      if (x3 <= hx && x3 > qx) {
        qx = x3;
        m3 = p3.x < p3.next.x ? p3 : p3.next;
        if (x3 === hx) return m3;
      }
    }
    p3 = p3.next;
  } while (p3 !== outerNode);
  if (!m3) return null;
  const stop = m3, mx = m3.x, my = m3.y;
  let tanMin = Infinity, tan2;
  p3 = m3;
  do {
    if (hx >= p3.x && p3.x >= mx && hx !== p3.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p3.x, p3.y)) {
      tan2 = Math.abs(hy - p3.y) / (hx - p3.x);
      if (locallyInside(p3, hole) && (tan2 < tanMin || tan2 === tanMin && (p3.x > m3.x || p3.x === m3.x && sectorContainsSector(m3, p3)))) {
        m3 = p3;
        tanMin = tan2;
      }
    }
    p3 = p3.next;
  } while (p3 !== stop);
  return m3;
}
function sectorContainsSector(m3, p3) {
  return area(m3.prev, m3, p3.prev) < 0 && area(p3.next, m3, m3.next) < 0;
}
function indexCurve(start2, minX, minY, invSize) {
  let p3 = start2;
  do {
    if (p3.z === 0) p3.z = zOrder(p3.x, p3.y, minX, minY, invSize);
    p3.prevZ = p3.prev;
    p3.nextZ = p3.next;
    p3 = p3.next;
  } while (p3 !== start2);
  p3.prevZ.nextZ = null;
  p3.prevZ = null;
  sortLinked(p3);
}
function sortLinked(list) {
  let i2, p3, q2, e3, tail2, numMerges, pSize, qSize, inSize = 1;
  do {
    p3 = list;
    list = null;
    tail2 = null;
    numMerges = 0;
    while (p3) {
      numMerges++;
      q2 = p3;
      pSize = 0;
      for (i2 = 0; i2 < inSize; i2++) {
        pSize++;
        q2 = q2.nextZ;
        if (!q2) break;
      }
      qSize = inSize;
      while (pSize > 0 || qSize > 0 && q2) {
        if (pSize !== 0 && (qSize === 0 || !q2 || p3.z <= q2.z)) {
          e3 = p3;
          p3 = p3.nextZ;
          pSize--;
        } else {
          e3 = q2;
          q2 = q2.nextZ;
          qSize--;
        }
        if (tail2) tail2.nextZ = e3;
        else list = e3;
        e3.prevZ = tail2;
        tail2 = e3;
      }
      p3 = q2;
    }
    tail2.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list;
}
function zOrder(x3, y3, minX, minY, invSize) {
  x3 = (x3 - minX) * invSize | 0;
  y3 = (y3 - minY) * invSize | 0;
  x3 = (x3 | x3 << 8) & 16711935;
  x3 = (x3 | x3 << 4) & 252645135;
  x3 = (x3 | x3 << 2) & 858993459;
  x3 = (x3 | x3 << 1) & 1431655765;
  y3 = (y3 | y3 << 8) & 16711935;
  y3 = (y3 | y3 << 4) & 252645135;
  y3 = (y3 | y3 << 2) & 858993459;
  y3 = (y3 | y3 << 1) & 1431655765;
  return x3 | y3 << 1;
}
function getLeftmost(start2) {
  let p3 = start2, leftmost = start2;
  do {
    if (p3.x < leftmost.x || p3.x === leftmost.x && p3.y < leftmost.y) leftmost = p3;
    p3 = p3.next;
  } while (p3 !== start2);
  return leftmost;
}
function pointInTriangle(ax, ay, bx, by, cx, cy, px2, py2) {
  return (cx - px2) * (ay - py2) >= (ax - px2) * (cy - py2) && (ax - px2) * (by - py2) >= (bx - px2) * (ay - py2) && (bx - px2) * (cy - py2) >= (cx - px2) * (by - py2);
}
function isValidDiagonal(a3, b) {
  return a3.next.i !== b.i && a3.prev.i !== b.i && !intersectsPolygon(a3, b) && // dones't intersect other edges
  (locallyInside(a3, b) && locallyInside(b, a3) && middleInside(a3, b) && // locally visible
  (area(a3.prev, a3, b.prev) || area(a3, b.prev, b)) || // does not create opposite-facing sectors
  equals(a3, b) && area(a3.prev, a3, a3.next) > 0 && area(b.prev, b, b.next) > 0);
}
function area(p3, q2, r2) {
  return (q2.y - p3.y) * (r2.x - q2.x) - (q2.x - p3.x) * (r2.y - q2.y);
}
function equals(p1, p22) {
  return p1.x === p22.x && p1.y === p22.y;
}
function intersects(p1, q12, p22, q2) {
  const o1 = sign(area(p1, q12, p22));
  const o2 = sign(area(p1, q12, q2));
  const o3 = sign(area(p22, q2, p1));
  const o4 = sign(area(p22, q2, q12));
  if (o1 !== o2 && o3 !== o4) return true;
  if (o1 === 0 && onSegment(p1, p22, q12)) return true;
  if (o2 === 0 && onSegment(p1, q2, q12)) return true;
  if (o3 === 0 && onSegment(p22, p1, q2)) return true;
  if (o4 === 0 && onSegment(p22, q12, q2)) return true;
  return false;
}
function onSegment(p3, q2, r2) {
  return q2.x <= Math.max(p3.x, r2.x) && q2.x >= Math.min(p3.x, r2.x) && q2.y <= Math.max(p3.y, r2.y) && q2.y >= Math.min(p3.y, r2.y);
}
function sign(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
}
function intersectsPolygon(a3, b) {
  let p3 = a3;
  do {
    if (p3.i !== a3.i && p3.next.i !== a3.i && p3.i !== b.i && p3.next.i !== b.i && intersects(p3, p3.next, a3, b)) return true;
    p3 = p3.next;
  } while (p3 !== a3);
  return false;
}
function locallyInside(a3, b) {
  return area(a3.prev, a3, a3.next) < 0 ? area(a3, b, a3.next) >= 0 && area(a3, a3.prev, b) >= 0 : area(a3, b, a3.prev) < 0 || area(a3, a3.next, b) < 0;
}
function middleInside(a3, b) {
  let p3 = a3, inside = false;
  const px2 = (a3.x + b.x) / 2, py2 = (a3.y + b.y) / 2;
  do {
    if (p3.y > py2 !== p3.next.y > py2 && p3.next.y !== p3.y && px2 < (p3.next.x - p3.x) * (py2 - p3.y) / (p3.next.y - p3.y) + p3.x)
      inside = !inside;
    p3 = p3.next;
  } while (p3 !== a3);
  return inside;
}
function splitPolygon(a3, b) {
  const a22 = new Node2(a3.i, a3.x, a3.y), b23 = new Node2(b.i, b.x, b.y), an = a3.next, bp = b.prev;
  a3.next = b;
  b.prev = a3;
  a22.next = an;
  an.prev = a22;
  b23.next = a22;
  a22.prev = b23;
  bp.next = b23;
  b23.prev = bp;
  return b23;
}
function insertNode(i2, x3, y3, last2) {
  const p3 = new Node2(i2, x3, y3);
  if (!last2) {
    p3.prev = p3;
    p3.next = p3;
  } else {
    p3.next = last2.next;
    p3.prev = last2;
    last2.next.prev = p3;
    last2.next = p3;
  }
  return p3;
}
function removeNode(p3) {
  p3.next.prev = p3.prev;
  p3.prev.next = p3.next;
  if (p3.prevZ) p3.prevZ.nextZ = p3.nextZ;
  if (p3.nextZ) p3.nextZ.prevZ = p3.prevZ;
}
function Node2(i2, x3, y3) {
  this.i = i2;
  this.x = x3;
  this.y = y3;
  this.prev = null;
  this.next = null;
  this.z = 0;
  this.prevZ = null;
  this.nextZ = null;
  this.steiner = false;
}
function signedArea(data, start2, end, dim) {
  let sum3 = 0;
  for (let i2 = start2, j2 = end - dim; i2 < end; i2 += dim) {
    sum3 += (data[j2] - data[i2]) * (data[i2 + 1] + data[j2 + 1]);
    j2 = i2;
  }
  return sum3;
}
var ShapeUtils = class _ShapeUtils {
  // calculate area of the contour polygon
  static area(contour) {
    const n2 = contour.length;
    let a3 = 0;
    for (let p3 = n2 - 1, q2 = 0; q2 < n2; p3 = q2++) {
      a3 += contour[p3].x * contour[q2].y - contour[q2].x * contour[p3].y;
    }
    return a3 * 0.5;
  }
  static isClockWise(pts) {
    return _ShapeUtils.area(pts) < 0;
  }
  static triangulateShape(contour, holes) {
    const vertices = [];
    const holeIndices = [];
    const faces = [];
    removeDupEndPts(contour);
    addContour(vertices, contour);
    let holeIndex = contour.length;
    holes.forEach(removeDupEndPts);
    for (let i2 = 0; i2 < holes.length; i2++) {
      holeIndices.push(holeIndex);
      holeIndex += holes[i2].length;
      addContour(vertices, holes[i2]);
    }
    const triangles = Earcut.triangulate(vertices, holeIndices);
    for (let i2 = 0; i2 < triangles.length; i2 += 3) {
      faces.push(triangles.slice(i2, i2 + 3));
    }
    return faces;
  }
};
function removeDupEndPts(points) {
  const l2 = points.length;
  if (l2 > 2 && points[l2 - 1].equals(points[0])) {
    points.pop();
  }
}
function addContour(vertices, contour) {
  for (let i2 = 0; i2 < contour.length; i2++) {
    vertices.push(contour[i2].x);
    vertices.push(contour[i2].y);
  }
}
var ExtrudeGeometry = class _ExtrudeGeometry extends BufferGeometry2 {
  constructor(shapes = new Shape([new Vector22(0.5, 0.5), new Vector22(-0.5, 0.5), new Vector22(-0.5, -0.5), new Vector22(0.5, -0.5)]), options = {}) {
    super();
    this.type = "ExtrudeGeometry";
    this.parameters = {
      shapes,
      options
    };
    shapes = Array.isArray(shapes) ? shapes : [shapes];
    const scope = this;
    const verticesArray = [];
    const uvArray = [];
    for (let i2 = 0, l2 = shapes.length; i2 < l2; i2++) {
      const shape = shapes[i2];
      addShape(shape);
    }
    this.setAttribute("position", new Float32BufferAttribute2(verticesArray, 3));
    this.setAttribute("uv", new Float32BufferAttribute2(uvArray, 2));
    this.computeVertexNormals();
    function addShape(shape) {
      const placeholder = [];
      const curveSegments = options.curveSegments !== void 0 ? options.curveSegments : 12;
      const steps = options.steps !== void 0 ? options.steps : 1;
      const depth2 = options.depth !== void 0 ? options.depth : 1;
      let bevelEnabled = options.bevelEnabled !== void 0 ? options.bevelEnabled : true;
      let bevelThickness = options.bevelThickness !== void 0 ? options.bevelThickness : 0.2;
      let bevelSize = options.bevelSize !== void 0 ? options.bevelSize : bevelThickness - 0.1;
      let bevelOffset = options.bevelOffset !== void 0 ? options.bevelOffset : 0;
      let bevelSegments = options.bevelSegments !== void 0 ? options.bevelSegments : 3;
      const extrudePath = options.extrudePath;
      const uvgen = options.UVGenerator !== void 0 ? options.UVGenerator : WorldUVGenerator;
      let extrudePts, extrudeByPath = false;
      let splineTube, binormal, normal2, position2;
      if (extrudePath) {
        extrudePts = extrudePath.getSpacedPoints(steps);
        extrudeByPath = true;
        bevelEnabled = false;
        splineTube = extrudePath.computeFrenetFrames(steps, false);
        binormal = new Vector32();
        normal2 = new Vector32();
        position2 = new Vector32();
      }
      if (!bevelEnabled) {
        bevelSegments = 0;
        bevelThickness = 0;
        bevelSize = 0;
        bevelOffset = 0;
      }
      const shapePoints = shape.extractPoints(curveSegments);
      let vertices = shapePoints.shape;
      const holes = shapePoints.holes;
      const reverse3 = !ShapeUtils.isClockWise(vertices);
      if (reverse3) {
        vertices = vertices.reverse();
        for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
          const ahole = holes[h2];
          if (ShapeUtils.isClockWise(ahole)) {
            holes[h2] = ahole.reverse();
          }
        }
      }
      const faces = ShapeUtils.triangulateShape(vertices, holes);
      const contour = vertices;
      for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
        const ahole = holes[h2];
        vertices = vertices.concat(ahole);
      }
      function scalePt2(pt, vec, size2) {
        if (!vec) console.error("THREE.ExtrudeGeometry: vec does not exist");
        return pt.clone().addScaledVector(vec, size2);
      }
      const vlen = vertices.length, flen = faces.length;
      function getBevelVec(inPt, inPrev, inNext) {
        let v_trans_x, v_trans_y, shrink_by;
        const v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
        const v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
        const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
        const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
        if (Math.abs(collinear0) > Number.EPSILON) {
          const v_prev_len = Math.sqrt(v_prev_lensq);
          const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
          const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
          const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
          const ptNextShift_x = inNext.x - v_next_y / v_next_len;
          const ptNextShift_y = inNext.y + v_next_x / v_next_len;
          const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
          v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
          v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
          const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
          if (v_trans_lensq <= 2) {
            return new Vector22(v_trans_x, v_trans_y);
          } else {
            shrink_by = Math.sqrt(v_trans_lensq / 2);
          }
        } else {
          let direction_eq = false;
          if (v_prev_x > Number.EPSILON) {
            if (v_next_x > Number.EPSILON) {
              direction_eq = true;
            }
          } else {
            if (v_prev_x < -Number.EPSILON) {
              if (v_next_x < -Number.EPSILON) {
                direction_eq = true;
              }
            } else {
              if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                direction_eq = true;
              }
            }
          }
          if (direction_eq) {
            v_trans_x = -v_prev_y;
            v_trans_y = v_prev_x;
            shrink_by = Math.sqrt(v_prev_lensq);
          } else {
            v_trans_x = v_prev_x;
            v_trans_y = v_prev_y;
            shrink_by = Math.sqrt(v_prev_lensq / 2);
          }
        }
        return new Vector22(v_trans_x / shrink_by, v_trans_y / shrink_by);
      }
      const contourMovements = [];
      for (let i2 = 0, il = contour.length, j2 = il - 1, k2 = i2 + 1; i2 < il; i2++, j2++, k2++) {
        if (j2 === il) j2 = 0;
        if (k2 === il) k2 = 0;
        contourMovements[i2] = getBevelVec(contour[i2], contour[j2], contour[k2]);
      }
      const holesMovements = [];
      let oneHoleMovements, verticesMovements = contourMovements.concat();
      for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
        const ahole = holes[h2];
        oneHoleMovements = [];
        for (let i2 = 0, il = ahole.length, j2 = il - 1, k2 = i2 + 1; i2 < il; i2++, j2++, k2++) {
          if (j2 === il) j2 = 0;
          if (k2 === il) k2 = 0;
          oneHoleMovements[i2] = getBevelVec(ahole[i2], ahole[j2], ahole[k2]);
        }
        holesMovements.push(oneHoleMovements);
        verticesMovements = verticesMovements.concat(oneHoleMovements);
      }
      for (let b = 0; b < bevelSegments; b++) {
        const t5 = b / bevelSegments;
        const z3 = bevelThickness * Math.cos(t5 * Math.PI / 2);
        const bs2 = bevelSize * Math.sin(t5 * Math.PI / 2) + bevelOffset;
        for (let i2 = 0, il = contour.length; i2 < il; i2++) {
          const vert = scalePt2(contour[i2], contourMovements[i2], bs2);
          v2(vert.x, vert.y, -z3);
        }
        for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
          const ahole = holes[h2];
          oneHoleMovements = holesMovements[h2];
          for (let i2 = 0, il = ahole.length; i2 < il; i2++) {
            const vert = scalePt2(ahole[i2], oneHoleMovements[i2], bs2);
            v2(vert.x, vert.y, -z3);
          }
        }
      }
      const bs = bevelSize + bevelOffset;
      for (let i2 = 0; i2 < vlen; i2++) {
        const vert = bevelEnabled ? scalePt2(vertices[i2], verticesMovements[i2], bs) : vertices[i2];
        if (!extrudeByPath) {
          v2(vert.x, vert.y, 0);
        } else {
          normal2.copy(splineTube.normals[0]).multiplyScalar(vert.x);
          binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
          position2.copy(extrudePts[0]).add(normal2).add(binormal);
          v2(position2.x, position2.y, position2.z);
        }
      }
      for (let s2 = 1; s2 <= steps; s2++) {
        for (let i2 = 0; i2 < vlen; i2++) {
          const vert = bevelEnabled ? scalePt2(vertices[i2], verticesMovements[i2], bs) : vertices[i2];
          if (!extrudeByPath) {
            v2(vert.x, vert.y, depth2 / steps * s2);
          } else {
            normal2.copy(splineTube.normals[s2]).multiplyScalar(vert.x);
            binormal.copy(splineTube.binormals[s2]).multiplyScalar(vert.y);
            position2.copy(extrudePts[s2]).add(normal2).add(binormal);
            v2(position2.x, position2.y, position2.z);
          }
        }
      }
      for (let b = bevelSegments - 1; b >= 0; b--) {
        const t5 = b / bevelSegments;
        const z3 = bevelThickness * Math.cos(t5 * Math.PI / 2);
        const bs2 = bevelSize * Math.sin(t5 * Math.PI / 2) + bevelOffset;
        for (let i2 = 0, il = contour.length; i2 < il; i2++) {
          const vert = scalePt2(contour[i2], contourMovements[i2], bs2);
          v2(vert.x, vert.y, depth2 + z3);
        }
        for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
          const ahole = holes[h2];
          oneHoleMovements = holesMovements[h2];
          for (let i2 = 0, il = ahole.length; i2 < il; i2++) {
            const vert = scalePt2(ahole[i2], oneHoleMovements[i2], bs2);
            if (!extrudeByPath) {
              v2(vert.x, vert.y, depth2 + z3);
            } else {
              v2(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z3);
            }
          }
        }
      }
      buildLidFaces();
      buildSideFaces();
      function buildLidFaces() {
        const start2 = verticesArray.length / 3;
        if (bevelEnabled) {
          let layer = 0;
          let offset = vlen * layer;
          for (let i2 = 0; i2 < flen; i2++) {
            const face = faces[i2];
            f3(face[2] + offset, face[1] + offset, face[0] + offset);
          }
          layer = steps + bevelSegments * 2;
          offset = vlen * layer;
          for (let i2 = 0; i2 < flen; i2++) {
            const face = faces[i2];
            f3(face[0] + offset, face[1] + offset, face[2] + offset);
          }
        } else {
          for (let i2 = 0; i2 < flen; i2++) {
            const face = faces[i2];
            f3(face[2], face[1], face[0]);
          }
          for (let i2 = 0; i2 < flen; i2++) {
            const face = faces[i2];
            f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
          }
        }
        scope.addGroup(start2, verticesArray.length / 3 - start2, 0);
      }
      function buildSideFaces() {
        const start2 = verticesArray.length / 3;
        let layeroffset = 0;
        sidewalls(contour, layeroffset);
        layeroffset += contour.length;
        for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
          const ahole = holes[h2];
          sidewalls(ahole, layeroffset);
          layeroffset += ahole.length;
        }
        scope.addGroup(start2, verticesArray.length / 3 - start2, 1);
      }
      function sidewalls(contour2, layeroffset) {
        let i2 = contour2.length;
        while (--i2 >= 0) {
          const j2 = i2;
          let k2 = i2 - 1;
          if (k2 < 0) k2 = contour2.length - 1;
          for (let s2 = 0, sl = steps + bevelSegments * 2; s2 < sl; s2++) {
            const slen1 = vlen * s2;
            const slen2 = vlen * (s2 + 1);
            const a3 = layeroffset + j2 + slen1, b = layeroffset + k2 + slen1, c5 = layeroffset + k2 + slen2, d3 = layeroffset + j2 + slen2;
            f4(a3, b, c5, d3);
          }
        }
      }
      function v2(x3, y3, z3) {
        placeholder.push(x3);
        placeholder.push(y3);
        placeholder.push(z3);
      }
      function f3(a3, b, c5) {
        addVertex(a3);
        addVertex(b);
        addVertex(c5);
        const nextIndex = verticesArray.length / 3;
        const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[2]);
      }
      function f4(a3, b, c5, d3) {
        addVertex(a3);
        addVertex(b);
        addVertex(d3);
        addVertex(b);
        addVertex(c5);
        addVertex(d3);
        const nextIndex = verticesArray.length / 3;
        const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[3]);
        addUV(uvs[1]);
        addUV(uvs[2]);
        addUV(uvs[3]);
      }
      function addVertex(index8) {
        verticesArray.push(placeholder[index8 * 3 + 0]);
        verticesArray.push(placeholder[index8 * 3 + 1]);
        verticesArray.push(placeholder[index8 * 3 + 2]);
      }
      function addUV(vector2) {
        uvArray.push(vector2.x);
        uvArray.push(vector2.y);
      }
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    const shapes = this.parameters.shapes;
    const options = this.parameters.options;
    return toJSON$1(shapes, options, data);
  }
  static fromJSON(data, shapes) {
    const geometryShapes = [];
    for (let j2 = 0, jl = data.shapes.length; j2 < jl; j2++) {
      const shape = shapes[data.shapes[j2]];
      geometryShapes.push(shape);
    }
    const extrudePath = data.options.extrudePath;
    if (extrudePath !== void 0) {
      data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
    }
    return new _ExtrudeGeometry(geometryShapes, data.options);
  }
};
var WorldUVGenerator = {
  generateTopUV: function(geometry, vertices, indexA, indexB, indexC) {
    const a_x = vertices[indexA * 3];
    const a_y = vertices[indexA * 3 + 1];
    const b_x = vertices[indexB * 3];
    const b_y = vertices[indexB * 3 + 1];
    const c_x = vertices[indexC * 3];
    const c_y = vertices[indexC * 3 + 1];
    return [
      new Vector22(a_x, a_y),
      new Vector22(b_x, b_y),
      new Vector22(c_x, c_y)
    ];
  },
  generateSideWallUV: function(geometry, vertices, indexA, indexB, indexC, indexD) {
    const a_x = vertices[indexA * 3];
    const a_y = vertices[indexA * 3 + 1];
    const a_z = vertices[indexA * 3 + 2];
    const b_x = vertices[indexB * 3];
    const b_y = vertices[indexB * 3 + 1];
    const b_z = vertices[indexB * 3 + 2];
    const c_x = vertices[indexC * 3];
    const c_y = vertices[indexC * 3 + 1];
    const c_z = vertices[indexC * 3 + 2];
    const d_x = vertices[indexD * 3];
    const d_y = vertices[indexD * 3 + 1];
    const d_z = vertices[indexD * 3 + 2];
    if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {
      return [
        new Vector22(a_x, 1 - a_z),
        new Vector22(b_x, 1 - b_z),
        new Vector22(c_x, 1 - c_z),
        new Vector22(d_x, 1 - d_z)
      ];
    } else {
      return [
        new Vector22(a_y, 1 - a_z),
        new Vector22(b_y, 1 - b_z),
        new Vector22(c_y, 1 - c_z),
        new Vector22(d_y, 1 - d_z)
      ];
    }
  }
};
function toJSON$1(shapes, options, data) {
  data.shapes = [];
  if (Array.isArray(shapes)) {
    for (let i2 = 0, l2 = shapes.length; i2 < l2; i2++) {
      const shape = shapes[i2];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }
  data.options = Object.assign({}, options);
  if (options.extrudePath !== void 0) data.options.extrudePath = options.extrudePath.toJSON();
  return data;
}
var IcosahedronGeometry = class _IcosahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const t5 = (1 + Math.sqrt(5)) / 2;
    const vertices = [
      -1,
      t5,
      0,
      1,
      t5,
      0,
      -1,
      -t5,
      0,
      1,
      -t5,
      0,
      0,
      -1,
      t5,
      0,
      1,
      t5,
      0,
      -1,
      -t5,
      0,
      1,
      -t5,
      t5,
      0,
      -1,
      t5,
      0,
      1,
      -t5,
      0,
      -1,
      -t5,
      0,
      1
    ];
    const indices = [
      0,
      11,
      5,
      0,
      5,
      1,
      0,
      1,
      7,
      0,
      7,
      10,
      0,
      10,
      11,
      1,
      5,
      9,
      5,
      11,
      4,
      11,
      10,
      2,
      10,
      7,
      6,
      7,
      1,
      8,
      3,
      9,
      4,
      3,
      4,
      2,
      3,
      2,
      6,
      3,
      6,
      8,
      3,
      8,
      9,
      4,
      9,
      5,
      2,
      4,
      11,
      6,
      2,
      10,
      8,
      6,
      7,
      9,
      8,
      1
    ];
    super(vertices, indices, radius, detail);
    this.type = "IcosahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
  static fromJSON(data) {
    return new _IcosahedronGeometry(data.radius, data.detail);
  }
};
var OctahedronGeometry = class _OctahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const vertices = [
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1
    ];
    const indices = [
      0,
      2,
      4,
      0,
      4,
      3,
      0,
      3,
      5,
      0,
      5,
      2,
      1,
      2,
      5,
      1,
      5,
      3,
      1,
      3,
      4,
      1,
      4,
      2
    ];
    super(vertices, indices, radius, detail);
    this.type = "OctahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
  static fromJSON(data) {
    return new _OctahedronGeometry(data.radius, data.detail);
  }
};
var RingGeometry = class _RingGeometry extends BufferGeometry2 {
  constructor(innerRadius = 0.5, outerRadius = 1, thetaSegments = 32, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = "RingGeometry";
    this.parameters = {
      innerRadius,
      outerRadius,
      thetaSegments,
      phiSegments,
      thetaStart,
      thetaLength
    };
    thetaSegments = Math.max(3, thetaSegments);
    phiSegments = Math.max(1, phiSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let radius = innerRadius;
    const radiusStep = (outerRadius - innerRadius) / phiSegments;
    const vertex = new Vector32();
    const uv2 = new Vector22();
    for (let j2 = 0; j2 <= phiSegments; j2++) {
      for (let i2 = 0; i2 <= thetaSegments; i2++) {
        const segment = thetaStart + i2 / thetaSegments * thetaLength;
        vertex.x = radius * Math.cos(segment);
        vertex.y = radius * Math.sin(segment);
        vertices.push(vertex.x, vertex.y, vertex.z);
        normals.push(0, 0, 1);
        uv2.x = (vertex.x / outerRadius + 1) / 2;
        uv2.y = (vertex.y / outerRadius + 1) / 2;
        uvs.push(uv2.x, uv2.y);
      }
      radius += radiusStep;
    }
    for (let j2 = 0; j2 < phiSegments; j2++) {
      const thetaSegmentLevel = j2 * (thetaSegments + 1);
      for (let i2 = 0; i2 < thetaSegments; i2++) {
        const segment = i2 + thetaSegmentLevel;
        const a3 = segment;
        const b = segment + thetaSegments + 1;
        const c5 = segment + thetaSegments + 2;
        const d3 = segment + 1;
        indices.push(a3, b, d3);
        indices.push(b, c5, d3);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new _RingGeometry(data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
  }
};
var ShapeGeometry = class _ShapeGeometry extends BufferGeometry2 {
  constructor(shapes = new Shape([new Vector22(0, 0.5), new Vector22(-0.5, -0.5), new Vector22(0.5, -0.5)]), curveSegments = 12) {
    super();
    this.type = "ShapeGeometry";
    this.parameters = {
      shapes,
      curveSegments
    };
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let groupStart = 0;
    let groupCount = 0;
    if (Array.isArray(shapes) === false) {
      addShape(shapes);
    } else {
      for (let i2 = 0; i2 < shapes.length; i2++) {
        addShape(shapes[i2]);
        this.addGroup(groupStart, groupCount, i2);
        groupStart += groupCount;
        groupCount = 0;
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
    function addShape(shape) {
      const indexOffset = vertices.length / 3;
      const points = shape.extractPoints(curveSegments);
      let shapeVertices = points.shape;
      const shapeHoles = points.holes;
      if (ShapeUtils.isClockWise(shapeVertices) === false) {
        shapeVertices = shapeVertices.reverse();
      }
      for (let i2 = 0, l2 = shapeHoles.length; i2 < l2; i2++) {
        const shapeHole = shapeHoles[i2];
        if (ShapeUtils.isClockWise(shapeHole) === true) {
          shapeHoles[i2] = shapeHole.reverse();
        }
      }
      const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
      for (let i2 = 0, l2 = shapeHoles.length; i2 < l2; i2++) {
        const shapeHole = shapeHoles[i2];
        shapeVertices = shapeVertices.concat(shapeHole);
      }
      for (let i2 = 0, l2 = shapeVertices.length; i2 < l2; i2++) {
        const vertex = shapeVertices[i2];
        vertices.push(vertex.x, vertex.y, 0);
        normals.push(0, 0, 1);
        uvs.push(vertex.x, vertex.y);
      }
      for (let i2 = 0, l2 = faces.length; i2 < l2; i2++) {
        const face = faces[i2];
        const a3 = face[0] + indexOffset;
        const b = face[1] + indexOffset;
        const c5 = face[2] + indexOffset;
        indices.push(a3, b, c5);
        groupCount += 3;
      }
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    const shapes = this.parameters.shapes;
    return toJSON(shapes, data);
  }
  static fromJSON(data, shapes) {
    const geometryShapes = [];
    for (let j2 = 0, jl = data.shapes.length; j2 < jl; j2++) {
      const shape = shapes[data.shapes[j2]];
      geometryShapes.push(shape);
    }
    return new _ShapeGeometry(geometryShapes, data.curveSegments);
  }
};
function toJSON(shapes, data) {
  data.shapes = [];
  if (Array.isArray(shapes)) {
    for (let i2 = 0, l2 = shapes.length; i2 < l2; i2++) {
      const shape = shapes[i2];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }
  return data;
}
var SphereGeometry2 = class _SphereGeometry extends BufferGeometry2 {
  constructor(radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
    super();
    this.type = "SphereGeometry";
    this.parameters = {
      radius,
      widthSegments,
      heightSegments,
      phiStart,
      phiLength,
      thetaStart,
      thetaLength
    };
    widthSegments = Math.max(3, Math.floor(widthSegments));
    heightSegments = Math.max(2, Math.floor(heightSegments));
    const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
    let index8 = 0;
    const grid = [];
    const vertex = new Vector32();
    const normal2 = new Vector32();
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy = 0; iy <= heightSegments; iy++) {
      const verticesRow = [];
      const v2 = iy / heightSegments;
      let uOffset = 0;
      if (iy === 0 && thetaStart === 0) {
        uOffset = 0.5 / widthSegments;
      } else if (iy === heightSegments && thetaEnd === Math.PI) {
        uOffset = -0.5 / widthSegments;
      }
      for (let ix = 0; ix <= widthSegments; ix++) {
        const u2 = ix / widthSegments;
        vertex.x = -radius * Math.cos(phiStart + u2 * phiLength) * Math.sin(thetaStart + v2 * thetaLength);
        vertex.y = radius * Math.cos(thetaStart + v2 * thetaLength);
        vertex.z = radius * Math.sin(phiStart + u2 * phiLength) * Math.sin(thetaStart + v2 * thetaLength);
        vertices.push(vertex.x, vertex.y, vertex.z);
        normal2.copy(vertex).normalize();
        normals.push(normal2.x, normal2.y, normal2.z);
        uvs.push(u2 + uOffset, 1 - v2);
        verticesRow.push(index8++);
      }
      grid.push(verticesRow);
    }
    for (let iy = 0; iy < heightSegments; iy++) {
      for (let ix = 0; ix < widthSegments; ix++) {
        const a3 = grid[iy][ix + 1];
        const b = grid[iy][ix];
        const c5 = grid[iy + 1][ix];
        const d3 = grid[iy + 1][ix + 1];
        if (iy !== 0 || thetaStart > 0) indices.push(a3, b, d3);
        if (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c5, d3);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new _SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
  }
};
var TetrahedronGeometry = class _TetrahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const vertices = [
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1
    ];
    const indices = [
      2,
      1,
      0,
      0,
      3,
      2,
      1,
      3,
      0,
      2,
      3,
      1
    ];
    super(vertices, indices, radius, detail);
    this.type = "TetrahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
  static fromJSON(data) {
    return new _TetrahedronGeometry(data.radius, data.detail);
  }
};
var TorusGeometry = class _TorusGeometry extends BufferGeometry2 {
  constructor(radius = 1, tube = 0.4, radialSegments = 12, tubularSegments = 48, arc = Math.PI * 2) {
    super();
    this.type = "TorusGeometry";
    this.parameters = {
      radius,
      tube,
      radialSegments,
      tubularSegments,
      arc
    };
    radialSegments = Math.floor(radialSegments);
    tubularSegments = Math.floor(tubularSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    const center = new Vector32();
    const vertex = new Vector32();
    const normal2 = new Vector32();
    for (let j2 = 0; j2 <= radialSegments; j2++) {
      for (let i2 = 0; i2 <= tubularSegments; i2++) {
        const u2 = i2 / tubularSegments * arc;
        const v2 = j2 / radialSegments * Math.PI * 2;
        vertex.x = (radius + tube * Math.cos(v2)) * Math.cos(u2);
        vertex.y = (radius + tube * Math.cos(v2)) * Math.sin(u2);
        vertex.z = tube * Math.sin(v2);
        vertices.push(vertex.x, vertex.y, vertex.z);
        center.x = radius * Math.cos(u2);
        center.y = radius * Math.sin(u2);
        normal2.subVectors(vertex, center).normalize();
        normals.push(normal2.x, normal2.y, normal2.z);
        uvs.push(i2 / tubularSegments);
        uvs.push(j2 / radialSegments);
      }
    }
    for (let j2 = 1; j2 <= radialSegments; j2++) {
      for (let i2 = 1; i2 <= tubularSegments; i2++) {
        const a3 = (tubularSegments + 1) * j2 + i2 - 1;
        const b = (tubularSegments + 1) * (j2 - 1) + i2 - 1;
        const c5 = (tubularSegments + 1) * (j2 - 1) + i2;
        const d3 = (tubularSegments + 1) * j2 + i2;
        indices.push(a3, b, d3);
        indices.push(b, c5, d3);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new _TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
  }
};
var TorusKnotGeometry = class _TorusKnotGeometry extends BufferGeometry2 {
  constructor(radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p3 = 2, q2 = 3) {
    super();
    this.type = "TorusKnotGeometry";
    this.parameters = {
      radius,
      tube,
      tubularSegments,
      radialSegments,
      p: p3,
      q: q2
    };
    tubularSegments = Math.floor(tubularSegments);
    radialSegments = Math.floor(radialSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    const vertex = new Vector32();
    const normal2 = new Vector32();
    const P1 = new Vector32();
    const P2 = new Vector32();
    const B4 = new Vector32();
    const T3 = new Vector32();
    const N3 = new Vector32();
    for (let i2 = 0; i2 <= tubularSegments; ++i2) {
      const u2 = i2 / tubularSegments * p3 * Math.PI * 2;
      calculatePositionOnCurve(u2, p3, q2, radius, P1);
      calculatePositionOnCurve(u2 + 0.01, p3, q2, radius, P2);
      T3.subVectors(P2, P1);
      N3.addVectors(P2, P1);
      B4.crossVectors(T3, N3);
      N3.crossVectors(B4, T3);
      B4.normalize();
      N3.normalize();
      for (let j2 = 0; j2 <= radialSegments; ++j2) {
        const v2 = j2 / radialSegments * Math.PI * 2;
        const cx = -tube * Math.cos(v2);
        const cy = tube * Math.sin(v2);
        vertex.x = P1.x + (cx * N3.x + cy * B4.x);
        vertex.y = P1.y + (cx * N3.y + cy * B4.y);
        vertex.z = P1.z + (cx * N3.z + cy * B4.z);
        vertices.push(vertex.x, vertex.y, vertex.z);
        normal2.subVectors(vertex, P1).normalize();
        normals.push(normal2.x, normal2.y, normal2.z);
        uvs.push(i2 / tubularSegments);
        uvs.push(j2 / radialSegments);
      }
    }
    for (let j2 = 1; j2 <= tubularSegments; j2++) {
      for (let i2 = 1; i2 <= radialSegments; i2++) {
        const a3 = (radialSegments + 1) * (j2 - 1) + (i2 - 1);
        const b = (radialSegments + 1) * j2 + (i2 - 1);
        const c5 = (radialSegments + 1) * j2 + i2;
        const d3 = (radialSegments + 1) * (j2 - 1) + i2;
        indices.push(a3, b, d3);
        indices.push(b, c5, d3);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
    function calculatePositionOnCurve(u2, p4, q3, radius2, position) {
      const cu = Math.cos(u2);
      const su = Math.sin(u2);
      const quOverP = q3 / p4 * u2;
      const cs = Math.cos(quOverP);
      position.x = radius2 * (2 + cs) * 0.5 * cu;
      position.y = radius2 * (2 + cs) * su * 0.5;
      position.z = radius2 * Math.sin(quOverP) * 0.5;
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new _TorusKnotGeometry(data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
  }
};
var TubeGeometry2 = class _TubeGeometry extends BufferGeometry2 {
  constructor(path = new QuadraticBezierCurve32(new Vector32(-1, -1, 0), new Vector32(-1, 1, 0), new Vector32(1, 1, 0)), tubularSegments = 64, radius = 1, radialSegments = 8, closed = false) {
    super();
    this.type = "TubeGeometry";
    this.parameters = {
      path,
      tubularSegments,
      radius,
      radialSegments,
      closed
    };
    const frames = path.computeFrenetFrames(tubularSegments, closed);
    this.tangents = frames.tangents;
    this.normals = frames.normals;
    this.binormals = frames.binormals;
    const vertex = new Vector32();
    const normal2 = new Vector32();
    const uv2 = new Vector22();
    let P2 = new Vector32();
    const vertices = [];
    const normals = [];
    const uvs = [];
    const indices = [];
    generateBufferData();
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
    function generateBufferData() {
      for (let i2 = 0; i2 < tubularSegments; i2++) {
        generateSegment(i2);
      }
      generateSegment(closed === false ? tubularSegments : 0);
      generateUVs();
      generateIndices();
    }
    function generateSegment(i2) {
      P2 = path.getPointAt(i2 / tubularSegments, P2);
      const N3 = frames.normals[i2];
      const B4 = frames.binormals[i2];
      for (let j2 = 0; j2 <= radialSegments; j2++) {
        const v2 = j2 / radialSegments * Math.PI * 2;
        const sin4 = Math.sin(v2);
        const cos4 = -Math.cos(v2);
        normal2.x = cos4 * N3.x + sin4 * B4.x;
        normal2.y = cos4 * N3.y + sin4 * B4.y;
        normal2.z = cos4 * N3.z + sin4 * B4.z;
        normal2.normalize();
        normals.push(normal2.x, normal2.y, normal2.z);
        vertex.x = P2.x + radius * normal2.x;
        vertex.y = P2.y + radius * normal2.y;
        vertex.z = P2.z + radius * normal2.z;
        vertices.push(vertex.x, vertex.y, vertex.z);
      }
    }
    function generateIndices() {
      for (let j2 = 1; j2 <= tubularSegments; j2++) {
        for (let i2 = 1; i2 <= radialSegments; i2++) {
          const a3 = (radialSegments + 1) * (j2 - 1) + (i2 - 1);
          const b = (radialSegments + 1) * j2 + (i2 - 1);
          const c5 = (radialSegments + 1) * j2 + i2;
          const d3 = (radialSegments + 1) * (j2 - 1) + i2;
          indices.push(a3, b, d3);
          indices.push(b, c5, d3);
        }
      }
    }
    function generateUVs() {
      for (let i2 = 0; i2 <= tubularSegments; i2++) {
        for (let j2 = 0; j2 <= radialSegments; j2++) {
          uv2.x = i2 / tubularSegments;
          uv2.y = j2 / radialSegments;
          uvs.push(uv2.x, uv2.y);
        }
      }
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.path = this.parameters.path.toJSON();
    return data;
  }
  static fromJSON(data) {
    return new _TubeGeometry(
      new Curves[data.path.type]().fromJSON(data.path),
      data.tubularSegments,
      data.radius,
      data.radialSegments,
      data.closed
    );
  }
};
var WireframeGeometry = class extends BufferGeometry2 {
  constructor(geometry = null) {
    super();
    this.type = "WireframeGeometry";
    this.parameters = {
      geometry
    };
    if (geometry !== null) {
      const vertices = [];
      const edges = /* @__PURE__ */ new Set();
      const start2 = new Vector32();
      const end = new Vector32();
      if (geometry.index !== null) {
        const position = geometry.attributes.position;
        const indices = geometry.index;
        let groups2 = geometry.groups;
        if (groups2.length === 0) {
          groups2 = [{ start: 0, count: indices.count, materialIndex: 0 }];
        }
        for (let o2 = 0, ol = groups2.length; o2 < ol; ++o2) {
          const group2 = groups2[o2];
          const groupStart = group2.start;
          const groupCount = group2.count;
          for (let i2 = groupStart, l2 = groupStart + groupCount; i2 < l2; i2 += 3) {
            for (let j2 = 0; j2 < 3; j2++) {
              const index1 = indices.getX(i2 + j2);
              const index22 = indices.getX(i2 + (j2 + 1) % 3);
              start2.fromBufferAttribute(position, index1);
              end.fromBufferAttribute(position, index22);
              if (isUniqueEdge(start2, end, edges) === true) {
                vertices.push(start2.x, start2.y, start2.z);
                vertices.push(end.x, end.y, end.z);
              }
            }
          }
        }
      } else {
        const position = geometry.attributes.position;
        for (let i2 = 0, l2 = position.count / 3; i2 < l2; i2++) {
          for (let j2 = 0; j2 < 3; j2++) {
            const index1 = 3 * i2 + j2;
            const index22 = 3 * i2 + (j2 + 1) % 3;
            start2.fromBufferAttribute(position, index1);
            end.fromBufferAttribute(position, index22);
            if (isUniqueEdge(start2, end, edges) === true) {
              vertices.push(start2.x, start2.y, start2.z);
              vertices.push(end.x, end.y, end.z);
            }
          }
        }
      }
      this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
};
function isUniqueEdge(start2, end, edges) {
  const hash1 = `${start2.x},${start2.y},${start2.z}-${end.x},${end.y},${end.z}`;
  const hash2 = `${end.x},${end.y},${end.z}-${start2.x},${start2.y},${start2.z}`;
  if (edges.has(hash1) === true || edges.has(hash2) === true) {
    return false;
  } else {
    edges.add(hash1);
    edges.add(hash2);
    return true;
  }
}
var Geometries = Object.freeze({
  __proto__: null,
  BoxGeometry: BoxGeometry2,
  CapsuleGeometry,
  CircleGeometry,
  ConeGeometry: ConeGeometry2,
  CylinderGeometry: CylinderGeometry2,
  DodecahedronGeometry,
  EdgesGeometry,
  ExtrudeGeometry,
  IcosahedronGeometry,
  LatheGeometry,
  OctahedronGeometry,
  PlaneGeometry: PlaneGeometry2,
  PolyhedronGeometry,
  RingGeometry,
  ShapeGeometry,
  SphereGeometry: SphereGeometry2,
  TetrahedronGeometry,
  TorusGeometry,
  TorusKnotGeometry,
  TubeGeometry: TubeGeometry2,
  WireframeGeometry
});
var MeshPhongMaterial2 = class extends Material2 {
  constructor(parameters) {
    super();
    this.isMeshPhongMaterial = true;
    this.type = "MeshPhongMaterial";
    this.color = new Color2(16777215);
    this.specular = new Color2(1118481);
    this.shininess = 30;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color2(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap2;
    this.normalScale = new Vector22(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.envMapRotation = new Euler2();
    this.combine = MultiplyOperation2;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.flatShading = false;
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.specular.copy(source.specular);
    this.shininess = source.shininess;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.envMapRotation.copy(source.envMapRotation);
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.flatShading = source.flatShading;
    this.fog = source.fog;
    return this;
  }
};
var MeshLambertMaterial2 = class extends Material2 {
  constructor(parameters) {
    super();
    this.isMeshLambertMaterial = true;
    this.type = "MeshLambertMaterial";
    this.color = new Color2(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color2(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap2;
    this.normalScale = new Vector22(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.envMapRotation = new Euler2();
    this.combine = MultiplyOperation2;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.flatShading = false;
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.envMapRotation.copy(source.envMapRotation);
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.flatShading = source.flatShading;
    this.fog = source.fog;
    return this;
  }
};
function convertArray(array4, type, forceClone) {
  if (!array4 || // let 'undefined' and 'null' pass
  !forceClone && array4.constructor === type) return array4;
  if (typeof type.BYTES_PER_ELEMENT === "number") {
    return new type(array4);
  }
  return Array.prototype.slice.call(array4);
}
function isTypedArray2(object) {
  return ArrayBuffer.isView(object) && !(object instanceof DataView);
}
function getKeyframeOrder(times2) {
  function compareTime(i2, j2) {
    return times2[i2] - times2[j2];
  }
  const n2 = times2.length;
  const result2 = new Array(n2);
  for (let i2 = 0; i2 !== n2; ++i2) result2[i2] = i2;
  result2.sort(compareTime);
  return result2;
}
function sortedArray(values2, stride, order) {
  const nValues = values2.length;
  const result2 = new values2.constructor(nValues);
  for (let i2 = 0, dstOffset = 0; dstOffset !== nValues; ++i2) {
    const srcOffset = order[i2] * stride;
    for (let j2 = 0; j2 !== stride; ++j2) {
      result2[dstOffset++] = values2[srcOffset + j2];
    }
  }
  return result2;
}
function flattenJSON(jsonKeys, times2, values2, valuePropertyName) {
  let i2 = 1, key = jsonKeys[0];
  while (key !== void 0 && key[valuePropertyName] === void 0) {
    key = jsonKeys[i2++];
  }
  if (key === void 0) return;
  let value = key[valuePropertyName];
  if (value === void 0) return;
  if (Array.isArray(value)) {
    do {
      value = key[valuePropertyName];
      if (value !== void 0) {
        times2.push(key.time);
        values2.push.apply(values2, value);
      }
      key = jsonKeys[i2++];
    } while (key !== void 0);
  } else if (value.toArray !== void 0) {
    do {
      value = key[valuePropertyName];
      if (value !== void 0) {
        times2.push(key.time);
        value.toArray(values2, values2.length);
      }
      key = jsonKeys[i2++];
    } while (key !== void 0);
  } else {
    do {
      value = key[valuePropertyName];
      if (value !== void 0) {
        times2.push(key.time);
        values2.push(value);
      }
      key = jsonKeys[i2++];
    } while (key !== void 0);
  }
}
var Interpolant = class {
  constructor(parameterPositions, sampleValues, sampleSize2, resultBuffer) {
    this.parameterPositions = parameterPositions;
    this._cachedIndex = 0;
    this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize2);
    this.sampleValues = sampleValues;
    this.valueSize = sampleSize2;
    this.settings = null;
    this.DefaultSettings_ = {};
  }
  evaluate(t5) {
    const pp = this.parameterPositions;
    let i1 = this._cachedIndex, t13 = pp[i1], t03 = pp[i1 - 1];
    validate_interval: {
      seek: {
        let right;
        linear_scan: {
          forward_scan: if (!(t5 < t13)) {
            for (let giveUpAt = i1 + 2; ; ) {
              if (t13 === void 0) {
                if (t5 < t03) break forward_scan;
                i1 = pp.length;
                this._cachedIndex = i1;
                return this.copySampleValue_(i1 - 1);
              }
              if (i1 === giveUpAt) break;
              t03 = t13;
              t13 = pp[++i1];
              if (t5 < t13) {
                break seek;
              }
            }
            right = pp.length;
            break linear_scan;
          }
          if (!(t5 >= t03)) {
            const t1global = pp[1];
            if (t5 < t1global) {
              i1 = 2;
              t03 = t1global;
            }
            for (let giveUpAt = i1 - 2; ; ) {
              if (t03 === void 0) {
                this._cachedIndex = 0;
                return this.copySampleValue_(0);
              }
              if (i1 === giveUpAt) break;
              t13 = t03;
              t03 = pp[--i1 - 1];
              if (t5 >= t03) {
                break seek;
              }
            }
            right = i1;
            i1 = 0;
            break linear_scan;
          }
          break validate_interval;
        }
        while (i1 < right) {
          const mid = i1 + right >>> 1;
          if (t5 < pp[mid]) {
            right = mid;
          } else {
            i1 = mid + 1;
          }
        }
        t13 = pp[i1];
        t03 = pp[i1 - 1];
        if (t03 === void 0) {
          this._cachedIndex = 0;
          return this.copySampleValue_(0);
        }
        if (t13 === void 0) {
          i1 = pp.length;
          this._cachedIndex = i1;
          return this.copySampleValue_(i1 - 1);
        }
      }
      this._cachedIndex = i1;
      this.intervalChanged_(i1, t03, t13);
    }
    return this.interpolate_(i1, t03, t5, t13);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(index8) {
    const result2 = this.resultBuffer, values2 = this.sampleValues, stride = this.valueSize, offset = index8 * stride;
    for (let i2 = 0; i2 !== stride; ++i2) {
      result2[i2] = values2[offset + i2];
    }
    return result2;
  }
  // Template methods for derived classes:
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {
  }
};
var CubicInterpolant = class extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize2, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize2, resultBuffer);
    this._weightPrev = -0;
    this._offsetPrev = -0;
    this._weightNext = -0;
    this._offsetNext = -0;
    this.DefaultSettings_ = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    };
  }
  intervalChanged_(i1, t03, t13) {
    const pp = this.parameterPositions;
    let iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
    if (tPrev === void 0) {
      switch (this.getSettings_().endingStart) {
        case ZeroSlopeEnding:
          iPrev = i1;
          tPrev = 2 * t03 - t13;
          break;
        case WrapAroundEnding:
          iPrev = pp.length - 2;
          tPrev = t03 + pp[iPrev] - pp[iPrev + 1];
          break;
        default:
          iPrev = i1;
          tPrev = t13;
      }
    }
    if (tNext === void 0) {
      switch (this.getSettings_().endingEnd) {
        case ZeroSlopeEnding:
          iNext = i1;
          tNext = 2 * t13 - t03;
          break;
        case WrapAroundEnding:
          iNext = 1;
          tNext = t13 + pp[1] - pp[0];
          break;
        default:
          iNext = i1 - 1;
          tNext = t03;
      }
    }
    const halfDt = (t13 - t03) * 0.5, stride = this.valueSize;
    this._weightPrev = halfDt / (t03 - tPrev);
    this._weightNext = halfDt / (tNext - t13);
    this._offsetPrev = iPrev * stride;
    this._offsetNext = iNext * stride;
  }
  interpolate_(i1, t03, t5, t13) {
    const result2 = this.resultBuffer, values2 = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p3 = (t5 - t03) / (t13 - t03), pp = p3 * p3, ppp = pp * p3;
    const sP = -wP * ppp + 2 * wP * pp - wP * p3;
    const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p3 + 1;
    const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p3;
    const sN = wN * ppp - wN * pp;
    for (let i2 = 0; i2 !== stride; ++i2) {
      result2[i2] = sP * values2[oP + i2] + s0 * values2[o0 + i2] + s1 * values2[o1 + i2] + sN * values2[oN + i2];
    }
    return result2;
  }
};
var LinearInterpolant = class extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize2, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize2, resultBuffer);
  }
  interpolate_(i1, t03, t5, t13) {
    const result2 = this.resultBuffer, values2 = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t5 - t03) / (t13 - t03), weight0 = 1 - weight1;
    for (let i2 = 0; i2 !== stride; ++i2) {
      result2[i2] = values2[offset0 + i2] * weight0 + values2[offset1 + i2] * weight1;
    }
    return result2;
  }
};
var DiscreteInterpolant = class extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize2, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize2, resultBuffer);
  }
  interpolate_(i1) {
    return this.copySampleValue_(i1 - 1);
  }
};
var KeyframeTrack = class {
  constructor(name, times2, values2, interpolation) {
    if (name === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (times2 === void 0 || times2.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name);
    this.name = name;
    this.times = convertArray(times2, this.TimeBufferType);
    this.values = convertArray(values2, this.ValueBufferType);
    this.setInterpolation(interpolation || this.DefaultInterpolation);
  }
  // Serialization (in static context, because of constructor invocation
  // and automatic invocation of .toJSON):
  static toJSON(track) {
    const trackType = track.constructor;
    let json;
    if (trackType.toJSON !== this.toJSON) {
      json = trackType.toJSON(track);
    } else {
      json = {
        "name": track.name,
        "times": convertArray(track.times, Array),
        "values": convertArray(track.values, Array)
      };
      const interpolation = track.getInterpolation();
      if (interpolation !== track.DefaultInterpolation) {
        json.interpolation = interpolation;
      }
    }
    json.type = track.ValueTypeName;
    return json;
  }
  InterpolantFactoryMethodDiscrete(result2) {
    return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result2);
  }
  InterpolantFactoryMethodLinear(result2) {
    return new LinearInterpolant(this.times, this.values, this.getValueSize(), result2);
  }
  InterpolantFactoryMethodSmooth(result2) {
    return new CubicInterpolant(this.times, this.values, this.getValueSize(), result2);
  }
  setInterpolation(interpolation) {
    let factoryMethod;
    switch (interpolation) {
      case InterpolateDiscrete:
        factoryMethod = this.InterpolantFactoryMethodDiscrete;
        break;
      case InterpolateLinear:
        factoryMethod = this.InterpolantFactoryMethodLinear;
        break;
      case InterpolateSmooth:
        factoryMethod = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (factoryMethod === void 0) {
      const message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0) {
        if (interpolation !== this.DefaultInterpolation) {
          this.setInterpolation(this.DefaultInterpolation);
        } else {
          throw new Error(message);
        }
      }
      console.warn("THREE.KeyframeTrack:", message);
      return this;
    }
    this.createInterpolant = factoryMethod;
    return this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return InterpolateDiscrete;
      case this.InterpolantFactoryMethodLinear:
        return InterpolateLinear;
      case this.InterpolantFactoryMethodSmooth:
        return InterpolateSmooth;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  // move all keyframes either forwards or backwards in time
  shift(timeOffset) {
    if (timeOffset !== 0) {
      const times2 = this.times;
      for (let i2 = 0, n2 = times2.length; i2 !== n2; ++i2) {
        times2[i2] += timeOffset;
      }
    }
    return this;
  }
  // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  scale(timeScale) {
    if (timeScale !== 1) {
      const times2 = this.times;
      for (let i2 = 0, n2 = times2.length; i2 !== n2; ++i2) {
        times2[i2] *= timeScale;
      }
    }
    return this;
  }
  // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  trim(startTime, endTime) {
    const times2 = this.times, nKeys = times2.length;
    let from = 0, to = nKeys - 1;
    while (from !== nKeys && times2[from] < startTime) {
      ++from;
    }
    while (to !== -1 && times2[to] > endTime) {
      --to;
    }
    ++to;
    if (from !== 0 || to !== nKeys) {
      if (from >= to) {
        to = Math.max(to, 1);
        from = to - 1;
      }
      const stride = this.getValueSize();
      this.times = times2.slice(from, to);
      this.values = this.values.slice(from * stride, to * stride);
    }
    return this;
  }
  // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  validate() {
    let valid = true;
    const valueSize = this.getValueSize();
    if (valueSize - Math.floor(valueSize) !== 0) {
      console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
      valid = false;
    }
    const times2 = this.times, values2 = this.values, nKeys = times2.length;
    if (nKeys === 0) {
      console.error("THREE.KeyframeTrack: Track is empty.", this);
      valid = false;
    }
    let prevTime = null;
    for (let i2 = 0; i2 !== nKeys; i2++) {
      const currTime = times2[i2];
      if (typeof currTime === "number" && isNaN(currTime)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i2, currTime);
        valid = false;
        break;
      }
      if (prevTime !== null && prevTime > currTime) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, i2, currTime, prevTime);
        valid = false;
        break;
      }
      prevTime = currTime;
    }
    if (values2 !== void 0) {
      if (isTypedArray2(values2)) {
        for (let i2 = 0, n2 = values2.length; i2 !== n2; ++i2) {
          const value = values2[i2];
          if (isNaN(value)) {
            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i2, value);
            valid = false;
            break;
          }
        }
      }
    }
    return valid;
  }
  // removes equivalent sequential keys as common in morph target sequences
  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  optimize() {
    const times2 = this.times.slice(), values2 = this.values.slice(), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times2.length - 1;
    let writeIndex = 1;
    for (let i2 = 1; i2 < lastIndex; ++i2) {
      let keep = false;
      const time3 = times2[i2];
      const timeNext = times2[i2 + 1];
      if (time3 !== timeNext && (i2 !== 1 || time3 !== times2[0])) {
        if (!smoothInterpolation) {
          const offset = i2 * stride, offsetP = offset - stride, offsetN = offset + stride;
          for (let j2 = 0; j2 !== stride; ++j2) {
            const value = values2[offset + j2];
            if (value !== values2[offsetP + j2] || value !== values2[offsetN + j2]) {
              keep = true;
              break;
            }
          }
        } else {
          keep = true;
        }
      }
      if (keep) {
        if (i2 !== writeIndex) {
          times2[writeIndex] = times2[i2];
          const readOffset = i2 * stride, writeOffset = writeIndex * stride;
          for (let j2 = 0; j2 !== stride; ++j2) {
            values2[writeOffset + j2] = values2[readOffset + j2];
          }
        }
        ++writeIndex;
      }
    }
    if (lastIndex > 0) {
      times2[writeIndex] = times2[lastIndex];
      for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j2 = 0; j2 !== stride; ++j2) {
        values2[writeOffset + j2] = values2[readOffset + j2];
      }
      ++writeIndex;
    }
    if (writeIndex !== times2.length) {
      this.times = times2.slice(0, writeIndex);
      this.values = values2.slice(0, writeIndex * stride);
    } else {
      this.times = times2;
      this.values = values2;
    }
    return this;
  }
  clone() {
    const times2 = this.times.slice();
    const values2 = this.values.slice();
    const TypedKeyframeTrack = this.constructor;
    const track = new TypedKeyframeTrack(this.name, times2, values2);
    track.createInterpolant = this.createInterpolant;
    return track;
  }
};
KeyframeTrack.prototype.TimeBufferType = Float32Array;
KeyframeTrack.prototype.ValueBufferType = Float32Array;
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
var BooleanKeyframeTrack = class extends KeyframeTrack {
};
BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
BooleanKeyframeTrack.prototype.ValueBufferType = Array;
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
var ColorKeyframeTrack = class extends KeyframeTrack {
};
ColorKeyframeTrack.prototype.ValueTypeName = "color";
var NumberKeyframeTrack = class extends KeyframeTrack {
};
NumberKeyframeTrack.prototype.ValueTypeName = "number";
var QuaternionLinearInterpolant = class extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize2, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize2, resultBuffer);
  }
  interpolate_(i1, t03, t5, t13) {
    const result2 = this.resultBuffer, values2 = this.sampleValues, stride = this.valueSize, alpha = (t5 - t03) / (t13 - t03);
    let offset = i1 * stride;
    for (let end = offset + stride; offset !== end; offset += 4) {
      Quaternion2.slerpFlat(result2, 0, values2, offset - stride, values2, offset, alpha);
    }
    return result2;
  }
};
var QuaternionKeyframeTrack = class extends KeyframeTrack {
  InterpolantFactoryMethodLinear(result2) {
    return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result2);
  }
};
QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
var StringKeyframeTrack = class extends KeyframeTrack {
};
StringKeyframeTrack.prototype.ValueTypeName = "string";
StringKeyframeTrack.prototype.ValueBufferType = Array;
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
var VectorKeyframeTrack = class extends KeyframeTrack {
};
VectorKeyframeTrack.prototype.ValueTypeName = "vector";
var AnimationClip = class {
  constructor(name = "", duration = -1, tracks = [], blendMode = NormalAnimationBlendMode) {
    this.name = name;
    this.tracks = tracks;
    this.duration = duration;
    this.blendMode = blendMode;
    this.uuid = generateUUID();
    if (this.duration < 0) {
      this.resetDuration();
    }
  }
  static parse(json) {
    const tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
    for (let i2 = 0, n2 = jsonTracks.length; i2 !== n2; ++i2) {
      tracks.push(parseKeyframeTrack(jsonTracks[i2]).scale(frameTime));
    }
    const clip = new this(json.name, json.duration, tracks, json.blendMode);
    clip.uuid = json.uuid;
    return clip;
  }
  static toJSON(clip) {
    const tracks = [], clipTracks = clip.tracks;
    const json = {
      "name": clip.name,
      "duration": clip.duration,
      "tracks": tracks,
      "uuid": clip.uuid,
      "blendMode": clip.blendMode
    };
    for (let i2 = 0, n2 = clipTracks.length; i2 !== n2; ++i2) {
      tracks.push(KeyframeTrack.toJSON(clipTracks[i2]));
    }
    return json;
  }
  static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
    const numMorphTargets = morphTargetSequence.length;
    const tracks = [];
    for (let i2 = 0; i2 < numMorphTargets; i2++) {
      let times2 = [];
      let values2 = [];
      times2.push(
        (i2 + numMorphTargets - 1) % numMorphTargets,
        i2,
        (i2 + 1) % numMorphTargets
      );
      values2.push(0, 1, 0);
      const order = getKeyframeOrder(times2);
      times2 = sortedArray(times2, 1, order);
      values2 = sortedArray(values2, 1, order);
      if (!noLoop && times2[0] === 0) {
        times2.push(numMorphTargets);
        values2.push(values2[0]);
      }
      tracks.push(
        new NumberKeyframeTrack(
          ".morphTargetInfluences[" + morphTargetSequence[i2].name + "]",
          times2,
          values2
        ).scale(1 / fps)
      );
    }
    return new this(name, -1, tracks);
  }
  static findByName(objectOrClipArray, name) {
    let clipArray = objectOrClipArray;
    if (!Array.isArray(objectOrClipArray)) {
      const o2 = objectOrClipArray;
      clipArray = o2.geometry && o2.geometry.animations || o2.animations;
    }
    for (let i2 = 0; i2 < clipArray.length; i2++) {
      if (clipArray[i2].name === name) {
        return clipArray[i2];
      }
    }
    return null;
  }
  static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
    const animationToMorphTargets = {};
    const pattern = /^([\w-]*?)([\d]+)$/;
    for (let i2 = 0, il = morphTargets.length; i2 < il; i2++) {
      const morphTarget = morphTargets[i2];
      const parts = morphTarget.name.match(pattern);
      if (parts && parts.length > 1) {
        const name = parts[1];
        let animationMorphTargets = animationToMorphTargets[name];
        if (!animationMorphTargets) {
          animationToMorphTargets[name] = animationMorphTargets = [];
        }
        animationMorphTargets.push(morphTarget);
      }
    }
    const clips = [];
    for (const name in animationToMorphTargets) {
      clips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
    }
    return clips;
  }
  // parse the animation.hierarchy format
  static parseAnimation(animation, bones) {
    if (!animation) {
      console.error("THREE.AnimationClip: No animation in JSONLoader data.");
      return null;
    }
    const addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
      if (animationKeys.length !== 0) {
        const times2 = [];
        const values2 = [];
        flattenJSON(animationKeys, times2, values2, propertyName);
        if (times2.length !== 0) {
          destTracks.push(new trackType(trackName, times2, values2));
        }
      }
    };
    const tracks = [];
    const clipName = animation.name || "default";
    const fps = animation.fps || 30;
    const blendMode = animation.blendMode;
    let duration = animation.length || -1;
    const hierarchyTracks = animation.hierarchy || [];
    for (let h2 = 0; h2 < hierarchyTracks.length; h2++) {
      const animationKeys = hierarchyTracks[h2].keys;
      if (!animationKeys || animationKeys.length === 0) continue;
      if (animationKeys[0].morphTargets) {
        const morphTargetNames = {};
        let k2;
        for (k2 = 0; k2 < animationKeys.length; k2++) {
          if (animationKeys[k2].morphTargets) {
            for (let m3 = 0; m3 < animationKeys[k2].morphTargets.length; m3++) {
              morphTargetNames[animationKeys[k2].morphTargets[m3]] = -1;
            }
          }
        }
        for (const morphTargetName in morphTargetNames) {
          const times2 = [];
          const values2 = [];
          for (let m3 = 0; m3 !== animationKeys[k2].morphTargets.length; ++m3) {
            const animationKey = animationKeys[k2];
            times2.push(animationKey.time);
            values2.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
          }
          tracks.push(new NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]", times2, values2));
        }
        duration = morphTargetNames.length * fps;
      } else {
        const boneName = ".bones[" + bones[h2].name + "]";
        addNonemptyTrack(
          VectorKeyframeTrack,
          boneName + ".position",
          animationKeys,
          "pos",
          tracks
        );
        addNonemptyTrack(
          QuaternionKeyframeTrack,
          boneName + ".quaternion",
          animationKeys,
          "rot",
          tracks
        );
        addNonemptyTrack(
          VectorKeyframeTrack,
          boneName + ".scale",
          animationKeys,
          "scl",
          tracks
        );
      }
    }
    if (tracks.length === 0) {
      return null;
    }
    const clip = new this(clipName, duration, tracks, blendMode);
    return clip;
  }
  resetDuration() {
    const tracks = this.tracks;
    let duration = 0;
    for (let i2 = 0, n2 = tracks.length; i2 !== n2; ++i2) {
      const track = this.tracks[i2];
      duration = Math.max(duration, track.times[track.times.length - 1]);
    }
    this.duration = duration;
    return this;
  }
  trim() {
    for (let i2 = 0; i2 < this.tracks.length; i2++) {
      this.tracks[i2].trim(0, this.duration);
    }
    return this;
  }
  validate() {
    let valid = true;
    for (let i2 = 0; i2 < this.tracks.length; i2++) {
      valid = valid && this.tracks[i2].validate();
    }
    return valid;
  }
  optimize() {
    for (let i2 = 0; i2 < this.tracks.length; i2++) {
      this.tracks[i2].optimize();
    }
    return this;
  }
  clone() {
    const tracks = [];
    for (let i2 = 0; i2 < this.tracks.length; i2++) {
      tracks.push(this.tracks[i2].clone());
    }
    return new this.constructor(this.name, this.duration, tracks, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
};
function getTrackTypeForValueTypeName(typeName) {
  switch (typeName.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return NumberKeyframeTrack;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return VectorKeyframeTrack;
    case "color":
      return ColorKeyframeTrack;
    case "quaternion":
      return QuaternionKeyframeTrack;
    case "bool":
    case "boolean":
      return BooleanKeyframeTrack;
    case "string":
      return StringKeyframeTrack;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + typeName);
}
function parseKeyframeTrack(json) {
  if (json.type === void 0) {
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  }
  const trackType = getTrackTypeForValueTypeName(json.type);
  if (json.times === void 0) {
    const times2 = [], values2 = [];
    flattenJSON(json.keys, times2, values2, "value");
    json.times = times2;
    json.values = values2;
  }
  if (trackType.parse !== void 0) {
    return trackType.parse(json);
  } else {
    return new trackType(json.name, json.times, json.values, json.interpolation);
  }
}
var Cache = {
  enabled: false,
  files: {},
  add: function(key, file) {
    if (this.enabled === false) return;
    this.files[key] = file;
  },
  get: function(key) {
    if (this.enabled === false) return;
    return this.files[key];
  },
  remove: function(key) {
    delete this.files[key];
  },
  clear: function() {
    this.files = {};
  }
};
var LoadingManager = class {
  constructor(onLoad, onProgress, onError) {
    const scope = this;
    let isLoading = false;
    let itemsLoaded = 0;
    let itemsTotal = 0;
    let urlModifier = void 0;
    const handlers = [];
    this.onStart = void 0;
    this.onLoad = onLoad;
    this.onProgress = onProgress;
    this.onError = onError;
    this.itemStart = function(url) {
      itemsTotal++;
      if (isLoading === false) {
        if (scope.onStart !== void 0) {
          scope.onStart(url, itemsLoaded, itemsTotal);
        }
      }
      isLoading = true;
    };
    this.itemEnd = function(url) {
      itemsLoaded++;
      if (scope.onProgress !== void 0) {
        scope.onProgress(url, itemsLoaded, itemsTotal);
      }
      if (itemsLoaded === itemsTotal) {
        isLoading = false;
        if (scope.onLoad !== void 0) {
          scope.onLoad();
        }
      }
    };
    this.itemError = function(url) {
      if (scope.onError !== void 0) {
        scope.onError(url);
      }
    };
    this.resolveURL = function(url) {
      if (urlModifier) {
        return urlModifier(url);
      }
      return url;
    };
    this.setURLModifier = function(transform3) {
      urlModifier = transform3;
      return this;
    };
    this.addHandler = function(regex, loader) {
      handlers.push(regex, loader);
      return this;
    };
    this.removeHandler = function(regex) {
      const index8 = handlers.indexOf(regex);
      if (index8 !== -1) {
        handlers.splice(index8, 2);
      }
      return this;
    };
    this.getHandler = function(file) {
      for (let i2 = 0, l2 = handlers.length; i2 < l2; i2 += 2) {
        const regex = handlers[i2];
        const loader = handlers[i2 + 1];
        if (regex.global) regex.lastIndex = 0;
        if (regex.test(file)) {
          return loader;
        }
      }
      return null;
    };
  }
};
var DefaultLoadingManager = new LoadingManager();
var Loader = class {
  constructor(manager) {
    this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
    this.crossOrigin = "anonymous";
    this.withCredentials = false;
    this.path = "";
    this.resourcePath = "";
    this.requestHeader = {};
  }
  load() {
  }
  loadAsync(url, onProgress) {
    const scope = this;
    return new Promise(function(resolve, reject2) {
      scope.load(url, resolve, onProgress, reject2);
    });
  }
  parse() {
  }
  setCrossOrigin(crossOrigin) {
    this.crossOrigin = crossOrigin;
    return this;
  }
  setWithCredentials(value) {
    this.withCredentials = value;
    return this;
  }
  setPath(path) {
    this.path = path;
    return this;
  }
  setResourcePath(resourcePath) {
    this.resourcePath = resourcePath;
    return this;
  }
  setRequestHeader(requestHeader) {
    this.requestHeader = requestHeader;
    return this;
  }
};
Loader.DEFAULT_MATERIAL_NAME = "__DEFAULT";
var loading = {};
var HttpError = class extends Error {
  constructor(message, response) {
    super(message);
    this.response = response;
  }
};
var FileLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    if (url === void 0) url = "";
    if (this.path !== void 0) url = this.path + url;
    url = this.manager.resolveURL(url);
    const cached = Cache.get(url);
    if (cached !== void 0) {
      this.manager.itemStart(url);
      setTimeout(() => {
        if (onLoad) onLoad(cached);
        this.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    if (loading[url] !== void 0) {
      loading[url].push({
        onLoad,
        onProgress,
        onError
      });
      return;
    }
    loading[url] = [];
    loading[url].push({
      onLoad,
      onProgress,
      onError
    });
    const req = new Request(url, {
      headers: new Headers(this.requestHeader),
      credentials: this.withCredentials ? "include" : "same-origin"
      // An abort controller could be added within a future PR
    });
    const mimeType = this.mimeType;
    const responseType = this.responseType;
    fetch(req).then((response) => {
      if (response.status === 200 || response.status === 0) {
        if (response.status === 0) {
          console.warn("THREE.FileLoader: HTTP Status 0 received.");
        }
        if (typeof ReadableStream === "undefined" || response.body === void 0 || response.body.getReader === void 0) {
          return response;
        }
        const callbacks = loading[url];
        const reader = response.body.getReader();
        const contentLength = response.headers.get("X-File-Size") || response.headers.get("Content-Length");
        const total = contentLength ? parseInt(contentLength) : 0;
        const lengthComputable = total !== 0;
        let loaded = 0;
        const stream = new ReadableStream({
          start(controller) {
            readData();
            function readData() {
              reader.read().then(({ done, value }) => {
                if (done) {
                  controller.close();
                } else {
                  loaded += value.byteLength;
                  const event = new ProgressEvent("progress", { lengthComputable, loaded, total });
                  for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
                    const callback = callbacks[i2];
                    if (callback.onProgress) callback.onProgress(event);
                  }
                  controller.enqueue(value);
                  readData();
                }
              });
            }
          }
        });
        return new Response(stream);
      } else {
        throw new HttpError(`fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`, response);
      }
    }).then((response) => {
      switch (responseType) {
        case "arraybuffer":
          return response.arrayBuffer();
        case "blob":
          return response.blob();
        case "document":
          return response.text().then((text) => {
            const parser = new DOMParser();
            return parser.parseFromString(text, mimeType);
          });
        case "json":
          return response.json();
        default:
          if (mimeType === void 0) {
            return response.text();
          } else {
            const re2 = /charset="?([^;"\s]*)"?/i;
            const exec = re2.exec(mimeType);
            const label2 = exec && exec[1] ? exec[1].toLowerCase() : void 0;
            const decoder = new TextDecoder(label2);
            return response.arrayBuffer().then((ab) => decoder.decode(ab));
          }
      }
    }).then((data) => {
      Cache.add(url, data);
      const callbacks = loading[url];
      delete loading[url];
      for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
        const callback = callbacks[i2];
        if (callback.onLoad) callback.onLoad(data);
      }
    }).catch((err2) => {
      const callbacks = loading[url];
      if (callbacks === void 0) {
        this.manager.itemError(url);
        throw err2;
      }
      delete loading[url];
      for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
        const callback = callbacks[i2];
        if (callback.onError) callback.onError(err2);
      }
      this.manager.itemError(url);
    }).finally(() => {
      this.manager.itemEnd(url);
    });
    this.manager.itemStart(url);
  }
  setResponseType(value) {
    this.responseType = value;
    return this;
  }
  setMimeType(value) {
    this.mimeType = value;
    return this;
  }
};
var ImageLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    if (this.path !== void 0) url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function() {
        if (onLoad) onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    const image = createElementNS("img");
    function onImageLoad() {
      removeEventListeners();
      Cache.add(url, this);
      if (onLoad) onLoad(this);
      scope.manager.itemEnd(url);
    }
    function onImageError(event) {
      removeEventListeners();
      if (onError) onError(event);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    }
    function removeEventListeners() {
      image.removeEventListener("load", onImageLoad, false);
      image.removeEventListener("error", onImageError, false);
    }
    image.addEventListener("load", onImageLoad, false);
    image.addEventListener("error", onImageError, false);
    if (url.slice(0, 5) !== "data:") {
      if (this.crossOrigin !== void 0) image.crossOrigin = this.crossOrigin;
    }
    scope.manager.itemStart(url);
    image.src = url;
    return image;
  }
};
var DataTextureLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const texture2 = new DataTexture2();
    const loader = new FileLoader(this.manager);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setPath(this.path);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(url, function(buffer2) {
      let texData;
      try {
        texData = scope.parse(buffer2);
      } catch (error2) {
        if (onError !== void 0) {
          onError(error2);
        } else {
          console.error(error2);
          return;
        }
      }
      if (texData.image !== void 0) {
        texture2.image = texData.image;
      } else if (texData.data !== void 0) {
        texture2.image.width = texData.width;
        texture2.image.height = texData.height;
        texture2.image.data = texData.data;
      }
      texture2.wrapS = texData.wrapS !== void 0 ? texData.wrapS : ClampToEdgeWrapping2;
      texture2.wrapT = texData.wrapT !== void 0 ? texData.wrapT : ClampToEdgeWrapping2;
      texture2.magFilter = texData.magFilter !== void 0 ? texData.magFilter : LinearFilter2;
      texture2.minFilter = texData.minFilter !== void 0 ? texData.minFilter : LinearFilter2;
      texture2.anisotropy = texData.anisotropy !== void 0 ? texData.anisotropy : 1;
      if (texData.colorSpace !== void 0) {
        texture2.colorSpace = texData.colorSpace;
      }
      if (texData.flipY !== void 0) {
        texture2.flipY = texData.flipY;
      }
      if (texData.format !== void 0) {
        texture2.format = texData.format;
      }
      if (texData.type !== void 0) {
        texture2.type = texData.type;
      }
      if (texData.mipmaps !== void 0) {
        texture2.mipmaps = texData.mipmaps;
        texture2.minFilter = LinearMipmapLinearFilter2;
      }
      if (texData.mipmapCount === 1) {
        texture2.minFilter = LinearFilter2;
      }
      if (texData.generateMipmaps !== void 0) {
        texture2.generateMipmaps = texData.generateMipmaps;
      }
      texture2.needsUpdate = true;
      if (onLoad) onLoad(texture2, texData);
    }, onProgress, onError);
    return texture2;
  }
};
var TextureLoader2 = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const texture2 = new Texture2();
    const loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    loader.load(url, function(image) {
      texture2.image = image;
      texture2.needsUpdate = true;
      if (onLoad !== void 0) {
        onLoad(texture2);
      }
    }, onProgress, onError);
    return texture2;
  }
};
var Light = class extends Object3D2 {
  constructor(color3, intensity = 1) {
    super();
    this.isLight = true;
    this.type = "Light";
    this.color = new Color2(color3);
    this.intensity = intensity;
  }
  dispose() {
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.color.copy(source.color);
    this.intensity = source.intensity;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.color = this.color.getHex();
    data.object.intensity = this.intensity;
    if (this.groundColor !== void 0) data.object.groundColor = this.groundColor.getHex();
    if (this.distance !== void 0) data.object.distance = this.distance;
    if (this.angle !== void 0) data.object.angle = this.angle;
    if (this.decay !== void 0) data.object.decay = this.decay;
    if (this.penumbra !== void 0) data.object.penumbra = this.penumbra;
    if (this.shadow !== void 0) data.object.shadow = this.shadow.toJSON();
    return data;
  }
};
var _projScreenMatrix$1 = new Matrix42();
var _lightPositionWorld$1 = new Vector32();
var _lookTarget$1 = new Vector32();
var LightShadow = class {
  constructor(camera3) {
    this.camera = camera3;
    this.bias = 0;
    this.normalBias = 0;
    this.radius = 1;
    this.blurSamples = 8;
    this.mapSize = new Vector22(512, 512);
    this.map = null;
    this.mapPass = null;
    this.matrix = new Matrix42();
    this.autoUpdate = true;
    this.needsUpdate = false;
    this._frustum = new Frustum2();
    this._frameExtents = new Vector22(1, 1);
    this._viewportCount = 1;
    this._viewports = [
      new Vector42(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(light) {
    const shadowCamera = this.camera;
    const shadowMatrix = this.matrix;
    _lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);
    shadowCamera.position.copy(_lightPositionWorld$1);
    _lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);
    shadowCamera.lookAt(_lookTarget$1);
    shadowCamera.updateMatrixWorld();
    _projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
    this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);
    shadowMatrix.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    );
    shadowMatrix.multiply(_projScreenMatrix$1);
  }
  getViewport(viewportIndex) {
    return this._viewports[viewportIndex];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    if (this.map) {
      this.map.dispose();
    }
    if (this.mapPass) {
      this.mapPass.dispose();
    }
  }
  copy(source) {
    this.camera = source.camera.clone();
    this.bias = source.bias;
    this.radius = source.radius;
    this.mapSize.copy(source.mapSize);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const object = {};
    if (this.bias !== 0) object.bias = this.bias;
    if (this.normalBias !== 0) object.normalBias = this.normalBias;
    if (this.radius !== 1) object.radius = this.radius;
    if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();
    object.camera = this.camera.toJSON(false).object;
    delete object.camera.matrix;
    return object;
  }
};
var SpotLightShadow = class extends LightShadow {
  constructor() {
    super(new PerspectiveCamera2(50, 1, 0.5, 500));
    this.isSpotLightShadow = true;
    this.focus = 1;
  }
  updateMatrices(light) {
    const camera3 = this.camera;
    const fov = RAD2DEG2 * 2 * light.angle * this.focus;
    const aspect = this.mapSize.width / this.mapSize.height;
    const far = light.distance || camera3.far;
    if (fov !== camera3.fov || aspect !== camera3.aspect || far !== camera3.far) {
      camera3.fov = fov;
      camera3.aspect = aspect;
      camera3.far = far;
      camera3.updateProjectionMatrix();
    }
    super.updateMatrices(light);
  }
  copy(source) {
    super.copy(source);
    this.focus = source.focus;
    return this;
  }
};
var SpotLight2 = class extends Light {
  constructor(color3, intensity, distance4 = 0, angle2 = Math.PI / 3, penumbra = 0, decay = 2) {
    super(color3, intensity);
    this.isSpotLight = true;
    this.type = "SpotLight";
    this.position.copy(Object3D2.DEFAULT_UP);
    this.updateMatrix();
    this.target = new Object3D2();
    this.distance = distance4;
    this.angle = angle2;
    this.penumbra = penumbra;
    this.decay = decay;
    this.map = null;
    this.shadow = new SpotLightShadow();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(power) {
    this.intensity = power / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.distance = source.distance;
    this.angle = source.angle;
    this.penumbra = source.penumbra;
    this.decay = source.decay;
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
};
var _projScreenMatrix = new Matrix42();
var _lightPositionWorld = new Vector32();
var _lookTarget = new Vector32();
var PointLightShadow = class extends LightShadow {
  constructor() {
    super(new PerspectiveCamera2(90, 1, 0.5, 500));
    this.isPointLightShadow = true;
    this._frameExtents = new Vector22(4, 2);
    this._viewportCount = 6;
    this._viewports = [
      // These viewports map a cube-map onto a 2D texture with the
      // following orientation:
      //
      //  xzXZ
      //   y Y
      //
      // X - Positive x direction
      // x - Negative x direction
      // Y - Positive y direction
      // y - Negative y direction
      // Z - Positive z direction
      // z - Negative z direction
      // positive X
      new Vector42(2, 1, 1, 1),
      // negative X
      new Vector42(0, 1, 1, 1),
      // positive Z
      new Vector42(3, 1, 1, 1),
      // negative Z
      new Vector42(1, 1, 1, 1),
      // positive Y
      new Vector42(3, 0, 1, 1),
      // negative Y
      new Vector42(1, 0, 1, 1)
    ];
    this._cubeDirections = [
      new Vector32(1, 0, 0),
      new Vector32(-1, 0, 0),
      new Vector32(0, 0, 1),
      new Vector32(0, 0, -1),
      new Vector32(0, 1, 0),
      new Vector32(0, -1, 0)
    ];
    this._cubeUps = [
      new Vector32(0, 1, 0),
      new Vector32(0, 1, 0),
      new Vector32(0, 1, 0),
      new Vector32(0, 1, 0),
      new Vector32(0, 0, 1),
      new Vector32(0, 0, -1)
    ];
  }
  updateMatrices(light, viewportIndex = 0) {
    const camera3 = this.camera;
    const shadowMatrix = this.matrix;
    const far = light.distance || camera3.far;
    if (far !== camera3.far) {
      camera3.far = far;
      camera3.updateProjectionMatrix();
    }
    _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
    camera3.position.copy(_lightPositionWorld);
    _lookTarget.copy(camera3.position);
    _lookTarget.add(this._cubeDirections[viewportIndex]);
    camera3.up.copy(this._cubeUps[viewportIndex]);
    camera3.lookAt(_lookTarget);
    camera3.updateMatrixWorld();
    shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
    _projScreenMatrix.multiplyMatrices(camera3.projectionMatrix, camera3.matrixWorldInverse);
    this._frustum.setFromProjectionMatrix(_projScreenMatrix);
  }
};
var PointLight2 = class extends Light {
  constructor(color3, intensity, distance4 = 0, decay = 2) {
    super(color3, intensity);
    this.isPointLight = true;
    this.type = "PointLight";
    this.distance = distance4;
    this.decay = decay;
    this.shadow = new PointLightShadow();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(power) {
    this.intensity = power / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.distance = source.distance;
    this.decay = source.decay;
    this.shadow = source.shadow.clone();
    return this;
  }
};
var DirectionalLightShadow = class extends LightShadow {
  constructor() {
    super(new OrthographicCamera2(-5, 5, 5, -5, 0.5, 500));
    this.isDirectionalLightShadow = true;
  }
};
var DirectionalLight2 = class extends Light {
  constructor(color3, intensity) {
    super(color3, intensity);
    this.isDirectionalLight = true;
    this.type = "DirectionalLight";
    this.position.copy(Object3D2.DEFAULT_UP);
    this.updateMatrix();
    this.target = new Object3D2();
    this.shadow = new DirectionalLightShadow();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(source) {
    super.copy(source);
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
};
var AmbientLight2 = class extends Light {
  constructor(color3, intensity) {
    super(color3, intensity);
    this.isAmbientLight = true;
    this.type = "AmbientLight";
  }
};
var LoaderUtils = class {
  static decodeText(array4) {
    if (typeof TextDecoder !== "undefined") {
      return new TextDecoder().decode(array4);
    }
    let s2 = "";
    for (let i2 = 0, il = array4.length; i2 < il; i2++) {
      s2 += String.fromCharCode(array4[i2]);
    }
    try {
      return decodeURIComponent(escape(s2));
    } catch (e3) {
      return s2;
    }
  }
  static extractUrlBase(url) {
    const index8 = url.lastIndexOf("/");
    if (index8 === -1) return "./";
    return url.slice(0, index8 + 1);
  }
  static resolveURL(url, path) {
    if (typeof url !== "string" || url === "") return "";
    if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
      path = path.replace(/(^https?:\/\/[^\/]+).*/i, "$1");
    }
    if (/^(https?:)?\/\//i.test(url)) return url;
    if (/^data:.*,.*$/i.test(url)) return url;
    if (/^blob:.*$/i.test(url)) return url;
    return path + url;
  }
};
var _eyeRight = new Matrix42();
var _eyeLeft = new Matrix42();
var _projectionMatrix = new Matrix42();
var _position$1 = new Vector32();
var _quaternion$1 = new Quaternion2();
var _scale$1 = new Vector32();
var _orientation$1 = new Vector32();
var _position = new Vector32();
var _quaternion = new Quaternion2();
var _scale = new Vector32();
var _orientation = new Vector32();
var _RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
var _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g");
var _wordChar = "[^" + _RESERVED_CHARS_RE + "]";
var _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]";
var _directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", _wordChar);
var _nodeRe = /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot);
var _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar);
var _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar);
var _trackRe = new RegExp(
  "^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$"
);
var _supportedObjectNames = ["material", "materials", "bones", "map"];
var Composite = class {
  constructor(targetGroup, path, optionalParsedPath) {
    const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
    this._targetGroup = targetGroup;
    this._bindings = targetGroup.subscribe_(path, parsedPath);
  }
  getValue(array4, offset) {
    this.bind();
    const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
    if (binding !== void 0) binding.getValue(array4, offset);
  }
  setValue(array4, offset) {
    const bindings = this._bindings;
    for (let i2 = this._targetGroup.nCachedObjects_, n2 = bindings.length; i2 !== n2; ++i2) {
      bindings[i2].setValue(array4, offset);
    }
  }
  bind() {
    const bindings = this._bindings;
    for (let i2 = this._targetGroup.nCachedObjects_, n2 = bindings.length; i2 !== n2; ++i2) {
      bindings[i2].bind();
    }
  }
  unbind() {
    const bindings = this._bindings;
    for (let i2 = this._targetGroup.nCachedObjects_, n2 = bindings.length; i2 !== n2; ++i2) {
      bindings[i2].unbind();
    }
  }
};
var PropertyBinding = class _PropertyBinding {
  constructor(rootNode, path, parsedPath) {
    this.path = path;
    this.parsedPath = parsedPath || _PropertyBinding.parseTrackName(path);
    this.node = _PropertyBinding.findNode(rootNode, this.parsedPath.nodeName);
    this.rootNode = rootNode;
    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }
  static create(root3, path, parsedPath) {
    if (!(root3 && root3.isAnimationObjectGroup)) {
      return new _PropertyBinding(root3, path, parsedPath);
    } else {
      return new _PropertyBinding.Composite(root3, path, parsedPath);
    }
  }
  /**
   * Replaces spaces with underscores and removes unsupported characters from
   * node names, to ensure compatibility with parseTrackName().
   *
   * @param {string} name Node name to be sanitized.
   * @return {string}
   */
  static sanitizeNodeName(name) {
    return name.replace(/\s/g, "_").replace(_reservedRe, "");
  }
  static parseTrackName(trackName) {
    const matches2 = _trackRe.exec(trackName);
    if (matches2 === null) {
      throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
    }
    const results = {
      // directoryName: matches[ 1 ], // (tschw) currently unused
      nodeName: matches2[2],
      objectName: matches2[3],
      objectIndex: matches2[4],
      propertyName: matches2[5],
      // required
      propertyIndex: matches2[6]
    };
    const lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
    if (lastDot !== void 0 && lastDot !== -1) {
      const objectName = results.nodeName.substring(lastDot + 1);
      if (_supportedObjectNames.indexOf(objectName) !== -1) {
        results.nodeName = results.nodeName.substring(0, lastDot);
        results.objectName = objectName;
      }
    }
    if (results.propertyName === null || results.propertyName.length === 0) {
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
    }
    return results;
  }
  static findNode(root3, nodeName) {
    if (nodeName === void 0 || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root3.name || nodeName === root3.uuid) {
      return root3;
    }
    if (root3.skeleton) {
      const bone = root3.skeleton.getBoneByName(nodeName);
      if (bone !== void 0) {
        return bone;
      }
    }
    if (root3.children) {
      const searchNodeSubtree = function(children2) {
        for (let i2 = 0; i2 < children2.length; i2++) {
          const childNode = children2[i2];
          if (childNode.name === nodeName || childNode.uuid === nodeName) {
            return childNode;
          }
          const result2 = searchNodeSubtree(childNode.children);
          if (result2) return result2;
        }
        return null;
      };
      const subTreeNode = searchNodeSubtree(root3.children);
      if (subTreeNode) {
        return subTreeNode;
      }
    }
    return null;
  }
  // these are used to "bind" a nonexistent property
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  // Getters
  _getValue_direct(buffer2, offset) {
    buffer2[offset] = this.targetObject[this.propertyName];
  }
  _getValue_array(buffer2, offset) {
    const source = this.resolvedProperty;
    for (let i2 = 0, n2 = source.length; i2 !== n2; ++i2) {
      buffer2[offset++] = source[i2];
    }
  }
  _getValue_arrayElement(buffer2, offset) {
    buffer2[offset] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(buffer2, offset) {
    this.resolvedProperty.toArray(buffer2, offset);
  }
  // Direct
  _setValue_direct(buffer2, offset) {
    this.targetObject[this.propertyName] = buffer2[offset];
  }
  _setValue_direct_setNeedsUpdate(buffer2, offset) {
    this.targetObject[this.propertyName] = buffer2[offset];
    this.targetObject.needsUpdate = true;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(buffer2, offset) {
    this.targetObject[this.propertyName] = buffer2[offset];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  // EntireArray
  _setValue_array(buffer2, offset) {
    const dest = this.resolvedProperty;
    for (let i2 = 0, n2 = dest.length; i2 !== n2; ++i2) {
      dest[i2] = buffer2[offset++];
    }
  }
  _setValue_array_setNeedsUpdate(buffer2, offset) {
    const dest = this.resolvedProperty;
    for (let i2 = 0, n2 = dest.length; i2 !== n2; ++i2) {
      dest[i2] = buffer2[offset++];
    }
    this.targetObject.needsUpdate = true;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(buffer2, offset) {
    const dest = this.resolvedProperty;
    for (let i2 = 0, n2 = dest.length; i2 !== n2; ++i2) {
      dest[i2] = buffer2[offset++];
    }
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  // ArrayElement
  _setValue_arrayElement(buffer2, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer2[offset];
  }
  _setValue_arrayElement_setNeedsUpdate(buffer2, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer2[offset];
    this.targetObject.needsUpdate = true;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer2, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer2[offset];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  // HasToFromArray
  _setValue_fromArray(buffer2, offset) {
    this.resolvedProperty.fromArray(buffer2, offset);
  }
  _setValue_fromArray_setNeedsUpdate(buffer2, offset) {
    this.resolvedProperty.fromArray(buffer2, offset);
    this.targetObject.needsUpdate = true;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer2, offset) {
    this.resolvedProperty.fromArray(buffer2, offset);
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _getValue_unbound(targetArray, offset) {
    this.bind();
    this.getValue(targetArray, offset);
  }
  _setValue_unbound(sourceArray, offset) {
    this.bind();
    this.setValue(sourceArray, offset);
  }
  // create getter / setter pair for a property in the scene graph
  bind() {
    let targetObject = this.node;
    const parsedPath = this.parsedPath;
    const objectName = parsedPath.objectName;
    const propertyName = parsedPath.propertyName;
    let propertyIndex = parsedPath.propertyIndex;
    if (!targetObject) {
      targetObject = _PropertyBinding.findNode(this.rootNode, parsedPath.nodeName);
      this.node = targetObject;
    }
    this.getValue = this._getValue_unavailable;
    this.setValue = this._setValue_unavailable;
    if (!targetObject) {
      console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
      return;
    }
    if (objectName) {
      let objectIndex = parsedPath.objectIndex;
      switch (objectName) {
        case "materials":
          if (!targetObject.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!targetObject.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          targetObject = targetObject.material.materials;
          break;
        case "bones":
          if (!targetObject.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          targetObject = targetObject.skeleton.bones;
          for (let i2 = 0; i2 < targetObject.length; i2++) {
            if (targetObject[i2].name === objectIndex) {
              objectIndex = i2;
              break;
            }
          }
          break;
        case "map":
          if ("map" in targetObject) {
            targetObject = targetObject.map;
            break;
          }
          if (!targetObject.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!targetObject.material.map) {
            console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
            return;
          }
          targetObject = targetObject.material.map;
          break;
        default:
          if (targetObject[objectName] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          targetObject = targetObject[objectName];
      }
      if (objectIndex !== void 0) {
        if (targetObject[objectIndex] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
          return;
        }
        targetObject = targetObject[objectIndex];
      }
    }
    const nodeProperty = targetObject[propertyName];
    if (nodeProperty === void 0) {
      const nodeName = parsedPath.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
      return;
    }
    let versioning = this.Versioning.None;
    this.targetObject = targetObject;
    if (targetObject.needsUpdate !== void 0) {
      versioning = this.Versioning.NeedsUpdate;
    } else if (targetObject.matrixWorldNeedsUpdate !== void 0) {
      versioning = this.Versioning.MatrixWorldNeedsUpdate;
    }
    let bindingType = this.BindingType.Direct;
    if (propertyIndex !== void 0) {
      if (propertyName === "morphTargetInfluences") {
        if (!targetObject.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (!targetObject.geometry.morphAttributes) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
          return;
        }
        if (targetObject.morphTargetDictionary[propertyIndex] !== void 0) {
          propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
        }
      }
      bindingType = this.BindingType.ArrayElement;
      this.resolvedProperty = nodeProperty;
      this.propertyIndex = propertyIndex;
    } else if (nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0) {
      bindingType = this.BindingType.HasFromToArray;
      this.resolvedProperty = nodeProperty;
    } else if (Array.isArray(nodeProperty)) {
      bindingType = this.BindingType.EntireArray;
      this.resolvedProperty = nodeProperty;
    } else {
      this.propertyName = propertyName;
    }
    this.getValue = this.GetterByBindingType[bindingType];
    this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
  }
  unbind() {
    this.node = null;
    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }
};
PropertyBinding.Composite = Composite;
PropertyBinding.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
};
PropertyBinding.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
};
PropertyBinding.prototype.GetterByBindingType = [
  PropertyBinding.prototype._getValue_direct,
  PropertyBinding.prototype._getValue_array,
  PropertyBinding.prototype._getValue_arrayElement,
  PropertyBinding.prototype._getValue_toArray
];
PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [
  [
    // Direct
    PropertyBinding.prototype._setValue_direct,
    PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
    PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate
  ],
  [
    // EntireArray
    PropertyBinding.prototype._setValue_array,
    PropertyBinding.prototype._setValue_array_setNeedsUpdate,
    PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate
  ],
  [
    // ArrayElement
    PropertyBinding.prototype._setValue_arrayElement,
    PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
    PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
  ],
  [
    // HasToFromArray
    PropertyBinding.prototype._setValue_fromArray,
    PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
    PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
  ]
];
var _controlInterpolantsResultBuffer = new Float32Array(1);
var _matrix = new Matrix42();
var _vector$4 = new Vector22();
var _startP = new Vector32();
var _startEnd = new Vector32();
var _vector$3 = new Vector32();
var _vector$2 = new Vector32();
var _boneMatrix = new Matrix42();
var _matrixWorldInv = new Matrix42();
var _vector$1 = new Vector32();
var _color1 = new Color2();
var _color2 = new Color2();
var _v1 = new Vector32();
var _v2 = new Vector32();
var _v3 = new Vector32();
var _vector = new Vector32();
var _camera = new Camera2();
var _box = new Box32();
var _axis = new Vector32();
if (typeof __THREE_DEVTOOLS__ !== "undefined") {
  __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
    revision: REVISION2
  } }));
}
if (typeof window !== "undefined") {
  if (window.__THREE__) {
    console.warn("WARNING: Multiple instances of Three.js being imported.");
  } else {
    window.__THREE__ = REVISION2;
  }
}

// node_modules/aframe-extras/node_modules/three/examples/jsm/loaders/TGALoader.js
var TGALoader = class extends DataTextureLoader {
  constructor(manager) {
    super(manager);
  }
  parse(buffer2) {
    function tgaCheckHeader(header2) {
      switch (header2.image_type) {
        // check indexed type
        case TGA_TYPE_INDEXED:
        case TGA_TYPE_RLE_INDEXED:
          if (header2.colormap_length > 256 || header2.colormap_size !== 24 || header2.colormap_type !== 1) {
            throw new Error("THREE.TGALoader: Invalid type colormap data for indexed type.");
          }
          break;
        // check colormap type
        case TGA_TYPE_RGB:
        case TGA_TYPE_GREY:
        case TGA_TYPE_RLE_RGB:
        case TGA_TYPE_RLE_GREY:
          if (header2.colormap_type) {
            throw new Error("THREE.TGALoader: Invalid type colormap data for colormap type.");
          }
          break;
        // What the need of a file without data ?
        case TGA_TYPE_NO_DATA:
          throw new Error("THREE.TGALoader: No data.");
        // Invalid type ?
        default:
          throw new Error("THREE.TGALoader: Invalid type " + header2.image_type);
      }
      if (header2.width <= 0 || header2.height <= 0) {
        throw new Error("THREE.TGALoader: Invalid image size.");
      }
      if (header2.pixel_size !== 8 && header2.pixel_size !== 16 && header2.pixel_size !== 24 && header2.pixel_size !== 32) {
        throw new Error("THREE.TGALoader: Invalid pixel size " + header2.pixel_size);
      }
    }
    function tgaParse(use_rle2, use_pal2, header2, offset2, data) {
      let pixel_data, palettes;
      const pixel_size = header2.pixel_size >> 3;
      const pixel_total = header2.width * header2.height * pixel_size;
      if (use_pal2) {
        palettes = data.subarray(offset2, offset2 += header2.colormap_length * (header2.colormap_size >> 3));
      }
      if (use_rle2) {
        pixel_data = new Uint8Array(pixel_total);
        let c5, count2, i2;
        let shift = 0;
        const pixels = new Uint8Array(pixel_size);
        while (shift < pixel_total) {
          c5 = data[offset2++];
          count2 = (c5 & 127) + 1;
          if (c5 & 128) {
            for (i2 = 0; i2 < pixel_size; ++i2) {
              pixels[i2] = data[offset2++];
            }
            for (i2 = 0; i2 < count2; ++i2) {
              pixel_data.set(pixels, shift + i2 * pixel_size);
            }
            shift += pixel_size * count2;
          } else {
            count2 *= pixel_size;
            for (i2 = 0; i2 < count2; ++i2) {
              pixel_data[shift + i2] = data[offset2++];
            }
            shift += count2;
          }
        }
      } else {
        pixel_data = data.subarray(
          offset2,
          offset2 += use_pal2 ? header2.width * header2.height : pixel_total
        );
      }
      return {
        pixel_data,
        palettes
      };
    }
    function tgaGetImageData8bits(imageData2, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes) {
      const colormap = palettes;
      let color3, i2 = 0, x3, y3;
      const width = header.width;
      for (y3 = y_start; y3 !== y_end; y3 += y_step) {
        for (x3 = x_start; x3 !== x_end; x3 += x_step, i2++) {
          color3 = image[i2];
          imageData2[(x3 + width * y3) * 4 + 3] = 255;
          imageData2[(x3 + width * y3) * 4 + 2] = colormap[color3 * 3 + 0];
          imageData2[(x3 + width * y3) * 4 + 1] = colormap[color3 * 3 + 1];
          imageData2[(x3 + width * y3) * 4 + 0] = colormap[color3 * 3 + 2];
        }
      }
      return imageData2;
    }
    function tgaGetImageData16bits(imageData2, y_start, y_step, y_end, x_start, x_step, x_end, image) {
      let color3, i2 = 0, x3, y3;
      const width = header.width;
      for (y3 = y_start; y3 !== y_end; y3 += y_step) {
        for (x3 = x_start; x3 !== x_end; x3 += x_step, i2 += 2) {
          color3 = image[i2 + 0] + (image[i2 + 1] << 8);
          imageData2[(x3 + width * y3) * 4 + 0] = (color3 & 31744) >> 7;
          imageData2[(x3 + width * y3) * 4 + 1] = (color3 & 992) >> 2;
          imageData2[(x3 + width * y3) * 4 + 2] = (color3 & 31) << 3;
          imageData2[(x3 + width * y3) * 4 + 3] = color3 & 32768 ? 0 : 255;
        }
      }
      return imageData2;
    }
    function tgaGetImageData24bits(imageData2, y_start, y_step, y_end, x_start, x_step, x_end, image) {
      let i2 = 0, x3, y3;
      const width = header.width;
      for (y3 = y_start; y3 !== y_end; y3 += y_step) {
        for (x3 = x_start; x3 !== x_end; x3 += x_step, i2 += 3) {
          imageData2[(x3 + width * y3) * 4 + 3] = 255;
          imageData2[(x3 + width * y3) * 4 + 2] = image[i2 + 0];
          imageData2[(x3 + width * y3) * 4 + 1] = image[i2 + 1];
          imageData2[(x3 + width * y3) * 4 + 0] = image[i2 + 2];
        }
      }
      return imageData2;
    }
    function tgaGetImageData32bits(imageData2, y_start, y_step, y_end, x_start, x_step, x_end, image) {
      let i2 = 0, x3, y3;
      const width = header.width;
      for (y3 = y_start; y3 !== y_end; y3 += y_step) {
        for (x3 = x_start; x3 !== x_end; x3 += x_step, i2 += 4) {
          imageData2[(x3 + width * y3) * 4 + 2] = image[i2 + 0];
          imageData2[(x3 + width * y3) * 4 + 1] = image[i2 + 1];
          imageData2[(x3 + width * y3) * 4 + 0] = image[i2 + 2];
          imageData2[(x3 + width * y3) * 4 + 3] = image[i2 + 3];
        }
      }
      return imageData2;
    }
    function tgaGetImageDataGrey8bits(imageData2, y_start, y_step, y_end, x_start, x_step, x_end, image) {
      let color3, i2 = 0, x3, y3;
      const width = header.width;
      for (y3 = y_start; y3 !== y_end; y3 += y_step) {
        for (x3 = x_start; x3 !== x_end; x3 += x_step, i2++) {
          color3 = image[i2];
          imageData2[(x3 + width * y3) * 4 + 0] = color3;
          imageData2[(x3 + width * y3) * 4 + 1] = color3;
          imageData2[(x3 + width * y3) * 4 + 2] = color3;
          imageData2[(x3 + width * y3) * 4 + 3] = 255;
        }
      }
      return imageData2;
    }
    function tgaGetImageDataGrey16bits(imageData2, y_start, y_step, y_end, x_start, x_step, x_end, image) {
      let i2 = 0, x3, y3;
      const width = header.width;
      for (y3 = y_start; y3 !== y_end; y3 += y_step) {
        for (x3 = x_start; x3 !== x_end; x3 += x_step, i2 += 2) {
          imageData2[(x3 + width * y3) * 4 + 0] = image[i2 + 0];
          imageData2[(x3 + width * y3) * 4 + 1] = image[i2 + 0];
          imageData2[(x3 + width * y3) * 4 + 2] = image[i2 + 0];
          imageData2[(x3 + width * y3) * 4 + 3] = image[i2 + 1];
        }
      }
      return imageData2;
    }
    function getTgaRGBA(data, width, height, image, palette) {
      let x_start, y_start, x_step, y_step, x_end, y_end;
      switch ((header.flags & TGA_ORIGIN_MASK) >> TGA_ORIGIN_SHIFT) {
        default:
        case TGA_ORIGIN_UL:
          x_start = 0;
          x_step = 1;
          x_end = width;
          y_start = 0;
          y_step = 1;
          y_end = height;
          break;
        case TGA_ORIGIN_BL:
          x_start = 0;
          x_step = 1;
          x_end = width;
          y_start = height - 1;
          y_step = -1;
          y_end = -1;
          break;
        case TGA_ORIGIN_UR:
          x_start = width - 1;
          x_step = -1;
          x_end = -1;
          y_start = 0;
          y_step = 1;
          y_end = height;
          break;
        case TGA_ORIGIN_BR:
          x_start = width - 1;
          x_step = -1;
          x_end = -1;
          y_start = height - 1;
          y_step = -1;
          y_end = -1;
          break;
      }
      if (use_grey) {
        switch (header.pixel_size) {
          case 8:
            tgaGetImageDataGrey8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);
            break;
          case 16:
            tgaGetImageDataGrey16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);
            break;
          default:
            throw new Error("THREE.TGALoader: Format not supported.");
            break;
        }
      } else {
        switch (header.pixel_size) {
          case 8:
            tgaGetImageData8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette);
            break;
          case 16:
            tgaGetImageData16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);
            break;
          case 24:
            tgaGetImageData24bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);
            break;
          case 32:
            tgaGetImageData32bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);
            break;
          default:
            throw new Error("THREE.TGALoader: Format not supported.");
            break;
        }
      }
      return data;
    }
    const TGA_TYPE_NO_DATA = 0, TGA_TYPE_INDEXED = 1, TGA_TYPE_RGB = 2, TGA_TYPE_GREY = 3, TGA_TYPE_RLE_INDEXED = 9, TGA_TYPE_RLE_RGB = 10, TGA_TYPE_RLE_GREY = 11, TGA_ORIGIN_MASK = 48, TGA_ORIGIN_SHIFT = 4, TGA_ORIGIN_BL = 0, TGA_ORIGIN_BR = 1, TGA_ORIGIN_UL = 2, TGA_ORIGIN_UR = 3;
    if (buffer2.length < 19) throw new Error("THREE.TGALoader: Not enough data to contain header.");
    let offset = 0;
    const content = new Uint8Array(buffer2), header = {
      id_length: content[offset++],
      colormap_type: content[offset++],
      image_type: content[offset++],
      colormap_index: content[offset++] | content[offset++] << 8,
      colormap_length: content[offset++] | content[offset++] << 8,
      colormap_size: content[offset++],
      origin: [
        content[offset++] | content[offset++] << 8,
        content[offset++] | content[offset++] << 8
      ],
      width: content[offset++] | content[offset++] << 8,
      height: content[offset++] | content[offset++] << 8,
      pixel_size: content[offset++],
      flags: content[offset++]
    };
    tgaCheckHeader(header);
    if (header.id_length + offset > buffer2.length) {
      throw new Error("THREE.TGALoader: No data.");
    }
    offset += header.id_length;
    let use_rle = false, use_pal = false, use_grey = false;
    switch (header.image_type) {
      case TGA_TYPE_RLE_INDEXED:
        use_rle = true;
        use_pal = true;
        break;
      case TGA_TYPE_INDEXED:
        use_pal = true;
        break;
      case TGA_TYPE_RLE_RGB:
        use_rle = true;
        break;
      case TGA_TYPE_RGB:
        break;
      case TGA_TYPE_RLE_GREY:
        use_rle = true;
        use_grey = true;
        break;
      case TGA_TYPE_GREY:
        use_grey = true;
        break;
    }
    const imageData = new Uint8Array(header.width * header.height * 4);
    const result2 = tgaParse(use_rle, use_pal, header, offset, content);
    getTgaRGBA(imageData, header.width, header.height, result2.pixel_data, result2.palettes);
    return {
      data: imageData,
      width: header.width,
      height: header.height,
      flipY: true,
      generateMipmaps: true,
      minFilter: LinearMipmapLinearFilter2
    };
  }
};

// node_modules/aframe-extras/node_modules/three/examples/jsm/loaders/ColladaLoader.js
var ColladaLoader = class extends Loader {
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const path = scope.path === "" ? LoaderUtils.extractUrlBase(url) : scope.path;
    const loader = new FileLoader(scope.manager);
    loader.setPath(scope.path);
    loader.setRequestHeader(scope.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(url, function(text) {
      try {
        onLoad(scope.parse(text, path));
      } catch (e3) {
        if (onError) {
          onError(e3);
        } else {
          console.error(e3);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(text, path) {
    function getElementsByTagName(xml2, name) {
      const array4 = [];
      const childNodes = xml2.childNodes;
      for (let i2 = 0, l2 = childNodes.length; i2 < l2; i2++) {
        const child = childNodes[i2];
        if (child.nodeName === name) {
          array4.push(child);
        }
      }
      return array4;
    }
    function parseStrings(text2) {
      if (text2.length === 0) return [];
      const parts = text2.trim().split(/\s+/);
      const array4 = new Array(parts.length);
      for (let i2 = 0, l2 = parts.length; i2 < l2; i2++) {
        array4[i2] = parts[i2];
      }
      return array4;
    }
    function parseFloats(text2) {
      if (text2.length === 0) return [];
      const parts = text2.trim().split(/\s+/);
      const array4 = new Array(parts.length);
      for (let i2 = 0, l2 = parts.length; i2 < l2; i2++) {
        array4[i2] = parseFloat(parts[i2]);
      }
      return array4;
    }
    function parseInts(text2) {
      if (text2.length === 0) return [];
      const parts = text2.trim().split(/\s+/);
      const array4 = new Array(parts.length);
      for (let i2 = 0, l2 = parts.length; i2 < l2; i2++) {
        array4[i2] = parseInt(parts[i2]);
      }
      return array4;
    }
    function parseId(text2) {
      return text2.substring(1);
    }
    function generateId() {
      return "three_default_" + count2++;
    }
    function isEmpty2(object) {
      return Object.keys(object).length === 0;
    }
    function parseAsset(xml2) {
      return {
        unit: parseAssetUnit(getElementsByTagName(xml2, "unit")[0]),
        upAxis: parseAssetUpAxis(getElementsByTagName(xml2, "up_axis")[0])
      };
    }
    function parseAssetUnit(xml2) {
      if (xml2 !== void 0 && xml2.hasAttribute("meter") === true) {
        return parseFloat(xml2.getAttribute("meter"));
      } else {
        return 1;
      }
    }
    function parseAssetUpAxis(xml2) {
      return xml2 !== void 0 ? xml2.textContent : "Y_UP";
    }
    function parseLibrary(xml2, libraryName, nodeName, parser) {
      const library2 = getElementsByTagName(xml2, libraryName)[0];
      if (library2 !== void 0) {
        const elements = getElementsByTagName(library2, nodeName);
        for (let i2 = 0; i2 < elements.length; i2++) {
          parser(elements[i2]);
        }
      }
    }
    function buildLibrary(data, builder) {
      for (const name in data) {
        const object = data[name];
        object.build = builder(data[name]);
      }
    }
    function getBuild(data, builder) {
      if (data.build !== void 0) return data.build;
      data.build = builder(data);
      return data.build;
    }
    function parseAnimation(xml2) {
      const data = {
        sources: {},
        samplers: {},
        channels: {}
      };
      let hasChildren = false;
      for (let i2 = 0, l2 = xml2.childNodes.length; i2 < l2; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1) continue;
        let id2;
        switch (child.nodeName) {
          case "source":
            id2 = child.getAttribute("id");
            data.sources[id2] = parseSource(child);
            break;
          case "sampler":
            id2 = child.getAttribute("id");
            data.samplers[id2] = parseAnimationSampler(child);
            break;
          case "channel":
            id2 = child.getAttribute("target");
            data.channels[id2] = parseAnimationChannel(child);
            break;
          case "animation":
            parseAnimation(child);
            hasChildren = true;
            break;
          default:
            console.log(child);
        }
      }
      if (hasChildren === false) {
        library.animations[xml2.getAttribute("id") || MathUtils2.generateUUID()] = data;
      }
    }
    function parseAnimationSampler(xml2) {
      const data = {
        inputs: {}
      };
      for (let i2 = 0, l2 = xml2.childNodes.length; i2 < l2; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1) continue;
        switch (child.nodeName) {
          case "input":
            const id2 = parseId(child.getAttribute("source"));
            const semantic = child.getAttribute("semantic");
            data.inputs[semantic] = id2;
            break;
        }
      }
      return data;
    }
    function parseAnimationChannel(xml2) {
      const data = {};
      const target = xml2.getAttribute("target");
      let parts = target.split("/");
      const id2 = parts.shift();
      let sid = parts.shift();
      const arraySyntax = sid.indexOf("(") !== -1;
      const memberSyntax = sid.indexOf(".") !== -1;
      if (memberSyntax) {
        parts = sid.split(".");
        sid = parts.shift();
        data.member = parts.shift();
      } else if (arraySyntax) {
        const indices = sid.split("(");
        sid = indices.shift();
        for (let i2 = 0; i2 < indices.length; i2++) {
          indices[i2] = parseInt(indices[i2].replace(/\)/, ""));
        }
        data.indices = indices;
      }
      data.id = id2;
      data.sid = sid;
      data.arraySyntax = arraySyntax;
      data.memberSyntax = memberSyntax;
      data.sampler = parseId(xml2.getAttribute("source"));
      return data;
    }
    function buildAnimation(data) {
      const tracks = [];
      const channels = data.channels;
      const samplers = data.samplers;
      const sources = data.sources;
      for (const target in channels) {
        if (channels.hasOwnProperty(target)) {
          const channel = channels[target];
          const sampler2 = samplers[channel.sampler];
          const inputId = sampler2.inputs.INPUT;
          const outputId = sampler2.inputs.OUTPUT;
          const inputSource = sources[inputId];
          const outputSource = sources[outputId];
          const animation = buildAnimationChannel(channel, inputSource, outputSource);
          createKeyframeTracks(animation, tracks);
        }
      }
      return tracks;
    }
    function getAnimation(id2) {
      return getBuild(library.animations[id2], buildAnimation);
    }
    function buildAnimationChannel(channel, inputSource, outputSource) {
      const node = library.nodes[channel.id];
      const object3D = getNode(node.id);
      const transform3 = node.transforms[channel.sid];
      const defaultMatrix = node.matrix.clone().transpose();
      let time3, stride;
      let i2, il, j2, jl;
      const data = {};
      switch (transform3) {
        case "matrix":
          for (i2 = 0, il = inputSource.array.length; i2 < il; i2++) {
            time3 = inputSource.array[i2];
            stride = i2 * outputSource.stride;
            if (data[time3] === void 0) data[time3] = {};
            if (channel.arraySyntax === true) {
              const value = outputSource.array[stride];
              const index8 = channel.indices[0] + 4 * channel.indices[1];
              data[time3][index8] = value;
            } else {
              for (j2 = 0, jl = outputSource.stride; j2 < jl; j2++) {
                data[time3][j2] = outputSource.array[stride + j2];
              }
            }
          }
          break;
        case "translate":
          console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', transform3);
          break;
        case "rotate":
          console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', transform3);
          break;
        case "scale":
          console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', transform3);
          break;
      }
      const keyframes = prepareAnimationData(data, defaultMatrix);
      const animation = {
        name: object3D.uuid,
        keyframes
      };
      return animation;
    }
    function prepareAnimationData(data, defaultMatrix) {
      const keyframes = [];
      for (const time3 in data) {
        keyframes.push({ time: parseFloat(time3), value: data[time3] });
      }
      keyframes.sort(ascending3);
      for (let i2 = 0; i2 < 16; i2++) {
        transformAnimationData(keyframes, i2, defaultMatrix.elements[i2]);
      }
      return keyframes;
      function ascending3(a3, b) {
        return a3.time - b.time;
      }
    }
    const position = new Vector32();
    const scale2 = new Vector32();
    const quaternion = new Quaternion2();
    function createKeyframeTracks(animation, tracks) {
      const keyframes = animation.keyframes;
      const name = animation.name;
      const times2 = [];
      const positionData = [];
      const quaternionData = [];
      const scaleData = [];
      for (let i2 = 0, l2 = keyframes.length; i2 < l2; i2++) {
        const keyframe = keyframes[i2];
        const time3 = keyframe.time;
        const value = keyframe.value;
        matrix.fromArray(value).transpose();
        matrix.decompose(position, quaternion, scale2);
        times2.push(time3);
        positionData.push(position.x, position.y, position.z);
        quaternionData.push(quaternion.x, quaternion.y, quaternion.z, quaternion.w);
        scaleData.push(scale2.x, scale2.y, scale2.z);
      }
      if (positionData.length > 0) tracks.push(new VectorKeyframeTrack(name + ".position", times2, positionData));
      if (quaternionData.length > 0) tracks.push(new QuaternionKeyframeTrack(name + ".quaternion", times2, quaternionData));
      if (scaleData.length > 0) tracks.push(new VectorKeyframeTrack(name + ".scale", times2, scaleData));
      return tracks;
    }
    function transformAnimationData(keyframes, property3, defaultValue) {
      let keyframe;
      let empty2 = true;
      let i2, l2;
      for (i2 = 0, l2 = keyframes.length; i2 < l2; i2++) {
        keyframe = keyframes[i2];
        if (keyframe.value[property3] === void 0) {
          keyframe.value[property3] = null;
        } else {
          empty2 = false;
        }
      }
      if (empty2 === true) {
        for (i2 = 0, l2 = keyframes.length; i2 < l2; i2++) {
          keyframe = keyframes[i2];
          keyframe.value[property3] = defaultValue;
        }
      } else {
        createMissingKeyframes(keyframes, property3);
      }
    }
    function createMissingKeyframes(keyframes, property3) {
      let prev, next;
      for (let i2 = 0, l2 = keyframes.length; i2 < l2; i2++) {
        const keyframe = keyframes[i2];
        if (keyframe.value[property3] === null) {
          prev = getPrev(keyframes, i2, property3);
          next = getNext(keyframes, i2, property3);
          if (prev === null) {
            keyframe.value[property3] = next.value[property3];
            continue;
          }
          if (next === null) {
            keyframe.value[property3] = prev.value[property3];
            continue;
          }
          interpolate(keyframe, prev, next, property3);
        }
      }
    }
    function getPrev(keyframes, i2, property3) {
      while (i2 >= 0) {
        const keyframe = keyframes[i2];
        if (keyframe.value[property3] !== null) return keyframe;
        i2--;
      }
      return null;
    }
    function getNext(keyframes, i2, property3) {
      while (i2 < keyframes.length) {
        const keyframe = keyframes[i2];
        if (keyframe.value[property3] !== null) return keyframe;
        i2++;
      }
      return null;
    }
    function interpolate(key, prev, next, property3) {
      if (next.time - prev.time === 0) {
        key.value[property3] = prev.value[property3];
        return;
      }
      key.value[property3] = (key.time - prev.time) * (next.value[property3] - prev.value[property3]) / (next.time - prev.time) + prev.value[property3];
    }
    function parseAnimationClip(xml2) {
      const data = {
        name: xml2.getAttribute("id") || "default",
        start: parseFloat(xml2.getAttribute("start") || 0),
        end: parseFloat(xml2.getAttribute("end") || 0),
        animations: []
      };
      for (let i2 = 0, l2 = xml2.childNodes.length; i2 < l2; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1) continue;
        switch (child.nodeName) {
          case "instance_animation":
            data.animations.push(parseId(child.getAttribute("url")));
            break;
        }
      }
      library.clips[xml2.getAttribute("id")] = data;
    }
    function buildAnimationClip(data) {
      const tracks = [];
      const name = data.name;
      const duration = data.end - data.start || -1;
      const animations2 = data.animations;
      for (let i2 = 0, il = animations2.length; i2 < il; i2++) {
        const animationTracks = getAnimation(animations2[i2]);
        for (let j2 = 0, jl = animationTracks.length; j2 < jl; j2++) {
          tracks.push(animationTracks[j2]);
        }
      }
      return new AnimationClip(name, duration, tracks);
    }
    function getAnimationClip(id2) {
      return getBuild(library.clips[id2], buildAnimationClip);
    }
    function parseController(xml2) {
      const data = {};
      for (let i2 = 0, l2 = xml2.childNodes.length; i2 < l2; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1) continue;
        switch (child.nodeName) {
          case "skin":
            data.id = parseId(child.getAttribute("source"));
            data.skin = parseSkin(child);
            break;
          case "morph":
            data.id = parseId(child.getAttribute("source"));
            console.warn("THREE.ColladaLoader: Morph target animation not supported yet.");
            break;
        }
      }
      library.controllers[xml2.getAttribute("id")] = data;
    }
    function parseSkin(xml2) {
      const data = {
        sources: {}
      };
      for (let i2 = 0, l2 = xml2.childNodes.length; i2 < l2; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1) continue;
        switch (child.nodeName) {
          case "bind_shape_matrix":
            data.bindShapeMatrix = parseFloats(child.textContent);
            break;
          case "source":
            const id2 = child.getAttribute("id");
            data.sources[id2] = parseSource(child);
            break;
          case "joints":
            data.joints = parseJoints(child);
            break;
          case "vertex_weights":
            data.vertexWeights = parseVertexWeights(child);
            break;
        }
      }
      return data;
    }
    function parseJoints(xml2) {
      const data = {
        inputs: {}
      };
      for (let i2 = 0, l2 = xml2.childNodes.length; i2 < l2; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1) continue;
        switch (child.nodeName) {
          case "input":
            const semantic = child.getAttribute("semantic");
            const id2 = parseId(child.getAttribute("source"));
            data.inputs[semantic] = id2;
            break;
        }
      }
      return data;
    }
    function parseVertexWeights(xml2) {
      const data = {
        inputs: {}
      };
      for (let i2 = 0, l2 = xml2.childNodes.length; i2 < l2; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1) continue;
        switch (child.nodeName) {
          case "input":
            const semantic = child.getAttribute("semantic");
            const id2 = parseId(child.getAttribute("source"));
            const offset = parseInt(child.getAttribute("offset"));
            data.inputs[semantic] = { id: id2, offset };
            break;
          case "vcount":
            data.vcount = parseInts(child.textContent);
            break;
          case "v":
            data.v = parseInts(child.textContent);
            break;
        }
      }
      return data;
    }
    function buildController(data) {
      const build = {
        id: data.id
      };
      const geometry = library.geometries[build.id];
      if (data.skin !== void 0) {
        build.skin = buildSkin(data.skin);
        geometry.sources.skinIndices = build.skin.indices;
        geometry.sources.skinWeights = build.skin.weights;
      }
      return build;
    }
    function buildSkin(data) {
      const BONE_LIMIT = 4;
      const build = {
        joints: [],
        // this must be an array to preserve the joint order
        indices: {
          array: [],
          stride: BONE_LIMIT
        },
        weights: {
          array: [],
          stride: BONE_LIMIT
        }
      };
      const sources = data.sources;
      const vertexWeights = data.vertexWeights;
      const vcount = vertexWeights.vcount;
      const v2 = vertexWeights.v;
      const jointOffset = vertexWeights.inputs.JOINT.offset;
      const weightOffset = vertexWeights.inputs.WEIGHT.offset;
      const jointSource = data.sources[data.joints.inputs.JOINT];
      const inverseSource = data.sources[data.joints.inputs.INV_BIND_MATRIX];
      const weights = sources[vertexWeights.inputs.WEIGHT.id].array;
      let stride = 0;
      let i2, j2, l2;
      for (i2 = 0, l2 = vcount.length; i2 < l2; i2++) {
        const jointCount = vcount[i2];
        const vertexSkinData = [];
        for (j2 = 0; j2 < jointCount; j2++) {
          const skinIndex = v2[stride + jointOffset];
          const weightId = v2[stride + weightOffset];
          const skinWeight = weights[weightId];
          vertexSkinData.push({ index: skinIndex, weight: skinWeight });
          stride += 2;
        }
        vertexSkinData.sort(descending2);
        for (j2 = 0; j2 < BONE_LIMIT; j2++) {
          const d3 = vertexSkinData[j2];
          if (d3 !== void 0) {
            build.indices.array.push(d3.index);
            build.weights.array.push(d3.weight);
          } else {
            build.indices.array.push(0);
            build.weights.array.push(0);
          }
        }
      }
      if (data.bindShapeMatrix) {
        build.bindMatrix = new Matrix42().fromArray(data.bindShapeMatrix).transpose();
      } else {
        build.bindMatrix = new Matrix42().identity();
      }
      for (i2 = 0, l2 = jointSource.array.length; i2 < l2; i2++) {
        const name = jointSource.array[i2];
        const boneInverse = new Matrix42().fromArray(inverseSource.array, i2 * inverseSource.stride).transpose();
        build.joints.push({ name, boneInverse });
      }
      return build;
      function descending2(a3, b) {
        return b.weight - a3.weight;
      }
    }
    function getController(id2) {
      return getBuild(library.controllers[id2], buildController);
    }
    function parseImage(xml2) {
      const data = {
        init_from: getElementsByTagName(xml2, "init_from")[0].textContent
      };
      library.images[xml2.getAttribute("id")] = data;
    }
    function buildImage(data) {
      if (data.build !== void 0) return data.build;
      return data.init_from;
    }
    function getImage2(id2) {
      const data = library.images[id2];
      if (data !== void 0) {
        return getBuild(data, buildImage);
      }
      console.warn("THREE.ColladaLoader: Couldn't find image with ID:", id2);
      return null;
    }
    function parseEffect(xml2) {
      const data = {};
      for (let i2 = 0, l2 = xml2.childNodes.length; i2 < l2; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1) continue;
        switch (child.nodeName) {
          case "profile_COMMON":
            data.profile = parseEffectProfileCOMMON(child);
            break;
        }
      }
      library.effects[xml2.getAttribute("id")] = data;
    }
    function parseEffectProfileCOMMON(xml2) {
      const data = {
        surfaces: {},
        samplers: {}
      };
      for (let i2 = 0, l2 = xml2.childNodes.length; i2 < l2; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1) continue;
        switch (child.nodeName) {
          case "newparam":
            parseEffectNewparam(child, data);
            break;
          case "technique":
            data.technique = parseEffectTechnique(child);
            break;
          case "extra":
            data.extra = parseEffectExtra(child);
            break;
        }
      }
      return data;
    }
    function parseEffectNewparam(xml2, data) {
      const sid = xml2.getAttribute("sid");
      for (let i2 = 0, l2 = xml2.childNodes.length; i2 < l2; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1) continue;
        switch (child.nodeName) {
          case "surface":
            data.surfaces[sid] = parseEffectSurface(child);
            break;
          case "sampler2D":
            data.samplers[sid] = parseEffectSampler(child);
            break;
        }
      }
    }
    function parseEffectSurface(xml2) {
      const data = {};
      for (let i2 = 0, l2 = xml2.childNodes.length; i2 < l2; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1) continue;
        switch (child.nodeName) {
          case "init_from":
            data.init_from = child.textContent;
            break;
        }
      }
      return data;
    }
    function parseEffectSampler(xml2) {
      const data = {};
      for (let i2 = 0, l2 = xml2.childNodes.length; i2 < l2; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1) continue;
        switch (child.nodeName) {
          case "source":
            data.source = child.textContent;
            break;
        }
      }
      return data;
    }
    function parseEffectTechnique(xml2) {
      const data = {};
      for (let i2 = 0, l2 = xml2.childNodes.length; i2 < l2; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1) continue;
        switch (child.nodeName) {
          case "constant":
          case "lambert":
          case "blinn":
          case "phong":
            data.type = child.nodeName;
            data.parameters = parseEffectParameters(child);
            break;
          case "extra":
            data.extra = parseEffectExtra(child);
            break;
        }
      }
      return data;
    }
    function parseEffectParameters(xml2) {
      const data = {};
      for (let i2 = 0, l2 = xml2.childNodes.length; i2 < l2; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1) continue;
        switch (child.nodeName) {
          case "emission":
          case "diffuse":
          case "specular":
          case "bump":
          case "ambient":
          case "shininess":
          case "transparency":
            data[child.nodeName] = parseEffectParameter(child);
            break;
          case "transparent":
            data[child.nodeName] = {
              opaque: child.hasAttribute("opaque") ? child.getAttribute("opaque") : "A_ONE",
              data: parseEffectParameter(child)
            };
            break;
        }
      }
      return data;
    }
    function parseEffectParameter(xml2) {
      const data = {};
      for (let i2 = 0, l2 = xml2.childNodes.length; i2 < l2; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1) continue;
        switch (child.nodeName) {
          case "color":
            data[child.nodeName] = parseFloats(child.textContent);
            break;
          case "float":
            data[child.nodeName] = parseFloat(child.textContent);
            break;
          case "texture":
            data[child.nodeName] = { id: child.getAttribute("texture"), extra: parseEffectParameterTexture(child) };
            break;
        }
      }
      return data;
    }
    function parseEffectParameterTexture(xml2) {
      const data = {
        technique: {}
      };
      for (let i2 = 0, l2 = xml2.childNodes.length; i2 < l2; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1) continue;
        switch (child.nodeName) {
          case "extra":
            parseEffectParameterTextureExtra(child, data);
            break;
        }
      }
      return data;
    }
    function parseEffectParameterTextureExtra(xml2, data) {
      for (let i2 = 0, l2 = xml2.childNodes.length; i2 < l2; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1) continue;
        switch (child.nodeName) {
          case "technique":
            parseEffectParameterTextureExtraTechnique(child, data);
            break;
        }
      }
    }
    function parseEffectParameterTextureExtraTechnique(xml2, data) {
      for (let i2 = 0, l2 = xml2.childNodes.length; i2 < l2; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1) continue;
        switch (child.nodeName) {
          case "repeatU":
          case "repeatV":
          case "offsetU":
          case "offsetV":
            data.technique[child.nodeName] = parseFloat(child.textContent);
            break;
          case "wrapU":
          case "wrapV":
            if (child.textContent.toUpperCase() === "TRUE") {
              data.technique[child.nodeName] = 1;
            } else if (child.textContent.toUpperCase() === "FALSE") {
              data.technique[child.nodeName] = 0;
            } else {
              data.technique[child.nodeName] = parseInt(child.textContent);
            }
            break;
          case "bump":
            data[child.nodeName] = parseEffectExtraTechniqueBump(child);
            break;
        }
      }
    }
    function parseEffectExtra(xml2) {
      const data = {};
      for (let i2 = 0, l2 = xml2.childNodes.length; i2 < l2; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1) continue;
        switch (child.nodeName) {
          case "technique":
            data.technique = parseEffectExtraTechnique(child);
            break;
        }
      }
      return data;
    }
    function parseEffectExtraTechnique(xml2) {
      const data = {};
      for (let i2 = 0, l2 = xml2.childNodes.length; i2 < l2; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1) continue;
        switch (child.nodeName) {
          case "double_sided":
            data[child.nodeName] = parseInt(child.textContent);
            break;
          case "bump":
            data[child.nodeName] = parseEffectExtraTechniqueBump(child);
            break;
        }
      }
      return data;
    }
    function parseEffectExtraTechniqueBump(xml2) {
      const data = {};
      for (let i2 = 0, l2 = xml2.childNodes.length; i2 < l2; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1) continue;
        switch (child.nodeName) {
          case "texture":
            data[child.nodeName] = { id: child.getAttribute("texture"), texcoord: child.getAttribute("texcoord"), extra: parseEffectParameterTexture(child) };
            break;
        }
      }
      return data;
    }
    function buildEffect(data) {
      return data;
    }
    function getEffect(id2) {
      return getBuild(library.effects[id2], buildEffect);
    }
    function parseMaterial(xml2) {
      const data = {
        name: xml2.getAttribute("name")
      };
      for (let i2 = 0, l2 = xml2.childNodes.length; i2 < l2; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1) continue;
        switch (child.nodeName) {
          case "instance_effect":
            data.url = parseId(child.getAttribute("url"));
            break;
        }
      }
      library.materials[xml2.getAttribute("id")] = data;
    }
    function getTextureLoader(image) {
      let loader;
      let extension = image.slice((image.lastIndexOf(".") - 1 >>> 0) + 2);
      extension = extension.toLowerCase();
      switch (extension) {
        case "tga":
          loader = tgaLoader;
          break;
        default:
          loader = textureLoader;
      }
      return loader;
    }
    function buildMaterial(data) {
      const effect = getEffect(data.url);
      const technique = effect.profile.technique;
      let material;
      switch (technique.type) {
        case "phong":
        case "blinn":
          material = new MeshPhongMaterial2();
          break;
        case "lambert":
          material = new MeshLambertMaterial2();
          break;
        default:
          material = new MeshBasicMaterial2();
          break;
      }
      material.name = data.name || "";
      function getTexture(textureObject, colorSpace = null) {
        const sampler2 = effect.profile.samplers[textureObject.id];
        let image = null;
        if (sampler2 !== void 0) {
          const surface = effect.profile.surfaces[sampler2.source];
          image = getImage2(surface.init_from);
        } else {
          console.warn("THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).");
          image = getImage2(textureObject.id);
        }
        if (image !== null) {
          const loader = getTextureLoader(image);
          if (loader !== void 0) {
            const texture2 = loader.load(image);
            const extra = textureObject.extra;
            if (extra !== void 0 && extra.technique !== void 0 && isEmpty2(extra.technique) === false) {
              const technique2 = extra.technique;
              texture2.wrapS = technique2.wrapU ? RepeatWrapping2 : ClampToEdgeWrapping2;
              texture2.wrapT = technique2.wrapV ? RepeatWrapping2 : ClampToEdgeWrapping2;
              texture2.offset.set(technique2.offsetU || 0, technique2.offsetV || 0);
              texture2.repeat.set(technique2.repeatU || 1, technique2.repeatV || 1);
            } else {
              texture2.wrapS = RepeatWrapping2;
              texture2.wrapT = RepeatWrapping2;
            }
            if (colorSpace !== null) {
              texture2.colorSpace = colorSpace;
            }
            return texture2;
          } else {
            console.warn("THREE.ColladaLoader: Loader for texture %s not found.", image);
            return null;
          }
        } else {
          console.warn("THREE.ColladaLoader: Couldn't create texture with ID:", textureObject.id);
          return null;
        }
      }
      const parameters = technique.parameters;
      for (const key in parameters) {
        const parameter2 = parameters[key];
        switch (key) {
          case "diffuse":
            if (parameter2.color) material.color.fromArray(parameter2.color);
            if (parameter2.texture) material.map = getTexture(parameter2.texture, SRGBColorSpace2);
            break;
          case "specular":
            if (parameter2.color && material.specular) material.specular.fromArray(parameter2.color);
            if (parameter2.texture) material.specularMap = getTexture(parameter2.texture);
            break;
          case "bump":
            if (parameter2.texture) material.normalMap = getTexture(parameter2.texture);
            break;
          case "ambient":
            if (parameter2.texture) material.lightMap = getTexture(parameter2.texture, SRGBColorSpace2);
            break;
          case "shininess":
            if (parameter2.float && material.shininess) material.shininess = parameter2.float;
            break;
          case "emission":
            if (parameter2.color && material.emissive) material.emissive.fromArray(parameter2.color);
            if (parameter2.texture) material.emissiveMap = getTexture(parameter2.texture, SRGBColorSpace2);
            break;
        }
      }
      material.color.convertSRGBToLinear();
      if (material.specular) material.specular.convertSRGBToLinear();
      if (material.emissive) material.emissive.convertSRGBToLinear();
      let transparent = parameters["transparent"];
      let transparency = parameters["transparency"];
      if (transparency === void 0 && transparent) {
        transparency = {
          float: 1
        };
      }
      if (transparent === void 0 && transparency) {
        transparent = {
          opaque: "A_ONE",
          data: {
            color: [1, 1, 1, 1]
          }
        };
      }
      if (transparent && transparency) {
        if (transparent.data.texture) {
          material.transparent = true;
        } else {
          const color3 = transparent.data.color;
          switch (transparent.opaque) {
            case "A_ONE":
              material.opacity = color3[3] * transparency.float;
              break;
            case "RGB_ZERO":
              material.opacity = 1 - color3[0] * transparency.float;
              break;
            case "A_ZERO":
              material.opacity = 1 - color3[3] * transparency.float;
              break;
            case "RGB_ONE":
              material.opacity = color3[0] * transparency.float;
              break;
            default:
              console.warn('THREE.ColladaLoader: Invalid opaque type "%s" of transparent tag.', transparent.opaque);
          }
          if (material.opacity < 1) material.transparent = true;
        }
      }
      if (technique.extra !== void 0 && technique.extra.technique !== void 0) {
        const techniques = technique.extra.technique;
        for (const k2 in techniques) {
          const v2 = techniques[k2];
          switch (k2) {
            case "double_sided":
              material.side = v2 === 1 ? DoubleSide2 : FrontSide2;
              break;
            case "bump":
              material.normalMap = getTexture(v2.texture);
              material.normalScale = new Vector22(1, 1);
              break;
          }
        }
      }
      return material;
    }
    function getMaterial(id2) {
      return getBuild(library.materials[id2], buildMaterial);
    }
    function parseCamera(xml2) {
      const data = {
        name: xml2.getAttribute("name")
      };
      for (let i2 = 0, l2 = xml2.childNodes.length; i2 < l2; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1) continue;
        switch (child.nodeName) {
          case "optics":
            data.optics = parseCameraOptics(child);
            break;
        }
      }
      library.cameras[xml2.getAttribute("id")] = data;
    }
    function parseCameraOptics(xml2) {
      for (let i2 = 0; i2 < xml2.childNodes.length; i2++) {
        const child = xml2.childNodes[i2];
        switch (child.nodeName) {
          case "technique_common":
            return parseCameraTechnique(child);
        }
      }
      return {};
    }
    function parseCameraTechnique(xml2) {
      const data = {};
      for (let i2 = 0; i2 < xml2.childNodes.length; i2++) {
        const child = xml2.childNodes[i2];
        switch (child.nodeName) {
          case "perspective":
          case "orthographic":
            data.technique = child.nodeName;
            data.parameters = parseCameraParameters(child);
            break;
        }
      }
      return data;
    }
    function parseCameraParameters(xml2) {
      const data = {};
      for (let i2 = 0; i2 < xml2.childNodes.length; i2++) {
        const child = xml2.childNodes[i2];
        switch (child.nodeName) {
          case "xfov":
          case "yfov":
          case "xmag":
          case "ymag":
          case "znear":
          case "zfar":
          case "aspect_ratio":
            data[child.nodeName] = parseFloat(child.textContent);
            break;
        }
      }
      return data;
    }
    function buildCamera(data) {
      let camera3;
      switch (data.optics.technique) {
        case "perspective":
          camera3 = new PerspectiveCamera2(
            data.optics.parameters.yfov,
            data.optics.parameters.aspect_ratio,
            data.optics.parameters.znear,
            data.optics.parameters.zfar
          );
          break;
        case "orthographic":
          let ymag = data.optics.parameters.ymag;
          let xmag = data.optics.parameters.xmag;
          const aspectRatio = data.optics.parameters.aspect_ratio;
          xmag = xmag === void 0 ? ymag * aspectRatio : xmag;
          ymag = ymag === void 0 ? xmag / aspectRatio : ymag;
          xmag *= 0.5;
          ymag *= 0.5;
          camera3 = new OrthographicCamera2(
            -xmag,
            xmag,
            ymag,
            -ymag,
            // left, right, top, bottom
            data.optics.parameters.znear,
            data.optics.parameters.zfar
          );
          break;
        default:
          camera3 = new PerspectiveCamera2();
          break;
      }
      camera3.name = data.name || "";
      return camera3;
    }
    function getCamera(id2) {
      const data = library.cameras[id2];
      if (data !== void 0) {
        return getBuild(data, buildCamera);
      }
      console.warn("THREE.ColladaLoader: Couldn't find camera with ID:", id2);
      return null;
    }
    function parseLight(xml2) {
      let data = {};
      for (let i2 = 0, l2 = xml2.childNodes.length; i2 < l2; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1) continue;
        switch (child.nodeName) {
          case "technique_common":
            data = parseLightTechnique(child);
            break;
        }
      }
      library.lights[xml2.getAttribute("id")] = data;
    }
    function parseLightTechnique(xml2) {
      const data = {};
      for (let i2 = 0, l2 = xml2.childNodes.length; i2 < l2; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1) continue;
        switch (child.nodeName) {
          case "directional":
          case "point":
          case "spot":
          case "ambient":
            data.technique = child.nodeName;
            data.parameters = parseLightParameters(child);
        }
      }
      return data;
    }
    function parseLightParameters(xml2) {
      const data = {};
      for (let i2 = 0, l2 = xml2.childNodes.length; i2 < l2; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1) continue;
        switch (child.nodeName) {
          case "color":
            const array4 = parseFloats(child.textContent);
            data.color = new Color2().fromArray(array4).convertSRGBToLinear();
            break;
          case "falloff_angle":
            data.falloffAngle = parseFloat(child.textContent);
            break;
          case "quadratic_attenuation":
            const f3 = parseFloat(child.textContent);
            data.distance = f3 ? Math.sqrt(1 / f3) : 0;
            break;
        }
      }
      return data;
    }
    function buildLight(data) {
      let light;
      switch (data.technique) {
        case "directional":
          light = new DirectionalLight2();
          break;
        case "point":
          light = new PointLight2();
          break;
        case "spot":
          light = new SpotLight2();
          break;
        case "ambient":
          light = new AmbientLight2();
          break;
      }
      if (data.parameters.color) light.color.copy(data.parameters.color);
      if (data.parameters.distance) light.distance = data.parameters.distance;
      return light;
    }
    function getLight(id2) {
      const data = library.lights[id2];
      if (data !== void 0) {
        return getBuild(data, buildLight);
      }
      console.warn("THREE.ColladaLoader: Couldn't find light with ID:", id2);
      return null;
    }
    function parseGeometry(xml2) {
      const data = {
        name: xml2.getAttribute("name"),
        sources: {},
        vertices: {},
        primitives: []
      };
      const mesh = getElementsByTagName(xml2, "mesh")[0];
      if (mesh === void 0) return;
      for (let i2 = 0; i2 < mesh.childNodes.length; i2++) {
        const child = mesh.childNodes[i2];
        if (child.nodeType !== 1) continue;
        const id2 = child.getAttribute("id");
        switch (child.nodeName) {
          case "source":
            data.sources[id2] = parseSource(child);
            break;
          case "vertices":
            data.vertices = parseGeometryVertices(child);
            break;
          case "polygons":
            console.warn("THREE.ColladaLoader: Unsupported primitive type: ", child.nodeName);
            break;
          case "lines":
          case "linestrips":
          case "polylist":
          case "triangles":
            data.primitives.push(parseGeometryPrimitive(child));
            break;
          default:
            console.log(child);
        }
      }
      library.geometries[xml2.getAttribute("id")] = data;
    }
    function parseSource(xml2) {
      const data = {
        array: [],
        stride: 3
      };
      for (let i2 = 0; i2 < xml2.childNodes.length; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1) continue;
        switch (child.nodeName) {
          case "float_array":
            data.array = parseFloats(child.textContent);
            break;
          case "Name_array":
            data.array = parseStrings(child.textContent);
            break;
          case "technique_common":
            const accessor = getElementsByTagName(child, "accessor")[0];
            if (accessor !== void 0) {
              data.stride = parseInt(accessor.getAttribute("stride"));
            }
            break;
        }
      }
      return data;
    }
    function parseGeometryVertices(xml2) {
      const data = {};
      for (let i2 = 0; i2 < xml2.childNodes.length; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1) continue;
        data[child.getAttribute("semantic")] = parseId(child.getAttribute("source"));
      }
      return data;
    }
    function parseGeometryPrimitive(xml2) {
      const primitive = {
        type: xml2.nodeName,
        material: xml2.getAttribute("material"),
        count: parseInt(xml2.getAttribute("count")),
        inputs: {},
        stride: 0,
        hasUV: false
      };
      for (let i2 = 0, l2 = xml2.childNodes.length; i2 < l2; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1) continue;
        switch (child.nodeName) {
          case "input":
            const id2 = parseId(child.getAttribute("source"));
            const semantic = child.getAttribute("semantic");
            const offset = parseInt(child.getAttribute("offset"));
            const set4 = parseInt(child.getAttribute("set"));
            const inputname = set4 > 0 ? semantic + set4 : semantic;
            primitive.inputs[inputname] = { id: id2, offset };
            primitive.stride = Math.max(primitive.stride, offset + 1);
            if (semantic === "TEXCOORD") primitive.hasUV = true;
            break;
          case "vcount":
            primitive.vcount = parseInts(child.textContent);
            break;
          case "p":
            primitive.p = parseInts(child.textContent);
            break;
        }
      }
      return primitive;
    }
    function groupPrimitives(primitives) {
      const build = {};
      for (let i2 = 0; i2 < primitives.length; i2++) {
        const primitive = primitives[i2];
        if (build[primitive.type] === void 0) build[primitive.type] = [];
        build[primitive.type].push(primitive);
      }
      return build;
    }
    function checkUVCoordinates(primitives) {
      let count3 = 0;
      for (let i2 = 0, l2 = primitives.length; i2 < l2; i2++) {
        const primitive = primitives[i2];
        if (primitive.hasUV === true) {
          count3++;
        }
      }
      if (count3 > 0 && count3 < primitives.length) {
        primitives.uvsNeedsFix = true;
      }
    }
    function buildGeometry(data) {
      const build = {};
      const sources = data.sources;
      const vertices = data.vertices;
      const primitives = data.primitives;
      if (primitives.length === 0) return {};
      const groupedPrimitives = groupPrimitives(primitives);
      for (const type in groupedPrimitives) {
        const primitiveType = groupedPrimitives[type];
        checkUVCoordinates(primitiveType);
        build[type] = buildGeometryType(primitiveType, sources, vertices);
      }
      return build;
    }
    function buildGeometryType(primitives, sources, vertices) {
      const build = {};
      const position2 = { array: [], stride: 0 };
      const normal2 = { array: [], stride: 0 };
      const uv2 = { array: [], stride: 0 };
      const uv1 = { array: [], stride: 0 };
      const color3 = { array: [], stride: 0 };
      const skinIndex = { array: [], stride: 4 };
      const skinWeight = { array: [], stride: 4 };
      const geometry = new BufferGeometry2();
      const materialKeys = [];
      let start2 = 0;
      for (let p3 = 0; p3 < primitives.length; p3++) {
        const primitive = primitives[p3];
        const inputs = primitive.inputs;
        let count3 = 0;
        switch (primitive.type) {
          case "lines":
          case "linestrips":
            count3 = primitive.count * 2;
            break;
          case "triangles":
            count3 = primitive.count * 3;
            break;
          case "polylist":
            for (let g3 = 0; g3 < primitive.count; g3++) {
              const vc = primitive.vcount[g3];
              switch (vc) {
                case 3:
                  count3 += 3;
                  break;
                case 4:
                  count3 += 6;
                  break;
                default:
                  count3 += (vc - 2) * 3;
                  break;
              }
            }
            break;
          default:
            console.warn("THREE.ColladaLoader: Unknow primitive type:", primitive.type);
        }
        geometry.addGroup(start2, count3, p3);
        start2 += count3;
        if (primitive.material) {
          materialKeys.push(primitive.material);
        }
        for (const name in inputs) {
          const input = inputs[name];
          switch (name) {
            case "VERTEX":
              for (const key in vertices) {
                const id2 = vertices[key];
                switch (key) {
                  case "POSITION":
                    const prevLength = position2.array.length;
                    buildGeometryData(primitive, sources[id2], input.offset, position2.array);
                    position2.stride = sources[id2].stride;
                    if (sources.skinWeights && sources.skinIndices) {
                      buildGeometryData(primitive, sources.skinIndices, input.offset, skinIndex.array);
                      buildGeometryData(primitive, sources.skinWeights, input.offset, skinWeight.array);
                    }
                    if (primitive.hasUV === false && primitives.uvsNeedsFix === true) {
                      const count4 = (position2.array.length - prevLength) / position2.stride;
                      for (let i2 = 0; i2 < count4; i2++) {
                        uv2.array.push(0, 0);
                      }
                    }
                    break;
                  case "NORMAL":
                    buildGeometryData(primitive, sources[id2], input.offset, normal2.array);
                    normal2.stride = sources[id2].stride;
                    break;
                  case "COLOR":
                    buildGeometryData(primitive, sources[id2], input.offset, color3.array);
                    color3.stride = sources[id2].stride;
                    break;
                  case "TEXCOORD":
                    buildGeometryData(primitive, sources[id2], input.offset, uv2.array);
                    uv2.stride = sources[id2].stride;
                    break;
                  case "TEXCOORD1":
                    buildGeometryData(primitive, sources[id2], input.offset, uv1.array);
                    uv2.stride = sources[id2].stride;
                    break;
                  default:
                    console.warn('THREE.ColladaLoader: Semantic "%s" not handled in geometry build process.', key);
                }
              }
              break;
            case "NORMAL":
              buildGeometryData(primitive, sources[input.id], input.offset, normal2.array);
              normal2.stride = sources[input.id].stride;
              break;
            case "COLOR":
              buildGeometryData(primitive, sources[input.id], input.offset, color3.array, true);
              color3.stride = sources[input.id].stride;
              break;
            case "TEXCOORD":
              buildGeometryData(primitive, sources[input.id], input.offset, uv2.array);
              uv2.stride = sources[input.id].stride;
              break;
            case "TEXCOORD1":
              buildGeometryData(primitive, sources[input.id], input.offset, uv1.array);
              uv1.stride = sources[input.id].stride;
              break;
          }
        }
      }
      if (position2.array.length > 0) geometry.setAttribute("position", new Float32BufferAttribute2(position2.array, position2.stride));
      if (normal2.array.length > 0) geometry.setAttribute("normal", new Float32BufferAttribute2(normal2.array, normal2.stride));
      if (color3.array.length > 0) geometry.setAttribute("color", new Float32BufferAttribute2(color3.array, color3.stride));
      if (uv2.array.length > 0) geometry.setAttribute("uv", new Float32BufferAttribute2(uv2.array, uv2.stride));
      if (uv1.array.length > 0) geometry.setAttribute("uv1", new Float32BufferAttribute2(uv1.array, uv1.stride));
      if (skinIndex.array.length > 0) geometry.setAttribute("skinIndex", new Float32BufferAttribute2(skinIndex.array, skinIndex.stride));
      if (skinWeight.array.length > 0) geometry.setAttribute("skinWeight", new Float32BufferAttribute2(skinWeight.array, skinWeight.stride));
      build.data = geometry;
      build.type = primitives[0].type;
      build.materialKeys = materialKeys;
      return build;
    }
    function buildGeometryData(primitive, source, offset, array4, isColor = false) {
      const indices = primitive.p;
      const stride = primitive.stride;
      const vcount = primitive.vcount;
      function pushVector(i2) {
        let index8 = indices[i2 + offset] * sourceStride;
        const length2 = index8 + sourceStride;
        for (; index8 < length2; index8++) {
          array4.push(sourceArray[index8]);
        }
        if (isColor) {
          const startIndex = array4.length - sourceStride - 1;
          tempColor.setRGB(
            array4[startIndex + 0],
            array4[startIndex + 1],
            array4[startIndex + 2]
          ).convertSRGBToLinear();
          array4[startIndex + 0] = tempColor.r;
          array4[startIndex + 1] = tempColor.g;
          array4[startIndex + 2] = tempColor.b;
        }
      }
      const sourceArray = source.array;
      const sourceStride = source.stride;
      if (primitive.vcount !== void 0) {
        let index8 = 0;
        for (let i2 = 0, l2 = vcount.length; i2 < l2; i2++) {
          const count3 = vcount[i2];
          if (count3 === 4) {
            const a3 = index8 + stride * 0;
            const b = index8 + stride * 1;
            const c5 = index8 + stride * 2;
            const d3 = index8 + stride * 3;
            pushVector(a3);
            pushVector(b);
            pushVector(d3);
            pushVector(b);
            pushVector(c5);
            pushVector(d3);
          } else if (count3 === 3) {
            const a3 = index8 + stride * 0;
            const b = index8 + stride * 1;
            const c5 = index8 + stride * 2;
            pushVector(a3);
            pushVector(b);
            pushVector(c5);
          } else if (count3 > 4) {
            for (let k2 = 1, kl = count3 - 2; k2 <= kl; k2++) {
              const a3 = index8 + stride * 0;
              const b = index8 + stride * k2;
              const c5 = index8 + stride * (k2 + 1);
              pushVector(a3);
              pushVector(b);
              pushVector(c5);
            }
          }
          index8 += stride * count3;
        }
      } else {
        for (let i2 = 0, l2 = indices.length; i2 < l2; i2 += stride) {
          pushVector(i2);
        }
      }
    }
    function getGeometry(id2) {
      return getBuild(library.geometries[id2], buildGeometry);
    }
    function parseKinematicsModel(xml2) {
      const data = {
        name: xml2.getAttribute("name") || "",
        joints: {},
        links: []
      };
      for (let i2 = 0; i2 < xml2.childNodes.length; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1) continue;
        switch (child.nodeName) {
          case "technique_common":
            parseKinematicsTechniqueCommon(child, data);
            break;
        }
      }
      library.kinematicsModels[xml2.getAttribute("id")] = data;
    }
    function buildKinematicsModel(data) {
      if (data.build !== void 0) return data.build;
      return data;
    }
    function getKinematicsModel(id2) {
      return getBuild(library.kinematicsModels[id2], buildKinematicsModel);
    }
    function parseKinematicsTechniqueCommon(xml2, data) {
      for (let i2 = 0; i2 < xml2.childNodes.length; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1) continue;
        switch (child.nodeName) {
          case "joint":
            data.joints[child.getAttribute("sid")] = parseKinematicsJoint(child);
            break;
          case "link":
            data.links.push(parseKinematicsLink(child));
            break;
        }
      }
    }
    function parseKinematicsJoint(xml2) {
      let data;
      for (let i2 = 0; i2 < xml2.childNodes.length; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1) continue;
        switch (child.nodeName) {
          case "prismatic":
          case "revolute":
            data = parseKinematicsJointParameter(child);
            break;
        }
      }
      return data;
    }
    function parseKinematicsJointParameter(xml2) {
      const data = {
        sid: xml2.getAttribute("sid"),
        name: xml2.getAttribute("name") || "",
        axis: new Vector32(),
        limits: {
          min: 0,
          max: 0
        },
        type: xml2.nodeName,
        static: false,
        zeroPosition: 0,
        middlePosition: 0
      };
      for (let i2 = 0; i2 < xml2.childNodes.length; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1) continue;
        switch (child.nodeName) {
          case "axis":
            const array4 = parseFloats(child.textContent);
            data.axis.fromArray(array4);
            break;
          case "limits":
            const max6 = child.getElementsByTagName("max")[0];
            const min5 = child.getElementsByTagName("min")[0];
            data.limits.max = parseFloat(max6.textContent);
            data.limits.min = parseFloat(min5.textContent);
            break;
        }
      }
      if (data.limits.min >= data.limits.max) {
        data.static = true;
      }
      data.middlePosition = (data.limits.min + data.limits.max) / 2;
      return data;
    }
    function parseKinematicsLink(xml2) {
      const data = {
        sid: xml2.getAttribute("sid"),
        name: xml2.getAttribute("name") || "",
        attachments: [],
        transforms: []
      };
      for (let i2 = 0; i2 < xml2.childNodes.length; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1) continue;
        switch (child.nodeName) {
          case "attachment_full":
            data.attachments.push(parseKinematicsAttachment(child));
            break;
          case "matrix":
          case "translate":
          case "rotate":
            data.transforms.push(parseKinematicsTransform(child));
            break;
        }
      }
      return data;
    }
    function parseKinematicsAttachment(xml2) {
      const data = {
        joint: xml2.getAttribute("joint").split("/").pop(),
        transforms: [],
        links: []
      };
      for (let i2 = 0; i2 < xml2.childNodes.length; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1) continue;
        switch (child.nodeName) {
          case "link":
            data.links.push(parseKinematicsLink(child));
            break;
          case "matrix":
          case "translate":
          case "rotate":
            data.transforms.push(parseKinematicsTransform(child));
            break;
        }
      }
      return data;
    }
    function parseKinematicsTransform(xml2) {
      const data = {
        type: xml2.nodeName
      };
      const array4 = parseFloats(xml2.textContent);
      switch (data.type) {
        case "matrix":
          data.obj = new Matrix42();
          data.obj.fromArray(array4).transpose();
          break;
        case "translate":
          data.obj = new Vector32();
          data.obj.fromArray(array4);
          break;
        case "rotate":
          data.obj = new Vector32();
          data.obj.fromArray(array4);
          data.angle = MathUtils2.degToRad(array4[3]);
          break;
      }
      return data;
    }
    function parsePhysicsModel(xml2) {
      const data = {
        name: xml2.getAttribute("name") || "",
        rigidBodies: {}
      };
      for (let i2 = 0; i2 < xml2.childNodes.length; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1) continue;
        switch (child.nodeName) {
          case "rigid_body":
            data.rigidBodies[child.getAttribute("name")] = {};
            parsePhysicsRigidBody(child, data.rigidBodies[child.getAttribute("name")]);
            break;
        }
      }
      library.physicsModels[xml2.getAttribute("id")] = data;
    }
    function parsePhysicsRigidBody(xml2, data) {
      for (let i2 = 0; i2 < xml2.childNodes.length; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1) continue;
        switch (child.nodeName) {
          case "technique_common":
            parsePhysicsTechniqueCommon(child, data);
            break;
        }
      }
    }
    function parsePhysicsTechniqueCommon(xml2, data) {
      for (let i2 = 0; i2 < xml2.childNodes.length; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1) continue;
        switch (child.nodeName) {
          case "inertia":
            data.inertia = parseFloats(child.textContent);
            break;
          case "mass":
            data.mass = parseFloats(child.textContent)[0];
            break;
        }
      }
    }
    function parseKinematicsScene(xml2) {
      const data = {
        bindJointAxis: []
      };
      for (let i2 = 0; i2 < xml2.childNodes.length; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1) continue;
        switch (child.nodeName) {
          case "bind_joint_axis":
            data.bindJointAxis.push(parseKinematicsBindJointAxis(child));
            break;
        }
      }
      library.kinematicsScenes[parseId(xml2.getAttribute("url"))] = data;
    }
    function parseKinematicsBindJointAxis(xml2) {
      const data = {
        target: xml2.getAttribute("target").split("/").pop()
      };
      for (let i2 = 0; i2 < xml2.childNodes.length; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1) continue;
        switch (child.nodeName) {
          case "axis":
            const param = child.getElementsByTagName("param")[0];
            data.axis = param.textContent;
            const tmpJointIndex = data.axis.split("inst_").pop().split("axis")[0];
            data.jointIndex = tmpJointIndex.substring(0, tmpJointIndex.length - 1);
            break;
        }
      }
      return data;
    }
    function buildKinematicsScene(data) {
      if (data.build !== void 0) return data.build;
      return data;
    }
    function getKinematicsScene(id2) {
      return getBuild(library.kinematicsScenes[id2], buildKinematicsScene);
    }
    function setupKinematics() {
      const kinematicsModelId = Object.keys(library.kinematicsModels)[0];
      const kinematicsSceneId = Object.keys(library.kinematicsScenes)[0];
      const visualSceneId = Object.keys(library.visualScenes)[0];
      if (kinematicsModelId === void 0 || kinematicsSceneId === void 0) return;
      const kinematicsModel = getKinematicsModel(kinematicsModelId);
      const kinematicsScene = getKinematicsScene(kinematicsSceneId);
      const visualScene = getVisualScene(visualSceneId);
      const bindJointAxis = kinematicsScene.bindJointAxis;
      const jointMap = {};
      for (let i2 = 0, l2 = bindJointAxis.length; i2 < l2; i2++) {
        const axis = bindJointAxis[i2];
        const targetElement = collada.querySelector('[sid="' + axis.target + '"]');
        if (targetElement) {
          const parentVisualElement = targetElement.parentElement;
          connect(axis.jointIndex, parentVisualElement);
        }
      }
      function connect(jointIndex, visualElement) {
        const visualElementName = visualElement.getAttribute("name");
        const joint = kinematicsModel.joints[jointIndex];
        visualScene.traverse(function(object) {
          if (object.name === visualElementName) {
            jointMap[jointIndex] = {
              object,
              transforms: buildTransformList(visualElement),
              joint,
              position: joint.zeroPosition
            };
          }
        });
      }
      const m0 = new Matrix42();
      kinematics = {
        joints: kinematicsModel && kinematicsModel.joints,
        getJointValue: function(jointIndex) {
          const jointData = jointMap[jointIndex];
          if (jointData) {
            return jointData.position;
          } else {
            console.warn("THREE.ColladaLoader: Joint " + jointIndex + " doesn't exist.");
          }
        },
        setJointValue: function(jointIndex, value) {
          const jointData = jointMap[jointIndex];
          if (jointData) {
            const joint = jointData.joint;
            if (value > joint.limits.max || value < joint.limits.min) {
              console.warn("THREE.ColladaLoader: Joint " + jointIndex + " value " + value + " outside of limits (min: " + joint.limits.min + ", max: " + joint.limits.max + ").");
            } else if (joint.static) {
              console.warn("THREE.ColladaLoader: Joint " + jointIndex + " is static.");
            } else {
              const object = jointData.object;
              const axis = joint.axis;
              const transforms = jointData.transforms;
              matrix.identity();
              for (let i2 = 0; i2 < transforms.length; i2++) {
                const transform3 = transforms[i2];
                if (transform3.sid && transform3.sid.indexOf(jointIndex) !== -1) {
                  switch (joint.type) {
                    case "revolute":
                      matrix.multiply(m0.makeRotationAxis(axis, MathUtils2.degToRad(value)));
                      break;
                    case "prismatic":
                      matrix.multiply(m0.makeTranslation(axis.x * value, axis.y * value, axis.z * value));
                      break;
                    default:
                      console.warn("THREE.ColladaLoader: Unknown joint type: " + joint.type);
                      break;
                  }
                } else {
                  switch (transform3.type) {
                    case "matrix":
                      matrix.multiply(transform3.obj);
                      break;
                    case "translate":
                      matrix.multiply(m0.makeTranslation(transform3.obj.x, transform3.obj.y, transform3.obj.z));
                      break;
                    case "scale":
                      matrix.scale(transform3.obj);
                      break;
                    case "rotate":
                      matrix.multiply(m0.makeRotationAxis(transform3.obj, transform3.angle));
                      break;
                  }
                }
              }
              object.matrix.copy(matrix);
              object.matrix.decompose(object.position, object.quaternion, object.scale);
              jointMap[jointIndex].position = value;
            }
          } else {
            console.log("THREE.ColladaLoader: " + jointIndex + " does not exist.");
          }
        }
      };
    }
    function buildTransformList(node) {
      const transforms = [];
      const xml2 = collada.querySelector('[id="' + node.id + '"]');
      for (let i2 = 0; i2 < xml2.childNodes.length; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1) continue;
        let array4, vector2;
        switch (child.nodeName) {
          case "matrix":
            array4 = parseFloats(child.textContent);
            const matrix2 = new Matrix42().fromArray(array4).transpose();
            transforms.push({
              sid: child.getAttribute("sid"),
              type: child.nodeName,
              obj: matrix2
            });
            break;
          case "translate":
          case "scale":
            array4 = parseFloats(child.textContent);
            vector2 = new Vector32().fromArray(array4);
            transforms.push({
              sid: child.getAttribute("sid"),
              type: child.nodeName,
              obj: vector2
            });
            break;
          case "rotate":
            array4 = parseFloats(child.textContent);
            vector2 = new Vector32().fromArray(array4);
            const angle2 = MathUtils2.degToRad(array4[3]);
            transforms.push({
              sid: child.getAttribute("sid"),
              type: child.nodeName,
              obj: vector2,
              angle: angle2
            });
            break;
        }
      }
      return transforms;
    }
    function prepareNodes(xml2) {
      const elements = xml2.getElementsByTagName("node");
      for (let i2 = 0; i2 < elements.length; i2++) {
        const element2 = elements[i2];
        if (element2.hasAttribute("id") === false) {
          element2.setAttribute("id", generateId());
        }
      }
    }
    const matrix = new Matrix42();
    const vector = new Vector32();
    function parseNode(xml2) {
      const data = {
        name: xml2.getAttribute("name") || "",
        type: xml2.getAttribute("type"),
        id: xml2.getAttribute("id"),
        sid: xml2.getAttribute("sid"),
        matrix: new Matrix42(),
        nodes: [],
        instanceCameras: [],
        instanceControllers: [],
        instanceLights: [],
        instanceGeometries: [],
        instanceNodes: [],
        transforms: {}
      };
      for (let i2 = 0; i2 < xml2.childNodes.length; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1) continue;
        let array4;
        switch (child.nodeName) {
          case "node":
            data.nodes.push(child.getAttribute("id"));
            parseNode(child);
            break;
          case "instance_camera":
            data.instanceCameras.push(parseId(child.getAttribute("url")));
            break;
          case "instance_controller":
            data.instanceControllers.push(parseNodeInstance(child));
            break;
          case "instance_light":
            data.instanceLights.push(parseId(child.getAttribute("url")));
            break;
          case "instance_geometry":
            data.instanceGeometries.push(parseNodeInstance(child));
            break;
          case "instance_node":
            data.instanceNodes.push(parseId(child.getAttribute("url")));
            break;
          case "matrix":
            array4 = parseFloats(child.textContent);
            data.matrix.multiply(matrix.fromArray(array4).transpose());
            data.transforms[child.getAttribute("sid")] = child.nodeName;
            break;
          case "translate":
            array4 = parseFloats(child.textContent);
            vector.fromArray(array4);
            data.matrix.multiply(matrix.makeTranslation(vector.x, vector.y, vector.z));
            data.transforms[child.getAttribute("sid")] = child.nodeName;
            break;
          case "rotate":
            array4 = parseFloats(child.textContent);
            const angle2 = MathUtils2.degToRad(array4[3]);
            data.matrix.multiply(matrix.makeRotationAxis(vector.fromArray(array4), angle2));
            data.transforms[child.getAttribute("sid")] = child.nodeName;
            break;
          case "scale":
            array4 = parseFloats(child.textContent);
            data.matrix.scale(vector.fromArray(array4));
            data.transforms[child.getAttribute("sid")] = child.nodeName;
            break;
          case "extra":
            break;
          default:
            console.log(child);
        }
      }
      if (hasNode(data.id)) {
        console.warn("THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.", data.id);
      } else {
        library.nodes[data.id] = data;
      }
      return data;
    }
    function parseNodeInstance(xml2) {
      const data = {
        id: parseId(xml2.getAttribute("url")),
        materials: {},
        skeletons: []
      };
      for (let i2 = 0; i2 < xml2.childNodes.length; i2++) {
        const child = xml2.childNodes[i2];
        switch (child.nodeName) {
          case "bind_material":
            const instances = child.getElementsByTagName("instance_material");
            for (let j2 = 0; j2 < instances.length; j2++) {
              const instance2 = instances[j2];
              const symbol = instance2.getAttribute("symbol");
              const target = instance2.getAttribute("target");
              data.materials[symbol] = parseId(target);
            }
            break;
          case "skeleton":
            data.skeletons.push(parseId(child.textContent));
            break;
          default:
            break;
        }
      }
      return data;
    }
    function buildSkeleton(skeletons, joints) {
      const boneData = [];
      const sortedBoneData = [];
      let i2, j2, data;
      for (i2 = 0; i2 < skeletons.length; i2++) {
        const skeleton = skeletons[i2];
        let root3;
        if (hasNode(skeleton)) {
          root3 = getNode(skeleton);
          buildBoneHierarchy(root3, joints, boneData);
        } else if (hasVisualScene(skeleton)) {
          const visualScene = library.visualScenes[skeleton];
          const children2 = visualScene.children;
          for (let j3 = 0; j3 < children2.length; j3++) {
            const child = children2[j3];
            if (child.type === "JOINT") {
              const root4 = getNode(child.id);
              buildBoneHierarchy(root4, joints, boneData);
            }
          }
        } else {
          console.error("THREE.ColladaLoader: Unable to find root bone of skeleton with ID:", skeleton);
        }
      }
      for (i2 = 0; i2 < joints.length; i2++) {
        for (j2 = 0; j2 < boneData.length; j2++) {
          data = boneData[j2];
          if (data.bone.name === joints[i2].name) {
            sortedBoneData[i2] = data;
            data.processed = true;
            break;
          }
        }
      }
      for (i2 = 0; i2 < boneData.length; i2++) {
        data = boneData[i2];
        if (data.processed === false) {
          sortedBoneData.push(data);
          data.processed = true;
        }
      }
      const bones = [];
      const boneInverses = [];
      for (i2 = 0; i2 < sortedBoneData.length; i2++) {
        data = sortedBoneData[i2];
        bones.push(data.bone);
        boneInverses.push(data.boneInverse);
      }
      return new Skeleton(bones, boneInverses);
    }
    function buildBoneHierarchy(root3, joints, boneData) {
      root3.traverse(function(object) {
        if (object.isBone === true) {
          let boneInverse;
          for (let i2 = 0; i2 < joints.length; i2++) {
            const joint = joints[i2];
            if (joint.name === object.name) {
              boneInverse = joint.boneInverse;
              break;
            }
          }
          if (boneInverse === void 0) {
            boneInverse = new Matrix42();
          }
          boneData.push({ bone: object, boneInverse, processed: false });
        }
      });
    }
    function buildNode(data) {
      const objects = [];
      const matrix2 = data.matrix;
      const nodes = data.nodes;
      const type = data.type;
      const instanceCameras = data.instanceCameras;
      const instanceControllers = data.instanceControllers;
      const instanceLights = data.instanceLights;
      const instanceGeometries = data.instanceGeometries;
      const instanceNodes = data.instanceNodes;
      for (let i2 = 0, l2 = nodes.length; i2 < l2; i2++) {
        objects.push(getNode(nodes[i2]));
      }
      for (let i2 = 0, l2 = instanceCameras.length; i2 < l2; i2++) {
        const instanceCamera = getCamera(instanceCameras[i2]);
        if (instanceCamera !== null) {
          objects.push(instanceCamera.clone());
        }
      }
      for (let i2 = 0, l2 = instanceControllers.length; i2 < l2; i2++) {
        const instance2 = instanceControllers[i2];
        const controller = getController(instance2.id);
        const geometries = getGeometry(controller.id);
        const newObjects = buildObjects(geometries, instance2.materials);
        const skeletons = instance2.skeletons;
        const joints = controller.skin.joints;
        const skeleton = buildSkeleton(skeletons, joints);
        for (let j2 = 0, jl = newObjects.length; j2 < jl; j2++) {
          const object2 = newObjects[j2];
          if (object2.isSkinnedMesh) {
            object2.bind(skeleton, controller.skin.bindMatrix);
            object2.normalizeSkinWeights();
          }
          objects.push(object2);
        }
      }
      for (let i2 = 0, l2 = instanceLights.length; i2 < l2; i2++) {
        const instanceLight = getLight(instanceLights[i2]);
        if (instanceLight !== null) {
          objects.push(instanceLight.clone());
        }
      }
      for (let i2 = 0, l2 = instanceGeometries.length; i2 < l2; i2++) {
        const instance2 = instanceGeometries[i2];
        const geometries = getGeometry(instance2.id);
        const newObjects = buildObjects(geometries, instance2.materials);
        for (let j2 = 0, jl = newObjects.length; j2 < jl; j2++) {
          objects.push(newObjects[j2]);
        }
      }
      for (let i2 = 0, l2 = instanceNodes.length; i2 < l2; i2++) {
        objects.push(getNode(instanceNodes[i2]).clone());
      }
      let object;
      if (nodes.length === 0 && objects.length === 1) {
        object = objects[0];
      } else {
        object = type === "JOINT" ? new Bone() : new Group2();
        for (let i2 = 0; i2 < objects.length; i2++) {
          object.add(objects[i2]);
        }
      }
      object.name = type === "JOINT" ? data.sid : data.name;
      object.matrix.copy(matrix2);
      object.matrix.decompose(object.position, object.quaternion, object.scale);
      return object;
    }
    const fallbackMaterial = new MeshBasicMaterial2({
      name: Loader.DEFAULT_MATERIAL_NAME,
      color: 16711935
    });
    function resolveMaterialBinding(keys2, instanceMaterials) {
      const materials = [];
      for (let i2 = 0, l2 = keys2.length; i2 < l2; i2++) {
        const id2 = instanceMaterials[keys2[i2]];
        if (id2 === void 0) {
          console.warn("THREE.ColladaLoader: Material with key %s not found. Apply fallback material.", keys2[i2]);
          materials.push(fallbackMaterial);
        } else {
          materials.push(getMaterial(id2));
        }
      }
      return materials;
    }
    function buildObjects(geometries, instanceMaterials) {
      const objects = [];
      for (const type in geometries) {
        const geometry = geometries[type];
        const materials = resolveMaterialBinding(geometry.materialKeys, instanceMaterials);
        if (materials.length === 0) {
          if (type === "lines" || type === "linestrips") {
            materials.push(new LineBasicMaterial2());
          } else {
            materials.push(new MeshPhongMaterial2());
          }
        }
        if (type === "lines" || type === "linestrips") {
          for (let i2 = 0, l2 = materials.length; i2 < l2; i2++) {
            const material2 = materials[i2];
            if (material2.isMeshPhongMaterial === true || material2.isMeshLambertMaterial === true) {
              const lineMaterial = new LineBasicMaterial2();
              lineMaterial.color.copy(material2.color);
              lineMaterial.opacity = material2.opacity;
              lineMaterial.transparent = material2.transparent;
              materials[i2] = lineMaterial;
            }
          }
        }
        const skinning2 = geometry.data.attributes.skinIndex !== void 0;
        const material = materials.length === 1 ? materials[0] : materials;
        let object;
        switch (type) {
          case "lines":
            object = new LineSegments(geometry.data, material);
            break;
          case "linestrips":
            object = new Line2(geometry.data, material);
            break;
          case "triangles":
          case "polylist":
            if (skinning2) {
              object = new SkinnedMesh(geometry.data, material);
            } else {
              object = new Mesh2(geometry.data, material);
            }
            break;
        }
        objects.push(object);
      }
      return objects;
    }
    function hasNode(id2) {
      return library.nodes[id2] !== void 0;
    }
    function getNode(id2) {
      return getBuild(library.nodes[id2], buildNode);
    }
    function parseVisualScene(xml2) {
      const data = {
        name: xml2.getAttribute("name"),
        children: []
      };
      prepareNodes(xml2);
      const elements = getElementsByTagName(xml2, "node");
      for (let i2 = 0; i2 < elements.length; i2++) {
        data.children.push(parseNode(elements[i2]));
      }
      library.visualScenes[xml2.getAttribute("id")] = data;
    }
    function buildVisualScene(data) {
      const group2 = new Group2();
      group2.name = data.name;
      const children2 = data.children;
      for (let i2 = 0; i2 < children2.length; i2++) {
        const child = children2[i2];
        group2.add(getNode(child.id));
      }
      return group2;
    }
    function hasVisualScene(id2) {
      return library.visualScenes[id2] !== void 0;
    }
    function getVisualScene(id2) {
      return getBuild(library.visualScenes[id2], buildVisualScene);
    }
    function parseScene(xml2) {
      const instance2 = getElementsByTagName(xml2, "instance_visual_scene")[0];
      return getVisualScene(parseId(instance2.getAttribute("url")));
    }
    function setupAnimations() {
      const clips = library.clips;
      if (isEmpty2(clips) === true) {
        if (isEmpty2(library.animations) === false) {
          const tracks = [];
          for (const id2 in library.animations) {
            const animationTracks = getAnimation(id2);
            for (let i2 = 0, l2 = animationTracks.length; i2 < l2; i2++) {
              tracks.push(animationTracks[i2]);
            }
          }
          animations.push(new AnimationClip("default", -1, tracks));
        }
      } else {
        for (const id2 in clips) {
          animations.push(getAnimationClip(id2));
        }
      }
    }
    function parserErrorToText(parserError2) {
      let result2 = "";
      const stack2 = [parserError2];
      while (stack2.length) {
        const node = stack2.shift();
        if (node.nodeType === Node.TEXT_NODE) {
          result2 += node.textContent;
        } else {
          result2 += "\n";
          stack2.push.apply(stack2, node.childNodes);
        }
      }
      return result2.trim();
    }
    if (text.length === 0) {
      return { scene: new Scene2() };
    }
    const xml = new DOMParser().parseFromString(text, "application/xml");
    const collada = getElementsByTagName(xml, "COLLADA")[0];
    const parserError = xml.getElementsByTagName("parsererror")[0];
    if (parserError !== void 0) {
      const errorElement = getElementsByTagName(parserError, "div")[0];
      let errorText;
      if (errorElement) {
        errorText = errorElement.textContent;
      } else {
        errorText = parserErrorToText(parserError);
      }
      console.error("THREE.ColladaLoader: Failed to parse collada file.\n", errorText);
      return null;
    }
    const version = collada.getAttribute("version");
    console.debug("THREE.ColladaLoader: File version", version);
    const asset = parseAsset(getElementsByTagName(collada, "asset")[0]);
    const textureLoader = new TextureLoader2(this.manager);
    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);
    let tgaLoader;
    if (TGALoader) {
      tgaLoader = new TGALoader(this.manager);
      tgaLoader.setPath(this.resourcePath || path);
    }
    const tempColor = new Color2();
    const animations = [];
    let kinematics = {};
    let count2 = 0;
    const library = {
      animations: {},
      clips: {},
      controllers: {},
      images: {},
      effects: {},
      materials: {},
      cameras: {},
      lights: {},
      geometries: {},
      nodes: {},
      visualScenes: {},
      kinematicsModels: {},
      physicsModels: {},
      kinematicsScenes: {}
    };
    parseLibrary(collada, "library_animations", "animation", parseAnimation);
    parseLibrary(collada, "library_animation_clips", "animation_clip", parseAnimationClip);
    parseLibrary(collada, "library_controllers", "controller", parseController);
    parseLibrary(collada, "library_images", "image", parseImage);
    parseLibrary(collada, "library_effects", "effect", parseEffect);
    parseLibrary(collada, "library_materials", "material", parseMaterial);
    parseLibrary(collada, "library_cameras", "camera", parseCamera);
    parseLibrary(collada, "library_lights", "light", parseLight);
    parseLibrary(collada, "library_geometries", "geometry", parseGeometry);
    parseLibrary(collada, "library_nodes", "node", parseNode);
    parseLibrary(collada, "library_visual_scenes", "visual_scene", parseVisualScene);
    parseLibrary(collada, "library_kinematics_models", "kinematics_model", parseKinematicsModel);
    parseLibrary(collada, "library_physics_models", "physics_model", parsePhysicsModel);
    parseLibrary(collada, "scene", "instance_kinematics_scene", parseKinematicsScene);
    buildLibrary(library.animations, buildAnimation);
    buildLibrary(library.clips, buildAnimationClip);
    buildLibrary(library.controllers, buildController);
    buildLibrary(library.images, buildImage);
    buildLibrary(library.effects, buildEffect);
    buildLibrary(library.materials, buildMaterial);
    buildLibrary(library.cameras, buildCamera);
    buildLibrary(library.lights, buildLight);
    buildLibrary(library.geometries, buildGeometry);
    buildLibrary(library.visualScenes, buildVisualScene);
    setupAnimations();
    setupKinematics();
    const scene3 = parseScene(getElementsByTagName(collada, "scene")[0]);
    scene3.animations = animations;
    if (asset.upAxis === "Z_UP") {
      console.warn("THREE.ColladaLoader: You are loading an asset with a Z-UP coordinate system. The loader just rotates the asset to transform it into Y-UP. The vertex data are not converted, see #24289.");
      scene3.rotation.set(-Math.PI / 2, 0, 0);
    }
    scene3.scale.multiplyScalar(asset.unit);
    return {
      get animations() {
        console.warn("THREE.ColladaLoader: Please access animations over scene.animations now.");
        return animations;
      },
      kinematics,
      library,
      scene: scene3
    };
  }
};

// node_modules/aframe-extras/src/loaders/collada-model-legacy.js
THREE.ColladaLoader = ColladaLoader;
AFRAME.registerComponent("collada-model-legacy", {
  schema: { type: "asset" },
  init: function() {
    this.model = null;
    this.loader = new THREE.ColladaLoader();
  },
  update: function() {
    var self2 = this;
    var el = this.el;
    var src = this.data;
    var rendererSystem = this.el.sceneEl.systems.renderer;
    if (!src) {
      return;
    }
    this.remove();
    this.loader.load(src, function(colladaModel) {
      self2.model = colladaModel.scene;
      self2.model.traverse(function(object) {
        if (object.isMesh) {
          var material = object.material;
          if (material.color) rendererSystem.applyColorCorrection(material.color);
          if (material.map) rendererSystem.applyColorCorrection(material.map);
          if (material.emissive) rendererSystem.applyColorCorrection(material.emissive);
          if (material.emissiveMap) rendererSystem.applyColorCorrection(material.emissiveMap);
        }
      });
      el.setObject3D("mesh", self2.model);
      el.emit("model-loaded", { format: "collada", model: self2.model });
    });
  },
  remove: function() {
    if (!this.model) {
      return;
    }
    this.el.removeObject3D("mesh");
  }
});

// node_modules/aframe-extras/node_modules/three/examples/jsm/libs/fflate.module.js
var ch2 = {};
var wk = (function(c5, id2, msg, transfer, cb) {
  var w4 = new Worker(ch2[id2] || (ch2[id2] = URL.createObjectURL(new Blob([
    c5 + ';addEventListener("error",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})'
  ], { type: "text/javascript" }))));
  w4.onmessage = function(e3) {
    var d3 = e3.data, ed = d3.$e$;
    if (ed) {
      var err2 = new Error(ed[0]);
      err2["code"] = ed[1];
      err2.stack = ed[2];
      cb(err2, null);
    } else
      cb(null, d3);
  };
  w4.postMessage(msg, transfer);
  return w4;
});
var u8 = Uint8Array;
var u16 = Uint16Array;
var i32 = Int32Array;
var fleb = new u8([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]);
var fdeb = new u8([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]);
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var freb = function(eb, start2) {
  var b = new u16(31);
  for (var i2 = 0; i2 < 31; ++i2) {
    b[i2] = start2 += 1 << eb[i2 - 1];
  }
  var r2 = new i32(b[30]);
  for (var i2 = 1; i2 < 30; ++i2) {
    for (var j2 = b[i2]; j2 < b[i2 + 1]; ++j2) {
      r2[j2] = j2 - b[i2] << 5 | i2;
    }
  }
  return { b, r: r2 };
};
var _a = freb(fleb, 2);
var fl = _a.b;
var revfl = _a.r;
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0);
var fd = _b.b;
var revfd = _b.r;
var rev = new u16(32768);
for (i2 = 0; i2 < 32768; ++i2) {
  x3 = (i2 & 43690) >> 1 | (i2 & 21845) << 1;
  x3 = (x3 & 52428) >> 2 | (x3 & 13107) << 2;
  x3 = (x3 & 61680) >> 4 | (x3 & 3855) << 4;
  rev[i2] = ((x3 & 65280) >> 8 | (x3 & 255) << 8) >> 1;
}
var x3;
var i2;
var hMap = (function(cd, mb, r2) {
  var s2 = cd.length;
  var i2 = 0;
  var l2 = new u16(mb);
  for (; i2 < s2; ++i2) {
    if (cd[i2])
      ++l2[cd[i2] - 1];
  }
  var le = new u16(mb);
  for (i2 = 1; i2 < mb; ++i2) {
    le[i2] = le[i2 - 1] + l2[i2 - 1] << 1;
  }
  var co;
  if (r2) {
    co = new u16(1 << mb);
    var rvb = 15 - mb;
    for (i2 = 0; i2 < s2; ++i2) {
      if (cd[i2]) {
        var sv = i2 << 4 | cd[i2];
        var r_1 = mb - cd[i2];
        var v2 = le[cd[i2] - 1]++ << r_1;
        for (var m3 = v2 | (1 << r_1) - 1; v2 <= m3; ++v2) {
          co[rev[v2] >> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s2);
    for (i2 = 0; i2 < s2; ++i2) {
      if (cd[i2]) {
        co[i2] = rev[le[cd[i2] - 1]++] >> 15 - cd[i2];
      }
    }
  }
  return co;
});
var flt = new u8(288);
for (i2 = 0; i2 < 144; ++i2)
  flt[i2] = 8;
var i2;
for (i2 = 144; i2 < 256; ++i2)
  flt[i2] = 9;
var i2;
for (i2 = 256; i2 < 280; ++i2)
  flt[i2] = 7;
var i2;
for (i2 = 280; i2 < 288; ++i2)
  flt[i2] = 8;
var i2;
var fdt = new u8(32);
for (i2 = 0; i2 < 32; ++i2)
  fdt[i2] = 5;
var i2;
var flm = hMap(flt, 9, 0);
var flrm = hMap(flt, 9, 1);
var fdm = hMap(fdt, 5, 0);
var fdrm = hMap(fdt, 5, 1);
var max = function(a3) {
  var m3 = a3[0];
  for (var i2 = 1; i2 < a3.length; ++i2) {
    if (a3[i2] > m3)
      m3 = a3[i2];
  }
  return m3;
};
var bits = function(d3, p3, m3) {
  var o2 = p3 / 8 | 0;
  return (d3[o2] | d3[o2 + 1] << 8) >> (p3 & 7) & m3;
};
var bits16 = function(d3, p3) {
  var o2 = p3 / 8 | 0;
  return (d3[o2] | d3[o2 + 1] << 8 | d3[o2 + 2] << 16) >> (p3 & 7);
};
var shft = function(p3) {
  return (p3 + 7) / 8 | 0;
};
var slc = function(v2, s2, e3) {
  if (s2 == null || s2 < 0)
    s2 = 0;
  if (e3 == null || e3 > v2.length)
    e3 = v2.length;
  return new u8(v2.subarray(s2, e3));
};
var ec = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
  // determined by unknown compression method
];
var err = function(ind, msg, nt) {
  var e3 = new Error(msg || ec[ind]);
  e3.code = ind;
  if (Error.captureStackTrace)
    Error.captureStackTrace(e3, err);
  if (!nt)
    throw e3;
  return e3;
};
var inflt = function(dat, st, buf, dict) {
  var sl = dat.length, dl = dict ? dict.length : 0;
  if (!sl || st.f && !st.l)
    return buf || new u8(0);
  var noBuf = !buf;
  var resize = noBuf || st.i != 2;
  var noSt = st.i;
  if (noBuf)
    buf = new u8(sl * 3);
  var cbuf = function(l3) {
    var bl = buf.length;
    if (l3 > bl) {
      var nbuf = new u8(Math.max(bl * 2, l3));
      nbuf.set(buf);
      buf = nbuf;
    }
  };
  var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
  var tbts = sl * 8;
  do {
    if (!lm) {
      final = bits(dat, pos, 1);
      var type = bits(dat, pos + 1, 3);
      pos += 3;
      if (!type) {
        var s2 = shft(pos) + 4, l2 = dat[s2 - 4] | dat[s2 - 3] << 8, t5 = s2 + l2;
        if (t5 > sl) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt + l2);
        buf.set(dat.subarray(s2, t5), bt);
        st.b = bt += l2, st.p = pos = t5 * 8, st.f = final;
        continue;
      } else if (type == 1)
        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
      else if (type == 2) {
        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
        var tl = hLit + bits(dat, pos + 5, 31) + 1;
        pos += 14;
        var ldt = new u8(tl);
        var clt = new u8(19);
        for (var i2 = 0; i2 < hcLen; ++i2) {
          clt[clim[i2]] = bits(dat, pos + i2 * 3, 7);
        }
        pos += hcLen * 3;
        var clb = max(clt), clbmsk = (1 << clb) - 1;
        var clm = hMap(clt, clb, 1);
        for (var i2 = 0; i2 < tl; ) {
          var r2 = clm[bits(dat, pos, clbmsk)];
          pos += r2 & 15;
          var s2 = r2 >> 4;
          if (s2 < 16) {
            ldt[i2++] = s2;
          } else {
            var c5 = 0, n2 = 0;
            if (s2 == 16)
              n2 = 3 + bits(dat, pos, 3), pos += 2, c5 = ldt[i2 - 1];
            else if (s2 == 17)
              n2 = 3 + bits(dat, pos, 7), pos += 3;
            else if (s2 == 18)
              n2 = 11 + bits(dat, pos, 127), pos += 7;
            while (n2--)
              ldt[i2++] = c5;
          }
        }
        var lt2 = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
        lbt = max(lt2);
        dbt = max(dt);
        lm = hMap(lt2, lbt, 1);
        dm = hMap(dt, dbt, 1);
      } else
        err(1);
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
    }
    if (resize)
      cbuf(bt + 131072);
    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
    var lpos = pos;
    for (; ; lpos = pos) {
      var c5 = lm[bits16(dat, pos) & lms], sym = c5 >> 4;
      pos += c5 & 15;
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
      if (!c5)
        err(2);
      if (sym < 256)
        buf[bt++] = sym;
      else if (sym == 256) {
        lpos = pos, lm = null;
        break;
      } else {
        var add7 = sym - 254;
        if (sym > 264) {
          var i2 = sym - 257, b = fleb[i2];
          add7 = bits(dat, pos, (1 << b) - 1) + fl[i2];
          pos += b;
        }
        var d3 = dm[bits16(dat, pos) & dms], dsym = d3 >> 4;
        if (!d3)
          err(3);
        pos += d3 & 15;
        var dt = fd[dsym];
        if (dsym > 3) {
          var b = fdeb[dsym];
          dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
        }
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt + 131072);
        var end = bt + add7;
        if (bt < dt) {
          var shift = dl - dt, dend = Math.min(dt, end);
          if (shift + bt < 0)
            err(3);
          for (; bt < dend; ++bt)
            buf[bt] = dict[shift + bt];
        }
        for (; bt < end; ++bt)
          buf[bt] = buf[bt - dt];
      }
    }
    st.l = lm, st.p = lpos, st.b = bt, st.f = final;
    if (lm)
      final = 1, st.m = lbt, st.d = dm, st.n = dbt;
  } while (!final);
  return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);
};
var wbits = function(d3, p3, v2) {
  v2 <<= p3 & 7;
  var o2 = p3 / 8 | 0;
  d3[o2] |= v2;
  d3[o2 + 1] |= v2 >> 8;
};
var wbits16 = function(d3, p3, v2) {
  v2 <<= p3 & 7;
  var o2 = p3 / 8 | 0;
  d3[o2] |= v2;
  d3[o2 + 1] |= v2 >> 8;
  d3[o2 + 2] |= v2 >> 16;
};
var hTree = function(d3, mb) {
  var t5 = [];
  for (var i2 = 0; i2 < d3.length; ++i2) {
    if (d3[i2])
      t5.push({ s: i2, f: d3[i2] });
  }
  var s2 = t5.length;
  var t22 = t5.slice();
  if (!s2)
    return { t: et, l: 0 };
  if (s2 == 1) {
    var v2 = new u8(t5[0].s + 1);
    v2[t5[0].s] = 1;
    return { t: v2, l: 1 };
  }
  t5.sort(function(a3, b) {
    return a3.f - b.f;
  });
  t5.push({ s: -1, f: 25001 });
  var l2 = t5[0], r2 = t5[1], i0 = 0, i1 = 1, i22 = 2;
  t5[0] = { s: -1, f: l2.f + r2.f, l: l2, r: r2 };
  while (i1 != s2 - 1) {
    l2 = t5[t5[i0].f < t5[i22].f ? i0++ : i22++];
    r2 = t5[i0 != i1 && t5[i0].f < t5[i22].f ? i0++ : i22++];
    t5[i1++] = { s: -1, f: l2.f + r2.f, l: l2, r: r2 };
  }
  var maxSym = t22[0].s;
  for (var i2 = 1; i2 < s2; ++i2) {
    if (t22[i2].s > maxSym)
      maxSym = t22[i2].s;
  }
  var tr = new u16(maxSym + 1);
  var mbt = ln(t5[i1 - 1], tr, 0);
  if (mbt > mb) {
    var i2 = 0, dt = 0;
    var lft = mbt - mb, cst = 1 << lft;
    t22.sort(function(a3, b) {
      return tr[b.s] - tr[a3.s] || a3.f - b.f;
    });
    for (; i2 < s2; ++i2) {
      var i2_1 = t22[i2].s;
      if (tr[i2_1] > mb) {
        dt += cst - (1 << mbt - tr[i2_1]);
        tr[i2_1] = mb;
      } else
        break;
    }
    dt >>= lft;
    while (dt > 0) {
      var i2_2 = t22[i2].s;
      if (tr[i2_2] < mb)
        dt -= 1 << mb - tr[i2_2]++ - 1;
      else
        ++i2;
    }
    for (; i2 >= 0 && dt; --i2) {
      var i2_3 = t22[i2].s;
      if (tr[i2_3] == mb) {
        --tr[i2_3];
        ++dt;
      }
    }
    mbt = mb;
  }
  return { t: new u8(tr), l: mbt };
};
var ln = function(n2, l2, d3) {
  return n2.s == -1 ? Math.max(ln(n2.l, l2, d3 + 1), ln(n2.r, l2, d3 + 1)) : l2[n2.s] = d3;
};
var lc = function(c5) {
  var s2 = c5.length;
  while (s2 && !c5[--s2])
    ;
  var cl = new u16(++s2);
  var cli = 0, cln = c5[0], cls = 1;
  var w4 = function(v2) {
    cl[cli++] = v2;
  };
  for (var i2 = 1; i2 <= s2; ++i2) {
    if (c5[i2] == cln && i2 != s2)
      ++cls;
    else {
      if (!cln && cls > 2) {
        for (; cls > 138; cls -= 138)
          w4(32754);
        if (cls > 2) {
          w4(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);
          cls = 0;
        }
      } else if (cls > 3) {
        w4(cln), --cls;
        for (; cls > 6; cls -= 6)
          w4(8304);
        if (cls > 2)
          w4(cls - 3 << 5 | 8208), cls = 0;
      }
      while (cls--)
        w4(cln);
      cls = 1;
      cln = c5[i2];
    }
  }
  return { c: cl.subarray(0, cli), n: s2 };
};
var clen = function(cf, cl) {
  var l2 = 0;
  for (var i2 = 0; i2 < cl.length; ++i2)
    l2 += cf[i2] * cl[i2];
  return l2;
};
var wfblk = function(out, pos, dat) {
  var s2 = dat.length;
  var o2 = shft(pos + 2);
  out[o2] = s2 & 255;
  out[o2 + 1] = s2 >> 8;
  out[o2 + 2] = out[o2] ^ 255;
  out[o2 + 3] = out[o2 + 1] ^ 255;
  for (var i2 = 0; i2 < s2; ++i2)
    out[o2 + i2 + 4] = dat[i2];
  return (o2 + 4 + s2) * 8;
};
var wblk = function(dat, out, final, syms, lf, df, eb, li, bs, bl, p3) {
  wbits(out, p3++, final);
  ++lf[256];
  var _a2 = hTree(lf, 15), dlt = _a2.t, mlb = _a2.l;
  var _b2 = hTree(df, 15), ddt = _b2.t, mdb = _b2.l;
  var _c = lc(dlt), lclt = _c.c, nlc = _c.n;
  var _d = lc(ddt), lcdt = _d.c, ndc = _d.n;
  var lcfreq = new u16(19);
  for (var i2 = 0; i2 < lclt.length; ++i2)
    ++lcfreq[lclt[i2] & 31];
  for (var i2 = 0; i2 < lcdt.length; ++i2)
    ++lcfreq[lcdt[i2] & 31];
  var _e = hTree(lcfreq, 7), lct = _e.t, mlcb = _e.l;
  var nlcc = 19;
  for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)
    ;
  var flen = bl + 5 << 3;
  var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
  var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + 2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18];
  if (bs >= 0 && flen <= ftlen && flen <= dtlen)
    return wfblk(out, p3, dat.subarray(bs, bs + bl));
  var lm, ll, dm, dl;
  wbits(out, p3, 1 + (dtlen < ftlen)), p3 += 2;
  if (dtlen < ftlen) {
    lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
    var llm = hMap(lct, mlcb, 0);
    wbits(out, p3, nlc - 257);
    wbits(out, p3 + 5, ndc - 1);
    wbits(out, p3 + 10, nlcc - 4);
    p3 += 14;
    for (var i2 = 0; i2 < nlcc; ++i2)
      wbits(out, p3 + 3 * i2, lct[clim[i2]]);
    p3 += 3 * nlcc;
    var lcts = [lclt, lcdt];
    for (var it = 0; it < 2; ++it) {
      var clct = lcts[it];
      for (var i2 = 0; i2 < clct.length; ++i2) {
        var len = clct[i2] & 31;
        wbits(out, p3, llm[len]), p3 += lct[len];
        if (len > 15)
          wbits(out, p3, clct[i2] >> 5 & 127), p3 += clct[i2] >> 12;
      }
    }
  } else {
    lm = flm, ll = flt, dm = fdm, dl = fdt;
  }
  for (var i2 = 0; i2 < li; ++i2) {
    var sym = syms[i2];
    if (sym > 255) {
      var len = sym >> 18 & 31;
      wbits16(out, p3, lm[len + 257]), p3 += ll[len + 257];
      if (len > 7)
        wbits(out, p3, sym >> 23 & 31), p3 += fleb[len];
      var dst = sym & 31;
      wbits16(out, p3, dm[dst]), p3 += dl[dst];
      if (dst > 3)
        wbits16(out, p3, sym >> 5 & 8191), p3 += fdeb[dst];
    } else {
      wbits16(out, p3, lm[sym]), p3 += ll[sym];
    }
  }
  wbits16(out, p3, lm[256]);
  return p3 + ll[256];
};
var deo = new i32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
var et = new u8(0);
var dflt = function(dat, lvl, plvl, pre, post, st) {
  var s2 = st.z || dat.length;
  var o2 = new u8(pre + s2 + 5 * (1 + Math.ceil(s2 / 7e3)) + post);
  var w4 = o2.subarray(pre, o2.length - post);
  var lst = st.l;
  var pos = (st.r || 0) & 7;
  if (lvl) {
    if (pos)
      w4[0] = st.r >> 3;
    var opt = deo[lvl - 1];
    var n2 = opt >> 13, c5 = opt & 8191;
    var msk_1 = (1 << plvl) - 1;
    var prev = st.p || new u16(32768), head2 = st.h || new u16(msk_1 + 1);
    var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
    var hsh = function(i3) {
      return (dat[i3] ^ dat[i3 + 1] << bs1_1 ^ dat[i3 + 2] << bs2_1) & msk_1;
    };
    var syms = new i32(25e3);
    var lf = new u16(288), df = new u16(32);
    var lc_1 = 0, eb = 0, i2 = st.i || 0, li = 0, wi = st.w || 0, bs = 0;
    for (; i2 + 2 < s2; ++i2) {
      var hv = hsh(i2);
      var imod = i2 & 32767, pimod = head2[hv];
      prev[imod] = pimod;
      head2[hv] = imod;
      if (wi <= i2) {
        var rem2 = s2 - i2;
        if ((lc_1 > 7e3 || li > 24576) && (rem2 > 423 || !lst)) {
          pos = wblk(dat, w4, 0, syms, lf, df, eb, li, bs, i2 - bs, pos);
          li = lc_1 = eb = 0, bs = i2;
          for (var j2 = 0; j2 < 286; ++j2)
            lf[j2] = 0;
          for (var j2 = 0; j2 < 30; ++j2)
            df[j2] = 0;
        }
        var l2 = 2, d3 = 0, ch_1 = c5, dif = imod - pimod & 32767;
        if (rem2 > 2 && hv == hsh(i2 - dif)) {
          var maxn = Math.min(n2, rem2) - 1;
          var maxd = Math.min(32767, i2);
          var ml = Math.min(258, rem2);
          while (dif <= maxd && --ch_1 && imod != pimod) {
            if (dat[i2 + l2] == dat[i2 + l2 - dif]) {
              var nl = 0;
              for (; nl < ml && dat[i2 + nl] == dat[i2 + nl - dif]; ++nl)
                ;
              if (nl > l2) {
                l2 = nl, d3 = dif;
                if (nl > maxn)
                  break;
                var mmd = Math.min(dif, nl - 2);
                var md = 0;
                for (var j2 = 0; j2 < mmd; ++j2) {
                  var ti = i2 - dif + j2 & 32767;
                  var pti = prev[ti];
                  var cd = ti - pti & 32767;
                  if (cd > md)
                    md = cd, pimod = ti;
                }
              }
            }
            imod = pimod, pimod = prev[imod];
            dif += imod - pimod & 32767;
          }
        }
        if (d3) {
          syms[li++] = 268435456 | revfl[l2] << 18 | revfd[d3];
          var lin = revfl[l2] & 31, din = revfd[d3] & 31;
          eb += fleb[lin] + fdeb[din];
          ++lf[257 + lin];
          ++df[din];
          wi = i2 + l2;
          ++lc_1;
        } else {
          syms[li++] = dat[i2];
          ++lf[dat[i2]];
        }
      }
    }
    for (i2 = Math.max(i2, wi); i2 < s2; ++i2) {
      syms[li++] = dat[i2];
      ++lf[dat[i2]];
    }
    pos = wblk(dat, w4, lst, syms, lf, df, eb, li, bs, i2 - bs, pos);
    if (!lst) {
      st.r = pos & 7 | w4[pos / 8 | 0] << 3;
      pos -= 7;
      st.h = head2, st.p = prev, st.i = i2, st.w = wi;
    }
  } else {
    for (var i2 = st.w || 0; i2 < s2 + lst; i2 += 65535) {
      var e3 = i2 + 65535;
      if (e3 >= s2) {
        w4[pos / 8 | 0] = lst;
        e3 = s2;
      }
      pos = wfblk(w4, pos + 1, dat.subarray(i2, e3));
    }
    st.i = s2;
  }
  return slc(o2, 0, pre + shft(pos) + post);
};
var crct = (function() {
  var t5 = new Int32Array(256);
  for (var i2 = 0; i2 < 256; ++i2) {
    var c5 = i2, k2 = 9;
    while (--k2)
      c5 = (c5 & 1 && -306674912) ^ c5 >>> 1;
    t5[i2] = c5;
  }
  return t5;
})();
var crc = function() {
  var c5 = -1;
  return {
    p: function(d3) {
      var cr = c5;
      for (var i2 = 0; i2 < d3.length; ++i2)
        cr = crct[cr & 255 ^ d3[i2]] ^ cr >>> 8;
      c5 = cr;
    },
    d: function() {
      return ~c5;
    }
  };
};
var adler = function() {
  var a3 = 1, b = 0;
  return {
    p: function(d3) {
      var n2 = a3, m3 = b;
      var l2 = d3.length | 0;
      for (var i2 = 0; i2 != l2; ) {
        var e3 = Math.min(i2 + 2655, l2);
        for (; i2 < e3; ++i2)
          m3 += n2 += d3[i2];
        n2 = (n2 & 65535) + 15 * (n2 >> 16), m3 = (m3 & 65535) + 15 * (m3 >> 16);
      }
      a3 = n2, b = m3;
    },
    d: function() {
      a3 %= 65521, b %= 65521;
      return (a3 & 255) << 24 | (a3 & 65280) << 8 | (b & 255) << 8 | b >> 8;
    }
  };
};
var dopt = function(dat, opt, pre, post, st) {
  if (!st) {
    st = { l: 1 };
    if (opt.dictionary) {
      var dict = opt.dictionary.subarray(-32768);
      var newDat = new u8(dict.length + dat.length);
      newDat.set(dict);
      newDat.set(dat, dict.length);
      dat = newDat;
      st.w = dict.length;
    }
  }
  return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? st.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 20 : 12 + opt.mem, pre, post, st);
};
var mrg = function(a3, b) {
  var o2 = {};
  for (var k2 in a3)
    o2[k2] = a3[k2];
  for (var k2 in b)
    o2[k2] = b[k2];
  return o2;
};
var wcln = function(fn, fnStr, td2) {
  var dt = fn();
  var st = fn.toString();
  var ks = st.slice(st.indexOf("[") + 1, st.lastIndexOf("]")).replace(/\s+/g, "").split(",");
  for (var i2 = 0; i2 < dt.length; ++i2) {
    var v2 = dt[i2], k2 = ks[i2];
    if (typeof v2 == "function") {
      fnStr += ";" + k2 + "=";
      var st_1 = v2.toString();
      if (v2.prototype) {
        if (st_1.indexOf("[native code]") != -1) {
          var spInd = st_1.indexOf(" ", 8) + 1;
          fnStr += st_1.slice(spInd, st_1.indexOf("(", spInd));
        } else {
          fnStr += st_1;
          for (var t5 in v2.prototype)
            fnStr += ";" + k2 + ".prototype." + t5 + "=" + v2.prototype[t5].toString();
        }
      } else
        fnStr += st_1;
    } else
      td2[k2] = v2;
  }
  return fnStr;
};
var ch = [];
var cbfs = function(v2) {
  var tl = [];
  for (var k2 in v2) {
    if (v2[k2].buffer) {
      tl.push((v2[k2] = new v2[k2].constructor(v2[k2])).buffer);
    }
  }
  return tl;
};
var wrkr = function(fns, init10, id2, cb) {
  if (!ch[id2]) {
    var fnStr = "", td_1 = {}, m3 = fns.length - 1;
    for (var i2 = 0; i2 < m3; ++i2)
      fnStr = wcln(fns[i2], fnStr, td_1);
    ch[id2] = { c: wcln(fns[m3], fnStr, td_1), e: td_1 };
  }
  var td2 = mrg({}, ch[id2].e);
  return wk(ch[id2].c + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + init10.toString() + "}", id2, td2, cbfs(td2), cb);
};
var bInflt = function() {
  return [u8, u16, i32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, ec, hMap, max, bits, bits16, shft, slc, err, inflt, inflateSync, pbf, gopt];
};
var bDflt = function() {
  return [u8, u16, i32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf];
};
var guze = function() {
  return [gzs, gzl];
};
var zule = function() {
  return [zls];
};
var pbf = function(msg) {
  return postMessage(msg, [msg.buffer]);
};
var gopt = function(o2) {
  return o2 && {
    out: o2.size && new u8(o2.size),
    dictionary: o2.dictionary
  };
};
var astrm = function(strm) {
  strm.ondata = function(dat, final) {
    return postMessage([dat, final], [dat.buffer]);
  };
  return function(ev) {
    if (ev.data.length) {
      strm.push(ev.data[0], ev.data[1]);
      postMessage([ev.data[0].length]);
    } else
      strm.flush();
  };
};
var astrmify = function(fns, strm, opts, init10, id2, flush, ext) {
  var t5;
  var w4 = wrkr(fns, init10, id2, function(err2, dat) {
    if (err2)
      w4.terminate(), strm.ondata.call(strm, err2);
    else if (!Array.isArray(dat))
      ext(dat);
    else if (dat.length == 1) {
      strm.queuedSize -= dat[0];
      if (strm.ondrain)
        strm.ondrain(dat[0]);
    } else {
      if (dat[1])
        w4.terminate();
      strm.ondata.call(strm, err2, dat[0], dat[1]);
    }
  });
  w4.postMessage(opts);
  strm.queuedSize = 0;
  strm.push = function(d3, f3) {
    if (!strm.ondata)
      err(5);
    if (t5)
      strm.ondata(err(4, 0, 1), null, !!f3);
    strm.queuedSize += d3.length;
    w4.postMessage([d3, t5 = f3], [d3.buffer]);
  };
  strm.terminate = function() {
    w4.terminate();
  };
  if (flush) {
    strm.flush = function() {
      w4.postMessage([]);
    };
  }
};
var b2 = function(d3, b) {
  return d3[b] | d3[b + 1] << 8;
};
var b4 = function(d3, b) {
  return (d3[b] | d3[b + 1] << 8 | d3[b + 2] << 16 | d3[b + 3] << 24) >>> 0;
};
var b8 = function(d3, b) {
  return b4(d3, b) + b4(d3, b + 4) * 4294967296;
};
var wbytes = function(d3, b, v2) {
  for (; v2; ++b)
    d3[b] = v2, v2 >>>= 8;
};
var gzh = function(c5, o2) {
  var fn = o2.filename;
  c5[0] = 31, c5[1] = 139, c5[2] = 8, c5[8] = o2.level < 2 ? 4 : o2.level == 9 ? 2 : 0, c5[9] = 3;
  if (o2.mtime != 0)
    wbytes(c5, 4, Math.floor(new Date(o2.mtime || Date.now()) / 1e3));
  if (fn) {
    c5[3] = 8;
    for (var i2 = 0; i2 <= fn.length; ++i2)
      c5[i2 + 10] = fn.charCodeAt(i2);
  }
};
var gzs = function(d3) {
  if (d3[0] != 31 || d3[1] != 139 || d3[2] != 8)
    err(6, "invalid gzip data");
  var flg = d3[3];
  var st = 10;
  if (flg & 4)
    st += (d3[10] | d3[11] << 8) + 2;
  for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d3[st++])
    ;
  return st + (flg & 2);
};
var gzl = function(d3) {
  var l2 = d3.length;
  return (d3[l2 - 4] | d3[l2 - 3] << 8 | d3[l2 - 2] << 16 | d3[l2 - 1] << 24) >>> 0;
};
var gzhl = function(o2) {
  return 10 + (o2.filename ? o2.filename.length + 1 : 0);
};
var zlh = function(c5, o2) {
  var lv = o2.level, fl2 = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;
  c5[0] = 120, c5[1] = fl2 << 6 | (o2.dictionary && 32);
  c5[1] |= 31 - (c5[0] << 8 | c5[1]) % 31;
  if (o2.dictionary) {
    var h2 = adler();
    h2.p(o2.dictionary);
    wbytes(c5, 2, h2.d());
  }
};
var zls = function(d3, dict) {
  if ((d3[0] & 15) != 8 || d3[0] >> 4 > 7 || (d3[0] << 8 | d3[1]) % 31)
    err(6, "invalid zlib data");
  if ((d3[1] >> 5 & 1) == +!dict)
    err(6, "invalid zlib data: " + (d3[1] & 32 ? "need" : "unexpected") + " dictionary");
  return (d3[1] >> 3 & 4) + 2;
};
function StrmOpt(opts, cb) {
  if (typeof opts == "function")
    cb = opts, opts = {};
  this.ondata = cb;
  return opts;
}
var Deflate = (function() {
  function Deflate2(opts, cb) {
    if (typeof opts == "function")
      cb = opts, opts = {};
    this.ondata = cb;
    this.o = opts || {};
    this.s = { l: 0, i: 32768, w: 32768, z: 32768 };
    this.b = new u8(98304);
    if (this.o.dictionary) {
      var dict = this.o.dictionary.subarray(-32768);
      this.b.set(dict, 32768 - dict.length);
      this.s.i = 32768 - dict.length;
    }
  }
  Deflate2.prototype.p = function(c5, f3) {
    this.ondata(dopt(c5, this.o, 0, 0, this.s), f3);
  };
  Deflate2.prototype.push = function(chunk2, final) {
    if (!this.ondata)
      err(5);
    if (this.s.l)
      err(4);
    var endLen = chunk2.length + this.s.z;
    if (endLen > this.b.length) {
      if (endLen > 2 * this.b.length - 32768) {
        var newBuf = new u8(endLen & -32768);
        newBuf.set(this.b.subarray(0, this.s.z));
        this.b = newBuf;
      }
      var split3 = this.b.length - this.s.z;
      this.b.set(chunk2.subarray(0, split3), this.s.z);
      this.s.z = this.b.length;
      this.p(this.b, false);
      this.b.set(this.b.subarray(-32768));
      this.b.set(chunk2.subarray(split3), 32768);
      this.s.z = chunk2.length - split3 + 32768;
      this.s.i = 32766, this.s.w = 32768;
    } else {
      this.b.set(chunk2, this.s.z);
      this.s.z += chunk2.length;
    }
    this.s.l = final & 1;
    if (this.s.z > this.s.w + 8191 || final) {
      this.p(this.b, final || false);
      this.s.w = this.s.i, this.s.i -= 2;
    }
  };
  Deflate2.prototype.flush = function() {
    if (!this.ondata)
      err(5);
    if (this.s.l)
      err(4);
    this.p(this.b, false);
    this.s.w = this.s.i, this.s.i -= 2;
  };
  return Deflate2;
})();
var AsyncDeflate = /* @__PURE__ */ (function() {
  function AsyncDeflate2(opts, cb) {
    astrmify([
      bDflt,
      function() {
        return [astrm, Deflate];
      }
    ], this, StrmOpt.call(this, opts, cb), function(ev) {
      var strm = new Deflate(ev.data);
      onmessage = astrm(strm);
    }, 6, 1);
  }
  return AsyncDeflate2;
})();
function deflateSync(data, opts) {
  return dopt(data, opts || {}, 0, 0);
}
var Inflate = (function() {
  function Inflate2(opts, cb) {
    if (typeof opts == "function")
      cb = opts, opts = {};
    this.ondata = cb;
    var dict = opts && opts.dictionary && opts.dictionary.subarray(-32768);
    this.s = { i: 0, b: dict ? dict.length : 0 };
    this.o = new u8(32768);
    this.p = new u8(0);
    if (dict)
      this.o.set(dict);
  }
  Inflate2.prototype.e = function(c5) {
    if (!this.ondata)
      err(5);
    if (this.d)
      err(4);
    if (!this.p.length)
      this.p = c5;
    else if (c5.length) {
      var n2 = new u8(this.p.length + c5.length);
      n2.set(this.p), n2.set(c5, this.p.length), this.p = n2;
    }
  };
  Inflate2.prototype.c = function(final) {
    this.s.i = +(this.d = final || false);
    var bts = this.s.b;
    var dt = inflt(this.p, this.s, this.o);
    this.ondata(slc(dt, bts, this.s.b), this.d);
    this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;
    this.p = slc(this.p, this.s.p / 8 | 0), this.s.p &= 7;
  };
  Inflate2.prototype.push = function(chunk2, final) {
    this.e(chunk2), this.c(final);
  };
  return Inflate2;
})();
var AsyncInflate = /* @__PURE__ */ (function() {
  function AsyncInflate2(opts, cb) {
    astrmify([
      bInflt,
      function() {
        return [astrm, Inflate];
      }
    ], this, StrmOpt.call(this, opts, cb), function(ev) {
      var strm = new Inflate(ev.data);
      onmessage = astrm(strm);
    }, 7, 0);
  }
  return AsyncInflate2;
})();
function inflateSync(data, opts) {
  return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
var Gzip = (function() {
  function Gzip2(opts, cb) {
    this.c = crc();
    this.l = 0;
    this.v = 1;
    Deflate.call(this, opts, cb);
  }
  Gzip2.prototype.push = function(chunk2, final) {
    this.c.p(chunk2);
    this.l += chunk2.length;
    Deflate.prototype.push.call(this, chunk2, final);
  };
  Gzip2.prototype.p = function(c5, f3) {
    var raw = dopt(c5, this.o, this.v && gzhl(this.o), f3 && 8, this.s);
    if (this.v)
      gzh(raw, this.o), this.v = 0;
    if (f3)
      wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);
    this.ondata(raw, f3);
  };
  Gzip2.prototype.flush = function() {
    Deflate.prototype.flush.call(this);
  };
  return Gzip2;
})();
var Gunzip = (function() {
  function Gunzip2(opts, cb) {
    this.v = 1;
    this.r = 0;
    Inflate.call(this, opts, cb);
  }
  Gunzip2.prototype.push = function(chunk2, final) {
    Inflate.prototype.e.call(this, chunk2);
    this.r += chunk2.length;
    if (this.v) {
      var p3 = this.p.subarray(this.v - 1);
      var s2 = p3.length > 3 ? gzs(p3) : 4;
      if (s2 > p3.length) {
        if (!final)
          return;
      } else if (this.v > 1 && this.onmember) {
        this.onmember(this.r - p3.length);
      }
      this.p = p3.subarray(s2), this.v = 0;
    }
    Inflate.prototype.c.call(this, final);
    if (this.s.f && !this.s.l && !final) {
      this.v = shft(this.s.p) + 9;
      this.s = { i: 0 };
      this.o = new u8(0);
      this.push(new u8(0), final);
    }
  };
  return Gunzip2;
})();
var AsyncGunzip = /* @__PURE__ */ (function() {
  function AsyncGunzip2(opts, cb) {
    var _this = this;
    astrmify([
      bInflt,
      guze,
      function() {
        return [astrm, Inflate, Gunzip];
      }
    ], this, StrmOpt.call(this, opts, cb), function(ev) {
      var strm = new Gunzip(ev.data);
      strm.onmember = function(offset) {
        return postMessage(offset);
      };
      onmessage = astrm(strm);
    }, 9, 0, function(offset) {
      return _this.onmember && _this.onmember(offset);
    });
  }
  return AsyncGunzip2;
})();
var Zlib = (function() {
  function Zlib2(opts, cb) {
    this.c = adler();
    this.v = 1;
    Deflate.call(this, opts, cb);
  }
  Zlib2.prototype.push = function(chunk2, final) {
    this.c.p(chunk2);
    Deflate.prototype.push.call(this, chunk2, final);
  };
  Zlib2.prototype.p = function(c5, f3) {
    var raw = dopt(c5, this.o, this.v && (this.o.dictionary ? 6 : 2), f3 && 4, this.s);
    if (this.v)
      zlh(raw, this.o), this.v = 0;
    if (f3)
      wbytes(raw, raw.length - 4, this.c.d());
    this.ondata(raw, f3);
  };
  Zlib2.prototype.flush = function() {
    Deflate.prototype.flush.call(this);
  };
  return Zlib2;
})();
var Unzlib = (function() {
  function Unzlib2(opts, cb) {
    Inflate.call(this, opts, cb);
    this.v = opts && opts.dictionary ? 2 : 1;
  }
  Unzlib2.prototype.push = function(chunk2, final) {
    Inflate.prototype.e.call(this, chunk2);
    if (this.v) {
      if (this.p.length < 6 && !final)
        return;
      this.p = this.p.subarray(zls(this.p, this.v - 1)), this.v = 0;
    }
    if (final) {
      if (this.p.length < 4)
        err(6, "invalid zlib data");
      this.p = this.p.subarray(0, -4);
    }
    Inflate.prototype.c.call(this, final);
  };
  return Unzlib2;
})();
var AsyncUnzlib = /* @__PURE__ */ (function() {
  function AsyncUnzlib2(opts, cb) {
    astrmify([
      bInflt,
      zule,
      function() {
        return [astrm, Inflate, Unzlib];
      }
    ], this, StrmOpt.call(this, opts, cb), function(ev) {
      var strm = new Unzlib(ev.data);
      onmessage = astrm(strm);
    }, 11, 0);
  }
  return AsyncUnzlib2;
})();
function unzlibSync(data, opts) {
  return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
var Decompress = (function() {
  function Decompress2(opts, cb) {
    this.o = StrmOpt.call(this, opts, cb) || {};
    this.G = Gunzip;
    this.I = Inflate;
    this.Z = Unzlib;
  }
  Decompress2.prototype.i = function() {
    var _this = this;
    this.s.ondata = function(dat, final) {
      _this.ondata(dat, final);
    };
  };
  Decompress2.prototype.push = function(chunk2, final) {
    if (!this.ondata)
      err(5);
    if (!this.s) {
      if (this.p && this.p.length) {
        var n2 = new u8(this.p.length + chunk2.length);
        n2.set(this.p), n2.set(chunk2, this.p.length);
      } else
        this.p = chunk2;
      if (this.p.length > 2) {
        this.s = this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8 ? new this.G(this.o) : (this.p[0] & 15) != 8 || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(this.o) : new this.Z(this.o);
        this.i();
        this.s.push(this.p, final);
        this.p = null;
      }
    } else
      this.s.push(chunk2, final);
  };
  return Decompress2;
})();
var AsyncDecompress = (function() {
  function AsyncDecompress2(opts, cb) {
    Decompress.call(this, opts, cb);
    this.queuedSize = 0;
    this.G = AsyncGunzip;
    this.I = AsyncInflate;
    this.Z = AsyncUnzlib;
  }
  AsyncDecompress2.prototype.i = function() {
    var _this = this;
    this.s.ondata = function(err2, dat, final) {
      _this.ondata(err2, dat, final);
    };
    this.s.ondrain = function(size2) {
      _this.queuedSize -= size2;
      if (_this.ondrain)
        _this.ondrain(size2);
    };
  };
  AsyncDecompress2.prototype.push = function(chunk2, final) {
    this.queuedSize += chunk2.length;
    Decompress.prototype.push.call(this, chunk2, final);
  };
  return AsyncDecompress2;
})();
var te = typeof TextEncoder != "undefined" && new TextEncoder();
var td = typeof TextDecoder != "undefined" && new TextDecoder();
var tds = 0;
try {
  td.decode(et, { stream: true });
  tds = 1;
} catch (e3) {
}
var dutf8 = function(d3) {
  for (var r2 = "", i2 = 0; ; ) {
    var c5 = d3[i2++];
    var eb = (c5 > 127) + (c5 > 223) + (c5 > 239);
    if (i2 + eb > d3.length)
      return { s: r2, r: slc(d3, i2 - 1) };
    if (!eb)
      r2 += String.fromCharCode(c5);
    else if (eb == 3) {
      c5 = ((c5 & 15) << 18 | (d3[i2++] & 63) << 12 | (d3[i2++] & 63) << 6 | d3[i2++] & 63) - 65536, r2 += String.fromCharCode(55296 | c5 >> 10, 56320 | c5 & 1023);
    } else if (eb & 1)
      r2 += String.fromCharCode((c5 & 31) << 6 | d3[i2++] & 63);
    else
      r2 += String.fromCharCode((c5 & 15) << 12 | (d3[i2++] & 63) << 6 | d3[i2++] & 63);
  }
};
var DecodeUTF8 = (function() {
  function DecodeUTF82(cb) {
    this.ondata = cb;
    if (tds)
      this.t = new TextDecoder();
    else
      this.p = et;
  }
  DecodeUTF82.prototype.push = function(chunk2, final) {
    if (!this.ondata)
      err(5);
    final = !!final;
    if (this.t) {
      this.ondata(this.t.decode(chunk2, { stream: true }), final);
      if (final) {
        if (this.t.decode().length)
          err(8);
        this.t = null;
      }
      return;
    }
    if (!this.p)
      err(4);
    var dat = new u8(this.p.length + chunk2.length);
    dat.set(this.p);
    dat.set(chunk2, this.p.length);
    var _a2 = dutf8(dat), s2 = _a2.s, r2 = _a2.r;
    if (final) {
      if (r2.length)
        err(8);
      this.p = null;
    } else
      this.p = r2;
    this.ondata(s2, final);
  };
  return DecodeUTF82;
})();
var EncodeUTF8 = (function() {
  function EncodeUTF82(cb) {
    this.ondata = cb;
  }
  EncodeUTF82.prototype.push = function(chunk2, final) {
    if (!this.ondata)
      err(5);
    if (this.d)
      err(4);
    this.ondata(strToU8(chunk2), this.d = final || false);
  };
  return EncodeUTF82;
})();
function strToU8(str, latin1) {
  if (latin1) {
    var ar_1 = new u8(str.length);
    for (var i2 = 0; i2 < str.length; ++i2)
      ar_1[i2] = str.charCodeAt(i2);
    return ar_1;
  }
  if (te)
    return te.encode(str);
  var l2 = str.length;
  var ar = new u8(str.length + (str.length >> 1));
  var ai = 0;
  var w4 = function(v2) {
    ar[ai++] = v2;
  };
  for (var i2 = 0; i2 < l2; ++i2) {
    if (ai + 5 > ar.length) {
      var n2 = new u8(ai + 8 + (l2 - i2 << 1));
      n2.set(ar);
      ar = n2;
    }
    var c5 = str.charCodeAt(i2);
    if (c5 < 128 || latin1)
      w4(c5);
    else if (c5 < 2048)
      w4(192 | c5 >> 6), w4(128 | c5 & 63);
    else if (c5 > 55295 && c5 < 57344)
      c5 = 65536 + (c5 & 1023 << 10) | str.charCodeAt(++i2) & 1023, w4(240 | c5 >> 18), w4(128 | c5 >> 12 & 63), w4(128 | c5 >> 6 & 63), w4(128 | c5 & 63);
    else
      w4(224 | c5 >> 12), w4(128 | c5 >> 6 & 63), w4(128 | c5 & 63);
  }
  return slc(ar, 0, ai);
}
function strFromU8(dat, latin1) {
  if (latin1) {
    var r2 = "";
    for (var i2 = 0; i2 < dat.length; i2 += 16384)
      r2 += String.fromCharCode.apply(null, dat.subarray(i2, i2 + 16384));
    return r2;
  } else if (td) {
    return td.decode(dat);
  } else {
    var _a2 = dutf8(dat), s2 = _a2.s, r2 = _a2.r;
    if (r2.length)
      err(8);
    return s2;
  }
}
var dbf = function(l2) {
  return l2 == 1 ? 3 : l2 < 6 ? 2 : l2 == 9 ? 1 : 0;
};
var z64e = function(d3, b) {
  for (; b2(d3, b) != 1; b += 4 + b2(d3, b + 2))
    ;
  return [b8(d3, b + 12), b8(d3, b + 4), b8(d3, b + 20)];
};
var exfl = function(ex) {
  var le = 0;
  if (ex) {
    for (var k2 in ex) {
      var l2 = ex[k2].length;
      if (l2 > 65535)
        err(9);
      le += l2 + 4;
    }
  }
  return le;
};
var wzh = function(d3, b, f3, fn, u2, c5, ce, co) {
  var fl2 = fn.length, ex = f3.extra, col = co && co.length;
  var exl = exfl(ex);
  wbytes(d3, b, ce != null ? 33639248 : 67324752), b += 4;
  if (ce != null)
    d3[b++] = 20, d3[b++] = f3.os;
  d3[b] = 20, b += 2;
  d3[b++] = f3.flag << 1 | (c5 < 0 && 8), d3[b++] = u2 && 8;
  d3[b++] = f3.compression & 255, d3[b++] = f3.compression >> 8;
  var dt = new Date(f3.mtime == null ? Date.now() : f3.mtime), y3 = dt.getFullYear() - 1980;
  if (y3 < 0 || y3 > 119)
    err(10);
  wbytes(d3, b, y3 << 25 | dt.getMonth() + 1 << 21 | dt.getDate() << 16 | dt.getHours() << 11 | dt.getMinutes() << 5 | dt.getSeconds() >> 1), b += 4;
  if (c5 != -1) {
    wbytes(d3, b, f3.crc);
    wbytes(d3, b + 4, c5 < 0 ? -c5 - 2 : c5);
    wbytes(d3, b + 8, f3.size);
  }
  wbytes(d3, b + 12, fl2);
  wbytes(d3, b + 14, exl), b += 16;
  if (ce != null) {
    wbytes(d3, b, col);
    wbytes(d3, b + 6, f3.attrs);
    wbytes(d3, b + 10, ce), b += 14;
  }
  d3.set(fn, b);
  b += fl2;
  if (exl) {
    for (var k2 in ex) {
      var exf = ex[k2], l2 = exf.length;
      wbytes(d3, b, +k2);
      wbytes(d3, b + 2, l2);
      d3.set(exf, b + 4), b += 4 + l2;
    }
  }
  if (col)
    d3.set(co, b), b += col;
  return b;
};
var wzf = function(o2, b, c5, d3, e3) {
  wbytes(o2, b, 101010256);
  wbytes(o2, b + 8, c5);
  wbytes(o2, b + 10, c5);
  wbytes(o2, b + 12, d3);
  wbytes(o2, b + 16, e3);
};
var ZipPassThrough = (function() {
  function ZipPassThrough2(filename) {
    this.filename = filename;
    this.c = crc();
    this.size = 0;
    this.compression = 0;
  }
  ZipPassThrough2.prototype.process = function(chunk2, final) {
    this.ondata(null, chunk2, final);
  };
  ZipPassThrough2.prototype.push = function(chunk2, final) {
    if (!this.ondata)
      err(5);
    this.c.p(chunk2);
    this.size += chunk2.length;
    if (final)
      this.crc = this.c.d();
    this.process(chunk2, final || false);
  };
  return ZipPassThrough2;
})();
var ZipDeflate = (function() {
  function ZipDeflate2(filename, opts) {
    var _this = this;
    if (!opts)
      opts = {};
    ZipPassThrough.call(this, filename);
    this.d = new Deflate(opts, function(dat, final) {
      _this.ondata(null, dat, final);
    });
    this.compression = 8;
    this.flag = dbf(opts.level);
  }
  ZipDeflate2.prototype.process = function(chunk2, final) {
    try {
      this.d.push(chunk2, final);
    } catch (e3) {
      this.ondata(e3, null, final);
    }
  };
  ZipDeflate2.prototype.push = function(chunk2, final) {
    ZipPassThrough.prototype.push.call(this, chunk2, final);
  };
  return ZipDeflate2;
})();
var AsyncZipDeflate = (function() {
  function AsyncZipDeflate2(filename, opts) {
    var _this = this;
    if (!opts)
      opts = {};
    ZipPassThrough.call(this, filename);
    this.d = new AsyncDeflate(opts, function(err2, dat, final) {
      _this.ondata(err2, dat, final);
    });
    this.compression = 8;
    this.flag = dbf(opts.level);
    this.terminate = this.d.terminate;
  }
  AsyncZipDeflate2.prototype.process = function(chunk2, final) {
    this.d.push(chunk2, final);
  };
  AsyncZipDeflate2.prototype.push = function(chunk2, final) {
    ZipPassThrough.prototype.push.call(this, chunk2, final);
  };
  return AsyncZipDeflate2;
})();
var Zip = (function() {
  function Zip2(cb) {
    this.ondata = cb;
    this.u = [];
    this.d = 1;
  }
  Zip2.prototype.add = function(file) {
    var _this = this;
    if (!this.ondata)
      err(5);
    if (this.d & 2)
      this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, false);
    else {
      var f3 = strToU8(file.filename), fl_1 = f3.length;
      var com = file.comment, o2 = com && strToU8(com);
      var u2 = fl_1 != file.filename.length || o2 && com.length != o2.length;
      var hl_1 = fl_1 + exfl(file.extra) + 30;
      if (fl_1 > 65535)
        this.ondata(err(11, 0, 1), null, false);
      var header = new u8(hl_1);
      wzh(header, 0, file, f3, u2, -1);
      var chks_1 = [header];
      var pAll_1 = function() {
        for (var _i = 0, chks_2 = chks_1; _i < chks_2.length; _i++) {
          var chk = chks_2[_i];
          _this.ondata(null, chk, false);
        }
        chks_1 = [];
      };
      var tr_1 = this.d;
      this.d = 0;
      var ind_1 = this.u.length;
      var uf_1 = mrg(file, {
        f: f3,
        u: u2,
        o: o2,
        t: function() {
          if (file.terminate)
            file.terminate();
        },
        r: function() {
          pAll_1();
          if (tr_1) {
            var nxt = _this.u[ind_1 + 1];
            if (nxt)
              nxt.r();
            else
              _this.d = 1;
          }
          tr_1 = 1;
        }
      });
      var cl_1 = 0;
      file.ondata = function(err2, dat, final) {
        if (err2) {
          _this.ondata(err2, dat, final);
          _this.terminate();
        } else {
          cl_1 += dat.length;
          chks_1.push(dat);
          if (final) {
            var dd = new u8(16);
            wbytes(dd, 0, 134695760);
            wbytes(dd, 4, file.crc);
            wbytes(dd, 8, cl_1);
            wbytes(dd, 12, file.size);
            chks_1.push(dd);
            uf_1.c = cl_1, uf_1.b = hl_1 + cl_1 + 16, uf_1.crc = file.crc, uf_1.size = file.size;
            if (tr_1)
              uf_1.r();
            tr_1 = 1;
          } else if (tr_1)
            pAll_1();
        }
      };
      this.u.push(uf_1);
    }
  };
  Zip2.prototype.end = function() {
    var _this = this;
    if (this.d & 2) {
      this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, true);
      return;
    }
    if (this.d)
      this.e();
    else
      this.u.push({
        r: function() {
          if (!(_this.d & 1))
            return;
          _this.u.splice(-1, 1);
          _this.e();
        },
        t: function() {
        }
      });
    this.d = 3;
  };
  Zip2.prototype.e = function() {
    var bt = 0, l2 = 0, tl = 0;
    for (var _i = 0, _a2 = this.u; _i < _a2.length; _i++) {
      var f3 = _a2[_i];
      tl += 46 + f3.f.length + exfl(f3.extra) + (f3.o ? f3.o.length : 0);
    }
    var out = new u8(tl + 22);
    for (var _b2 = 0, _c = this.u; _b2 < _c.length; _b2++) {
      var f3 = _c[_b2];
      wzh(out, bt, f3, f3.f, f3.u, -f3.c - 2, l2, f3.o);
      bt += 46 + f3.f.length + exfl(f3.extra) + (f3.o ? f3.o.length : 0), l2 += f3.b;
    }
    wzf(out, bt, this.u.length, tl, l2);
    this.ondata(null, out, true);
    this.d = 2;
  };
  Zip2.prototype.terminate = function() {
    for (var _i = 0, _a2 = this.u; _i < _a2.length; _i++) {
      var f3 = _a2[_i];
      f3.t();
    }
    this.d = 2;
  };
  return Zip2;
})();
var UnzipPassThrough = (function() {
  function UnzipPassThrough2() {
  }
  UnzipPassThrough2.prototype.push = function(data, final) {
    this.ondata(null, data, final);
  };
  UnzipPassThrough2.compression = 0;
  return UnzipPassThrough2;
})();
var UnzipInflate = (function() {
  function UnzipInflate2() {
    var _this = this;
    this.i = new Inflate(function(dat, final) {
      _this.ondata(null, dat, final);
    });
  }
  UnzipInflate2.prototype.push = function(data, final) {
    try {
      this.i.push(data, final);
    } catch (e3) {
      this.ondata(e3, null, final);
    }
  };
  UnzipInflate2.compression = 8;
  return UnzipInflate2;
})();
var AsyncUnzipInflate = (function() {
  function AsyncUnzipInflate2(_2, sz) {
    var _this = this;
    if (sz < 32e4) {
      this.i = new Inflate(function(dat, final) {
        _this.ondata(null, dat, final);
      });
    } else {
      this.i = new AsyncInflate(function(err2, dat, final) {
        _this.ondata(err2, dat, final);
      });
      this.terminate = this.i.terminate;
    }
  }
  AsyncUnzipInflate2.prototype.push = function(data, final) {
    if (this.i.terminate)
      data = slc(data, 0);
    this.i.push(data, final);
  };
  AsyncUnzipInflate2.compression = 8;
  return AsyncUnzipInflate2;
})();
var Unzip = (function() {
  function Unzip2(cb) {
    this.onfile = cb;
    this.k = [];
    this.o = {
      0: UnzipPassThrough
    };
    this.p = et;
  }
  Unzip2.prototype.push = function(chunk2, final) {
    var _this = this;
    if (!this.onfile)
      err(5);
    if (!this.p)
      err(4);
    if (this.c > 0) {
      var len = Math.min(this.c, chunk2.length);
      var toAdd = chunk2.subarray(0, len);
      this.c -= len;
      if (this.d)
        this.d.push(toAdd, !this.c);
      else
        this.k[0].push(toAdd);
      chunk2 = chunk2.subarray(len);
      if (chunk2.length)
        return this.push(chunk2, final);
    } else {
      var f3 = 0, i2 = 0, is = void 0, buf = void 0;
      if (!this.p.length)
        buf = chunk2;
      else if (!chunk2.length)
        buf = this.p;
      else {
        buf = new u8(this.p.length + chunk2.length);
        buf.set(this.p), buf.set(chunk2, this.p.length);
      }
      var l2 = buf.length, oc = this.c, add7 = oc && this.d;
      var _loop_2 = function() {
        var _a2;
        var sig = b4(buf, i2);
        if (sig == 67324752) {
          f3 = 1, is = i2;
          this_1.d = null;
          this_1.c = 0;
          var bf = b2(buf, i2 + 6), cmp_1 = b2(buf, i2 + 8), u2 = bf & 2048, dd = bf & 8, fnl = b2(buf, i2 + 26), es = b2(buf, i2 + 28);
          if (l2 > i2 + 30 + fnl + es) {
            var chks_3 = [];
            this_1.k.unshift(chks_3);
            f3 = 2;
            var sc_1 = b4(buf, i2 + 18), su_1 = b4(buf, i2 + 22);
            var fn_1 = strFromU8(buf.subarray(i2 + 30, i2 += 30 + fnl), !u2);
            if (sc_1 == 4294967295) {
              _a2 = dd ? [-2] : z64e(buf, i2), sc_1 = _a2[0], su_1 = _a2[1];
            } else if (dd)
              sc_1 = -1;
            i2 += es;
            this_1.c = sc_1;
            var d_1;
            var file_1 = {
              name: fn_1,
              compression: cmp_1,
              start: function() {
                if (!file_1.ondata)
                  err(5);
                if (!sc_1)
                  file_1.ondata(null, et, true);
                else {
                  var ctr = _this.o[cmp_1];
                  if (!ctr)
                    file_1.ondata(err(14, "unknown compression type " + cmp_1, 1), null, false);
                  d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);
                  d_1.ondata = function(err2, dat3, final2) {
                    file_1.ondata(err2, dat3, final2);
                  };
                  for (var _i = 0, chks_4 = chks_3; _i < chks_4.length; _i++) {
                    var dat2 = chks_4[_i];
                    d_1.push(dat2, false);
                  }
                  if (_this.k[0] == chks_3 && _this.c)
                    _this.d = d_1;
                  else
                    d_1.push(et, true);
                }
              },
              terminate: function() {
                if (d_1 && d_1.terminate)
                  d_1.terminate();
              }
            };
            if (sc_1 >= 0)
              file_1.size = sc_1, file_1.originalSize = su_1;
            this_1.onfile(file_1);
          }
          return "break";
        } else if (oc) {
          if (sig == 134695760) {
            is = i2 += 12 + (oc == -2 && 8), f3 = 3, this_1.c = 0;
            return "break";
          } else if (sig == 33639248) {
            is = i2 -= 4, f3 = 3, this_1.c = 0;
            return "break";
          }
        }
      };
      var this_1 = this;
      for (; i2 < l2 - 4; ++i2) {
        var state_1 = _loop_2();
        if (state_1 === "break")
          break;
      }
      this.p = et;
      if (oc < 0) {
        var dat = f3 ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 134695760 && 4)) : buf.subarray(0, i2);
        if (add7)
          add7.push(dat, !!f3);
        else
          this.k[+(f3 == 2)].push(dat);
      }
      if (f3 & 2)
        return this.push(buf.subarray(i2), final);
      this.p = buf.subarray(i2);
    }
    if (final) {
      if (this.c)
        err(13);
      this.p = null;
    }
  };
  Unzip2.prototype.register = function(decoder) {
    this.o[decoder.compression] = decoder;
  };
  return Unzip2;
})();

// node_modules/aframe-extras/node_modules/three/examples/jsm/curves/NURBSUtils.js
function findSpan(p3, u2, U) {
  const n2 = U.length - p3 - 1;
  if (u2 >= U[n2]) {
    return n2 - 1;
  }
  if (u2 <= U[p3]) {
    return p3;
  }
  let low = p3;
  let high = n2;
  let mid = Math.floor((low + high) / 2);
  while (u2 < U[mid] || u2 >= U[mid + 1]) {
    if (u2 < U[mid]) {
      high = mid;
    } else {
      low = mid;
    }
    mid = Math.floor((low + high) / 2);
  }
  return mid;
}
function calcBasisFunctions(span, u2, p3, U) {
  const N3 = [];
  const left = [];
  const right = [];
  N3[0] = 1;
  for (let j2 = 1; j2 <= p3; ++j2) {
    left[j2] = u2 - U[span + 1 - j2];
    right[j2] = U[span + j2] - u2;
    let saved = 0;
    for (let r2 = 0; r2 < j2; ++r2) {
      const rv = right[r2 + 1];
      const lv = left[j2 - r2];
      const temp = N3[r2] / (rv + lv);
      N3[r2] = saved + rv * temp;
      saved = lv * temp;
    }
    N3[j2] = saved;
  }
  return N3;
}
function calcBSplinePoint(p3, U, P2, u2) {
  const span = findSpan(p3, u2, U);
  const N3 = calcBasisFunctions(span, u2, p3, U);
  const C3 = new Vector42(0, 0, 0, 0);
  for (let j2 = 0; j2 <= p3; ++j2) {
    const point2 = P2[span - p3 + j2];
    const Nj = N3[j2];
    const wNj = point2.w * Nj;
    C3.x += point2.x * wNj;
    C3.y += point2.y * wNj;
    C3.z += point2.z * wNj;
    C3.w += point2.w * Nj;
  }
  return C3;
}
function calcBasisFunctionDerivatives(span, u2, p3, n2, U) {
  const zeroArr = [];
  for (let i2 = 0; i2 <= p3; ++i2)
    zeroArr[i2] = 0;
  const ders = [];
  for (let i2 = 0; i2 <= n2; ++i2)
    ders[i2] = zeroArr.slice(0);
  const ndu = [];
  for (let i2 = 0; i2 <= p3; ++i2)
    ndu[i2] = zeroArr.slice(0);
  ndu[0][0] = 1;
  const left = zeroArr.slice(0);
  const right = zeroArr.slice(0);
  for (let j2 = 1; j2 <= p3; ++j2) {
    left[j2] = u2 - U[span + 1 - j2];
    right[j2] = U[span + j2] - u2;
    let saved = 0;
    for (let r3 = 0; r3 < j2; ++r3) {
      const rv = right[r3 + 1];
      const lv = left[j2 - r3];
      ndu[j2][r3] = rv + lv;
      const temp = ndu[r3][j2 - 1] / ndu[j2][r3];
      ndu[r3][j2] = saved + rv * temp;
      saved = lv * temp;
    }
    ndu[j2][j2] = saved;
  }
  for (let j2 = 0; j2 <= p3; ++j2) {
    ders[0][j2] = ndu[j2][p3];
  }
  for (let r3 = 0; r3 <= p3; ++r3) {
    let s1 = 0;
    let s2 = 1;
    const a3 = [];
    for (let i2 = 0; i2 <= p3; ++i2) {
      a3[i2] = zeroArr.slice(0);
    }
    a3[0][0] = 1;
    for (let k2 = 1; k2 <= n2; ++k2) {
      let d3 = 0;
      const rk = r3 - k2;
      const pk = p3 - k2;
      if (r3 >= k2) {
        a3[s2][0] = a3[s1][0] / ndu[pk + 1][rk];
        d3 = a3[s2][0] * ndu[rk][pk];
      }
      const j1 = rk >= -1 ? 1 : -rk;
      const j2 = r3 - 1 <= pk ? k2 - 1 : p3 - r3;
      for (let j4 = j1; j4 <= j2; ++j4) {
        a3[s2][j4] = (a3[s1][j4] - a3[s1][j4 - 1]) / ndu[pk + 1][rk + j4];
        d3 += a3[s2][j4] * ndu[rk + j4][pk];
      }
      if (r3 <= pk) {
        a3[s2][k2] = -a3[s1][k2 - 1] / ndu[pk + 1][r3];
        d3 += a3[s2][k2] * ndu[r3][pk];
      }
      ders[k2][r3] = d3;
      const j3 = s1;
      s1 = s2;
      s2 = j3;
    }
  }
  let r2 = p3;
  for (let k2 = 1; k2 <= n2; ++k2) {
    for (let j2 = 0; j2 <= p3; ++j2) {
      ders[k2][j2] *= r2;
    }
    r2 *= p3 - k2;
  }
  return ders;
}
function calcBSplineDerivatives(p3, U, P2, u2, nd) {
  const du = nd < p3 ? nd : p3;
  const CK = [];
  const span = findSpan(p3, u2, U);
  const nders = calcBasisFunctionDerivatives(span, u2, p3, du, U);
  const Pw = [];
  for (let i2 = 0; i2 < P2.length; ++i2) {
    const point2 = P2[i2].clone();
    const w4 = point2.w;
    point2.x *= w4;
    point2.y *= w4;
    point2.z *= w4;
    Pw[i2] = point2;
  }
  for (let k2 = 0; k2 <= du; ++k2) {
    const point2 = Pw[span - p3].clone().multiplyScalar(nders[k2][0]);
    for (let j2 = 1; j2 <= p3; ++j2) {
      point2.add(Pw[span - p3 + j2].clone().multiplyScalar(nders[k2][j2]));
    }
    CK[k2] = point2;
  }
  for (let k2 = du + 1; k2 <= nd + 1; ++k2) {
    CK[k2] = new Vector42(0, 0, 0);
  }
  return CK;
}
function calcKoverI(k2, i2) {
  let nom = 1;
  for (let j2 = 2; j2 <= k2; ++j2) {
    nom *= j2;
  }
  let denom = 1;
  for (let j2 = 2; j2 <= i2; ++j2) {
    denom *= j2;
  }
  for (let j2 = 2; j2 <= k2 - i2; ++j2) {
    denom *= j2;
  }
  return nom / denom;
}
function calcRationalCurveDerivatives(Pders) {
  const nd = Pders.length;
  const Aders = [];
  const wders = [];
  for (let i2 = 0; i2 < nd; ++i2) {
    const point2 = Pders[i2];
    Aders[i2] = new Vector32(point2.x, point2.y, point2.z);
    wders[i2] = point2.w;
  }
  const CK = [];
  for (let k2 = 0; k2 < nd; ++k2) {
    const v2 = Aders[k2].clone();
    for (let i2 = 1; i2 <= k2; ++i2) {
      v2.sub(CK[k2 - i2].clone().multiplyScalar(calcKoverI(k2, i2) * wders[i2]));
    }
    CK[k2] = v2.divideScalar(wders[0]);
  }
  return CK;
}
function calcNURBSDerivatives(p3, U, P2, u2, nd) {
  const Pders = calcBSplineDerivatives(p3, U, P2, u2, nd);
  return calcRationalCurveDerivatives(Pders);
}

// node_modules/aframe-extras/node_modules/three/examples/jsm/curves/NURBSCurve.js
var NURBSCurve = class extends Curve {
  constructor(degree, knots, controlPoints, startKnot, endKnot) {
    super();
    this.degree = degree;
    this.knots = knots;
    this.controlPoints = [];
    this.startKnot = startKnot || 0;
    this.endKnot = endKnot || this.knots.length - 1;
    for (let i2 = 0; i2 < controlPoints.length; ++i2) {
      const point2 = controlPoints[i2];
      this.controlPoints[i2] = new Vector42(point2.x, point2.y, point2.z, point2.w);
    }
  }
  getPoint(t5, optionalTarget = new Vector32()) {
    const point2 = optionalTarget;
    const u2 = this.knots[this.startKnot] + t5 * (this.knots[this.endKnot] - this.knots[this.startKnot]);
    const hpoint = calcBSplinePoint(this.degree, this.knots, this.controlPoints, u2);
    if (hpoint.w !== 1) {
      hpoint.divideScalar(hpoint.w);
    }
    return point2.set(hpoint.x, hpoint.y, hpoint.z);
  }
  getTangent(t5, optionalTarget = new Vector32()) {
    const tangent = optionalTarget;
    const u2 = this.knots[0] + t5 * (this.knots[this.knots.length - 1] - this.knots[0]);
    const ders = calcNURBSDerivatives(this.degree, this.knots, this.controlPoints, u2, 1);
    tangent.copy(ders[1]).normalize();
    return tangent;
  }
};

// node_modules/aframe-extras/node_modules/three/examples/jsm/loaders/FBXLoader.js
var fbxTree;
var connections;
var sceneGraph;
var FBXLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const path = scope.path === "" ? LoaderUtils.extractUrlBase(url) : scope.path;
    const loader = new FileLoader(this.manager);
    loader.setPath(scope.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(scope.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(url, function(buffer2) {
      try {
        onLoad(scope.parse(buffer2, path));
      } catch (e3) {
        if (onError) {
          onError(e3);
        } else {
          console.error(e3);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(FBXBuffer, path) {
    if (isFbxFormatBinary(FBXBuffer)) {
      fbxTree = new BinaryParser().parse(FBXBuffer);
    } else {
      const FBXText = convertArrayBufferToString(FBXBuffer);
      if (!isFbxFormatASCII(FBXText)) {
        throw new Error("THREE.FBXLoader: Unknown format.");
      }
      if (getFbxVersion(FBXText) < 7e3) {
        throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + getFbxVersion(FBXText));
      }
      fbxTree = new TextParser().parse(FBXText);
    }
    const textureLoader = new TextureLoader2(this.manager).setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);
    return new FBXTreeParser(textureLoader, this.manager).parse(fbxTree);
  }
};
var FBXTreeParser = class {
  constructor(textureLoader, manager) {
    this.textureLoader = textureLoader;
    this.manager = manager;
  }
  parse() {
    connections = this.parseConnections();
    const images = this.parseImages();
    const textures = this.parseTextures(images);
    const materials = this.parseMaterials(textures);
    const deformers = this.parseDeformers();
    const geometryMap = new GeometryParser().parse(deformers);
    this.parseScene(deformers, geometryMap, materials);
    return sceneGraph;
  }
  // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )
  // and details the connection type
  parseConnections() {
    const connectionMap = /* @__PURE__ */ new Map();
    if ("Connections" in fbxTree) {
      const rawConnections = fbxTree.Connections.connections;
      rawConnections.forEach(function(rawConnection) {
        const fromID = rawConnection[0];
        const toID = rawConnection[1];
        const relationship = rawConnection[2];
        if (!connectionMap.has(fromID)) {
          connectionMap.set(fromID, {
            parents: [],
            children: []
          });
        }
        const parentRelationship = { ID: toID, relationship };
        connectionMap.get(fromID).parents.push(parentRelationship);
        if (!connectionMap.has(toID)) {
          connectionMap.set(toID, {
            parents: [],
            children: []
          });
        }
        const childRelationship = { ID: fromID, relationship };
        connectionMap.get(toID).children.push(childRelationship);
      });
    }
    return connectionMap;
  }
  // Parse FBXTree.Objects.Video for embedded image data
  // These images are connected to textures in FBXTree.Objects.Textures
  // via FBXTree.Connections.
  parseImages() {
    const images = {};
    const blobs = {};
    if ("Video" in fbxTree.Objects) {
      const videoNodes = fbxTree.Objects.Video;
      for (const nodeID in videoNodes) {
        const videoNode = videoNodes[nodeID];
        const id2 = parseInt(nodeID);
        images[id2] = videoNode.RelativeFilename || videoNode.Filename;
        if ("Content" in videoNode) {
          const arrayBufferContent = videoNode.Content instanceof ArrayBuffer && videoNode.Content.byteLength > 0;
          const base64Content = typeof videoNode.Content === "string" && videoNode.Content !== "";
          if (arrayBufferContent || base64Content) {
            const image = this.parseImage(videoNodes[nodeID]);
            blobs[videoNode.RelativeFilename || videoNode.Filename] = image;
          }
        }
      }
    }
    for (const id2 in images) {
      const filename = images[id2];
      if (blobs[filename] !== void 0) images[id2] = blobs[filename];
      else images[id2] = images[id2].split("\\").pop();
    }
    return images;
  }
  // Parse embedded image data in FBXTree.Video.Content
  parseImage(videoNode) {
    const content = videoNode.Content;
    const fileName = videoNode.RelativeFilename || videoNode.Filename;
    const extension = fileName.slice(fileName.lastIndexOf(".") + 1).toLowerCase();
    let type;
    switch (extension) {
      case "bmp":
        type = "image/bmp";
        break;
      case "jpg":
      case "jpeg":
        type = "image/jpeg";
        break;
      case "png":
        type = "image/png";
        break;
      case "tif":
        type = "image/tiff";
        break;
      case "tga":
        if (this.manager.getHandler(".tga") === null) {
          console.warn("FBXLoader: TGA loader not found, skipping ", fileName);
        }
        type = "image/tga";
        break;
      default:
        console.warn('FBXLoader: Image type "' + extension + '" is not supported.');
        return;
    }
    if (typeof content === "string") {
      return "data:" + type + ";base64," + content;
    } else {
      const array4 = new Uint8Array(content);
      return window.URL.createObjectURL(new Blob([array4], { type }));
    }
  }
  // Parse nodes in FBXTree.Objects.Texture
  // These contain details such as UV scaling, cropping, rotation etc and are connected
  // to images in FBXTree.Objects.Video
  parseTextures(images) {
    const textureMap = /* @__PURE__ */ new Map();
    if ("Texture" in fbxTree.Objects) {
      const textureNodes = fbxTree.Objects.Texture;
      for (const nodeID in textureNodes) {
        const texture2 = this.parseTexture(textureNodes[nodeID], images);
        textureMap.set(parseInt(nodeID), texture2);
      }
    }
    return textureMap;
  }
  // Parse individual node in FBXTree.Objects.Texture
  parseTexture(textureNode, images) {
    const texture2 = this.loadTexture(textureNode, images);
    texture2.ID = textureNode.id;
    texture2.name = textureNode.attrName;
    const wrapModeU = textureNode.WrapModeU;
    const wrapModeV = textureNode.WrapModeV;
    const valueU = wrapModeU !== void 0 ? wrapModeU.value : 0;
    const valueV = wrapModeV !== void 0 ? wrapModeV.value : 0;
    texture2.wrapS = valueU === 0 ? RepeatWrapping2 : ClampToEdgeWrapping2;
    texture2.wrapT = valueV === 0 ? RepeatWrapping2 : ClampToEdgeWrapping2;
    if ("Scaling" in textureNode) {
      const values2 = textureNode.Scaling.value;
      texture2.repeat.x = values2[0];
      texture2.repeat.y = values2[1];
    }
    if ("Translation" in textureNode) {
      const values2 = textureNode.Translation.value;
      texture2.offset.x = values2[0];
      texture2.offset.y = values2[1];
    }
    return texture2;
  }
  // load a texture specified as a blob or data URI, or via an external URL using TextureLoader
  loadTexture(textureNode, images) {
    let fileName;
    const currentPath = this.textureLoader.path;
    const children2 = connections.get(textureNode.id).children;
    if (children2 !== void 0 && children2.length > 0 && images[children2[0].ID] !== void 0) {
      fileName = images[children2[0].ID];
      if (fileName.indexOf("blob:") === 0 || fileName.indexOf("data:") === 0) {
        this.textureLoader.setPath(void 0);
      }
    }
    let texture2;
    const extension = textureNode.FileName.slice(-3).toLowerCase();
    if (extension === "tga") {
      const loader = this.manager.getHandler(".tga");
      if (loader === null) {
        console.warn("FBXLoader: TGA loader not found, creating placeholder texture for", textureNode.RelativeFilename);
        texture2 = new Texture2();
      } else {
        loader.setPath(this.textureLoader.path);
        texture2 = loader.load(fileName);
      }
    } else if (extension === "dds") {
      const loader = this.manager.getHandler(".dds");
      if (loader === null) {
        console.warn("FBXLoader: DDS loader not found, creating placeholder texture for", textureNode.RelativeFilename);
        texture2 = new Texture2();
      } else {
        loader.setPath(this.textureLoader.path);
        texture2 = loader.load(fileName);
      }
    } else if (extension === "psd") {
      console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for", textureNode.RelativeFilename);
      texture2 = new Texture2();
    } else {
      texture2 = this.textureLoader.load(fileName);
    }
    this.textureLoader.setPath(currentPath);
    return texture2;
  }
  // Parse nodes in FBXTree.Objects.Material
  parseMaterials(textureMap) {
    const materialMap = /* @__PURE__ */ new Map();
    if ("Material" in fbxTree.Objects) {
      const materialNodes = fbxTree.Objects.Material;
      for (const nodeID in materialNodes) {
        const material = this.parseMaterial(materialNodes[nodeID], textureMap);
        if (material !== null) materialMap.set(parseInt(nodeID), material);
      }
    }
    return materialMap;
  }
  // Parse single node in FBXTree.Objects.Material
  // Materials are connected to texture maps in FBXTree.Objects.Textures
  // FBX format currently only supports Lambert and Phong shading models
  parseMaterial(materialNode, textureMap) {
    const ID = materialNode.id;
    const name = materialNode.attrName;
    let type = materialNode.ShadingModel;
    if (typeof type === "object") {
      type = type.value;
    }
    if (!connections.has(ID)) return null;
    const parameters = this.parseParameters(materialNode, textureMap, ID);
    let material;
    switch (type.toLowerCase()) {
      case "phong":
        material = new MeshPhongMaterial2();
        break;
      case "lambert":
        material = new MeshLambertMaterial2();
        break;
      default:
        console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', type);
        material = new MeshPhongMaterial2();
        break;
    }
    material.setValues(parameters);
    material.name = name;
    return material;
  }
  // Parse FBX material and return parameters suitable for a three.js material
  // Also parse the texture map and return any textures associated with the material
  parseParameters(materialNode, textureMap, ID) {
    const parameters = {};
    if (materialNode.BumpFactor) {
      parameters.bumpScale = materialNode.BumpFactor.value;
    }
    if (materialNode.Diffuse) {
      parameters.color = new Color2().fromArray(materialNode.Diffuse.value).convertSRGBToLinear();
    } else if (materialNode.DiffuseColor && (materialNode.DiffuseColor.type === "Color" || materialNode.DiffuseColor.type === "ColorRGB")) {
      parameters.color = new Color2().fromArray(materialNode.DiffuseColor.value).convertSRGBToLinear();
    }
    if (materialNode.DisplacementFactor) {
      parameters.displacementScale = materialNode.DisplacementFactor.value;
    }
    if (materialNode.Emissive) {
      parameters.emissive = new Color2().fromArray(materialNode.Emissive.value).convertSRGBToLinear();
    } else if (materialNode.EmissiveColor && (materialNode.EmissiveColor.type === "Color" || materialNode.EmissiveColor.type === "ColorRGB")) {
      parameters.emissive = new Color2().fromArray(materialNode.EmissiveColor.value).convertSRGBToLinear();
    }
    if (materialNode.EmissiveFactor) {
      parameters.emissiveIntensity = parseFloat(materialNode.EmissiveFactor.value);
    }
    if (materialNode.Opacity) {
      parameters.opacity = parseFloat(materialNode.Opacity.value);
    }
    if (parameters.opacity < 1) {
      parameters.transparent = true;
    }
    if (materialNode.ReflectionFactor) {
      parameters.reflectivity = materialNode.ReflectionFactor.value;
    }
    if (materialNode.Shininess) {
      parameters.shininess = materialNode.Shininess.value;
    }
    if (materialNode.Specular) {
      parameters.specular = new Color2().fromArray(materialNode.Specular.value).convertSRGBToLinear();
    } else if (materialNode.SpecularColor && materialNode.SpecularColor.type === "Color") {
      parameters.specular = new Color2().fromArray(materialNode.SpecularColor.value).convertSRGBToLinear();
    }
    const scope = this;
    connections.get(ID).children.forEach(function(child) {
      const type = child.relationship;
      switch (type) {
        case "Bump":
          parameters.bumpMap = scope.getTexture(textureMap, child.ID);
          break;
        case "Maya|TEX_ao_map":
          parameters.aoMap = scope.getTexture(textureMap, child.ID);
          break;
        case "DiffuseColor":
        case "Maya|TEX_color_map":
          parameters.map = scope.getTexture(textureMap, child.ID);
          if (parameters.map !== void 0) {
            parameters.map.colorSpace = SRGBColorSpace2;
          }
          break;
        case "DisplacementColor":
          parameters.displacementMap = scope.getTexture(textureMap, child.ID);
          break;
        case "EmissiveColor":
          parameters.emissiveMap = scope.getTexture(textureMap, child.ID);
          if (parameters.emissiveMap !== void 0) {
            parameters.emissiveMap.colorSpace = SRGBColorSpace2;
          }
          break;
        case "NormalMap":
        case "Maya|TEX_normal_map":
          parameters.normalMap = scope.getTexture(textureMap, child.ID);
          break;
        case "ReflectionColor":
          parameters.envMap = scope.getTexture(textureMap, child.ID);
          if (parameters.envMap !== void 0) {
            parameters.envMap.mapping = EquirectangularReflectionMapping2;
            parameters.envMap.colorSpace = SRGBColorSpace2;
          }
          break;
        case "SpecularColor":
          parameters.specularMap = scope.getTexture(textureMap, child.ID);
          if (parameters.specularMap !== void 0) {
            parameters.specularMap.colorSpace = SRGBColorSpace2;
          }
          break;
        case "TransparentColor":
        case "TransparencyFactor":
          parameters.alphaMap = scope.getTexture(textureMap, child.ID);
          parameters.transparent = true;
          break;
        case "AmbientColor":
        case "ShininessExponent":
        // AKA glossiness map
        case "SpecularFactor":
        // AKA specularLevel
        case "VectorDisplacementColor":
        // NOTE: Seems to be a copy of DisplacementColor
        default:
          console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", type);
          break;
      }
    });
    return parameters;
  }
  // get a texture from the textureMap for use by a material.
  getTexture(textureMap, id2) {
    if ("LayeredTexture" in fbxTree.Objects && id2 in fbxTree.Objects.LayeredTexture) {
      console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.");
      id2 = connections.get(id2).children[0].ID;
    }
    return textureMap.get(id2);
  }
  // Parse nodes in FBXTree.Objects.Deformer
  // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here
  // Generates map of Skeleton-like objects for use later when generating and binding skeletons.
  parseDeformers() {
    const skeletons = {};
    const morphTargets = {};
    if ("Deformer" in fbxTree.Objects) {
      const DeformerNodes = fbxTree.Objects.Deformer;
      for (const nodeID in DeformerNodes) {
        const deformerNode = DeformerNodes[nodeID];
        const relationships = connections.get(parseInt(nodeID));
        if (deformerNode.attrType === "Skin") {
          const skeleton = this.parseSkeleton(relationships, DeformerNodes);
          skeleton.ID = nodeID;
          if (relationships.parents.length > 1) console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported.");
          skeleton.geometryID = relationships.parents[0].ID;
          skeletons[nodeID] = skeleton;
        } else if (deformerNode.attrType === "BlendShape") {
          const morphTarget = {
            id: nodeID
          };
          morphTarget.rawTargets = this.parseMorphTargets(relationships, DeformerNodes);
          morphTarget.id = nodeID;
          if (relationships.parents.length > 1) console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported.");
          morphTargets[nodeID] = morphTarget;
        }
      }
    }
    return {
      skeletons,
      morphTargets
    };
  }
  // Parse single nodes in FBXTree.Objects.Deformer
  // The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'
  // Each skin node represents a skeleton and each cluster node represents a bone
  parseSkeleton(relationships, deformerNodes) {
    const rawBones = [];
    relationships.children.forEach(function(child) {
      const boneNode = deformerNodes[child.ID];
      if (boneNode.attrType !== "Cluster") return;
      const rawBone = {
        ID: child.ID,
        indices: [],
        weights: [],
        transformLink: new Matrix42().fromArray(boneNode.TransformLink.a)
        // transform: new Matrix4().fromArray( boneNode.Transform.a ),
        // linkMode: boneNode.Mode,
      };
      if ("Indexes" in boneNode) {
        rawBone.indices = boneNode.Indexes.a;
        rawBone.weights = boneNode.Weights.a;
      }
      rawBones.push(rawBone);
    });
    return {
      rawBones,
      bones: []
    };
  }
  // The top level morph deformer node has type "BlendShape" and sub nodes have type "BlendShapeChannel"
  parseMorphTargets(relationships, deformerNodes) {
    const rawMorphTargets = [];
    for (let i2 = 0; i2 < relationships.children.length; i2++) {
      const child = relationships.children[i2];
      const morphTargetNode = deformerNodes[child.ID];
      const rawMorphTarget = {
        name: morphTargetNode.attrName,
        initialWeight: morphTargetNode.DeformPercent,
        id: morphTargetNode.id,
        fullWeights: morphTargetNode.FullWeights.a
      };
      if (morphTargetNode.attrType !== "BlendShapeChannel") return;
      rawMorphTarget.geoID = connections.get(parseInt(child.ID)).children.filter(function(child2) {
        return child2.relationship === void 0;
      })[0].ID;
      rawMorphTargets.push(rawMorphTarget);
    }
    return rawMorphTargets;
  }
  // create the main Group() to be returned by the loader
  parseScene(deformers, geometryMap, materialMap) {
    sceneGraph = new Group2();
    const modelMap = this.parseModels(deformers.skeletons, geometryMap, materialMap);
    const modelNodes = fbxTree.Objects.Model;
    const scope = this;
    modelMap.forEach(function(model) {
      const modelNode = modelNodes[model.ID];
      scope.setLookAtProperties(model, modelNode);
      const parentConnections = connections.get(model.ID).parents;
      parentConnections.forEach(function(connection) {
        const parent2 = modelMap.get(connection.ID);
        if (parent2 !== void 0) parent2.add(model);
      });
      if (model.parent === null) {
        sceneGraph.add(model);
      }
    });
    this.bindSkeleton(deformers.skeletons, geometryMap, modelMap);
    this.addGlobalSceneSettings();
    sceneGraph.traverse(function(node) {
      if (node.userData.transformData) {
        if (node.parent) {
          node.userData.transformData.parentMatrix = node.parent.matrix;
          node.userData.transformData.parentMatrixWorld = node.parent.matrixWorld;
        }
        const transform3 = generateTransform(node.userData.transformData);
        node.applyMatrix4(transform3);
        node.updateWorldMatrix();
      }
    });
    const animations = new AnimationParser().parse();
    if (sceneGraph.children.length === 1 && sceneGraph.children[0].isGroup) {
      sceneGraph.children[0].animations = animations;
      sceneGraph = sceneGraph.children[0];
    }
    sceneGraph.animations = animations;
  }
  // parse nodes in FBXTree.Objects.Model
  parseModels(skeletons, geometryMap, materialMap) {
    const modelMap = /* @__PURE__ */ new Map();
    const modelNodes = fbxTree.Objects.Model;
    for (const nodeID in modelNodes) {
      const id2 = parseInt(nodeID);
      const node = modelNodes[nodeID];
      const relationships = connections.get(id2);
      let model = this.buildSkeleton(relationships, skeletons, id2, node.attrName);
      if (!model) {
        switch (node.attrType) {
          case "Camera":
            model = this.createCamera(relationships);
            break;
          case "Light":
            model = this.createLight(relationships);
            break;
          case "Mesh":
            model = this.createMesh(relationships, geometryMap, materialMap);
            break;
          case "NurbsCurve":
            model = this.createCurve(relationships, geometryMap);
            break;
          case "LimbNode":
          case "Root":
            model = new Bone();
            break;
          case "Null":
          default:
            model = new Group2();
            break;
        }
        model.name = node.attrName ? PropertyBinding.sanitizeNodeName(node.attrName) : "";
        model.userData.originalName = node.attrName;
        model.ID = id2;
      }
      this.getTransformData(model, node);
      modelMap.set(id2, model);
    }
    return modelMap;
  }
  buildSkeleton(relationships, skeletons, id2, name) {
    let bone = null;
    relationships.parents.forEach(function(parent2) {
      for (const ID in skeletons) {
        const skeleton = skeletons[ID];
        skeleton.rawBones.forEach(function(rawBone, i2) {
          if (rawBone.ID === parent2.ID) {
            const subBone = bone;
            bone = new Bone();
            bone.matrixWorld.copy(rawBone.transformLink);
            bone.name = name ? PropertyBinding.sanitizeNodeName(name) : "";
            bone.userData.originalName = name;
            bone.ID = id2;
            skeleton.bones[i2] = bone;
            if (subBone !== null) {
              bone.add(subBone);
            }
          }
        });
      }
    });
    return bone;
  }
  // create a PerspectiveCamera or OrthographicCamera
  createCamera(relationships) {
    let model;
    let cameraAttribute;
    relationships.children.forEach(function(child) {
      const attr = fbxTree.Objects.NodeAttribute[child.ID];
      if (attr !== void 0) {
        cameraAttribute = attr;
      }
    });
    if (cameraAttribute === void 0) {
      model = new Object3D2();
    } else {
      let type = 0;
      if (cameraAttribute.CameraProjectionType !== void 0 && cameraAttribute.CameraProjectionType.value === 1) {
        type = 1;
      }
      let nearClippingPlane = 1;
      if (cameraAttribute.NearPlane !== void 0) {
        nearClippingPlane = cameraAttribute.NearPlane.value / 1e3;
      }
      let farClippingPlane = 1e3;
      if (cameraAttribute.FarPlane !== void 0) {
        farClippingPlane = cameraAttribute.FarPlane.value / 1e3;
      }
      let width = window.innerWidth;
      let height = window.innerHeight;
      if (cameraAttribute.AspectWidth !== void 0 && cameraAttribute.AspectHeight !== void 0) {
        width = cameraAttribute.AspectWidth.value;
        height = cameraAttribute.AspectHeight.value;
      }
      const aspect = width / height;
      let fov = 45;
      if (cameraAttribute.FieldOfView !== void 0) {
        fov = cameraAttribute.FieldOfView.value;
      }
      const focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null;
      switch (type) {
        case 0:
          model = new PerspectiveCamera2(fov, aspect, nearClippingPlane, farClippingPlane);
          if (focalLength !== null) model.setFocalLength(focalLength);
          break;
        case 1:
          model = new OrthographicCamera2(-width / 2, width / 2, height / 2, -height / 2, nearClippingPlane, farClippingPlane);
          break;
        default:
          console.warn("THREE.FBXLoader: Unknown camera type " + type + ".");
          model = new Object3D2();
          break;
      }
    }
    return model;
  }
  // Create a DirectionalLight, PointLight or SpotLight
  createLight(relationships) {
    let model;
    let lightAttribute;
    relationships.children.forEach(function(child) {
      const attr = fbxTree.Objects.NodeAttribute[child.ID];
      if (attr !== void 0) {
        lightAttribute = attr;
      }
    });
    if (lightAttribute === void 0) {
      model = new Object3D2();
    } else {
      let type;
      if (lightAttribute.LightType === void 0) {
        type = 0;
      } else {
        type = lightAttribute.LightType.value;
      }
      let color3 = 16777215;
      if (lightAttribute.Color !== void 0) {
        color3 = new Color2().fromArray(lightAttribute.Color.value).convertSRGBToLinear();
      }
      let intensity = lightAttribute.Intensity === void 0 ? 1 : lightAttribute.Intensity.value / 100;
      if (lightAttribute.CastLightOnObject !== void 0 && lightAttribute.CastLightOnObject.value === 0) {
        intensity = 0;
      }
      let distance4 = 0;
      if (lightAttribute.FarAttenuationEnd !== void 0) {
        if (lightAttribute.EnableFarAttenuation !== void 0 && lightAttribute.EnableFarAttenuation.value === 0) {
          distance4 = 0;
        } else {
          distance4 = lightAttribute.FarAttenuationEnd.value;
        }
      }
      const decay = 1;
      switch (type) {
        case 0:
          model = new PointLight2(color3, intensity, distance4, decay);
          break;
        case 1:
          model = new DirectionalLight2(color3, intensity);
          break;
        case 2:
          let angle2 = Math.PI / 3;
          if (lightAttribute.InnerAngle !== void 0) {
            angle2 = MathUtils2.degToRad(lightAttribute.InnerAngle.value);
          }
          let penumbra = 0;
          if (lightAttribute.OuterAngle !== void 0) {
            penumbra = MathUtils2.degToRad(lightAttribute.OuterAngle.value);
            penumbra = Math.max(penumbra, 1);
          }
          model = new SpotLight2(color3, intensity, distance4, angle2, penumbra, decay);
          break;
        default:
          console.warn("THREE.FBXLoader: Unknown light type " + lightAttribute.LightType.value + ", defaulting to a PointLight.");
          model = new PointLight2(color3, intensity);
          break;
      }
      if (lightAttribute.CastShadows !== void 0 && lightAttribute.CastShadows.value === 1) {
        model.castShadow = true;
      }
    }
    return model;
  }
  createMesh(relationships, geometryMap, materialMap) {
    let model;
    let geometry = null;
    let material = null;
    const materials = [];
    relationships.children.forEach(function(child) {
      if (geometryMap.has(child.ID)) {
        geometry = geometryMap.get(child.ID);
      }
      if (materialMap.has(child.ID)) {
        materials.push(materialMap.get(child.ID));
      }
    });
    if (materials.length > 1) {
      material = materials;
    } else if (materials.length > 0) {
      material = materials[0];
    } else {
      material = new MeshPhongMaterial2({
        name: Loader.DEFAULT_MATERIAL_NAME,
        color: 13421772
      });
      materials.push(material);
    }
    if ("color" in geometry.attributes) {
      materials.forEach(function(material2) {
        material2.vertexColors = true;
      });
    }
    if (geometry.FBX_Deformer) {
      model = new SkinnedMesh(geometry, material);
      model.normalizeSkinWeights();
    } else {
      model = new Mesh2(geometry, material);
    }
    return model;
  }
  createCurve(relationships, geometryMap) {
    const geometry = relationships.children.reduce(function(geo, child) {
      if (geometryMap.has(child.ID)) geo = geometryMap.get(child.ID);
      return geo;
    }, null);
    const material = new LineBasicMaterial2({
      name: Loader.DEFAULT_MATERIAL_NAME,
      color: 3342591,
      linewidth: 1
    });
    return new Line2(geometry, material);
  }
  // parse the model node for transform data
  getTransformData(model, modelNode) {
    const transformData = {};
    if ("InheritType" in modelNode) transformData.inheritType = parseInt(modelNode.InheritType.value);
    if ("RotationOrder" in modelNode) transformData.eulerOrder = getEulerOrder(modelNode.RotationOrder.value);
    else transformData.eulerOrder = "ZYX";
    if ("Lcl_Translation" in modelNode) transformData.translation = modelNode.Lcl_Translation.value;
    if ("PreRotation" in modelNode) transformData.preRotation = modelNode.PreRotation.value;
    if ("Lcl_Rotation" in modelNode) transformData.rotation = modelNode.Lcl_Rotation.value;
    if ("PostRotation" in modelNode) transformData.postRotation = modelNode.PostRotation.value;
    if ("Lcl_Scaling" in modelNode) transformData.scale = modelNode.Lcl_Scaling.value;
    if ("ScalingOffset" in modelNode) transformData.scalingOffset = modelNode.ScalingOffset.value;
    if ("ScalingPivot" in modelNode) transformData.scalingPivot = modelNode.ScalingPivot.value;
    if ("RotationOffset" in modelNode) transformData.rotationOffset = modelNode.RotationOffset.value;
    if ("RotationPivot" in modelNode) transformData.rotationPivot = modelNode.RotationPivot.value;
    model.userData.transformData = transformData;
  }
  setLookAtProperties(model, modelNode) {
    if ("LookAtProperty" in modelNode) {
      const children2 = connections.get(model.ID).children;
      children2.forEach(function(child) {
        if (child.relationship === "LookAtProperty") {
          const lookAtTarget = fbxTree.Objects.Model[child.ID];
          if ("Lcl_Translation" in lookAtTarget) {
            const pos = lookAtTarget.Lcl_Translation.value;
            if (model.target !== void 0) {
              model.target.position.fromArray(pos);
              sceneGraph.add(model.target);
            } else {
              model.lookAt(new Vector32().fromArray(pos));
            }
          }
        }
      });
    }
  }
  bindSkeleton(skeletons, geometryMap, modelMap) {
    const bindMatrices = this.parsePoseNodes();
    for (const ID in skeletons) {
      const skeleton = skeletons[ID];
      const parents = connections.get(parseInt(skeleton.ID)).parents;
      parents.forEach(function(parent2) {
        if (geometryMap.has(parent2.ID)) {
          const geoID = parent2.ID;
          const geoRelationships = connections.get(geoID);
          geoRelationships.parents.forEach(function(geoConnParent) {
            if (modelMap.has(geoConnParent.ID)) {
              const model = modelMap.get(geoConnParent.ID);
              model.bind(new Skeleton(skeleton.bones), bindMatrices[geoConnParent.ID]);
            }
          });
        }
      });
    }
  }
  parsePoseNodes() {
    const bindMatrices = {};
    if ("Pose" in fbxTree.Objects) {
      const BindPoseNode = fbxTree.Objects.Pose;
      for (const nodeID in BindPoseNode) {
        if (BindPoseNode[nodeID].attrType === "BindPose" && BindPoseNode[nodeID].NbPoseNodes > 0) {
          const poseNodes = BindPoseNode[nodeID].PoseNode;
          if (Array.isArray(poseNodes)) {
            poseNodes.forEach(function(poseNode) {
              bindMatrices[poseNode.Node] = new Matrix42().fromArray(poseNode.Matrix.a);
            });
          } else {
            bindMatrices[poseNodes.Node] = new Matrix42().fromArray(poseNodes.Matrix.a);
          }
        }
      }
    }
    return bindMatrices;
  }
  addGlobalSceneSettings() {
    if ("GlobalSettings" in fbxTree) {
      if ("AmbientColor" in fbxTree.GlobalSettings) {
        const ambientColor = fbxTree.GlobalSettings.AmbientColor.value;
        const r2 = ambientColor[0];
        const g3 = ambientColor[1];
        const b = ambientColor[2];
        if (r2 !== 0 || g3 !== 0 || b !== 0) {
          const color3 = new Color2(r2, g3, b).convertSRGBToLinear();
          sceneGraph.add(new AmbientLight2(color3, 1));
        }
      }
      if ("UnitScaleFactor" in fbxTree.GlobalSettings) {
        sceneGraph.userData.unitScaleFactor = fbxTree.GlobalSettings.UnitScaleFactor.value;
      }
    }
  }
};
var GeometryParser = class {
  constructor() {
    this.negativeMaterialIndices = false;
  }
  // Parse nodes in FBXTree.Objects.Geometry
  parse(deformers) {
    const geometryMap = /* @__PURE__ */ new Map();
    if ("Geometry" in fbxTree.Objects) {
      const geoNodes = fbxTree.Objects.Geometry;
      for (const nodeID in geoNodes) {
        const relationships = connections.get(parseInt(nodeID));
        const geo = this.parseGeometry(relationships, geoNodes[nodeID], deformers);
        geometryMap.set(parseInt(nodeID), geo);
      }
    }
    if (this.negativeMaterialIndices === true) {
      console.warn("THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected.");
    }
    return geometryMap;
  }
  // Parse single node in FBXTree.Objects.Geometry
  parseGeometry(relationships, geoNode, deformers) {
    switch (geoNode.attrType) {
      case "Mesh":
        return this.parseMeshGeometry(relationships, geoNode, deformers);
        break;
      case "NurbsCurve":
        return this.parseNurbsGeometry(geoNode);
        break;
    }
  }
  // Parse single node mesh geometry in FBXTree.Objects.Geometry
  parseMeshGeometry(relationships, geoNode, deformers) {
    const skeletons = deformers.skeletons;
    const morphTargets = [];
    const modelNodes = relationships.parents.map(function(parent2) {
      return fbxTree.Objects.Model[parent2.ID];
    });
    if (modelNodes.length === 0) return;
    const skeleton = relationships.children.reduce(function(skeleton2, child) {
      if (skeletons[child.ID] !== void 0) skeleton2 = skeletons[child.ID];
      return skeleton2;
    }, null);
    relationships.children.forEach(function(child) {
      if (deformers.morphTargets[child.ID] !== void 0) {
        morphTargets.push(deformers.morphTargets[child.ID]);
      }
    });
    const modelNode = modelNodes[0];
    const transformData = {};
    if ("RotationOrder" in modelNode) transformData.eulerOrder = getEulerOrder(modelNode.RotationOrder.value);
    if ("InheritType" in modelNode) transformData.inheritType = parseInt(modelNode.InheritType.value);
    if ("GeometricTranslation" in modelNode) transformData.translation = modelNode.GeometricTranslation.value;
    if ("GeometricRotation" in modelNode) transformData.rotation = modelNode.GeometricRotation.value;
    if ("GeometricScaling" in modelNode) transformData.scale = modelNode.GeometricScaling.value;
    const transform3 = generateTransform(transformData);
    return this.genGeometry(geoNode, skeleton, morphTargets, transform3);
  }
  // Generate a BufferGeometry from a node in FBXTree.Objects.Geometry
  genGeometry(geoNode, skeleton, morphTargets, preTransform) {
    const geo = new BufferGeometry2();
    if (geoNode.attrName) geo.name = geoNode.attrName;
    const geoInfo = this.parseGeoNode(geoNode, skeleton);
    const buffers = this.genBuffers(geoInfo);
    const positionAttribute = new Float32BufferAttribute2(buffers.vertex, 3);
    positionAttribute.applyMatrix4(preTransform);
    geo.setAttribute("position", positionAttribute);
    if (buffers.colors.length > 0) {
      geo.setAttribute("color", new Float32BufferAttribute2(buffers.colors, 3));
    }
    if (skeleton) {
      geo.setAttribute("skinIndex", new Uint16BufferAttribute2(buffers.weightsIndices, 4));
      geo.setAttribute("skinWeight", new Float32BufferAttribute2(buffers.vertexWeights, 4));
      geo.FBX_Deformer = skeleton;
    }
    if (buffers.normal.length > 0) {
      const normalMatrix = new Matrix32().getNormalMatrix(preTransform);
      const normalAttribute = new Float32BufferAttribute2(buffers.normal, 3);
      normalAttribute.applyNormalMatrix(normalMatrix);
      geo.setAttribute("normal", normalAttribute);
    }
    buffers.uvs.forEach(function(uvBuffer, i2) {
      const name = i2 === 0 ? "uv" : `uv${i2}`;
      geo.setAttribute(name, new Float32BufferAttribute2(buffers.uvs[i2], 2));
    });
    if (geoInfo.material && geoInfo.material.mappingType !== "AllSame") {
      let prevMaterialIndex = buffers.materialIndex[0];
      let startIndex = 0;
      buffers.materialIndex.forEach(function(currentIndex, i2) {
        if (currentIndex !== prevMaterialIndex) {
          geo.addGroup(startIndex, i2 - startIndex, prevMaterialIndex);
          prevMaterialIndex = currentIndex;
          startIndex = i2;
        }
      });
      if (geo.groups.length > 0) {
        const lastGroup = geo.groups[geo.groups.length - 1];
        const lastIndex = lastGroup.start + lastGroup.count;
        if (lastIndex !== buffers.materialIndex.length) {
          geo.addGroup(lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex);
        }
      }
      if (geo.groups.length === 0) {
        geo.addGroup(0, buffers.materialIndex.length, buffers.materialIndex[0]);
      }
    }
    this.addMorphTargets(geo, geoNode, morphTargets, preTransform);
    return geo;
  }
  parseGeoNode(geoNode, skeleton) {
    const geoInfo = {};
    geoInfo.vertexPositions = geoNode.Vertices !== void 0 ? geoNode.Vertices.a : [];
    geoInfo.vertexIndices = geoNode.PolygonVertexIndex !== void 0 ? geoNode.PolygonVertexIndex.a : [];
    if (geoNode.LayerElementColor) {
      geoInfo.color = this.parseVertexColors(geoNode.LayerElementColor[0]);
    }
    if (geoNode.LayerElementMaterial) {
      geoInfo.material = this.parseMaterialIndices(geoNode.LayerElementMaterial[0]);
    }
    if (geoNode.LayerElementNormal) {
      geoInfo.normal = this.parseNormals(geoNode.LayerElementNormal[0]);
    }
    if (geoNode.LayerElementUV) {
      geoInfo.uv = [];
      let i2 = 0;
      while (geoNode.LayerElementUV[i2]) {
        if (geoNode.LayerElementUV[i2].UV) {
          geoInfo.uv.push(this.parseUVs(geoNode.LayerElementUV[i2]));
        }
        i2++;
      }
    }
    geoInfo.weightTable = {};
    if (skeleton !== null) {
      geoInfo.skeleton = skeleton;
      skeleton.rawBones.forEach(function(rawBone, i2) {
        rawBone.indices.forEach(function(index8, j2) {
          if (geoInfo.weightTable[index8] === void 0) geoInfo.weightTable[index8] = [];
          geoInfo.weightTable[index8].push({
            id: i2,
            weight: rawBone.weights[j2]
          });
        });
      });
    }
    return geoInfo;
  }
  genBuffers(geoInfo) {
    const buffers = {
      vertex: [],
      normal: [],
      colors: [],
      uvs: [],
      materialIndex: [],
      vertexWeights: [],
      weightsIndices: []
    };
    let polygonIndex = 0;
    let faceLength = 0;
    let displayedWeightsWarning = false;
    let facePositionIndexes = [];
    let faceNormals = [];
    let faceColors = [];
    let faceUVs = [];
    let faceWeights = [];
    let faceWeightIndices = [];
    const scope = this;
    geoInfo.vertexIndices.forEach(function(vertexIndex2, polygonVertexIndex) {
      let materialIndex;
      let endOfFace = false;
      if (vertexIndex2 < 0) {
        vertexIndex2 = vertexIndex2 ^ -1;
        endOfFace = true;
      }
      let weightIndices = [];
      let weights = [];
      facePositionIndexes.push(vertexIndex2 * 3, vertexIndex2 * 3 + 1, vertexIndex2 * 3 + 2);
      if (geoInfo.color) {
        const data = getData(polygonVertexIndex, polygonIndex, vertexIndex2, geoInfo.color);
        faceColors.push(data[0], data[1], data[2]);
      }
      if (geoInfo.skeleton) {
        if (geoInfo.weightTable[vertexIndex2] !== void 0) {
          geoInfo.weightTable[vertexIndex2].forEach(function(wt) {
            weights.push(wt.weight);
            weightIndices.push(wt.id);
          });
        }
        if (weights.length > 4) {
          if (!displayedWeightsWarning) {
            console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.");
            displayedWeightsWarning = true;
          }
          const wIndex = [0, 0, 0, 0];
          const Weight = [0, 0, 0, 0];
          weights.forEach(function(weight, weightIndex) {
            let currentWeight = weight;
            let currentIndex = weightIndices[weightIndex];
            Weight.forEach(function(comparedWeight, comparedWeightIndex, comparedWeightArray) {
              if (currentWeight > comparedWeight) {
                comparedWeightArray[comparedWeightIndex] = currentWeight;
                currentWeight = comparedWeight;
                const tmp2 = wIndex[comparedWeightIndex];
                wIndex[comparedWeightIndex] = currentIndex;
                currentIndex = tmp2;
              }
            });
          });
          weightIndices = wIndex;
          weights = Weight;
        }
        while (weights.length < 4) {
          weights.push(0);
          weightIndices.push(0);
        }
        for (let i2 = 0; i2 < 4; ++i2) {
          faceWeights.push(weights[i2]);
          faceWeightIndices.push(weightIndices[i2]);
        }
      }
      if (geoInfo.normal) {
        const data = getData(polygonVertexIndex, polygonIndex, vertexIndex2, geoInfo.normal);
        faceNormals.push(data[0], data[1], data[2]);
      }
      if (geoInfo.material && geoInfo.material.mappingType !== "AllSame") {
        materialIndex = getData(polygonVertexIndex, polygonIndex, vertexIndex2, geoInfo.material)[0];
        if (materialIndex < 0) {
          scope.negativeMaterialIndices = true;
          materialIndex = 0;
        }
      }
      if (geoInfo.uv) {
        geoInfo.uv.forEach(function(uv2, i2) {
          const data = getData(polygonVertexIndex, polygonIndex, vertexIndex2, uv2);
          if (faceUVs[i2] === void 0) {
            faceUVs[i2] = [];
          }
          faceUVs[i2].push(data[0]);
          faceUVs[i2].push(data[1]);
        });
      }
      faceLength++;
      if (endOfFace) {
        scope.genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength);
        polygonIndex++;
        faceLength = 0;
        facePositionIndexes = [];
        faceNormals = [];
        faceColors = [];
        faceUVs = [];
        faceWeights = [];
        faceWeightIndices = [];
      }
    });
    return buffers;
  }
  // See https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal
  getNormalNewell(vertices) {
    const normal2 = new Vector32(0, 0, 0);
    for (let i2 = 0; i2 < vertices.length; i2++) {
      const current = vertices[i2];
      const next = vertices[(i2 + 1) % vertices.length];
      normal2.x += (current.y - next.y) * (current.z + next.z);
      normal2.y += (current.z - next.z) * (current.x + next.x);
      normal2.z += (current.x - next.x) * (current.y + next.y);
    }
    normal2.normalize();
    return normal2;
  }
  getNormalTangentAndBitangent(vertices) {
    const normalVector = this.getNormalNewell(vertices);
    const up = Math.abs(normalVector.z) > 0.5 ? new Vector32(0, 1, 0) : new Vector32(0, 0, 1);
    const tangent = up.cross(normalVector).normalize();
    const bitangent = normalVector.clone().cross(tangent).normalize();
    return {
      normal: normalVector,
      tangent,
      bitangent
    };
  }
  flattenVertex(vertex, normalTangent, normalBitangent) {
    return new Vector22(
      vertex.dot(normalTangent),
      vertex.dot(normalBitangent)
    );
  }
  // Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris
  genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength) {
    let triangles;
    if (faceLength > 3) {
      const vertices = [];
      for (let i2 = 0; i2 < facePositionIndexes.length; i2 += 3) {
        vertices.push(new Vector32(
          geoInfo.vertexPositions[facePositionIndexes[i2]],
          geoInfo.vertexPositions[facePositionIndexes[i2 + 1]],
          geoInfo.vertexPositions[facePositionIndexes[i2 + 2]]
        ));
      }
      const { tangent, bitangent } = this.getNormalTangentAndBitangent(vertices);
      const triangulationInput = [];
      for (const vertex of vertices) {
        triangulationInput.push(this.flattenVertex(vertex, tangent, bitangent));
      }
      triangles = ShapeUtils.triangulateShape(triangulationInput, []);
    } else {
      triangles = [[0, 1, 2]];
    }
    for (const [i0, i1, i2] of triangles) {
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i0 * 3]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i0 * 3 + 1]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i0 * 3 + 2]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i1 * 3]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i1 * 3 + 1]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i1 * 3 + 2]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i2 * 3]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i2 * 3 + 1]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i2 * 3 + 2]]);
      if (geoInfo.skeleton) {
        buffers.vertexWeights.push(faceWeights[i0 * 4]);
        buffers.vertexWeights.push(faceWeights[i0 * 4 + 1]);
        buffers.vertexWeights.push(faceWeights[i0 * 4 + 2]);
        buffers.vertexWeights.push(faceWeights[i0 * 4 + 3]);
        buffers.vertexWeights.push(faceWeights[i1 * 4]);
        buffers.vertexWeights.push(faceWeights[i1 * 4 + 1]);
        buffers.vertexWeights.push(faceWeights[i1 * 4 + 2]);
        buffers.vertexWeights.push(faceWeights[i1 * 4 + 3]);
        buffers.vertexWeights.push(faceWeights[i2 * 4]);
        buffers.vertexWeights.push(faceWeights[i2 * 4 + 1]);
        buffers.vertexWeights.push(faceWeights[i2 * 4 + 2]);
        buffers.vertexWeights.push(faceWeights[i2 * 4 + 3]);
        buffers.weightsIndices.push(faceWeightIndices[i0 * 4]);
        buffers.weightsIndices.push(faceWeightIndices[i0 * 4 + 1]);
        buffers.weightsIndices.push(faceWeightIndices[i0 * 4 + 2]);
        buffers.weightsIndices.push(faceWeightIndices[i0 * 4 + 3]);
        buffers.weightsIndices.push(faceWeightIndices[i1 * 4]);
        buffers.weightsIndices.push(faceWeightIndices[i1 * 4 + 1]);
        buffers.weightsIndices.push(faceWeightIndices[i1 * 4 + 2]);
        buffers.weightsIndices.push(faceWeightIndices[i1 * 4 + 3]);
        buffers.weightsIndices.push(faceWeightIndices[i2 * 4]);
        buffers.weightsIndices.push(faceWeightIndices[i2 * 4 + 1]);
        buffers.weightsIndices.push(faceWeightIndices[i2 * 4 + 2]);
        buffers.weightsIndices.push(faceWeightIndices[i2 * 4 + 3]);
      }
      if (geoInfo.color) {
        buffers.colors.push(faceColors[i0 * 3]);
        buffers.colors.push(faceColors[i0 * 3 + 1]);
        buffers.colors.push(faceColors[i0 * 3 + 2]);
        buffers.colors.push(faceColors[i1 * 3]);
        buffers.colors.push(faceColors[i1 * 3 + 1]);
        buffers.colors.push(faceColors[i1 * 3 + 2]);
        buffers.colors.push(faceColors[i2 * 3]);
        buffers.colors.push(faceColors[i2 * 3 + 1]);
        buffers.colors.push(faceColors[i2 * 3 + 2]);
      }
      if (geoInfo.material && geoInfo.material.mappingType !== "AllSame") {
        buffers.materialIndex.push(materialIndex);
        buffers.materialIndex.push(materialIndex);
        buffers.materialIndex.push(materialIndex);
      }
      if (geoInfo.normal) {
        buffers.normal.push(faceNormals[i0 * 3]);
        buffers.normal.push(faceNormals[i0 * 3 + 1]);
        buffers.normal.push(faceNormals[i0 * 3 + 2]);
        buffers.normal.push(faceNormals[i1 * 3]);
        buffers.normal.push(faceNormals[i1 * 3 + 1]);
        buffers.normal.push(faceNormals[i1 * 3 + 2]);
        buffers.normal.push(faceNormals[i2 * 3]);
        buffers.normal.push(faceNormals[i2 * 3 + 1]);
        buffers.normal.push(faceNormals[i2 * 3 + 2]);
      }
      if (geoInfo.uv) {
        geoInfo.uv.forEach(function(uv2, j2) {
          if (buffers.uvs[j2] === void 0) buffers.uvs[j2] = [];
          buffers.uvs[j2].push(faceUVs[j2][i0 * 2]);
          buffers.uvs[j2].push(faceUVs[j2][i0 * 2 + 1]);
          buffers.uvs[j2].push(faceUVs[j2][i1 * 2]);
          buffers.uvs[j2].push(faceUVs[j2][i1 * 2 + 1]);
          buffers.uvs[j2].push(faceUVs[j2][i2 * 2]);
          buffers.uvs[j2].push(faceUVs[j2][i2 * 2 + 1]);
        });
      }
    }
  }
  addMorphTargets(parentGeo, parentGeoNode, morphTargets, preTransform) {
    if (morphTargets.length === 0) return;
    parentGeo.morphTargetsRelative = true;
    parentGeo.morphAttributes.position = [];
    const scope = this;
    morphTargets.forEach(function(morphTarget) {
      morphTarget.rawTargets.forEach(function(rawTarget) {
        const morphGeoNode = fbxTree.Objects.Geometry[rawTarget.geoID];
        if (morphGeoNode !== void 0) {
          scope.genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, rawTarget.name);
        }
      });
    });
  }
  // a morph geometry node is similar to a standard  node, and the node is also contained
  // in FBXTree.Objects.Geometry, however it can only have attributes for position, normal
  // and a special attribute Index defining which vertices of the original geometry are affected
  // Normal and position attributes only have data for the vertices that are affected by the morph
  genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, name) {
    const vertexIndices = parentGeoNode.PolygonVertexIndex !== void 0 ? parentGeoNode.PolygonVertexIndex.a : [];
    const morphPositionsSparse = morphGeoNode.Vertices !== void 0 ? morphGeoNode.Vertices.a : [];
    const indices = morphGeoNode.Indexes !== void 0 ? morphGeoNode.Indexes.a : [];
    const length2 = parentGeo.attributes.position.count * 3;
    const morphPositions = new Float32Array(length2);
    for (let i2 = 0; i2 < indices.length; i2++) {
      const morphIndex = indices[i2] * 3;
      morphPositions[morphIndex] = morphPositionsSparse[i2 * 3];
      morphPositions[morphIndex + 1] = morphPositionsSparse[i2 * 3 + 1];
      morphPositions[morphIndex + 2] = morphPositionsSparse[i2 * 3 + 2];
    }
    const morphGeoInfo = {
      vertexIndices,
      vertexPositions: morphPositions
    };
    const morphBuffers = this.genBuffers(morphGeoInfo);
    const positionAttribute = new Float32BufferAttribute2(morphBuffers.vertex, 3);
    positionAttribute.name = name || morphGeoNode.attrName;
    positionAttribute.applyMatrix4(preTransform);
    parentGeo.morphAttributes.position.push(positionAttribute);
  }
  // Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists
  parseNormals(NormalNode) {
    const mappingType = NormalNode.MappingInformationType;
    const referenceType = NormalNode.ReferenceInformationType;
    const buffer2 = NormalNode.Normals.a;
    let indexBuffer = [];
    if (referenceType === "IndexToDirect") {
      if ("NormalIndex" in NormalNode) {
        indexBuffer = NormalNode.NormalIndex.a;
      } else if ("NormalsIndex" in NormalNode) {
        indexBuffer = NormalNode.NormalsIndex.a;
      }
    }
    return {
      dataSize: 3,
      buffer: buffer2,
      indices: indexBuffer,
      mappingType,
      referenceType
    };
  }
  // Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists
  parseUVs(UVNode) {
    const mappingType = UVNode.MappingInformationType;
    const referenceType = UVNode.ReferenceInformationType;
    const buffer2 = UVNode.UV.a;
    let indexBuffer = [];
    if (referenceType === "IndexToDirect") {
      indexBuffer = UVNode.UVIndex.a;
    }
    return {
      dataSize: 2,
      buffer: buffer2,
      indices: indexBuffer,
      mappingType,
      referenceType
    };
  }
  // Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists
  parseVertexColors(ColorNode) {
    const mappingType = ColorNode.MappingInformationType;
    const referenceType = ColorNode.ReferenceInformationType;
    const buffer2 = ColorNode.Colors.a;
    let indexBuffer = [];
    if (referenceType === "IndexToDirect") {
      indexBuffer = ColorNode.ColorIndex.a;
    }
    for (let i2 = 0, c5 = new Color2(); i2 < buffer2.length; i2 += 4) {
      c5.fromArray(buffer2, i2).convertSRGBToLinear().toArray(buffer2, i2);
    }
    return {
      dataSize: 4,
      buffer: buffer2,
      indices: indexBuffer,
      mappingType,
      referenceType
    };
  }
  // Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists
  parseMaterialIndices(MaterialNode2) {
    const mappingType = MaterialNode2.MappingInformationType;
    const referenceType = MaterialNode2.ReferenceInformationType;
    if (mappingType === "NoMappingInformation") {
      return {
        dataSize: 1,
        buffer: [0],
        indices: [0],
        mappingType: "AllSame",
        referenceType
      };
    }
    const materialIndexBuffer = MaterialNode2.Materials.a;
    const materialIndices = [];
    for (let i2 = 0; i2 < materialIndexBuffer.length; ++i2) {
      materialIndices.push(i2);
    }
    return {
      dataSize: 1,
      buffer: materialIndexBuffer,
      indices: materialIndices,
      mappingType,
      referenceType
    };
  }
  // Generate a NurbGeometry from a node in FBXTree.Objects.Geometry
  parseNurbsGeometry(geoNode) {
    const order = parseInt(geoNode.Order);
    if (isNaN(order)) {
      console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", geoNode.Order, geoNode.id);
      return new BufferGeometry2();
    }
    const degree = order - 1;
    const knots = geoNode.KnotVector.a;
    const controlPoints = [];
    const pointsValues = geoNode.Points.a;
    for (let i2 = 0, l2 = pointsValues.length; i2 < l2; i2 += 4) {
      controlPoints.push(new Vector42().fromArray(pointsValues, i2));
    }
    let startKnot, endKnot;
    if (geoNode.Form === "Closed") {
      controlPoints.push(controlPoints[0]);
    } else if (geoNode.Form === "Periodic") {
      startKnot = degree;
      endKnot = knots.length - 1 - startKnot;
      for (let i2 = 0; i2 < degree; ++i2) {
        controlPoints.push(controlPoints[i2]);
      }
    }
    const curve = new NURBSCurve(degree, knots, controlPoints, startKnot, endKnot);
    const points = curve.getPoints(controlPoints.length * 12);
    return new BufferGeometry2().setFromPoints(points);
  }
};
var AnimationParser = class {
  // take raw animation clips and turn them into three.js animation clips
  parse() {
    const animationClips = [];
    const rawClips = this.parseClips();
    if (rawClips !== void 0) {
      for (const key in rawClips) {
        const rawClip = rawClips[key];
        const clip = this.addClip(rawClip);
        animationClips.push(clip);
      }
    }
    return animationClips;
  }
  parseClips() {
    if (fbxTree.Objects.AnimationCurve === void 0) return void 0;
    const curveNodesMap = this.parseAnimationCurveNodes();
    this.parseAnimationCurves(curveNodesMap);
    const layersMap = this.parseAnimationLayers(curveNodesMap);
    const rawClips = this.parseAnimStacks(layersMap);
    return rawClips;
  }
  // parse nodes in FBXTree.Objects.AnimationCurveNode
  // each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )
  // and is referenced by an AnimationLayer
  parseAnimationCurveNodes() {
    const rawCurveNodes = fbxTree.Objects.AnimationCurveNode;
    const curveNodesMap = /* @__PURE__ */ new Map();
    for (const nodeID in rawCurveNodes) {
      const rawCurveNode = rawCurveNodes[nodeID];
      if (rawCurveNode.attrName.match(/S|R|T|DeformPercent/) !== null) {
        const curveNode = {
          id: rawCurveNode.id,
          attr: rawCurveNode.attrName,
          curves: {}
        };
        curveNodesMap.set(curveNode.id, curveNode);
      }
    }
    return curveNodesMap;
  }
  // parse nodes in FBXTree.Objects.AnimationCurve and connect them up to
  // previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated
  // axis ( e.g. times and values of x rotation)
  parseAnimationCurves(curveNodesMap) {
    const rawCurves = fbxTree.Objects.AnimationCurve;
    for (const nodeID in rawCurves) {
      const animationCurve = {
        id: rawCurves[nodeID].id,
        times: rawCurves[nodeID].KeyTime.a.map(convertFBXTimeToSeconds),
        values: rawCurves[nodeID].KeyValueFloat.a
      };
      const relationships = connections.get(animationCurve.id);
      if (relationships !== void 0) {
        const animationCurveID = relationships.parents[0].ID;
        const animationCurveRelationship = relationships.parents[0].relationship;
        if (animationCurveRelationship.match(/X/)) {
          curveNodesMap.get(animationCurveID).curves["x"] = animationCurve;
        } else if (animationCurveRelationship.match(/Y/)) {
          curveNodesMap.get(animationCurveID).curves["y"] = animationCurve;
        } else if (animationCurveRelationship.match(/Z/)) {
          curveNodesMap.get(animationCurveID).curves["z"] = animationCurve;
        } else if (animationCurveRelationship.match(/DeformPercent/) && curveNodesMap.has(animationCurveID)) {
          curveNodesMap.get(animationCurveID).curves["morph"] = animationCurve;
        }
      }
    }
  }
  // parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references
  // to various AnimationCurveNodes and is referenced by an AnimationStack node
  // note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack
  parseAnimationLayers(curveNodesMap) {
    const rawLayers = fbxTree.Objects.AnimationLayer;
    const layersMap = /* @__PURE__ */ new Map();
    for (const nodeID in rawLayers) {
      const layerCurveNodes = [];
      const connection = connections.get(parseInt(nodeID));
      if (connection !== void 0) {
        const children2 = connection.children;
        children2.forEach(function(child, i2) {
          if (curveNodesMap.has(child.ID)) {
            const curveNode = curveNodesMap.get(child.ID);
            if (curveNode.curves.x !== void 0 || curveNode.curves.y !== void 0 || curveNode.curves.z !== void 0) {
              if (layerCurveNodes[i2] === void 0) {
                const modelID = connections.get(child.ID).parents.filter(function(parent2) {
                  return parent2.relationship !== void 0;
                })[0].ID;
                if (modelID !== void 0) {
                  const rawModel = fbxTree.Objects.Model[modelID.toString()];
                  if (rawModel === void 0) {
                    console.warn("THREE.FBXLoader: Encountered a unused curve.", child);
                    return;
                  }
                  const node = {
                    modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName(rawModel.attrName) : "",
                    ID: rawModel.id,
                    initialPosition: [0, 0, 0],
                    initialRotation: [0, 0, 0],
                    initialScale: [1, 1, 1]
                  };
                  sceneGraph.traverse(function(child2) {
                    if (child2.ID === rawModel.id) {
                      node.transform = child2.matrix;
                      if (child2.userData.transformData) node.eulerOrder = child2.userData.transformData.eulerOrder;
                    }
                  });
                  if (!node.transform) node.transform = new Matrix42();
                  if ("PreRotation" in rawModel) node.preRotation = rawModel.PreRotation.value;
                  if ("PostRotation" in rawModel) node.postRotation = rawModel.PostRotation.value;
                  layerCurveNodes[i2] = node;
                }
              }
              if (layerCurveNodes[i2]) layerCurveNodes[i2][curveNode.attr] = curveNode;
            } else if (curveNode.curves.morph !== void 0) {
              if (layerCurveNodes[i2] === void 0) {
                const deformerID = connections.get(child.ID).parents.filter(function(parent2) {
                  return parent2.relationship !== void 0;
                })[0].ID;
                const morpherID = connections.get(deformerID).parents[0].ID;
                const geoID = connections.get(morpherID).parents[0].ID;
                const modelID = connections.get(geoID).parents[0].ID;
                const rawModel = fbxTree.Objects.Model[modelID];
                const node = {
                  modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName(rawModel.attrName) : "",
                  morphName: fbxTree.Objects.Deformer[deformerID].attrName
                };
                layerCurveNodes[i2] = node;
              }
              layerCurveNodes[i2][curveNode.attr] = curveNode;
            }
          }
        });
        layersMap.set(parseInt(nodeID), layerCurveNodes);
      }
    }
    return layersMap;
  }
  // parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation
  // hierarchy. Each Stack node will be used to create a AnimationClip
  parseAnimStacks(layersMap) {
    const rawStacks = fbxTree.Objects.AnimationStack;
    const rawClips = {};
    for (const nodeID in rawStacks) {
      const children2 = connections.get(parseInt(nodeID)).children;
      if (children2.length > 1) {
        console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");
      }
      const layer = layersMap.get(children2[0].ID);
      rawClips[nodeID] = {
        name: rawStacks[nodeID].attrName,
        layer
      };
    }
    return rawClips;
  }
  addClip(rawClip) {
    let tracks = [];
    const scope = this;
    rawClip.layer.forEach(function(rawTracks) {
      tracks = tracks.concat(scope.generateTracks(rawTracks));
    });
    return new AnimationClip(rawClip.name, -1, tracks);
  }
  generateTracks(rawTracks) {
    const tracks = [];
    let initialPosition = new Vector32();
    let initialScale = new Vector32();
    if (rawTracks.transform) rawTracks.transform.decompose(initialPosition, new Quaternion2(), initialScale);
    initialPosition = initialPosition.toArray();
    initialScale = initialScale.toArray();
    if (rawTracks.T !== void 0 && Object.keys(rawTracks.T.curves).length > 0) {
      const positionTrack = this.generateVectorTrack(rawTracks.modelName, rawTracks.T.curves, initialPosition, "position");
      if (positionTrack !== void 0) tracks.push(positionTrack);
    }
    if (rawTracks.R !== void 0 && Object.keys(rawTracks.R.curves).length > 0) {
      const rotationTrack = this.generateRotationTrack(rawTracks.modelName, rawTracks.R.curves, rawTracks.preRotation, rawTracks.postRotation, rawTracks.eulerOrder);
      if (rotationTrack !== void 0) tracks.push(rotationTrack);
    }
    if (rawTracks.S !== void 0 && Object.keys(rawTracks.S.curves).length > 0) {
      const scaleTrack = this.generateVectorTrack(rawTracks.modelName, rawTracks.S.curves, initialScale, "scale");
      if (scaleTrack !== void 0) tracks.push(scaleTrack);
    }
    if (rawTracks.DeformPercent !== void 0) {
      const morphTrack = this.generateMorphTrack(rawTracks);
      if (morphTrack !== void 0) tracks.push(morphTrack);
    }
    return tracks;
  }
  generateVectorTrack(modelName, curves, initialValue, type) {
    const times2 = this.getTimesForAllAxes(curves);
    const values2 = this.getKeyframeTrackValues(times2, curves, initialValue);
    return new VectorKeyframeTrack(modelName + "." + type, times2, values2);
  }
  generateRotationTrack(modelName, curves, preRotation, postRotation, eulerOrder) {
    let times2;
    let values2;
    if (curves.x !== void 0 && curves.y !== void 0 && curves.z !== void 0) {
      const result2 = this.interpolateRotations(curves.x, curves.y, curves.z, eulerOrder);
      times2 = result2[0];
      values2 = result2[1];
    }
    if (preRotation !== void 0) {
      preRotation = preRotation.map(MathUtils2.degToRad);
      preRotation.push(eulerOrder);
      preRotation = new Euler2().fromArray(preRotation);
      preRotation = new Quaternion2().setFromEuler(preRotation);
    }
    if (postRotation !== void 0) {
      postRotation = postRotation.map(MathUtils2.degToRad);
      postRotation.push(eulerOrder);
      postRotation = new Euler2().fromArray(postRotation);
      postRotation = new Quaternion2().setFromEuler(postRotation).invert();
    }
    const quaternion = new Quaternion2();
    const euler = new Euler2();
    const quaternionValues = [];
    if (!values2 || !times2) return new QuaternionKeyframeTrack(modelName + ".quaternion", [0], [0]);
    for (let i2 = 0; i2 < values2.length; i2 += 3) {
      euler.set(values2[i2], values2[i2 + 1], values2[i2 + 2], eulerOrder);
      quaternion.setFromEuler(euler);
      if (preRotation !== void 0) quaternion.premultiply(preRotation);
      if (postRotation !== void 0) quaternion.multiply(postRotation);
      if (i2 > 2) {
        const prevQuat = new Quaternion2().fromArray(
          quaternionValues,
          (i2 - 3) / 3 * 4
        );
        if (prevQuat.dot(quaternion) < 0) {
          quaternion.set(-quaternion.x, -quaternion.y, -quaternion.z, -quaternion.w);
        }
      }
      quaternion.toArray(quaternionValues, i2 / 3 * 4);
    }
    return new QuaternionKeyframeTrack(modelName + ".quaternion", times2, quaternionValues);
  }
  generateMorphTrack(rawTracks) {
    const curves = rawTracks.DeformPercent.curves.morph;
    const values2 = curves.values.map(function(val) {
      return val / 100;
    });
    const morphNum = sceneGraph.getObjectByName(rawTracks.modelName).morphTargetDictionary[rawTracks.morphName];
    return new NumberKeyframeTrack(rawTracks.modelName + ".morphTargetInfluences[" + morphNum + "]", curves.times, values2);
  }
  // For all animated objects, times are defined separately for each axis
  // Here we'll combine the times into one sorted array without duplicates
  getTimesForAllAxes(curves) {
    let times2 = [];
    if (curves.x !== void 0) times2 = times2.concat(curves.x.times);
    if (curves.y !== void 0) times2 = times2.concat(curves.y.times);
    if (curves.z !== void 0) times2 = times2.concat(curves.z.times);
    times2 = times2.sort(function(a3, b) {
      return a3 - b;
    });
    if (times2.length > 1) {
      let targetIndex = 1;
      let lastValue = times2[0];
      for (let i2 = 1; i2 < times2.length; i2++) {
        const currentValue = times2[i2];
        if (currentValue !== lastValue) {
          times2[targetIndex] = currentValue;
          lastValue = currentValue;
          targetIndex++;
        }
      }
      times2 = times2.slice(0, targetIndex);
    }
    return times2;
  }
  getKeyframeTrackValues(times2, curves, initialValue) {
    const prevValue = initialValue;
    const values2 = [];
    let xIndex = -1;
    let yIndex = -1;
    let zIndex = -1;
    times2.forEach(function(time3) {
      if (curves.x) xIndex = curves.x.times.indexOf(time3);
      if (curves.y) yIndex = curves.y.times.indexOf(time3);
      if (curves.z) zIndex = curves.z.times.indexOf(time3);
      if (xIndex !== -1) {
        const xValue = curves.x.values[xIndex];
        values2.push(xValue);
        prevValue[0] = xValue;
      } else {
        values2.push(prevValue[0]);
      }
      if (yIndex !== -1) {
        const yValue = curves.y.values[yIndex];
        values2.push(yValue);
        prevValue[1] = yValue;
      } else {
        values2.push(prevValue[1]);
      }
      if (zIndex !== -1) {
        const zValue = curves.z.values[zIndex];
        values2.push(zValue);
        prevValue[2] = zValue;
      } else {
        values2.push(prevValue[2]);
      }
    });
    return values2;
  }
  // Rotations are defined as Euler angles which can have values  of any size
  // These will be converted to quaternions which don't support values greater than
  // PI, so we'll interpolate large rotations
  interpolateRotations(curvex, curvey, curvez, eulerOrder) {
    const times2 = [];
    const values2 = [];
    times2.push(curvex.times[0]);
    values2.push(MathUtils2.degToRad(curvex.values[0]));
    values2.push(MathUtils2.degToRad(curvey.values[0]));
    values2.push(MathUtils2.degToRad(curvez.values[0]));
    for (let i2 = 1; i2 < curvex.values.length; i2++) {
      const initialValue = [
        curvex.values[i2 - 1],
        curvey.values[i2 - 1],
        curvez.values[i2 - 1]
      ];
      if (isNaN(initialValue[0]) || isNaN(initialValue[1]) || isNaN(initialValue[2])) {
        continue;
      }
      const initialValueRad = initialValue.map(MathUtils2.degToRad);
      const currentValue = [
        curvex.values[i2],
        curvey.values[i2],
        curvez.values[i2]
      ];
      if (isNaN(currentValue[0]) || isNaN(currentValue[1]) || isNaN(currentValue[2])) {
        continue;
      }
      const currentValueRad = currentValue.map(MathUtils2.degToRad);
      const valuesSpan = [
        currentValue[0] - initialValue[0],
        currentValue[1] - initialValue[1],
        currentValue[2] - initialValue[2]
      ];
      const absoluteSpan = [
        Math.abs(valuesSpan[0]),
        Math.abs(valuesSpan[1]),
        Math.abs(valuesSpan[2])
      ];
      if (absoluteSpan[0] >= 180 || absoluteSpan[1] >= 180 || absoluteSpan[2] >= 180) {
        const maxAbsSpan = Math.max(...absoluteSpan);
        const numSubIntervals = maxAbsSpan / 180;
        const E1 = new Euler2(...initialValueRad, eulerOrder);
        const E22 = new Euler2(...currentValueRad, eulerOrder);
        const Q1 = new Quaternion2().setFromEuler(E1);
        const Q2 = new Quaternion2().setFromEuler(E22);
        if (Q1.dot(Q2)) {
          Q2.set(-Q2.x, -Q2.y, -Q2.z, -Q2.w);
        }
        const initialTime = curvex.times[i2 - 1];
        const timeSpan = curvex.times[i2] - initialTime;
        const Q = new Quaternion2();
        const E3 = new Euler2();
        for (let t5 = 0; t5 < 1; t5 += 1 / numSubIntervals) {
          Q.copy(Q1.clone().slerp(Q2.clone(), t5));
          times2.push(initialTime + t5 * timeSpan);
          E3.setFromQuaternion(Q, eulerOrder);
          values2.push(E3.x);
          values2.push(E3.y);
          values2.push(E3.z);
        }
      } else {
        times2.push(curvex.times[i2]);
        values2.push(MathUtils2.degToRad(curvex.values[i2]));
        values2.push(MathUtils2.degToRad(curvey.values[i2]));
        values2.push(MathUtils2.degToRad(curvez.values[i2]));
      }
    }
    return [times2, values2];
  }
};
var TextParser = class {
  getPrevNode() {
    return this.nodeStack[this.currentIndent - 2];
  }
  getCurrentNode() {
    return this.nodeStack[this.currentIndent - 1];
  }
  getCurrentProp() {
    return this.currentProp;
  }
  pushStack(node) {
    this.nodeStack.push(node);
    this.currentIndent += 1;
  }
  popStack() {
    this.nodeStack.pop();
    this.currentIndent -= 1;
  }
  setCurrentProp(val, name) {
    this.currentProp = val;
    this.currentPropName = name;
  }
  parse(text) {
    this.currentIndent = 0;
    this.allNodes = new FBXTree();
    this.nodeStack = [];
    this.currentProp = [];
    this.currentPropName = "";
    const scope = this;
    const split3 = text.split(/[\r\n]+/);
    split3.forEach(function(line, i2) {
      const matchComment = line.match(/^[\s\t]*;/);
      const matchEmpty = line.match(/^[\s\t]*$/);
      if (matchComment || matchEmpty) return;
      const matchBeginning = line.match("^\\t{" + scope.currentIndent + "}(\\w+):(.*){", "");
      const matchProperty = line.match("^\\t{" + scope.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)");
      const matchEnd = line.match("^\\t{" + (scope.currentIndent - 1) + "}}");
      if (matchBeginning) {
        scope.parseNodeBegin(line, matchBeginning);
      } else if (matchProperty) {
        scope.parseNodeProperty(line, matchProperty, split3[++i2]);
      } else if (matchEnd) {
        scope.popStack();
      } else if (line.match(/^[^\s\t}]/)) {
        scope.parseNodePropertyContinued(line);
      }
    });
    return this.allNodes;
  }
  parseNodeBegin(line, property3) {
    const nodeName = property3[1].trim().replace(/^"/, "").replace(/"$/, "");
    const nodeAttrs = property3[2].split(",").map(function(attr) {
      return attr.trim().replace(/^"/, "").replace(/"$/, "");
    });
    const node = { name: nodeName };
    const attrs = this.parseNodeAttr(nodeAttrs);
    const currentNode = this.getCurrentNode();
    if (this.currentIndent === 0) {
      this.allNodes.add(nodeName, node);
    } else {
      if (nodeName in currentNode) {
        if (nodeName === "PoseNode") {
          currentNode.PoseNode.push(node);
        } else if (currentNode[nodeName].id !== void 0) {
          currentNode[nodeName] = {};
          currentNode[nodeName][currentNode[nodeName].id] = currentNode[nodeName];
        }
        if (attrs.id !== "") currentNode[nodeName][attrs.id] = node;
      } else if (typeof attrs.id === "number") {
        currentNode[nodeName] = {};
        currentNode[nodeName][attrs.id] = node;
      } else if (nodeName !== "Properties70") {
        if (nodeName === "PoseNode") currentNode[nodeName] = [node];
        else currentNode[nodeName] = node;
      }
    }
    if (typeof attrs.id === "number") node.id = attrs.id;
    if (attrs.name !== "") node.attrName = attrs.name;
    if (attrs.type !== "") node.attrType = attrs.type;
    this.pushStack(node);
  }
  parseNodeAttr(attrs) {
    let id2 = attrs[0];
    if (attrs[0] !== "") {
      id2 = parseInt(attrs[0]);
      if (isNaN(id2)) {
        id2 = attrs[0];
      }
    }
    let name = "", type = "";
    if (attrs.length > 1) {
      name = attrs[1].replace(/^(\w+)::/, "");
      type = attrs[2];
    }
    return { id: id2, name, type };
  }
  parseNodeProperty(line, property3, contentLine) {
    let propName = property3[1].replace(/^"/, "").replace(/"$/, "").trim();
    let propValue = property3[2].replace(/^"/, "").replace(/"$/, "").trim();
    if (propName === "Content" && propValue === ",") {
      propValue = contentLine.replace(/"/g, "").replace(/,$/, "").trim();
    }
    const currentNode = this.getCurrentNode();
    const parentName = currentNode.name;
    if (parentName === "Properties70") {
      this.parseNodeSpecialProperty(line, propName, propValue);
      return;
    }
    if (propName === "C") {
      const connProps = propValue.split(",").slice(1);
      const from = parseInt(connProps[0]);
      const to = parseInt(connProps[1]);
      let rest2 = propValue.split(",").slice(3);
      rest2 = rest2.map(function(elem) {
        return elem.trim().replace(/^"/, "");
      });
      propName = "connections";
      propValue = [from, to];
      append(propValue, rest2);
      if (currentNode[propName] === void 0) {
        currentNode[propName] = [];
      }
    }
    if (propName === "Node") currentNode.id = propValue;
    if (propName in currentNode && Array.isArray(currentNode[propName])) {
      currentNode[propName].push(propValue);
    } else {
      if (propName !== "a") currentNode[propName] = propValue;
      else currentNode.a = propValue;
    }
    this.setCurrentProp(currentNode, propName);
    if (propName === "a" && propValue.slice(-1) !== ",") {
      currentNode.a = parseNumberArray(propValue);
    }
  }
  parseNodePropertyContinued(line) {
    const currentNode = this.getCurrentNode();
    currentNode.a += line;
    if (line.slice(-1) !== ",") {
      currentNode.a = parseNumberArray(currentNode.a);
    }
  }
  // parse "Property70"
  parseNodeSpecialProperty(line, propName, propValue) {
    const props = propValue.split('",').map(function(prop) {
      return prop.trim().replace(/^\"/, "").replace(/\s/, "_");
    });
    const innerPropName = props[0];
    const innerPropType1 = props[1];
    const innerPropType2 = props[2];
    const innerPropFlag = props[3];
    let innerPropValue = props[4];
    switch (innerPropType1) {
      case "int":
      case "enum":
      case "bool":
      case "ULongLong":
      case "double":
      case "Number":
      case "FieldOfView":
        innerPropValue = parseFloat(innerPropValue);
        break;
      case "Color":
      case "ColorRGB":
      case "Vector3D":
      case "Lcl_Translation":
      case "Lcl_Rotation":
      case "Lcl_Scaling":
        innerPropValue = parseNumberArray(innerPropValue);
        break;
    }
    this.getPrevNode()[innerPropName] = {
      "type": innerPropType1,
      "type2": innerPropType2,
      "flag": innerPropFlag,
      "value": innerPropValue
    };
    this.setCurrentProp(this.getPrevNode(), innerPropName);
  }
};
var BinaryParser = class {
  parse(buffer2) {
    const reader = new BinaryReader(buffer2);
    reader.skip(23);
    const version = reader.getUint32();
    if (version < 6400) {
      throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + version);
    }
    const allNodes = new FBXTree();
    while (!this.endOfContent(reader)) {
      const node = this.parseNode(reader, version);
      if (node !== null) allNodes.add(node.name, node);
    }
    return allNodes;
  }
  // Check if reader has reached the end of content.
  endOfContent(reader) {
    if (reader.size() % 16 === 0) {
      return (reader.getOffset() + 160 + 16 & ~15) >= reader.size();
    } else {
      return reader.getOffset() + 160 + 16 >= reader.size();
    }
  }
  // recursively parse nodes until the end of the file is reached
  parseNode(reader, version) {
    const node = {};
    const endOffset = version >= 7500 ? reader.getUint64() : reader.getUint32();
    const numProperties = version >= 7500 ? reader.getUint64() : reader.getUint32();
    version >= 7500 ? reader.getUint64() : reader.getUint32();
    const nameLen = reader.getUint8();
    const name = reader.getString(nameLen);
    if (endOffset === 0) return null;
    const propertyList = [];
    for (let i2 = 0; i2 < numProperties; i2++) {
      propertyList.push(this.parseProperty(reader));
    }
    const id2 = propertyList.length > 0 ? propertyList[0] : "";
    const attrName = propertyList.length > 1 ? propertyList[1] : "";
    const attrType = propertyList.length > 2 ? propertyList[2] : "";
    node.singleProperty = numProperties === 1 && reader.getOffset() === endOffset ? true : false;
    while (endOffset > reader.getOffset()) {
      const subNode = this.parseNode(reader, version);
      if (subNode !== null) this.parseSubNode(name, node, subNode);
    }
    node.propertyList = propertyList;
    if (typeof id2 === "number") node.id = id2;
    if (attrName !== "") node.attrName = attrName;
    if (attrType !== "") node.attrType = attrType;
    if (name !== "") node.name = name;
    return node;
  }
  parseSubNode(name, node, subNode) {
    if (subNode.singleProperty === true) {
      const value = subNode.propertyList[0];
      if (Array.isArray(value)) {
        node[subNode.name] = subNode;
        subNode.a = value;
      } else {
        node[subNode.name] = value;
      }
    } else if (name === "Connections" && subNode.name === "C") {
      const array4 = [];
      subNode.propertyList.forEach(function(property3, i2) {
        if (i2 !== 0) array4.push(property3);
      });
      if (node.connections === void 0) {
        node.connections = [];
      }
      node.connections.push(array4);
    } else if (subNode.name === "Properties70") {
      const keys2 = Object.keys(subNode);
      keys2.forEach(function(key) {
        node[key] = subNode[key];
      });
    } else if (name === "Properties70" && subNode.name === "P") {
      let innerPropName = subNode.propertyList[0];
      let innerPropType1 = subNode.propertyList[1];
      const innerPropType2 = subNode.propertyList[2];
      const innerPropFlag = subNode.propertyList[3];
      let innerPropValue;
      if (innerPropName.indexOf("Lcl ") === 0) innerPropName = innerPropName.replace("Lcl ", "Lcl_");
      if (innerPropType1.indexOf("Lcl ") === 0) innerPropType1 = innerPropType1.replace("Lcl ", "Lcl_");
      if (innerPropType1 === "Color" || innerPropType1 === "ColorRGB" || innerPropType1 === "Vector" || innerPropType1 === "Vector3D" || innerPropType1.indexOf("Lcl_") === 0) {
        innerPropValue = [
          subNode.propertyList[4],
          subNode.propertyList[5],
          subNode.propertyList[6]
        ];
      } else {
        innerPropValue = subNode.propertyList[4];
      }
      node[innerPropName] = {
        "type": innerPropType1,
        "type2": innerPropType2,
        "flag": innerPropFlag,
        "value": innerPropValue
      };
    } else if (node[subNode.name] === void 0) {
      if (typeof subNode.id === "number") {
        node[subNode.name] = {};
        node[subNode.name][subNode.id] = subNode;
      } else {
        node[subNode.name] = subNode;
      }
    } else {
      if (subNode.name === "PoseNode") {
        if (!Array.isArray(node[subNode.name])) {
          node[subNode.name] = [node[subNode.name]];
        }
        node[subNode.name].push(subNode);
      } else if (node[subNode.name][subNode.id] === void 0) {
        node[subNode.name][subNode.id] = subNode;
      }
    }
  }
  parseProperty(reader) {
    const type = reader.getString(1);
    let length2;
    switch (type) {
      case "C":
        return reader.getBoolean();
      case "D":
        return reader.getFloat64();
      case "F":
        return reader.getFloat32();
      case "I":
        return reader.getInt32();
      case "L":
        return reader.getInt64();
      case "R":
        length2 = reader.getUint32();
        return reader.getArrayBuffer(length2);
      case "S":
        length2 = reader.getUint32();
        return reader.getString(length2);
      case "Y":
        return reader.getInt16();
      case "b":
      case "c":
      case "d":
      case "f":
      case "i":
      case "l":
        const arrayLength = reader.getUint32();
        const encoding = reader.getUint32();
        const compressedLength = reader.getUint32();
        if (encoding === 0) {
          switch (type) {
            case "b":
            case "c":
              return reader.getBooleanArray(arrayLength);
            case "d":
              return reader.getFloat64Array(arrayLength);
            case "f":
              return reader.getFloat32Array(arrayLength);
            case "i":
              return reader.getInt32Array(arrayLength);
            case "l":
              return reader.getInt64Array(arrayLength);
          }
        }
        const data = unzlibSync(new Uint8Array(reader.getArrayBuffer(compressedLength)));
        const reader2 = new BinaryReader(data.buffer);
        switch (type) {
          case "b":
          case "c":
            return reader2.getBooleanArray(arrayLength);
          case "d":
            return reader2.getFloat64Array(arrayLength);
          case "f":
            return reader2.getFloat32Array(arrayLength);
          case "i":
            return reader2.getInt32Array(arrayLength);
          case "l":
            return reader2.getInt64Array(arrayLength);
        }
        break;
      // cannot happen but is required by the DeepScan
      default:
        throw new Error("THREE.FBXLoader: Unknown property type " + type);
    }
  }
};
var BinaryReader = class {
  constructor(buffer2, littleEndian) {
    this.dv = new DataView(buffer2);
    this.offset = 0;
    this.littleEndian = littleEndian !== void 0 ? littleEndian : true;
    this._textDecoder = new TextDecoder();
  }
  getOffset() {
    return this.offset;
  }
  size() {
    return this.dv.buffer.byteLength;
  }
  skip(length2) {
    this.offset += length2;
  }
  // seems like true/false representation depends on exporter.
  // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)
  // then sees LSB.
  getBoolean() {
    return (this.getUint8() & 1) === 1;
  }
  getBooleanArray(size2) {
    const a3 = [];
    for (let i2 = 0; i2 < size2; i2++) {
      a3.push(this.getBoolean());
    }
    return a3;
  }
  getUint8() {
    const value = this.dv.getUint8(this.offset);
    this.offset += 1;
    return value;
  }
  getInt16() {
    const value = this.dv.getInt16(this.offset, this.littleEndian);
    this.offset += 2;
    return value;
  }
  getInt32() {
    const value = this.dv.getInt32(this.offset, this.littleEndian);
    this.offset += 4;
    return value;
  }
  getInt32Array(size2) {
    const a3 = [];
    for (let i2 = 0; i2 < size2; i2++) {
      a3.push(this.getInt32());
    }
    return a3;
  }
  getUint32() {
    const value = this.dv.getUint32(this.offset, this.littleEndian);
    this.offset += 4;
    return value;
  }
  // JavaScript doesn't support 64-bit integer so calculate this here
  // 1 << 32 will return 1 so using multiply operation instead here.
  // There's a possibility that this method returns wrong value if the value
  // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.
  // TODO: safely handle 64-bit integer
  getInt64() {
    let low, high;
    if (this.littleEndian) {
      low = this.getUint32();
      high = this.getUint32();
    } else {
      high = this.getUint32();
      low = this.getUint32();
    }
    if (high & 2147483648) {
      high = ~high & 4294967295;
      low = ~low & 4294967295;
      if (low === 4294967295) high = high + 1 & 4294967295;
      low = low + 1 & 4294967295;
      return -(high * 4294967296 + low);
    }
    return high * 4294967296 + low;
  }
  getInt64Array(size2) {
    const a3 = [];
    for (let i2 = 0; i2 < size2; i2++) {
      a3.push(this.getInt64());
    }
    return a3;
  }
  // Note: see getInt64() comment
  getUint64() {
    let low, high;
    if (this.littleEndian) {
      low = this.getUint32();
      high = this.getUint32();
    } else {
      high = this.getUint32();
      low = this.getUint32();
    }
    return high * 4294967296 + low;
  }
  getFloat32() {
    const value = this.dv.getFloat32(this.offset, this.littleEndian);
    this.offset += 4;
    return value;
  }
  getFloat32Array(size2) {
    const a3 = [];
    for (let i2 = 0; i2 < size2; i2++) {
      a3.push(this.getFloat32());
    }
    return a3;
  }
  getFloat64() {
    const value = this.dv.getFloat64(this.offset, this.littleEndian);
    this.offset += 8;
    return value;
  }
  getFloat64Array(size2) {
    const a3 = [];
    for (let i2 = 0; i2 < size2; i2++) {
      a3.push(this.getFloat64());
    }
    return a3;
  }
  getArrayBuffer(size2) {
    const value = this.dv.buffer.slice(this.offset, this.offset + size2);
    this.offset += size2;
    return value;
  }
  getString(size2) {
    const start2 = this.offset;
    let a3 = new Uint8Array(this.dv.buffer, start2, size2);
    this.skip(size2);
    const nullByte = a3.indexOf(0);
    if (nullByte >= 0) a3 = new Uint8Array(this.dv.buffer, start2, nullByte);
    return this._textDecoder.decode(a3);
  }
};
var FBXTree = class {
  add(key, val) {
    this[key] = val;
  }
};
function isFbxFormatBinary(buffer2) {
  const CORRECT = "Kaydara FBX Binary  \0";
  return buffer2.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString(buffer2, 0, CORRECT.length);
}
function isFbxFormatASCII(text) {
  const CORRECT = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"];
  let cursor = 0;
  function read(offset) {
    const result2 = text[offset - 1];
    text = text.slice(cursor + offset);
    cursor++;
    return result2;
  }
  for (let i2 = 0; i2 < CORRECT.length; ++i2) {
    const num = read(1);
    if (num === CORRECT[i2]) {
      return false;
    }
  }
  return true;
}
function getFbxVersion(text) {
  const versionRegExp = /FBXVersion: (\d+)/;
  const match = text.match(versionRegExp);
  if (match) {
    const version = parseInt(match[1]);
    return version;
  }
  throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.");
}
function convertFBXTimeToSeconds(time3) {
  return time3 / 46186158e3;
}
var dataArray = [];
function getData(polygonVertexIndex, polygonIndex, vertexIndex2, infoObject) {
  let index8;
  switch (infoObject.mappingType) {
    case "ByPolygonVertex":
      index8 = polygonVertexIndex;
      break;
    case "ByPolygon":
      index8 = polygonIndex;
      break;
    case "ByVertice":
      index8 = vertexIndex2;
      break;
    case "AllSame":
      index8 = infoObject.indices[0];
      break;
    default:
      console.warn("THREE.FBXLoader: unknown attribute mapping type " + infoObject.mappingType);
  }
  if (infoObject.referenceType === "IndexToDirect") index8 = infoObject.indices[index8];
  const from = index8 * infoObject.dataSize;
  const to = from + infoObject.dataSize;
  return slice(dataArray, infoObject.buffer, from, to);
}
var tempEuler = new Euler2();
var tempVec = new Vector32();
function generateTransform(transformData) {
  const lTranslationM = new Matrix42();
  const lPreRotationM = new Matrix42();
  const lRotationM = new Matrix42();
  const lPostRotationM = new Matrix42();
  const lScalingM = new Matrix42();
  const lScalingPivotM = new Matrix42();
  const lScalingOffsetM = new Matrix42();
  const lRotationOffsetM = new Matrix42();
  const lRotationPivotM = new Matrix42();
  const lParentGX = new Matrix42();
  const lParentLX = new Matrix42();
  const lGlobalT = new Matrix42();
  const inheritType = transformData.inheritType ? transformData.inheritType : 0;
  if (transformData.translation) lTranslationM.setPosition(tempVec.fromArray(transformData.translation));
  if (transformData.preRotation) {
    const array4 = transformData.preRotation.map(MathUtils2.degToRad);
    array4.push(transformData.eulerOrder || Euler2.DEFAULT_ORDER);
    lPreRotationM.makeRotationFromEuler(tempEuler.fromArray(array4));
  }
  if (transformData.rotation) {
    const array4 = transformData.rotation.map(MathUtils2.degToRad);
    array4.push(transformData.eulerOrder || Euler2.DEFAULT_ORDER);
    lRotationM.makeRotationFromEuler(tempEuler.fromArray(array4));
  }
  if (transformData.postRotation) {
    const array4 = transformData.postRotation.map(MathUtils2.degToRad);
    array4.push(transformData.eulerOrder || Euler2.DEFAULT_ORDER);
    lPostRotationM.makeRotationFromEuler(tempEuler.fromArray(array4));
    lPostRotationM.invert();
  }
  if (transformData.scale) lScalingM.scale(tempVec.fromArray(transformData.scale));
  if (transformData.scalingOffset) lScalingOffsetM.setPosition(tempVec.fromArray(transformData.scalingOffset));
  if (transformData.scalingPivot) lScalingPivotM.setPosition(tempVec.fromArray(transformData.scalingPivot));
  if (transformData.rotationOffset) lRotationOffsetM.setPosition(tempVec.fromArray(transformData.rotationOffset));
  if (transformData.rotationPivot) lRotationPivotM.setPosition(tempVec.fromArray(transformData.rotationPivot));
  if (transformData.parentMatrixWorld) {
    lParentLX.copy(transformData.parentMatrix);
    lParentGX.copy(transformData.parentMatrixWorld);
  }
  const lLRM = lPreRotationM.clone().multiply(lRotationM).multiply(lPostRotationM);
  const lParentGRM = new Matrix42();
  lParentGRM.extractRotation(lParentGX);
  const lParentTM = new Matrix42();
  lParentTM.copyPosition(lParentGX);
  const lParentGRSM = lParentTM.clone().invert().multiply(lParentGX);
  const lParentGSM = lParentGRM.clone().invert().multiply(lParentGRSM);
  const lLSM = lScalingM;
  const lGlobalRS = new Matrix42();
  if (inheritType === 0) {
    lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM).multiply(lLSM);
  } else if (inheritType === 1) {
    lGlobalRS.copy(lParentGRM).multiply(lParentGSM).multiply(lLRM).multiply(lLSM);
  } else {
    const lParentLSM = new Matrix42().scale(new Vector32().setFromMatrixScale(lParentLX));
    const lParentLSM_inv = lParentLSM.clone().invert();
    const lParentGSM_noLocal = lParentGSM.clone().multiply(lParentLSM_inv);
    lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM_noLocal).multiply(lLSM);
  }
  const lRotationPivotM_inv = lRotationPivotM.clone().invert();
  const lScalingPivotM_inv = lScalingPivotM.clone().invert();
  let lTransform = lTranslationM.clone().multiply(lRotationOffsetM).multiply(lRotationPivotM).multiply(lPreRotationM).multiply(lRotationM).multiply(lPostRotationM).multiply(lRotationPivotM_inv).multiply(lScalingOffsetM).multiply(lScalingPivotM).multiply(lScalingM).multiply(lScalingPivotM_inv);
  const lLocalTWithAllPivotAndOffsetInfo = new Matrix42().copyPosition(lTransform);
  const lGlobalTranslation = lParentGX.clone().multiply(lLocalTWithAllPivotAndOffsetInfo);
  lGlobalT.copyPosition(lGlobalTranslation);
  lTransform = lGlobalT.clone().multiply(lGlobalRS);
  lTransform.premultiply(lParentGX.invert());
  return lTransform;
}
function getEulerOrder(order) {
  order = order || 0;
  const enums = [
    "ZYX",
    // -> XYZ extrinsic
    "YZX",
    // -> XZY extrinsic
    "XZY",
    // -> YZX extrinsic
    "ZXY",
    // -> YXZ extrinsic
    "YXZ",
    // -> ZXY extrinsic
    "XYZ"
    // -> ZYX extrinsic
    //'SphericXYZ', // not possible to support
  ];
  if (order === 6) {
    console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.");
    return enums[0];
  }
  return enums[order];
}
function parseNumberArray(value) {
  const array4 = value.split(",").map(function(val) {
    return parseFloat(val);
  });
  return array4;
}
function convertArrayBufferToString(buffer2, from, to) {
  if (from === void 0) from = 0;
  if (to === void 0) to = buffer2.byteLength;
  return new TextDecoder().decode(new Uint8Array(buffer2, from, to));
}
function append(a3, b) {
  for (let i2 = 0, j2 = a3.length, l2 = b.length; i2 < l2; i2++, j2++) {
    a3[j2] = b[i2];
  }
}
function slice(a3, b, from, to) {
  for (let i2 = from, j2 = 0; i2 < to; i2++, j2++) {
    a3[j2] = b[i2];
  }
  return a3;
}

// node_modules/aframe-extras/src/loaders/fbx-model.js
THREE.FBXLoader = FBXLoader;
AFRAME.registerComponent("fbx-model", {
  schema: {
    src: { type: "asset" },
    crossorigin: { default: "" }
  },
  init: function() {
    this.model = null;
  },
  update: function() {
    const data = this.data;
    if (!data.src) return;
    this.remove();
    const loader = new THREE.FBXLoader();
    if (data.crossorigin) loader.setCrossOrigin(data.crossorigin);
    loader.load(data.src, this.load.bind(this));
  },
  load: function(model) {
    this.model = model;
    this.el.setObject3D("mesh", model);
    this.el.emit("model-loaded", { format: "fbx", model });
  },
  remove: function() {
    if (this.model) this.el.removeObject3D("mesh");
  }
});

// node_modules/aframe-extras/src/loaders/object-model.js
AFRAME.registerComponent("object-model", {
  schema: {
    src: { type: "asset" },
    crossorigin: { default: "" }
  },
  init: function() {
    this.model = null;
  },
  update: function() {
    let loader;
    const data = this.data;
    if (!data.src) return;
    this.remove();
    loader = new THREE.ObjectLoader();
    if (data.crossorigin) loader.setCrossOrigin(data.crossorigin);
    loader.load(data.src, (object) => {
      object.traverse((o2) => {
        if (o2 instanceof THREE.SkinnedMesh && o2.material) {
          o2.material.skinning = !!(o2.geometry && o2.geometry.bones || []).length;
        }
      });
      this.load(object);
    });
  },
  load: function(model) {
    this.model = model;
    this.el.setObject3D("mesh", model);
    this.el.emit("model-loaded", { format: "json", model });
  },
  remove: function() {
    if (this.model) this.el.removeObject3D("mesh");
  }
});

// node_modules/aframe-extras/src/misc/checkpoint.js
AFRAME.registerComponent("checkpoint", {
  schema: {
    offset: { default: { x: 0, y: 0, z: 0 }, type: "vec3" }
  },
  init: function() {
    this.active = false;
    this.targetEl = null;
    this.fire = this.fire.bind(this);
    this.offset = new THREE.Vector3();
  },
  update: function() {
    this.offset.copy(this.data.offset);
  },
  play: function() {
    this.el.addEventListener("click", this.fire);
  },
  pause: function() {
    this.el.removeEventListener("click", this.fire);
  },
  remove: function() {
    this.pause();
  },
  fire: function() {
    const targetEl = this.el.sceneEl.querySelector("[checkpoint-controls]");
    if (!targetEl) {
      throw new Error("No `checkpoint-controls` component found.");
    }
    targetEl.components["checkpoint-controls"].setCheckpoint(this.el);
  },
  getOffset: function() {
    return this.offset.copy(this.data.offset);
  }
});

// node_modules/aframe-extras/src/misc/cube-env-map.js
function ensureMaterialArray(material) {
  if (!material) {
    return [];
  } else if (Array.isArray(material)) {
    return material;
  } else if (material.materials) {
    return material.materials;
  } else {
    return [material];
  }
}
function applyEnvMap(mesh, materialNames, envMap, reflectivity) {
  if (!mesh) return;
  materialNames = materialNames || [];
  mesh.traverse((node) => {
    if (!node.isMesh) return;
    const meshMaterials = ensureMaterialArray(node.material);
    meshMaterials.forEach((material) => {
      if (material && !("envMap" in material)) return;
      if (materialNames.length && materialNames.indexOf(material.name) === -1) return;
      material.envMap = envMap;
      material.reflectivity = reflectivity;
      material.needsUpdate = true;
    });
  });
}
AFRAME.registerComponent("cube-env-map", {
  multiple: true,
  schema: {
    path: { default: "" },
    extension: { default: "jpg", oneOf: ["jpg", "png"] },
    enableBackground: { default: false },
    reflectivity: { default: 1, min: 0, max: 1 },
    materials: { default: [] }
  },
  init: function() {
    const data = this.data;
    this.texture = new THREE.CubeTextureLoader().load([
      data.path + "posx." + data.extension,
      data.path + "negx." + data.extension,
      data.path + "posy." + data.extension,
      data.path + "negy." + data.extension,
      data.path + "posz." + data.extension,
      data.path + "negz." + data.extension
    ]);
    this.texture.format = THREE.RGBAFormat;
    this.object3dsetHandler = () => {
      const mesh = this.el.getObject3D("mesh");
      const data2 = this.data;
      applyEnvMap(mesh, data2.materials, this.texture, data2.reflectivity);
    };
    this.object3dsetHandler();
    this.el.addEventListener("object3dset", this.object3dsetHandler);
  },
  update: function(oldData) {
    const data = this.data;
    const mesh = this.el.getObject3D("mesh");
    let addedMaterialNames = [];
    let removedMaterialNames = [];
    if (data.materials.length) {
      if (oldData.materials) {
        addedMaterialNames = data.materials.filter((name) => !oldData.materials.includes(name));
        removedMaterialNames = oldData.materials.filter((name) => !data.materials.includes(name));
      } else {
        addedMaterialNames = data.materials;
      }
    }
    if (addedMaterialNames.length) {
      applyEnvMap(mesh, addedMaterialNames, this.texture, data.reflectivity);
    }
    if (removedMaterialNames.length) {
      applyEnvMap(mesh, removedMaterialNames, null, 1);
    }
    if (oldData.materials && data.reflectivity !== oldData.reflectivity) {
      const maintainedMaterialNames = data.materials.filter((name) => oldData.materials.includes(name));
      if (maintainedMaterialNames.length) {
        applyEnvMap(mesh, maintainedMaterialNames, this.texture, data.reflectivity);
      }
    }
    if (this.data.enableBackground && !oldData.enableBackground) {
      this.setBackground(this.texture);
    } else if (!this.data.enableBackground && oldData.enableBackground) {
      this.setBackground(null);
    }
  },
  remove: function() {
    this.el.removeEventListener("object3dset", this.object3dsetHandler);
    const mesh = this.el.getObject3D("mesh");
    const data = this.data;
    applyEnvMap(mesh, data.materials, null, 1);
    if (data.enableBackground) this.setBackground(null);
  },
  setBackground: function(texture2) {
    this.el.sceneEl.object3D.background = texture2;
  }
});

// node_modules/aframe-extras/src/misc/grab.js
AFRAME.registerComponent("grab", {
  init: function() {
    this.system = this.el.sceneEl.systems.physics;
    this.GRABBED_STATE = "grabbed";
    this.grabbing = false;
    this.hitEl = /** @type {AFRAME.Element}    */
    null;
    this.physics = /** @type {AFRAME.System}     */
    this.el.sceneEl.systems.physics;
    this.constraint = /** @type {CANNON.Constraint} */
    null;
    this.onHit = this.onHit.bind(this);
    this.onGripOpen = this.onGripOpen.bind(this);
    this.onGripClose = this.onGripClose.bind(this);
  },
  play: function() {
    const el = this.el;
    el.addEventListener("hit", this.onHit);
    el.addEventListener("gripdown", this.onGripClose);
    el.addEventListener("gripup", this.onGripOpen);
    el.addEventListener("trackpaddown", this.onGripClose);
    el.addEventListener("trackpadup", this.onGripOpen);
    el.addEventListener("triggerdown", this.onGripClose);
    el.addEventListener("triggerup", this.onGripOpen);
  },
  pause: function() {
    const el = this.el;
    el.removeEventListener("hit", this.onHit);
    el.removeEventListener("gripdown", this.onGripClose);
    el.removeEventListener("gripup", this.onGripOpen);
    el.removeEventListener("trackpaddown", this.onGripClose);
    el.removeEventListener("trackpadup", this.onGripOpen);
    el.removeEventListener("triggerdown", this.onGripClose);
    el.removeEventListener("triggerup", this.onGripOpen);
  },
  onGripClose: function() {
    this.grabbing = true;
  },
  onGripOpen: function() {
    const hitEl = this.hitEl;
    this.grabbing = false;
    if (!hitEl) {
      return;
    }
    hitEl.removeState(this.GRABBED_STATE);
    this.hitEl = void 0;
    this.system.removeConstraint(this.constraint);
    this.constraint = null;
  },
  onHit: function(evt) {
    const hitEl = evt.detail.el;
    if (hitEl.is(this.GRABBED_STATE) || !this.grabbing || this.hitEl) {
      return;
    }
    hitEl.addState(this.GRABBED_STATE);
    this.hitEl = hitEl;
    this.constraint = new CANNON.LockConstraint(this.el.body, hitEl.body);
    this.system.addConstraint(this.constraint);
  }
});

// node_modules/aframe-extras/src/misc/normal-material.js
AFRAME.registerComponent("normal-material", {
  init: function() {
    this.material = new THREE.MeshNormalMaterial({ flatShading: true });
    this.applyMaterial = this.applyMaterial.bind(this);
    this.el.addEventListener("object3dset", this.applyMaterial);
    this.applyMaterial();
  },
  remove: function() {
    this.el.removeEventListener("object3dset", this.applyMaterial);
  },
  applyMaterial: function() {
    this.el.object3D.traverse((node) => {
      if (node.isMesh) node.material = this.material;
    });
  }
});

// node_modules/aframe-extras/src/misc/sphere-collider.js
AFRAME.registerComponent("sphere-collider", {
  schema: {
    enabled: { default: true },
    interval: { default: 80 },
    objects: { default: "" },
    state: { default: "collided" },
    radius: { default: 0.05 },
    watch: { default: true }
  },
  init: function() {
    this.observer = null;
    this.els = [];
    this.collisions = [];
    this.prevCheckTime = void 0;
    this.eventDetail = {};
    this.handleHit = this.handleHit.bind(this);
    this.handleHitEnd = this.handleHitEnd.bind(this);
  },
  play: function() {
    const sceneEl = this.el.sceneEl;
    if (this.data.watch) {
      this.observer = new MutationObserver(this.update.bind(this, null));
      this.observer.observe(sceneEl, { childList: true, subtree: true });
    }
  },
  pause: function() {
    if (this.observer) {
      this.observer.disconnect();
      this.observer = null;
    }
  },
  /**
   * Update list of entities to test for collision.
   */
  update: function() {
    const data = this.data;
    let objectEls;
    if (data.objects) {
      objectEls = this.el.sceneEl.querySelectorAll(data.objects);
    } else {
      objectEls = this.el.sceneEl.children;
    }
    this.els = Array.prototype.slice.call(objectEls);
  },
  tick: (function() {
    const position = new THREE.Vector3(), meshPosition = new THREE.Vector3(), colliderScale = new THREE.Vector3(), size2 = new THREE.Vector3(), box = new THREE.Box3(), collisions = [], distanceMap = /* @__PURE__ */ new Map();
    return function(time3) {
      if (!this.data.enabled) {
        return;
      }
      const prevCheckTime = this.prevCheckTime;
      if (prevCheckTime && time3 - prevCheckTime < this.data.interval) {
        return;
      }
      this.prevCheckTime = time3;
      const el = this.el, data = this.data, mesh = el.getObject3D("mesh");
      let colliderRadius;
      if (!mesh) {
        return;
      }
      collisions.length = 0;
      distanceMap.clear();
      el.object3D.getWorldPosition(position);
      el.object3D.getWorldScale(colliderScale);
      colliderRadius = data.radius * scaleFactor(colliderScale);
      this.els.forEach(intersect);
      collisions.sort((a3, b) => distanceMap.get(a3) > distanceMap.get(b) ? 1 : -1).forEach(this.handleHit);
      this.collisions.filter((el2) => !distanceMap.has(el2)).forEach(this.handleHitEnd);
      copyArray(this.collisions, collisions);
      function intersect(el2) {
        let radius, mesh2, distance4, extent2;
        if (!el2.isEntity) {
          return;
        }
        mesh2 = el2.getObject3D("mesh");
        if (!mesh2) {
          return;
        }
        box.setFromObject(mesh2).getSize(size2);
        extent2 = Math.max(size2.x, size2.y, size2.z) / 2;
        radius = Math.sqrt(2 * extent2 * extent2);
        box.getCenter(meshPosition);
        if (!radius) {
          return;
        }
        distance4 = position.distanceTo(meshPosition);
        if (distance4 < radius + colliderRadius) {
          collisions.push(el2);
          distanceMap.set(el2, distance4);
        }
      }
      function scaleFactor(scaleVec) {
        return Math.max(scaleVec.x, scaleVec.y, scaleVec.z);
      }
    };
  })(),
  handleHit: function(targetEl) {
    targetEl.emit("hit");
    targetEl.addState(this.data.state);
    this.eventDetail.el = targetEl;
    this.el.emit("hit", this.eventDetail);
  },
  handleHitEnd: function(targetEl) {
    targetEl.emit("hitend");
    targetEl.removeState(this.data.state);
    this.eventDetail.el = targetEl;
    this.el.emit("hitend", this.eventDetail);
  }
});
function copyArray(dest, source) {
  dest.length = 0;
  for (let i2 = 0; i2 < source.length; i2++) {
    dest[i2] = source[i2];
  }
}

// node_modules/aframe-extras/src/pathfinding/nav-mesh.js
AFRAME.registerComponent("nav-mesh", {
  schema: {
    nodeName: { type: "string" }
  },
  init: function() {
    this.system = this.el.sceneEl.systems.nav;
    this.hasLoadedNavMesh = false;
    this.nodeName = this.data.nodeName;
    this.el.addEventListener("object3dset", this.loadNavMesh.bind(this));
  },
  play: function() {
    if (!this.hasLoadedNavMesh) this.loadNavMesh();
  },
  loadNavMesh: function() {
    var self2 = this;
    const object = this.el.getObject3D("mesh");
    const scene3 = this.el.sceneEl.object3D;
    if (!object) return;
    let navMesh;
    object.traverse((node) => {
      if (node.isMesh && (!self2.nodeName || node.name === self2.nodeName)) navMesh = node;
    });
    if (!navMesh) return;
    const navMeshGeometry = navMesh.geometry.clone();
    navMesh.updateWorldMatrix(true, false);
    navMeshGeometry.applyMatrix4(navMesh.matrixWorld);
    this.system.setNavMeshGeometry(navMeshGeometry);
    this.hasLoadedNavMesh = true;
  }
});

// node_modules/aframe-extras/src/pathfinding/nav-agent.js
AFRAME.registerComponent("nav-agent", {
  schema: {
    destination: { type: "vec3" },
    active: { default: false },
    speed: { default: 2 }
  },
  init: function() {
    this.system = this.el.sceneEl.systems.nav;
    this.system.addAgent(this);
    this.group = null;
    this.path = [];
    this.raycaster = new THREE.Raycaster();
  },
  remove: function() {
    this.system.removeAgent(this);
  },
  update: function() {
    this.path.length = 0;
  },
  updateNavLocation: function() {
    this.group = null;
    this.path = [];
  },
  tick: (function() {
    const vDest = new THREE.Vector3();
    const vDelta = new THREE.Vector3();
    const vNext = new THREE.Vector3();
    return function(t5, dt) {
      const el = this.el;
      const data = this.data;
      const raycaster = this.raycaster;
      const speed = data.speed * dt / 1e3;
      if (!data.active) return;
      if (!this.path.length) {
        const position = this.el.object3D.position;
        this.group = this.group || this.system.getGroup(position);
        this.path = this.system.getPath(position, vDest.copy(data.destination), this.group) || [];
        el.emit("navigation-start");
      }
      if (!this.path.length) {
        console.warn("[nav] Unable to find path to %o.", data.destination);
        this.el.setAttribute("nav-agent", { active: false });
        el.emit("navigation-end");
        return;
      }
      const vCurrent = el.object3D.position;
      const vWaypoint = this.path[0];
      vDelta.subVectors(vWaypoint, vCurrent);
      const distance4 = vDelta.length();
      let gazeTarget;
      if (distance4 < speed) {
        this.path.shift();
        if (!this.path.length) {
          this.el.setAttribute("nav-agent", { active: false });
          el.emit("navigation-end");
          return;
        }
        vNext.copy(vCurrent);
        gazeTarget = this.path[0];
      } else {
        vNext.copy(vDelta.setLength(speed)).add(vCurrent);
        gazeTarget = vWaypoint;
      }
      gazeTarget.y = vCurrent.y;
      el.object3D.lookAt(gazeTarget);
      raycaster.ray.origin.copy(vNext);
      raycaster.ray.origin.y += 1.5;
      raycaster.ray.direction = { x: 0, y: -1, z: 0 };
      const intersections = raycaster.intersectObject(this.system.getNavMesh());
      if (!intersections.length) {
        vCurrent.copy(vNext);
      } else {
        vDelta.subVectors(intersections[0].point, vCurrent);
        vCurrent.add(vDelta.setLength(speed));
      }
    };
  })()
});

// node_modules/three-pathfinding/dist/three-pathfinding.module.js
var d = class {
  static roundNumber(t5, e3) {
    const s2 = Math.pow(10, e3);
    return Math.round(t5 * s2) / s2;
  }
  static sample(t5) {
    return t5[Math.floor(Math.random() * t5.length)];
  }
  static distanceToSquared(t5, e3) {
    var s2 = t5.x - e3.x, r2 = t5.y - e3.y, n2 = t5.z - e3.z;
    return s2 * s2 + r2 * r2 + n2 * n2;
  }
  static isPointInPoly(t5, e3) {
    for (var s2 = false, r2 = -1, n2 = t5.length, o2 = n2 - 1; ++r2 < n2; o2 = r2) (t5[r2].z <= e3.z && e3.z < t5[o2].z || t5[o2].z <= e3.z && e3.z < t5[r2].z) && e3.x < (t5[o2].x - t5[r2].x) * (e3.z - t5[r2].z) / (t5[o2].z - t5[r2].z) + t5[r2].x && (s2 = !s2);
    return s2;
  }
  static isVectorInPolygon(t5, e3, s2) {
    var r2 = 1e5, n2 = -1e5, o2 = [];
    return e3.vertexIds.forEach((t6) => {
      r2 = Math.min(s2[t6].y, r2), n2 = Math.max(s2[t6].y, n2), o2.push(s2[t6]);
    }), !!(t5.y < n2 + 0.5 && t5.y > r2 - 0.5 && this.isPointInPoly(o2, t5));
  }
  static triarea2(t5, e3, s2) {
    return (s2.x - t5.x) * (e3.z - t5.z) - (e3.x - t5.x) * (s2.z - t5.z);
  }
  static vequal(t5, e3) {
    return this.distanceToSquared(t5, e3) < 1e-5;
  }
  static mergeVertices(s2, r2 = 1e-4) {
    r2 = Math.max(r2, Number.EPSILON);
    for (var n2 = {}, o2 = s2.getIndex(), i2 = s2.getAttribute("position"), h2 = o2 ? o2.count : i2.count, c5 = 0, a3 = [], u2 = [], l2 = Math.log10(1 / r2), d3 = Math.pow(10, l2), p3 = 0; p3 < h2; p3++) {
      var g3 = o2 ? o2.getX(p3) : p3, f3 = "";
      f3 += ~~(i2.getX(g3) * d3) + ",", f3 += ~~(i2.getY(g3) * d3) + ",", (f3 += ~~(i2.getZ(g3) * d3) + ",") in n2 ? a3.push(n2[f3]) : (u2.push(i2.getX(g3)), u2.push(i2.getY(g3)), u2.push(i2.getZ(g3)), n2[f3] = c5, a3.push(c5), c5++);
    }
    const v2 = new BufferAttribute(new Float32Array(u2), i2.itemSize, i2.normalized), b = new BufferGeometry();
    return b.setAttribute("position", v2), b.setIndex(a3), b;
  }
};
var p = class {
  constructor(t5) {
    this.content = [], this.scoreFunction = t5;
  }
  push(t5) {
    this.content.push(t5), this.sinkDown(this.content.length - 1);
  }
  pop() {
    const t5 = this.content[0], e3 = this.content.pop();
    return this.content.length > 0 && (this.content[0] = e3, this.bubbleUp(0)), t5;
  }
  remove(t5) {
    const e3 = this.content.indexOf(t5), s2 = this.content.pop();
    e3 !== this.content.length - 1 && (this.content[e3] = s2, this.scoreFunction(s2) < this.scoreFunction(t5) ? this.sinkDown(e3) : this.bubbleUp(e3));
  }
  size() {
    return this.content.length;
  }
  rescoreElement(t5) {
    this.sinkDown(this.content.indexOf(t5));
  }
  sinkDown(t5) {
    const e3 = this.content[t5];
    for (; t5 > 0; ) {
      const s2 = (t5 + 1 >> 1) - 1, r2 = this.content[s2];
      if (!(this.scoreFunction(e3) < this.scoreFunction(r2))) break;
      this.content[s2] = e3, this.content[t5] = r2, t5 = s2;
    }
  }
  bubbleUp(t5) {
    const e3 = this.content.length, s2 = this.content[t5], r2 = this.scoreFunction(s2);
    for (; ; ) {
      const n2 = t5 + 1 << 1, o2 = n2 - 1;
      let i2, h2 = null;
      if (o2 < e3 && (i2 = this.scoreFunction(this.content[o2]), i2 < r2 && (h2 = o2)), n2 < e3 && this.scoreFunction(this.content[n2]) < (null === h2 ? r2 : i2) && (h2 = n2), null === h2) break;
      this.content[t5] = this.content[h2], this.content[h2] = s2, t5 = h2;
    }
  }
};
var g = class {
  constructor() {
    this.portals = [];
  }
  push(t5, e3) {
    void 0 === e3 && (e3 = t5), this.portals.push({ left: t5, right: e3 });
  }
  stringPull() {
    const t5 = this.portals, e3 = [];
    let s2, r2, n2, o2 = 0, i2 = 0, h2 = 0;
    s2 = t5[0].left, r2 = t5[0].left, n2 = t5[0].right, e3.push(s2);
    for (let c5 = 1; c5 < t5.length; c5++) {
      const a3 = t5[c5].left, u2 = t5[c5].right;
      if (d.triarea2(s2, n2, u2) <= 0) {
        if (!(d.vequal(s2, n2) || d.triarea2(s2, r2, u2) > 0)) {
          e3.push(r2), s2 = r2, o2 = i2, r2 = s2, n2 = s2, i2 = o2, h2 = o2, c5 = o2;
          continue;
        }
        n2 = u2, h2 = c5;
      }
      if (d.triarea2(s2, r2, a3) >= 0) {
        if (!(d.vequal(s2, r2) || d.triarea2(s2, n2, a3) < 0)) {
          e3.push(n2), s2 = n2, o2 = h2, r2 = s2, n2 = s2, i2 = o2, h2 = o2, c5 = o2;
          continue;
        }
        r2 = a3, i2 = c5;
      }
    }
    return 0 !== e3.length && d.vequal(e3[e3.length - 1], t5[t5.length - 1].left) || e3.push(t5[t5.length - 1].left), this.path = e3, e3;
  }
};
var f = class {
  constructor() {
    this.zones = {};
  }
  static createZone(t5, e3 = 1e-4) {
    return (class {
      static buildZone(t6, e4) {
        const r2 = this._buildNavigationMesh(t6, e4), n2 = {};
        r2.vertices.forEach((t7) => {
          t7.x = d.roundNumber(t7.x, 2), t7.y = d.roundNumber(t7.y, 2), t7.z = d.roundNumber(t7.z, 2);
        }), n2.vertices = r2.vertices;
        const o2 = this._buildPolygonGroups(r2);
        return n2.groups = new Array(o2.length), o2.forEach((t7, e6) => {
          const r3 = /* @__PURE__ */ new Map();
          t7.forEach((t8, e7) => {
            r3.set(t8, e7);
          });
          const o3 = new Array(t7.length);
          t7.forEach((t8, e7) => {
            const i2 = [];
            t8.neighbours.forEach((t9) => i2.push(r3.get(t9)));
            const h2 = [];
            t8.neighbours.forEach((e8) => h2.push(this._getSharedVerticesInOrder(t8, e8)));
            const c5 = new Vector3(0, 0, 0);
            c5.add(n2.vertices[t8.vertexIds[0]]), c5.add(n2.vertices[t8.vertexIds[1]]), c5.add(n2.vertices[t8.vertexIds[2]]), c5.divideScalar(3), c5.x = d.roundNumber(c5.x, 2), c5.y = d.roundNumber(c5.y, 2), c5.z = d.roundNumber(c5.z, 2), o3[e7] = { id: e7, neighbours: i2, vertexIds: t8.vertexIds, centroid: c5, portals: h2 };
          }), n2.groups[e6] = o3;
        }), n2;
      }
      static _buildNavigationMesh(t6, e4) {
        return t6 = d.mergeVertices(t6, e4), this._buildPolygonsFromGeometry(t6);
      }
      static _spreadGroupId(t6) {
        let e4 = /* @__PURE__ */ new Set([t6]);
        for (; e4.size > 0; ) {
          const s2 = e4;
          e4 = /* @__PURE__ */ new Set(), s2.forEach((s3) => {
            s3.group = t6.group, s3.neighbours.forEach((t7) => {
              void 0 === t7.group && e4.add(t7);
            });
          });
        }
      }
      static _buildPolygonGroups(t6) {
        const e4 = [];
        return t6.polygons.forEach((t7) => {
          void 0 !== t7.group ? e4[t7.group].push(t7) : (t7.group = e4.length, this._spreadGroupId(t7), e4.push([t7]));
        }), e4;
      }
      static _buildPolygonNeighbours(t6, e4) {
        const s2 = /* @__PURE__ */ new Set(), r2 = e4[t6.vertexIds[1]], n2 = e4[t6.vertexIds[2]];
        return e4[t6.vertexIds[0]].forEach((e6) => {
          e6 !== t6 && (r2.includes(e6) || n2.includes(e6)) && s2.add(e6);
        }), r2.forEach((e6) => {
          e6 !== t6 && n2.includes(e6) && s2.add(e6);
        }), s2;
      }
      static _buildPolygonsFromGeometry(t6) {
        const e4 = [], r2 = [], n2 = t6.attributes.position, o2 = t6.index, i2 = [];
        for (let t7 = 0; t7 < n2.count; t7++) r2.push(new Vector3().fromBufferAttribute(n2, t7)), i2[t7] = [];
        for (let s2 = 0; s2 < t6.index.count; s2 += 3) {
          const t7 = o2.getX(s2), r3 = o2.getX(s2 + 1), n3 = o2.getX(s2 + 2), h2 = { vertexIds: [t7, r3, n3], neighbours: null };
          e4.push(h2), i2[t7].push(h2), i2[r3].push(h2), i2[n3].push(h2);
        }
        return e4.forEach((t7) => {
          t7.neighbours = this._buildPolygonNeighbours(t7, i2);
        }), { polygons: e4, vertices: r2 };
      }
      static _getSharedVerticesInOrder(t6, e4) {
        const s2 = t6.vertexIds, r2 = s2[0], n2 = s2[1], o2 = s2[2], i2 = e4.vertexIds, h2 = i2.includes(r2), c5 = i2.includes(n2), a3 = i2.includes(o2);
        return h2 && c5 && a3 ? Array.from(s2) : h2 && c5 ? [r2, n2] : c5 && a3 ? [n2, o2] : h2 && a3 ? [o2, r2] : (console.warn("Error processing navigation mesh neighbors; neighbors with <2 shared vertices found."), []);
      }
    }).buildZone(t5, e3);
  }
  setZoneData(t5, e3) {
    this.zones[t5] = e3;
  }
  getRandomNode(t5, e3, r2, n2) {
    if (!this.zones[t5]) return new Vector3();
    r2 = r2 || null, n2 = n2 || 0;
    const o2 = [];
    return this.zones[t5].groups[e3].forEach((t6) => {
      r2 && n2 ? d.distanceToSquared(r2, t6.centroid) < n2 * n2 && o2.push(t6.centroid) : o2.push(t6.centroid);
    }), d.sample(o2) || new Vector3();
  }
  getClosestNode(t5, e3, s2, r2 = false) {
    const n2 = this.zones[e3].vertices;
    let o2 = null, i2 = Infinity;
    return this.zones[e3].groups[s2].forEach((e4) => {
      const s3 = d.distanceToSquared(e4.centroid, t5);
      s3 < i2 && (!r2 || d.isVectorInPolygon(t5, e4, n2)) && (o2 = e4, i2 = s3);
    }), o2;
  }
  findPath(t5, e3, r2, n2) {
    const o2 = this.zones[r2].groups[n2], i2 = this.zones[r2].vertices, h2 = this.getClosestNode(t5, r2, n2, true), c5 = this.getClosestNode(e3, r2, n2, true);
    if (!h2 || !c5) return null;
    const a3 = (class {
      static init(t6) {
        for (let e4 = 0; e4 < t6.length; e4++) {
          const s2 = t6[e4];
          s2.f = 0, s2.g = 0, s2.h = 0, s2.cost = 1, s2.visited = false, s2.closed = false, s2.parent = null;
        }
      }
      static cleanUp(t6) {
        for (let e4 = 0; e4 < t6.length; e4++) {
          const s2 = t6[e4];
          delete s2.f, delete s2.g, delete s2.h, delete s2.cost, delete s2.visited, delete s2.closed, delete s2.parent;
        }
      }
      static heap() {
        return new p(function(t6) {
          return t6.f;
        });
      }
      static search(t6, e4, s2) {
        this.init(t6);
        const r3 = this.heap();
        for (r3.push(e4); r3.size() > 0; ) {
          const e6 = r3.pop();
          if (e6 === s2) {
            let t7 = e6;
            const s3 = [];
            for (; t7.parent; ) s3.push(t7), t7 = t7.parent;
            return this.cleanUp(s3), s3.reverse();
          }
          e6.closed = true;
          const n3 = this.neighbours(t6, e6);
          for (let t7 = 0, o3 = n3.length; t7 < o3; t7++) {
            const o4 = n3[t7];
            if (o4.closed) continue;
            const i3 = e6.g + o4.cost, h3 = o4.visited;
            if (!h3 || i3 < o4.g) {
              if (o4.visited = true, o4.parent = e6, !o4.centroid || !s2.centroid) throw new Error("Unexpected state");
              o4.h = o4.h || this.heuristic(o4.centroid, s2.centroid), o4.g = i3, o4.f = o4.g + o4.h, h3 ? r3.rescoreElement(o4) : r3.push(o4);
            }
          }
        }
        return [];
      }
      static heuristic(t6, e4) {
        return d.distanceToSquared(t6, e4);
      }
      static neighbours(t6, e4) {
        const s2 = [];
        for (let r3 = 0; r3 < e4.neighbours.length; r3++) s2.push(t6[e4.neighbours[r3]]);
        return s2;
      }
    }).search(o2, h2, c5), u2 = function(t6, e4) {
      for (var s2 = 0; s2 < t6.neighbours.length; s2++) if (t6.neighbours[s2] === e4.id) return t6.portals[s2];
    }, l2 = new g();
    l2.push(t5);
    for (let t6 = 0; t6 < a3.length; t6++) {
      const e4 = a3[t6], s2 = a3[t6 + 1];
      if (s2) {
        const t7 = u2(e4, s2);
        l2.push(i2[t7[0]], i2[t7[1]]);
      }
    }
    l2.push(e3), l2.stringPull();
    const f3 = l2.path.map((t6) => new Vector3(t6.x, t6.y, t6.z));
    return f3.shift(), f3;
  }
};
f.prototype.getGroup = (function() {
  const t5 = new Plane();
  return function(e3, s2, r2 = false) {
    if (!this.zones[e3]) return null;
    let n2 = null, o2 = Math.pow(50, 2);
    const i2 = this.zones[e3];
    for (let e4 = 0; e4 < i2.groups.length; e4++) {
      const h2 = i2.groups[e4];
      for (const c5 of h2) {
        if (r2 && (t5.setFromCoplanarPoints(i2.vertices[c5.vertexIds[0]], i2.vertices[c5.vertexIds[1]], i2.vertices[c5.vertexIds[2]]), Math.abs(t5.distanceToPoint(s2)) < 0.01) && d.isPointInPoly([i2.vertices[c5.vertexIds[0]], i2.vertices[c5.vertexIds[1]], i2.vertices[c5.vertexIds[2]]], s2)) return e4;
        const h3 = d.distanceToSquared(c5.centroid, s2);
        h3 < o2 && (n2 = e4, o2 = h3);
      }
    }
    return n2;
  };
})(), f.prototype.clampStep = (function() {
  const t5 = new Vector3(), e3 = new Plane(), o2 = new Triangle(), i2 = new Vector3();
  let h2, c5, a3 = new Vector3();
  return function(s2, r2, n2, u2, l2, d3) {
    const p3 = this.zones[u2].vertices, g3 = this.zones[u2].groups[l2], f3 = [n2], v2 = {};
    v2[n2.id] = 0, h2 = void 0, a3.set(0, 0, 0), c5 = Infinity, e3.setFromCoplanarPoints(p3[n2.vertexIds[0]], p3[n2.vertexIds[1]], p3[n2.vertexIds[2]]), e3.projectPoint(r2, t5), i2.copy(t5);
    for (let e4 = f3.pop(); e4; e4 = f3.pop()) {
      o2.set(p3[e4.vertexIds[0]], p3[e4.vertexIds[1]], p3[e4.vertexIds[2]]), o2.closestPointToPoint(i2, t5), t5.distanceToSquared(i2) < c5 && (h2 = e4, a3.copy(t5), c5 = t5.distanceToSquared(i2));
      const s3 = v2[e4.id];
      if (!(s3 > 2)) for (let t6 = 0; t6 < e4.neighbours.length; t6++) {
        const r3 = g3[e4.neighbours[t6]];
        r3.id in v2 || (f3.push(r3), v2[r3.id] = s3 + 1);
      }
    }
    return d3.copy(a3), h2;
  };
})();

// node_modules/aframe-extras/src/pathfinding/system.js
var pathfinder = new f();
var ZONE = "level";
AFRAME.registerSystem("nav", {
  init: function() {
    this.navMesh = null;
    this.agents = /* @__PURE__ */ new Set();
  },
  /**
   * @param {THREE.Geometry} geometry
   */
  setNavMeshGeometry: function(geometry) {
    this.navMesh = new THREE.Mesh(geometry);
    pathfinder.setZoneData(ZONE, f.createZone(geometry));
    Array.from(this.agents).forEach((agent) => agent.updateNavLocation());
  },
  /**
   * @return {THREE.Mesh}
   */
  getNavMesh: function() {
    return this.navMesh;
  },
  /**
   * @param {NavAgent} ctrl
   */
  addAgent: function(ctrl) {
    this.agents.add(ctrl);
  },
  /**
   * @param {NavAgent} ctrl
   */
  removeAgent: function(ctrl) {
    this.agents.delete(ctrl);
  },
  /**
   * @param  {THREE.Vector3} start
   * @param  {THREE.Vector3} end
   * @param  {number} groupID
   * @return {Array<THREE.Vector3>}
   */
  getPath: function(start2, end, groupID) {
    return this.navMesh ? pathfinder.findPath(start2, end, ZONE, groupID) : null;
  },
  /**
   * @param {THREE.Vector3} position
   * @return {number}
   */
  getGroup: function(position) {
    return this.navMesh ? pathfinder.getGroup(ZONE, position) : null;
  },
  /**
   * @param  {THREE.Vector3} position
   * @param  {number} groupID
   * @return {Node}
   */
  getNode: function(position, groupID) {
    return this.navMesh ? pathfinder.getClosestNode(position, ZONE, groupID, true) : null;
  },
  /**
   * @param  {THREE.Vector3} start Starting position.
   * @param  {THREE.Vector3} end Desired ending position.
   * @param  {number} groupID
   * @param  {Node} node
   * @param  {THREE.Vector3} endTarget (Output) Adjusted step end position.
   * @return {Node} Current node, after step is taken.
   */
  clampStep: function(start2, end, groupID, node, endTarget) {
    if (!this.navMesh) {
      endTarget.copy(end);
      return null;
    } else if (!node) {
      endTarget.copy(end);
      return this.getNode(end, groupID);
    }
    return pathfinder.clampStep(start2, end, node, ZONE, groupID, endTarget);
  }
});

// node_modules/aframe-extras/src/primitives/a-grid.js
AFRAME.registerPrimitive("a-grid", {
  defaultComponents: {
    geometry: {
      primitive: "plane",
      width: 75,
      height: 75
    },
    rotation: { x: -90, y: 0, z: 0 },
    material: {
      src: "url(https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v1.16.3/assets/grid.png)",
      repeat: "75 75"
    }
  },
  mappings: {
    width: "geometry.width",
    height: "geometry.height",
    src: "material.src"
  }
});

// node_modules/aframe-extras/src/primitives/a-ocean.js
AFRAME.registerPrimitive("a-ocean", {
  defaultComponents: {
    ocean: {},
    rotation: { x: -90, y: 0, z: 0 }
  },
  mappings: {
    width: "ocean.width",
    depth: "ocean.depth",
    density: "ocean.density",
    amplitude: "ocean.amplitude",
    amplitudeVariance: "ocean.amplitudeVariance",
    speed: "ocean.speed",
    speedVariance: "ocean.speedVariance",
    color: "ocean.color",
    opacity: "ocean.opacity"
  }
});
AFRAME.registerComponent("ocean", {
  schema: {
    // Dimensions of the ocean area.
    width: { default: 10, min: 0 },
    depth: { default: 10, min: 0 },
    // Density of waves.
    density: { default: 10 },
    // Wave amplitude and variance.
    amplitude: { default: 0.1 },
    amplitudeVariance: { default: 0.3 },
    // Wave speed and variance.
    speed: { default: 1 },
    speedVariance: { default: 2 },
    // Material.
    color: { default: "#7AD2F7", type: "color" },
    opacity: { default: 0.8 }
  },
  /**
   * Use play() instead of init(), because component mappings â unavailable as dependencies â are
   * not guaranteed to have parsed when this component is initialized.
   */
  play: function() {
    const el = this.el;
    const data = this.data;
    let material = el.components.material;
    const geometry = new THREE.PlaneGeometry(data.width, data.depth, data.density, data.density);
    this.waves = [];
    const posAttribute = geometry.getAttribute("position");
    for (let i2 = 0; i2 < posAttribute.count; i2++) {
      this.waves.push({
        z: posAttribute.getZ(i2),
        ang: Math.random() * Math.PI * 2,
        amp: data.amplitude + Math.random() * data.amplitudeVariance,
        speed: (data.speed + Math.random() * data.speedVariance) / 1e3
        // radians / frame
      });
    }
    if (!material) {
      material = {};
      material.material = new THREE.MeshPhongMaterial({
        color: data.color,
        transparent: data.opacity < 1,
        opacity: data.opacity,
        flatShading: true
      });
    }
    this.mesh = new THREE.Mesh(geometry, material.material);
    el.setObject3D("mesh", this.mesh);
  },
  remove: function() {
    this.el.removeObject3D("mesh");
  },
  tick: function(t5, dt) {
    if (!dt) return;
    const posAttribute = this.mesh.geometry.getAttribute("position");
    for (let i2 = 0; i2 < posAttribute.count; i2++) {
      const vprops = this.waves[i2];
      const value = vprops.z + Math.sin(vprops.ang) * vprops.amp;
      posAttribute.setZ(i2, value);
      vprops.ang += vprops.speed * dt;
    }
    posAttribute.needsUpdate = true;
  }
});

// node_modules/aframe-extras/src/primitives/a-tube.js
AFRAME.registerPrimitive("a-tube", {
  defaultComponents: {
    tube: {}
  },
  mappings: {
    path: "tube.path",
    segments: "tube.segments",
    radius: "tube.radius",
    "radial-segments": "tube.radialSegments",
    closed: "tube.closed"
  }
});
AFRAME.registerComponent("tube", {
  schema: {
    path: { default: [] },
    segments: { default: 64 },
    radius: { default: 1 },
    radialSegments: { default: 8 },
    closed: { default: false }
  },
  init: function() {
    const el = this.el, data = this.data;
    let material = el.components.material;
    if (!data.path.length) {
      console.error("[a-tube] `path` property expected but not found.");
      return;
    }
    const curve = new THREE.CatmullRomCurve3(data.path.map(function(point2) {
      point2 = point2.split(" ");
      return new THREE.Vector3(Number(point2[0]), Number(point2[1]), Number(point2[2]));
    }));
    const geometry = new THREE.TubeGeometry(
      curve,
      data.segments,
      data.radius,
      data.radialSegments,
      data.closed
    );
    if (!material) {
      material = {};
      material.material = new THREE.MeshPhongMaterial();
    }
    this.mesh = new THREE.Mesh(geometry, material.material);
    this.el.setObject3D("mesh", this.mesh);
  },
  update: function(prevData) {
    if (!Object.keys(prevData).length) return;
    this.remove();
    this.init();
  },
  remove: function() {
    if (this.mesh) this.el.removeObject3D("mesh");
  }
});

// node_modules/d3-force-3d/src/center.js
function center_default(x3, y3, z3) {
  var nodes, strength = 1;
  if (x3 == null) x3 = 0;
  if (y3 == null) y3 = 0;
  if (z3 == null) z3 = 0;
  function force() {
    var i2, n2 = nodes.length, node, sx = 0, sy = 0, sz = 0;
    for (i2 = 0; i2 < n2; ++i2) {
      node = nodes[i2], sx += node.x || 0, sy += node.y || 0, sz += node.z || 0;
    }
    for (sx = (sx / n2 - x3) * strength, sy = (sy / n2 - y3) * strength, sz = (sz / n2 - z3) * strength, i2 = 0; i2 < n2; ++i2) {
      node = nodes[i2];
      if (sx) {
        node.x -= sx;
      }
      if (sy) {
        node.y -= sy;
      }
      if (sz) {
        node.z -= sz;
      }
    }
  }
  force.initialize = function(_2) {
    nodes = _2;
  };
  force.x = function(_2) {
    return arguments.length ? (x3 = +_2, force) : x3;
  };
  force.y = function(_2) {
    return arguments.length ? (y3 = +_2, force) : y3;
  };
  force.z = function(_2) {
    return arguments.length ? (z3 = +_2, force) : z3;
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = +_2, force) : strength;
  };
  return force;
}

// node_modules/d3-binarytree/src/add.js
function add_default(d3) {
  const x3 = +this._x.call(null, d3);
  return add(this.cover(x3), x3, d3);
}
function add(tree, x3, d3) {
  if (isNaN(x3)) return tree;
  var parent2, node = tree._root, leaf = { data: d3 }, x0 = tree._x0, x1 = tree._x1, xm, xp, right, i2, j2;
  if (!node) return tree._root = leaf, tree;
  while (node.length) {
    if (right = x3 >= (xm = (x0 + x1) / 2)) x0 = xm;
    else x1 = xm;
    if (parent2 = node, !(node = node[i2 = +right])) return parent2[i2] = leaf, tree;
  }
  xp = +tree._x.call(null, node.data);
  if (x3 === xp) return leaf.next = node, parent2 ? parent2[i2] = leaf : tree._root = leaf, tree;
  do {
    parent2 = parent2 ? parent2[i2] = new Array(2) : tree._root = new Array(2);
    if (right = x3 >= (xm = (x0 + x1) / 2)) x0 = xm;
    else x1 = xm;
  } while ((i2 = +right) === (j2 = +(xp >= xm)));
  return parent2[j2] = node, parent2[i2] = leaf, tree;
}
function addAll(data) {
  if (!Array.isArray(data)) data = Array.from(data);
  const n2 = data.length;
  const xz = new Float64Array(n2);
  let x0 = Infinity, x1 = -Infinity;
  for (let i2 = 0, x3; i2 < n2; ++i2) {
    if (isNaN(x3 = +this._x.call(null, data[i2]))) continue;
    xz[i2] = x3;
    if (x3 < x0) x0 = x3;
    if (x3 > x1) x1 = x3;
  }
  if (x0 > x1) return this;
  this.cover(x0).cover(x1);
  for (let i2 = 0; i2 < n2; ++i2) {
    add(this, xz[i2], data[i2]);
  }
  return this;
}

// node_modules/d3-binarytree/src/cover.js
function cover_default(x3) {
  if (isNaN(x3 = +x3)) return this;
  var x0 = this._x0, x1 = this._x1;
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x3)) + 1;
  } else {
    var z3 = x1 - x0 || 1, node = this._root, parent2, i2;
    while (x0 > x3 || x3 >= x1) {
      i2 = +(x3 < x0);
      parent2 = new Array(2), parent2[i2] = node, node = parent2, z3 *= 2;
      switch (i2) {
        case 0:
          x1 = x0 + z3;
          break;
        case 1:
          x0 = x1 - z3;
          break;
      }
    }
    if (this._root && this._root.length) this._root = node;
  }
  this._x0 = x0;
  this._x1 = x1;
  return this;
}

// node_modules/d3-binarytree/src/data.js
function data_default() {
  var data = [];
  this.visit(function(node) {
    if (!node.length) do
      data.push(node.data);
    while (node = node.next);
  });
  return data;
}

// node_modules/d3-binarytree/src/extent.js
function extent_default(_2) {
  return arguments.length ? this.cover(+_2[0][0]).cover(+_2[1][0]) : isNaN(this._x0) ? void 0 : [[this._x0], [this._x1]];
}

// node_modules/d3-binarytree/src/half.js
function half_default(node, x0, x1) {
  this.node = node;
  this.x0 = x0;
  this.x1 = x1;
}

// node_modules/d3-binarytree/src/find.js
function find_default(x3, radius) {
  var data, x0 = this._x0, x1, x22, x32 = this._x1, halves = [], node = this._root, q2, i2;
  if (node) halves.push(new half_default(node, x0, x32));
  if (radius == null) radius = Infinity;
  else {
    x0 = x3 - radius;
    x32 = x3 + radius;
  }
  while (q2 = halves.pop()) {
    if (!(node = q2.node) || (x1 = q2.x0) > x32 || (x22 = q2.x1) < x0) continue;
    if (node.length) {
      var xm = (x1 + x22) / 2;
      halves.push(
        new half_default(node[1], xm, x22),
        new half_default(node[0], x1, xm)
      );
      if (i2 = +(x3 >= xm)) {
        q2 = halves[halves.length - 1];
        halves[halves.length - 1] = halves[halves.length - 1 - i2];
        halves[halves.length - 1 - i2] = q2;
      }
    } else {
      var d3 = Math.abs(x3 - +this._x.call(null, node.data));
      if (d3 < radius) {
        radius = d3;
        x0 = x3 - d3;
        x32 = x3 + d3;
        data = node.data;
      }
    }
  }
  return data;
}

// node_modules/d3-binarytree/src/remove.js
function remove_default(d3) {
  if (isNaN(x3 = +this._x.call(null, d3))) return this;
  var parent2, node = this._root, retainer, previous, next, x0 = this._x0, x1 = this._x1, x3, xm, right, i2, j2;
  if (!node) return this;
  if (node.length) while (true) {
    if (right = x3 >= (xm = (x0 + x1) / 2)) x0 = xm;
    else x1 = xm;
    if (!(parent2 = node, node = node[i2 = +right])) return this;
    if (!node.length) break;
    if (parent2[i2 + 1 & 1]) retainer = parent2, j2 = i2;
  }
  while (node.data !== d3) if (!(previous = node, node = node.next)) return this;
  if (next = node.next) delete node.next;
  if (previous) return next ? previous.next = next : delete previous.next, this;
  if (!parent2) return this._root = next, this;
  next ? parent2[i2] = next : delete parent2[i2];
  if ((node = parent2[0] || parent2[1]) && node === (parent2[1] || parent2[0]) && !node.length) {
    if (retainer) retainer[j2] = node;
    else this._root = node;
  }
  return this;
}
function removeAll(data) {
  for (var i2 = 0, n2 = data.length; i2 < n2; ++i2) this.remove(data[i2]);
  return this;
}

// node_modules/d3-binarytree/src/root.js
function root_default() {
  return this._root;
}

// node_modules/d3-binarytree/src/size.js
function size_default() {
  var size2 = 0;
  this.visit(function(node) {
    if (!node.length) do
      ++size2;
    while (node = node.next);
  });
  return size2;
}

// node_modules/d3-binarytree/src/visit.js
function visit_default(callback) {
  var halves = [], q2, node = this._root, child, x0, x1;
  if (node) halves.push(new half_default(node, this._x0, this._x1));
  while (q2 = halves.pop()) {
    if (!callback(node = q2.node, x0 = q2.x0, x1 = q2.x1) && node.length) {
      var xm = (x0 + x1) / 2;
      if (child = node[1]) halves.push(new half_default(child, xm, x1));
      if (child = node[0]) halves.push(new half_default(child, x0, xm));
    }
  }
  return this;
}

// node_modules/d3-binarytree/src/visitAfter.js
function visitAfter_default(callback) {
  var halves = [], next = [], q2;
  if (this._root) halves.push(new half_default(this._root, this._x0, this._x1));
  while (q2 = halves.pop()) {
    var node = q2.node;
    if (node.length) {
      var child, x0 = q2.x0, x1 = q2.x1, xm = (x0 + x1) / 2;
      if (child = node[0]) halves.push(new half_default(child, x0, xm));
      if (child = node[1]) halves.push(new half_default(child, xm, x1));
    }
    next.push(q2);
  }
  while (q2 = next.pop()) {
    callback(q2.node, q2.x0, q2.x1);
  }
  return this;
}

// node_modules/d3-binarytree/src/x.js
function defaultX(d3) {
  return d3[0];
}
function x_default(_2) {
  return arguments.length ? (this._x = _2, this) : this._x;
}

// node_modules/d3-binarytree/src/binarytree.js
function binarytree(nodes, x3) {
  var tree = new Binarytree(x3 == null ? defaultX : x3, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}
function Binarytree(x3, x0, x1) {
  this._x = x3;
  this._x0 = x0;
  this._x1 = x1;
  this._root = void 0;
}
function leaf_copy(leaf) {
  var copy3 = { data: leaf.data }, next = copy3;
  while (leaf = leaf.next) next = next.next = { data: leaf.data };
  return copy3;
}
var treeProto = binarytree.prototype = Binarytree.prototype;
treeProto.copy = function() {
  var copy3 = new Binarytree(this._x, this._x0, this._x1), node = this._root, nodes, child;
  if (!node) return copy3;
  if (!node.length) return copy3._root = leaf_copy(node), copy3;
  nodes = [{ source: node, target: copy3._root = new Array(2) }];
  while (node = nodes.pop()) {
    for (var i2 = 0; i2 < 2; ++i2) {
      if (child = node.source[i2]) {
        if (child.length) nodes.push({ source: child, target: node.target[i2] = new Array(2) });
        else node.target[i2] = leaf_copy(child);
      }
    }
  }
  return copy3;
};
treeProto.add = add_default;
treeProto.addAll = addAll;
treeProto.cover = cover_default;
treeProto.data = data_default;
treeProto.extent = extent_default;
treeProto.find = find_default;
treeProto.remove = remove_default;
treeProto.removeAll = removeAll;
treeProto.root = root_default;
treeProto.size = size_default;
treeProto.visit = visit_default;
treeProto.visitAfter = visitAfter_default;
treeProto.x = x_default;

// node_modules/d3-quadtree/src/add.js
function add_default2(d3) {
  const x3 = +this._x.call(null, d3), y3 = +this._y.call(null, d3);
  return add2(this.cover(x3, y3), x3, y3, d3);
}
function add2(tree, x3, y3, d3) {
  if (isNaN(x3) || isNaN(y3)) return tree;
  var parent2, node = tree._root, leaf = { data: d3 }, x0 = tree._x0, y0 = tree._y0, x1 = tree._x1, y1 = tree._y1, xm, ym, xp, yp, right, bottom, i2, j2;
  if (!node) return tree._root = leaf, tree;
  while (node.length) {
    if (right = x3 >= (xm = (x0 + x1) / 2)) x0 = xm;
    else x1 = xm;
    if (bottom = y3 >= (ym = (y0 + y1) / 2)) y0 = ym;
    else y1 = ym;
    if (parent2 = node, !(node = node[i2 = bottom << 1 | right])) return parent2[i2] = leaf, tree;
  }
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x3 === xp && y3 === yp) return leaf.next = node, parent2 ? parent2[i2] = leaf : tree._root = leaf, tree;
  do {
    parent2 = parent2 ? parent2[i2] = new Array(4) : tree._root = new Array(4);
    if (right = x3 >= (xm = (x0 + x1) / 2)) x0 = xm;
    else x1 = xm;
    if (bottom = y3 >= (ym = (y0 + y1) / 2)) y0 = ym;
    else y1 = ym;
  } while ((i2 = bottom << 1 | right) === (j2 = (yp >= ym) << 1 | xp >= xm));
  return parent2[j2] = node, parent2[i2] = leaf, tree;
}
function addAll2(data) {
  var d3, i2, n2 = data.length, x3, y3, xz = new Array(n2), yz = new Array(n2), x0 = Infinity, y0 = Infinity, x1 = -Infinity, y1 = -Infinity;
  for (i2 = 0; i2 < n2; ++i2) {
    if (isNaN(x3 = +this._x.call(null, d3 = data[i2])) || isNaN(y3 = +this._y.call(null, d3))) continue;
    xz[i2] = x3;
    yz[i2] = y3;
    if (x3 < x0) x0 = x3;
    if (x3 > x1) x1 = x3;
    if (y3 < y0) y0 = y3;
    if (y3 > y1) y1 = y3;
  }
  if (x0 > x1 || y0 > y1) return this;
  this.cover(x0, y0).cover(x1, y1);
  for (i2 = 0; i2 < n2; ++i2) {
    add2(this, xz[i2], yz[i2], data[i2]);
  }
  return this;
}

// node_modules/d3-quadtree/src/cover.js
function cover_default2(x3, y3) {
  if (isNaN(x3 = +x3) || isNaN(y3 = +y3)) return this;
  var x0 = this._x0, y0 = this._y0, x1 = this._x1, y1 = this._y1;
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x3)) + 1;
    y1 = (y0 = Math.floor(y3)) + 1;
  } else {
    var z3 = x1 - x0 || 1, node = this._root, parent2, i2;
    while (x0 > x3 || x3 >= x1 || y0 > y3 || y3 >= y1) {
      i2 = (y3 < y0) << 1 | x3 < x0;
      parent2 = new Array(4), parent2[i2] = node, node = parent2, z3 *= 2;
      switch (i2) {
        case 0:
          x1 = x0 + z3, y1 = y0 + z3;
          break;
        case 1:
          x0 = x1 - z3, y1 = y0 + z3;
          break;
        case 2:
          x1 = x0 + z3, y0 = y1 - z3;
          break;
        case 3:
          x0 = x1 - z3, y0 = y1 - z3;
          break;
      }
    }
    if (this._root && this._root.length) this._root = node;
  }
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  return this;
}

// node_modules/d3-quadtree/src/data.js
function data_default2() {
  var data = [];
  this.visit(function(node) {
    if (!node.length) do
      data.push(node.data);
    while (node = node.next);
  });
  return data;
}

// node_modules/d3-quadtree/src/extent.js
function extent_default2(_2) {
  return arguments.length ? this.cover(+_2[0][0], +_2[0][1]).cover(+_2[1][0], +_2[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
}

// node_modules/d3-quadtree/src/quad.js
function quad_default(node, x0, y0, x1, y1) {
  this.node = node;
  this.x0 = x0;
  this.y0 = y0;
  this.x1 = x1;
  this.y1 = y1;
}

// node_modules/d3-quadtree/src/find.js
function find_default2(x3, y3, radius) {
  var data, x0 = this._x0, y0 = this._y0, x1, y1, x22, y22, x32 = this._x1, y32 = this._y1, quads = [], node = this._root, q2, i2;
  if (node) quads.push(new quad_default(node, x0, y0, x32, y32));
  if (radius == null) radius = Infinity;
  else {
    x0 = x3 - radius, y0 = y3 - radius;
    x32 = x3 + radius, y32 = y3 + radius;
    radius *= radius;
  }
  while (q2 = quads.pop()) {
    if (!(node = q2.node) || (x1 = q2.x0) > x32 || (y1 = q2.y0) > y32 || (x22 = q2.x1) < x0 || (y22 = q2.y1) < y0) continue;
    if (node.length) {
      var xm = (x1 + x22) / 2, ym = (y1 + y22) / 2;
      quads.push(
        new quad_default(node[3], xm, ym, x22, y22),
        new quad_default(node[2], x1, ym, xm, y22),
        new quad_default(node[1], xm, y1, x22, ym),
        new quad_default(node[0], x1, y1, xm, ym)
      );
      if (i2 = (y3 >= ym) << 1 | x3 >= xm) {
        q2 = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i2];
        quads[quads.length - 1 - i2] = q2;
      }
    } else {
      var dx = x3 - +this._x.call(null, node.data), dy = y3 - +this._y.call(null, node.data), d22 = dx * dx + dy * dy;
      if (d22 < radius) {
        var d3 = Math.sqrt(radius = d22);
        x0 = x3 - d3, y0 = y3 - d3;
        x32 = x3 + d3, y32 = y3 + d3;
        data = node.data;
      }
    }
  }
  return data;
}

// node_modules/d3-quadtree/src/remove.js
function remove_default2(d3) {
  if (isNaN(x3 = +this._x.call(null, d3)) || isNaN(y3 = +this._y.call(null, d3))) return this;
  var parent2, node = this._root, retainer, previous, next, x0 = this._x0, y0 = this._y0, x1 = this._x1, y1 = this._y1, x3, y3, xm, ym, right, bottom, i2, j2;
  if (!node) return this;
  if (node.length) while (true) {
    if (right = x3 >= (xm = (x0 + x1) / 2)) x0 = xm;
    else x1 = xm;
    if (bottom = y3 >= (ym = (y0 + y1) / 2)) y0 = ym;
    else y1 = ym;
    if (!(parent2 = node, node = node[i2 = bottom << 1 | right])) return this;
    if (!node.length) break;
    if (parent2[i2 + 1 & 3] || parent2[i2 + 2 & 3] || parent2[i2 + 3 & 3]) retainer = parent2, j2 = i2;
  }
  while (node.data !== d3) if (!(previous = node, node = node.next)) return this;
  if (next = node.next) delete node.next;
  if (previous) return next ? previous.next = next : delete previous.next, this;
  if (!parent2) return this._root = next, this;
  next ? parent2[i2] = next : delete parent2[i2];
  if ((node = parent2[0] || parent2[1] || parent2[2] || parent2[3]) && node === (parent2[3] || parent2[2] || parent2[1] || parent2[0]) && !node.length) {
    if (retainer) retainer[j2] = node;
    else this._root = node;
  }
  return this;
}
function removeAll2(data) {
  for (var i2 = 0, n2 = data.length; i2 < n2; ++i2) this.remove(data[i2]);
  return this;
}

// node_modules/d3-quadtree/src/root.js
function root_default2() {
  return this._root;
}

// node_modules/d3-quadtree/src/size.js
function size_default2() {
  var size2 = 0;
  this.visit(function(node) {
    if (!node.length) do
      ++size2;
    while (node = node.next);
  });
  return size2;
}

// node_modules/d3-quadtree/src/visit.js
function visit_default2(callback) {
  var quads = [], q2, node = this._root, child, x0, y0, x1, y1;
  if (node) quads.push(new quad_default(node, this._x0, this._y0, this._x1, this._y1));
  while (q2 = quads.pop()) {
    if (!callback(node = q2.node, x0 = q2.x0, y0 = q2.y0, x1 = q2.x1, y1 = q2.y1) && node.length) {
      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[3]) quads.push(new quad_default(child, xm, ym, x1, y1));
      if (child = node[2]) quads.push(new quad_default(child, x0, ym, xm, y1));
      if (child = node[1]) quads.push(new quad_default(child, xm, y0, x1, ym));
      if (child = node[0]) quads.push(new quad_default(child, x0, y0, xm, ym));
    }
  }
  return this;
}

// node_modules/d3-quadtree/src/visitAfter.js
function visitAfter_default2(callback) {
  var quads = [], next = [], q2;
  if (this._root) quads.push(new quad_default(this._root, this._x0, this._y0, this._x1, this._y1));
  while (q2 = quads.pop()) {
    var node = q2.node;
    if (node.length) {
      var child, x0 = q2.x0, y0 = q2.y0, x1 = q2.x1, y1 = q2.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[0]) quads.push(new quad_default(child, x0, y0, xm, ym));
      if (child = node[1]) quads.push(new quad_default(child, xm, y0, x1, ym));
      if (child = node[2]) quads.push(new quad_default(child, x0, ym, xm, y1));
      if (child = node[3]) quads.push(new quad_default(child, xm, ym, x1, y1));
    }
    next.push(q2);
  }
  while (q2 = next.pop()) {
    callback(q2.node, q2.x0, q2.y0, q2.x1, q2.y1);
  }
  return this;
}

// node_modules/d3-quadtree/src/x.js
function defaultX2(d3) {
  return d3[0];
}
function x_default2(_2) {
  return arguments.length ? (this._x = _2, this) : this._x;
}

// node_modules/d3-quadtree/src/y.js
function defaultY(d3) {
  return d3[1];
}
function y_default(_2) {
  return arguments.length ? (this._y = _2, this) : this._y;
}

// node_modules/d3-quadtree/src/quadtree.js
function quadtree(nodes, x3, y3) {
  var tree = new Quadtree(x3 == null ? defaultX2 : x3, y3 == null ? defaultY : y3, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}
function Quadtree(x3, y3, x0, y0, x1, y1) {
  this._x = x3;
  this._y = y3;
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  this._root = void 0;
}
function leaf_copy2(leaf) {
  var copy3 = { data: leaf.data }, next = copy3;
  while (leaf = leaf.next) next = next.next = { data: leaf.data };
  return copy3;
}
var treeProto2 = quadtree.prototype = Quadtree.prototype;
treeProto2.copy = function() {
  var copy3 = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1), node = this._root, nodes, child;
  if (!node) return copy3;
  if (!node.length) return copy3._root = leaf_copy2(node), copy3;
  nodes = [{ source: node, target: copy3._root = new Array(4) }];
  while (node = nodes.pop()) {
    for (var i2 = 0; i2 < 4; ++i2) {
      if (child = node.source[i2]) {
        if (child.length) nodes.push({ source: child, target: node.target[i2] = new Array(4) });
        else node.target[i2] = leaf_copy2(child);
      }
    }
  }
  return copy3;
};
treeProto2.add = add_default2;
treeProto2.addAll = addAll2;
treeProto2.cover = cover_default2;
treeProto2.data = data_default2;
treeProto2.extent = extent_default2;
treeProto2.find = find_default2;
treeProto2.remove = remove_default2;
treeProto2.removeAll = removeAll2;
treeProto2.root = root_default2;
treeProto2.size = size_default2;
treeProto2.visit = visit_default2;
treeProto2.visitAfter = visitAfter_default2;
treeProto2.x = x_default2;
treeProto2.y = y_default;

// node_modules/d3-octree/src/add.js
function add_default3(d3) {
  const x3 = +this._x.call(null, d3), y3 = +this._y.call(null, d3), z3 = +this._z.call(null, d3);
  return add3(this.cover(x3, y3, z3), x3, y3, z3, d3);
}
function add3(tree, x3, y3, z3, d3) {
  if (isNaN(x3) || isNaN(y3) || isNaN(z3)) return tree;
  var parent2, node = tree._root, leaf = { data: d3 }, x0 = tree._x0, y0 = tree._y0, z0 = tree._z0, x1 = tree._x1, y1 = tree._y1, z1 = tree._z1, xm, ym, zm, xp, yp, zp, right, bottom, deep, i2, j2;
  if (!node) return tree._root = leaf, tree;
  while (node.length) {
    if (right = x3 >= (xm = (x0 + x1) / 2)) x0 = xm;
    else x1 = xm;
    if (bottom = y3 >= (ym = (y0 + y1) / 2)) y0 = ym;
    else y1 = ym;
    if (deep = z3 >= (zm = (z0 + z1) / 2)) z0 = zm;
    else z1 = zm;
    if (parent2 = node, !(node = node[i2 = deep << 2 | bottom << 1 | right])) return parent2[i2] = leaf, tree;
  }
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  zp = +tree._z.call(null, node.data);
  if (x3 === xp && y3 === yp && z3 === zp) return leaf.next = node, parent2 ? parent2[i2] = leaf : tree._root = leaf, tree;
  do {
    parent2 = parent2 ? parent2[i2] = new Array(8) : tree._root = new Array(8);
    if (right = x3 >= (xm = (x0 + x1) / 2)) x0 = xm;
    else x1 = xm;
    if (bottom = y3 >= (ym = (y0 + y1) / 2)) y0 = ym;
    else y1 = ym;
    if (deep = z3 >= (zm = (z0 + z1) / 2)) z0 = zm;
    else z1 = zm;
  } while ((i2 = deep << 2 | bottom << 1 | right) === (j2 = (zp >= zm) << 2 | (yp >= ym) << 1 | xp >= xm));
  return parent2[j2] = node, parent2[i2] = leaf, tree;
}
function addAll3(data) {
  if (!Array.isArray(data)) data = Array.from(data);
  const n2 = data.length;
  const xz = new Float64Array(n2);
  const yz = new Float64Array(n2);
  const zz = new Float64Array(n2);
  let x0 = Infinity, y0 = Infinity, z0 = Infinity, x1 = -Infinity, y1 = -Infinity, z1 = -Infinity;
  for (let i2 = 0, d3, x3, y3, z3; i2 < n2; ++i2) {
    if (isNaN(x3 = +this._x.call(null, d3 = data[i2])) || isNaN(y3 = +this._y.call(null, d3)) || isNaN(z3 = +this._z.call(null, d3))) continue;
    xz[i2] = x3;
    yz[i2] = y3;
    zz[i2] = z3;
    if (x3 < x0) x0 = x3;
    if (x3 > x1) x1 = x3;
    if (y3 < y0) y0 = y3;
    if (y3 > y1) y1 = y3;
    if (z3 < z0) z0 = z3;
    if (z3 > z1) z1 = z3;
  }
  if (x0 > x1 || y0 > y1 || z0 > z1) return this;
  this.cover(x0, y0, z0).cover(x1, y1, z1);
  for (let i2 = 0; i2 < n2; ++i2) {
    add3(this, xz[i2], yz[i2], zz[i2], data[i2]);
  }
  return this;
}

// node_modules/d3-octree/src/cover.js
function cover_default3(x3, y3, z3) {
  if (isNaN(x3 = +x3) || isNaN(y3 = +y3) || isNaN(z3 = +z3)) return this;
  var x0 = this._x0, y0 = this._y0, z0 = this._z0, x1 = this._x1, y1 = this._y1, z1 = this._z1;
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x3)) + 1;
    y1 = (y0 = Math.floor(y3)) + 1;
    z1 = (z0 = Math.floor(z3)) + 1;
  } else {
    var t5 = x1 - x0 || 1, node = this._root, parent2, i2;
    while (x0 > x3 || x3 >= x1 || y0 > y3 || y3 >= y1 || z0 > z3 || z3 >= z1) {
      i2 = (z3 < z0) << 2 | (y3 < y0) << 1 | x3 < x0;
      parent2 = new Array(8), parent2[i2] = node, node = parent2, t5 *= 2;
      switch (i2) {
        case 0:
          x1 = x0 + t5, y1 = y0 + t5, z1 = z0 + t5;
          break;
        case 1:
          x0 = x1 - t5, y1 = y0 + t5, z1 = z0 + t5;
          break;
        case 2:
          x1 = x0 + t5, y0 = y1 - t5, z1 = z0 + t5;
          break;
        case 3:
          x0 = x1 - t5, y0 = y1 - t5, z1 = z0 + t5;
          break;
        case 4:
          x1 = x0 + t5, y1 = y0 + t5, z0 = z1 - t5;
          break;
        case 5:
          x0 = x1 - t5, y1 = y0 + t5, z0 = z1 - t5;
          break;
        case 6:
          x1 = x0 + t5, y0 = y1 - t5, z0 = z1 - t5;
          break;
        case 7:
          x0 = x1 - t5, y0 = y1 - t5, z0 = z1 - t5;
          break;
      }
    }
    if (this._root && this._root.length) this._root = node;
  }
  this._x0 = x0;
  this._y0 = y0;
  this._z0 = z0;
  this._x1 = x1;
  this._y1 = y1;
  this._z1 = z1;
  return this;
}

// node_modules/d3-octree/src/data.js
function data_default3() {
  var data = [];
  this.visit(function(node) {
    if (!node.length) do
      data.push(node.data);
    while (node = node.next);
  });
  return data;
}

// node_modules/d3-octree/src/extent.js
function extent_default3(_2) {
  return arguments.length ? this.cover(+_2[0][0], +_2[0][1], +_2[0][2]).cover(+_2[1][0], +_2[1][1], +_2[1][2]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0, this._z0], [this._x1, this._y1, this._z1]];
}

// node_modules/d3-octree/src/octant.js
function octant_default(node, x0, y0, z0, x1, y1, z1) {
  this.node = node;
  this.x0 = x0;
  this.y0 = y0;
  this.z0 = z0;
  this.x1 = x1;
  this.y1 = y1;
  this.z1 = z1;
}

// node_modules/d3-octree/src/find.js
function find_default3(x3, y3, z3, radius) {
  var data, x0 = this._x0, y0 = this._y0, z0 = this._z0, x1, y1, z1, x22, y22, z22, x32 = this._x1, y32 = this._y1, z32 = this._z1, octs = [], node = this._root, q2, i2;
  if (node) octs.push(new octant_default(node, x0, y0, z0, x32, y32, z32));
  if (radius == null) radius = Infinity;
  else {
    x0 = x3 - radius, y0 = y3 - radius, z0 = z3 - radius;
    x32 = x3 + radius, y32 = y3 + radius, z32 = z3 + radius;
    radius *= radius;
  }
  while (q2 = octs.pop()) {
    if (!(node = q2.node) || (x1 = q2.x0) > x32 || (y1 = q2.y0) > y32 || (z1 = q2.z0) > z32 || (x22 = q2.x1) < x0 || (y22 = q2.y1) < y0 || (z22 = q2.z1) < z0) continue;
    if (node.length) {
      var xm = (x1 + x22) / 2, ym = (y1 + y22) / 2, zm = (z1 + z22) / 2;
      octs.push(
        new octant_default(node[7], xm, ym, zm, x22, y22, z22),
        new octant_default(node[6], x1, ym, zm, xm, y22, z22),
        new octant_default(node[5], xm, y1, zm, x22, ym, z22),
        new octant_default(node[4], x1, y1, zm, xm, ym, z22),
        new octant_default(node[3], xm, ym, z1, x22, y22, zm),
        new octant_default(node[2], x1, ym, z1, xm, y22, zm),
        new octant_default(node[1], xm, y1, z1, x22, ym, zm),
        new octant_default(node[0], x1, y1, z1, xm, ym, zm)
      );
      if (i2 = (z3 >= zm) << 2 | (y3 >= ym) << 1 | x3 >= xm) {
        q2 = octs[octs.length - 1];
        octs[octs.length - 1] = octs[octs.length - 1 - i2];
        octs[octs.length - 1 - i2] = q2;
      }
    } else {
      var dx = x3 - +this._x.call(null, node.data), dy = y3 - +this._y.call(null, node.data), dz = z3 - +this._z.call(null, node.data), d22 = dx * dx + dy * dy + dz * dz;
      if (d22 < radius) {
        var d3 = Math.sqrt(radius = d22);
        x0 = x3 - d3, y0 = y3 - d3, z0 = z3 - d3;
        x32 = x3 + d3, y32 = y3 + d3, z32 = z3 + d3;
        data = node.data;
      }
    }
  }
  return data;
}

// node_modules/d3-octree/src/findAll.js
var distance2 = (x1, y1, z1, x22, y22, z22) => Math.sqrt((x1 - x22) ** 2 + (y1 - y22) ** 2 + (z1 - z22) ** 2);
function findAllWithinRadius(x3, y3, z3, radius) {
  const result2 = [];
  const xMin = x3 - radius;
  const yMin = y3 - radius;
  const zMin = z3 - radius;
  const xMax = x3 + radius;
  const yMax = y3 + radius;
  const zMax = z3 + radius;
  this.visit((node, x1, y1, z1, x22, y22, z22) => {
    if (!node.length) {
      do {
        const d3 = node.data;
        if (distance2(x3, y3, z3, this._x(d3), this._y(d3), this._z(d3)) <= radius) {
          result2.push(d3);
        }
      } while (node = node.next);
    }
    return x1 > xMax || y1 > yMax || z1 > zMax || x22 < xMin || y22 < yMin || z22 < zMin;
  });
  return result2;
}

// node_modules/d3-octree/src/remove.js
function remove_default3(d3) {
  if (isNaN(x3 = +this._x.call(null, d3)) || isNaN(y3 = +this._y.call(null, d3)) || isNaN(z3 = +this._z.call(null, d3))) return this;
  var parent2, node = this._root, retainer, previous, next, x0 = this._x0, y0 = this._y0, z0 = this._z0, x1 = this._x1, y1 = this._y1, z1 = this._z1, x3, y3, z3, xm, ym, zm, right, bottom, deep, i2, j2;
  if (!node) return this;
  if (node.length) while (true) {
    if (right = x3 >= (xm = (x0 + x1) / 2)) x0 = xm;
    else x1 = xm;
    if (bottom = y3 >= (ym = (y0 + y1) / 2)) y0 = ym;
    else y1 = ym;
    if (deep = z3 >= (zm = (z0 + z1) / 2)) z0 = zm;
    else z1 = zm;
    if (!(parent2 = node, node = node[i2 = deep << 2 | bottom << 1 | right])) return this;
    if (!node.length) break;
    if (parent2[i2 + 1 & 7] || parent2[i2 + 2 & 7] || parent2[i2 + 3 & 7] || parent2[i2 + 4 & 7] || parent2[i2 + 5 & 7] || parent2[i2 + 6 & 7] || parent2[i2 + 7 & 7]) retainer = parent2, j2 = i2;
  }
  while (node.data !== d3) if (!(previous = node, node = node.next)) return this;
  if (next = node.next) delete node.next;
  if (previous) return next ? previous.next = next : delete previous.next, this;
  if (!parent2) return this._root = next, this;
  next ? parent2[i2] = next : delete parent2[i2];
  if ((node = parent2[0] || parent2[1] || parent2[2] || parent2[3] || parent2[4] || parent2[5] || parent2[6] || parent2[7]) && node === (parent2[7] || parent2[6] || parent2[5] || parent2[4] || parent2[3] || parent2[2] || parent2[1] || parent2[0]) && !node.length) {
    if (retainer) retainer[j2] = node;
    else this._root = node;
  }
  return this;
}
function removeAll3(data) {
  for (var i2 = 0, n2 = data.length; i2 < n2; ++i2) this.remove(data[i2]);
  return this;
}

// node_modules/d3-octree/src/root.js
function root_default3() {
  return this._root;
}

// node_modules/d3-octree/src/size.js
function size_default3() {
  var size2 = 0;
  this.visit(function(node) {
    if (!node.length) do
      ++size2;
    while (node = node.next);
  });
  return size2;
}

// node_modules/d3-octree/src/visit.js
function visit_default3(callback) {
  var octs = [], q2, node = this._root, child, x0, y0, z0, x1, y1, z1;
  if (node) octs.push(new octant_default(node, this._x0, this._y0, this._z0, this._x1, this._y1, this._z1));
  while (q2 = octs.pop()) {
    if (!callback(node = q2.node, x0 = q2.x0, y0 = q2.y0, z0 = q2.z0, x1 = q2.x1, y1 = q2.y1, z1 = q2.z1) && node.length) {
      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2, zm = (z0 + z1) / 2;
      if (child = node[7]) octs.push(new octant_default(child, xm, ym, zm, x1, y1, z1));
      if (child = node[6]) octs.push(new octant_default(child, x0, ym, zm, xm, y1, z1));
      if (child = node[5]) octs.push(new octant_default(child, xm, y0, zm, x1, ym, z1));
      if (child = node[4]) octs.push(new octant_default(child, x0, y0, zm, xm, ym, z1));
      if (child = node[3]) octs.push(new octant_default(child, xm, ym, z0, x1, y1, zm));
      if (child = node[2]) octs.push(new octant_default(child, x0, ym, z0, xm, y1, zm));
      if (child = node[1]) octs.push(new octant_default(child, xm, y0, z0, x1, ym, zm));
      if (child = node[0]) octs.push(new octant_default(child, x0, y0, z0, xm, ym, zm));
    }
  }
  return this;
}

// node_modules/d3-octree/src/visitAfter.js
function visitAfter_default3(callback) {
  var octs = [], next = [], q2;
  if (this._root) octs.push(new octant_default(this._root, this._x0, this._y0, this._z0, this._x1, this._y1, this._z1));
  while (q2 = octs.pop()) {
    var node = q2.node;
    if (node.length) {
      var child, x0 = q2.x0, y0 = q2.y0, z0 = q2.z0, x1 = q2.x1, y1 = q2.y1, z1 = q2.z1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2, zm = (z0 + z1) / 2;
      if (child = node[0]) octs.push(new octant_default(child, x0, y0, z0, xm, ym, zm));
      if (child = node[1]) octs.push(new octant_default(child, xm, y0, z0, x1, ym, zm));
      if (child = node[2]) octs.push(new octant_default(child, x0, ym, z0, xm, y1, zm));
      if (child = node[3]) octs.push(new octant_default(child, xm, ym, z0, x1, y1, zm));
      if (child = node[4]) octs.push(new octant_default(child, x0, y0, zm, xm, ym, z1));
      if (child = node[5]) octs.push(new octant_default(child, xm, y0, zm, x1, ym, z1));
      if (child = node[6]) octs.push(new octant_default(child, x0, ym, zm, xm, y1, z1));
      if (child = node[7]) octs.push(new octant_default(child, xm, ym, zm, x1, y1, z1));
    }
    next.push(q2);
  }
  while (q2 = next.pop()) {
    callback(q2.node, q2.x0, q2.y0, q2.z0, q2.x1, q2.y1, q2.z1);
  }
  return this;
}

// node_modules/d3-octree/src/x.js
function defaultX3(d3) {
  return d3[0];
}
function x_default3(_2) {
  return arguments.length ? (this._x = _2, this) : this._x;
}

// node_modules/d3-octree/src/y.js
function defaultY2(d3) {
  return d3[1];
}
function y_default2(_2) {
  return arguments.length ? (this._y = _2, this) : this._y;
}

// node_modules/d3-octree/src/z.js
function defaultZ(d3) {
  return d3[2];
}
function z_default(_2) {
  return arguments.length ? (this._z = _2, this) : this._z;
}

// node_modules/d3-octree/src/octree.js
function octree(nodes, x3, y3, z3) {
  var tree = new Octree(x3 == null ? defaultX3 : x3, y3 == null ? defaultY2 : y3, z3 == null ? defaultZ : z3, NaN, NaN, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}
function Octree(x3, y3, z3, x0, y0, z0, x1, y1, z1) {
  this._x = x3;
  this._y = y3;
  this._z = z3;
  this._x0 = x0;
  this._y0 = y0;
  this._z0 = z0;
  this._x1 = x1;
  this._y1 = y1;
  this._z1 = z1;
  this._root = void 0;
}
function leaf_copy3(leaf) {
  var copy3 = { data: leaf.data }, next = copy3;
  while (leaf = leaf.next) next = next.next = { data: leaf.data };
  return copy3;
}
var treeProto3 = octree.prototype = Octree.prototype;
treeProto3.copy = function() {
  var copy3 = new Octree(this._x, this._y, this._z, this._x0, this._y0, this._z0, this._x1, this._y1, this._z1), node = this._root, nodes, child;
  if (!node) return copy3;
  if (!node.length) return copy3._root = leaf_copy3(node), copy3;
  nodes = [{ source: node, target: copy3._root = new Array(8) }];
  while (node = nodes.pop()) {
    for (var i2 = 0; i2 < 8; ++i2) {
      if (child = node.source[i2]) {
        if (child.length) nodes.push({ source: child, target: node.target[i2] = new Array(8) });
        else node.target[i2] = leaf_copy3(child);
      }
    }
  }
  return copy3;
};
treeProto3.add = add_default3;
treeProto3.addAll = addAll3;
treeProto3.cover = cover_default3;
treeProto3.data = data_default3;
treeProto3.extent = extent_default3;
treeProto3.find = find_default3;
treeProto3.findAllWithinRadius = findAllWithinRadius;
treeProto3.remove = remove_default3;
treeProto3.removeAll = removeAll3;
treeProto3.root = root_default3;
treeProto3.size = size_default3;
treeProto3.visit = visit_default3;
treeProto3.visitAfter = visitAfter_default3;
treeProto3.x = x_default3;
treeProto3.y = y_default2;
treeProto3.z = z_default;

// node_modules/d3-force-3d/src/constant.js
function constant_default(x3) {
  return function() {
    return x3;
  };
}

// node_modules/d3-force-3d/src/jiggle.js
function jiggle_default(random2) {
  return (random2() - 0.5) * 1e-6;
}

// node_modules/d3-force-3d/src/link.js
function index2(d3) {
  return d3.index;
}
function find(nodeById, nodeId) {
  var node = nodeById.get(nodeId);
  if (!node) throw new Error("node not found: " + nodeId);
  return node;
}
function link_default(links) {
  var id2 = index2, strength = defaultStrength, strengths, distance4 = constant_default(30), distances, nodes, nDim, count2, bias, random2, iterations = 1;
  if (links == null) links = [];
  function defaultStrength(link) {
    return 1 / Math.min(count2[link.source.index], count2[link.target.index]);
  }
  function force(alpha) {
    for (var k2 = 0, n2 = links.length; k2 < iterations; ++k2) {
      for (var i2 = 0, link, source, target, x3 = 0, y3 = 0, z3 = 0, l2, b; i2 < n2; ++i2) {
        link = links[i2], source = link.source, target = link.target;
        x3 = target.x + target.vx - source.x - source.vx || jiggle_default(random2);
        if (nDim > 1) {
          y3 = target.y + target.vy - source.y - source.vy || jiggle_default(random2);
        }
        if (nDim > 2) {
          z3 = target.z + target.vz - source.z - source.vz || jiggle_default(random2);
        }
        l2 = Math.sqrt(x3 * x3 + y3 * y3 + z3 * z3);
        l2 = (l2 - distances[i2]) / l2 * alpha * strengths[i2];
        x3 *= l2, y3 *= l2, z3 *= l2;
        target.vx -= x3 * (b = bias[i2]);
        if (nDim > 1) {
          target.vy -= y3 * b;
        }
        if (nDim > 2) {
          target.vz -= z3 * b;
        }
        source.vx += x3 * (b = 1 - b);
        if (nDim > 1) {
          source.vy += y3 * b;
        }
        if (nDim > 2) {
          source.vz += z3 * b;
        }
      }
    }
  }
  function initialize() {
    if (!nodes) return;
    var i2, n2 = nodes.length, m3 = links.length, nodeById = new Map(nodes.map((d3, i3) => [id2(d3, i3, nodes), d3])), link;
    for (i2 = 0, count2 = new Array(n2); i2 < m3; ++i2) {
      link = links[i2], link.index = i2;
      if (typeof link.source !== "object") link.source = find(nodeById, link.source);
      if (typeof link.target !== "object") link.target = find(nodeById, link.target);
      count2[link.source.index] = (count2[link.source.index] || 0) + 1;
      count2[link.target.index] = (count2[link.target.index] || 0) + 1;
    }
    for (i2 = 0, bias = new Array(m3); i2 < m3; ++i2) {
      link = links[i2], bias[i2] = count2[link.source.index] / (count2[link.source.index] + count2[link.target.index]);
    }
    strengths = new Array(m3), initializeStrength();
    distances = new Array(m3), initializeDistance();
  }
  function initializeStrength() {
    if (!nodes) return;
    for (var i2 = 0, n2 = links.length; i2 < n2; ++i2) {
      strengths[i2] = +strength(links[i2], i2, links);
    }
  }
  function initializeDistance() {
    if (!nodes) return;
    for (var i2 = 0, n2 = links.length; i2 < n2; ++i2) {
      distances[i2] = +distance4(links[i2], i2, links);
    }
  }
  force.initialize = function(_nodes, ...args) {
    nodes = _nodes;
    random2 = args.find((arg) => typeof arg === "function") || Math.random;
    nDim = args.find((arg) => [1, 2, 3].includes(arg)) || 2;
    initialize();
  };
  force.links = function(_2) {
    return arguments.length ? (links = _2, initialize(), force) : links;
  };
  force.id = function(_2) {
    return arguments.length ? (id2 = _2, force) : id2;
  };
  force.iterations = function(_2) {
    return arguments.length ? (iterations = +_2, force) : iterations;
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default(+_2), initializeStrength(), force) : strength;
  };
  force.distance = function(_2) {
    return arguments.length ? (distance4 = typeof _2 === "function" ? _2 : constant_default(+_2), initializeDistance(), force) : distance4;
  };
  return force;
}

// node_modules/d3-dispatch/src/dispatch.js
var noop = { value: () => {
} };
function dispatch() {
  for (var i2 = 0, n2 = arguments.length, _2 = {}, t5; i2 < n2; ++i2) {
    if (!(t5 = arguments[i2] + "") || t5 in _2 || /[\s.]/.test(t5)) throw new Error("illegal type: " + t5);
    _2[t5] = [];
  }
  return new Dispatch(_2);
}
function Dispatch(_2) {
  this._ = _2;
}
function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t5) {
    var name = "", i2 = t5.indexOf(".");
    if (i2 >= 0) name = t5.slice(i2 + 1), t5 = t5.slice(0, i2);
    if (t5 && !types.hasOwnProperty(t5)) throw new Error("unknown type: " + t5);
    return { type: t5, name };
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _2 = this._, T3 = parseTypenames(typename + "", _2), t5, i2 = -1, n2 = T3.length;
    if (arguments.length < 2) {
      while (++i2 < n2) if ((t5 = (typename = T3[i2]).type) && (t5 = get(_2[t5], typename.name))) return t5;
      return;
    }
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i2 < n2) {
      if (t5 = (typename = T3[i2]).type) _2[t5] = set(_2[t5], typename.name, callback);
      else if (callback == null) for (t5 in _2) _2[t5] = set(_2[t5], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy3 = {}, _2 = this._;
    for (var t5 in _2) copy3[t5] = _2[t5].slice();
    return new Dispatch(copy3);
  },
  call: function(type, that) {
    if ((n2 = arguments.length - 2) > 0) for (var args = new Array(n2), i2 = 0, n2, t5; i2 < n2; ++i2) args[i2] = arguments[i2 + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t5 = this._[type], i2 = 0, n2 = t5.length; i2 < n2; ++i2) t5[i2].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t5 = this._[type], i2 = 0, n2 = t5.length; i2 < n2; ++i2) t5[i2].value.apply(that, args);
  }
};
function get(type, name) {
  for (var i2 = 0, n2 = type.length, c5; i2 < n2; ++i2) {
    if ((c5 = type[i2]).name === name) {
      return c5.value;
    }
  }
}
function set(type, name, callback) {
  for (var i2 = 0, n2 = type.length; i2 < n2; ++i2) {
    if (type[i2].name === name) {
      type[i2] = noop, type = type.slice(0, i2).concat(type.slice(i2 + 1));
      break;
    }
  }
  if (callback != null) type.push({ name, value: callback });
  return type;
}
var dispatch_default = dispatch;

// node_modules/d3-timer/src/timer.js
var frame = 0;
var timeout = 0;
var interval = 0;
var pokeDelay = 1e3;
var taskHead;
var taskTail;
var clockLast = 0;
var clockNow = 0;
var clockSkew = 0;
var clock = typeof performance === "object" && performance.now ? performance : Date;
var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f3) {
  setTimeout(f3, 17);
};
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay2, time3) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time3 = (time3 == null ? now() : +time3) + (delay2 == null ? 0 : +delay2);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time3;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay2, time3) {
  var t5 = new Timer();
  t5.restart(callback, delay2, time3);
  return t5;
}
function timerFlush() {
  now();
  ++frame;
  var t5 = taskHead, e3;
  while (t5) {
    if ((e3 = clockNow - t5._time) >= 0) t5._call.call(void 0, e3);
    t5 = t5._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now4 = clock.now(), delay2 = now4 - clockLast;
  if (delay2 > pokeDelay) clockSkew -= delay2, clockLast = now4;
}
function nap() {
  var t03, t13 = taskHead, t22, time3 = Infinity;
  while (t13) {
    if (t13._call) {
      if (time3 > t13._time) time3 = t13._time;
      t03 = t13, t13 = t13._next;
    } else {
      t22 = t13._next, t13._next = null;
      t13 = t03 ? t03._next = t22 : taskHead = t22;
    }
  }
  taskTail = t03;
  sleep(time3);
}
function sleep(time3) {
  if (frame) return;
  if (timeout) timeout = clearTimeout(timeout);
  var delay2 = time3 - clockNow;
  if (delay2 > 24) {
    if (time3 < Infinity) timeout = setTimeout(wake, time3 - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

// node_modules/d3-timer/src/timeout.js
function timeout_default(callback, delay2, time3) {
  var t5 = new Timer();
  delay2 = delay2 == null ? 0 : +delay2;
  t5.restart((elapsed) => {
    t5.stop();
    callback(elapsed + delay2);
  }, delay2, time3);
  return t5;
}

// node_modules/d3-force-3d/src/lcg.js
var a = 1664525;
var c = 1013904223;
var m = 4294967296;
function lcg_default() {
  let s2 = 1;
  return () => (s2 = (a * s2 + c) % m) / m;
}

// node_modules/d3-force-3d/src/simulation.js
var MAX_DIMENSIONS = 3;
function x(d3) {
  return d3.x;
}
function y(d3) {
  return d3.y;
}
function z(d3) {
  return d3.z;
}
var initialRadius = 10;
var initialAngleRoll = Math.PI * (3 - Math.sqrt(5));
var initialAngleYaw = Math.PI * 20 / (9 + Math.sqrt(221));
function simulation_default(nodes, numDimensions) {
  numDimensions = numDimensions || 2;
  var nDim = Math.min(MAX_DIMENSIONS, Math.max(1, Math.round(numDimensions))), simulation, alpha = 1, alphaMin = 1e-3, alphaDecay = 1 - Math.pow(alphaMin, 1 / 300), alphaTarget = 0, velocityDecay = 0.6, forces = /* @__PURE__ */ new Map(), stepper = timer(step2), event = dispatch_default("tick", "end"), random2 = lcg_default();
  if (nodes == null) nodes = [];
  function step2() {
    tick2();
    event.call("tick", simulation);
    if (alpha < alphaMin) {
      stepper.stop();
      event.call("end", simulation);
    }
  }
  function tick2(iterations) {
    var i2, n2 = nodes.length, node;
    if (iterations === void 0) iterations = 1;
    for (var k2 = 0; k2 < iterations; ++k2) {
      alpha += (alphaTarget - alpha) * alphaDecay;
      forces.forEach(function(force) {
        force(alpha);
      });
      for (i2 = 0; i2 < n2; ++i2) {
        node = nodes[i2];
        if (node.fx == null) node.x += node.vx *= velocityDecay;
        else node.x = node.fx, node.vx = 0;
        if (nDim > 1) {
          if (node.fy == null) node.y += node.vy *= velocityDecay;
          else node.y = node.fy, node.vy = 0;
        }
        if (nDim > 2) {
          if (node.fz == null) node.z += node.vz *= velocityDecay;
          else node.z = node.fz, node.vz = 0;
        }
      }
    }
    return simulation;
  }
  function initializeNodes() {
    for (var i2 = 0, n2 = nodes.length, node; i2 < n2; ++i2) {
      node = nodes[i2], node.index = i2;
      if (node.fx != null) node.x = node.fx;
      if (node.fy != null) node.y = node.fy;
      if (node.fz != null) node.z = node.fz;
      if (isNaN(node.x) || nDim > 1 && isNaN(node.y) || nDim > 2 && isNaN(node.z)) {
        var radius = initialRadius * (nDim > 2 ? Math.cbrt(0.5 + i2) : nDim > 1 ? Math.sqrt(0.5 + i2) : i2), rollAngle = i2 * initialAngleRoll, yawAngle = i2 * initialAngleYaw;
        if (nDim === 1) {
          node.x = radius;
        } else if (nDim === 2) {
          node.x = radius * Math.cos(rollAngle);
          node.y = radius * Math.sin(rollAngle);
        } else {
          node.x = radius * Math.sin(rollAngle) * Math.cos(yawAngle);
          node.y = radius * Math.cos(rollAngle);
          node.z = radius * Math.sin(rollAngle) * Math.sin(yawAngle);
        }
      }
      if (isNaN(node.vx) || nDim > 1 && isNaN(node.vy) || nDim > 2 && isNaN(node.vz)) {
        node.vx = 0;
        if (nDim > 1) {
          node.vy = 0;
        }
        if (nDim > 2) {
          node.vz = 0;
        }
      }
    }
  }
  function initializeForce(force) {
    if (force.initialize) force.initialize(nodes, random2, nDim);
    return force;
  }
  initializeNodes();
  return simulation = {
    tick: tick2,
    restart: function() {
      return stepper.restart(step2), simulation;
    },
    stop: function() {
      return stepper.stop(), simulation;
    },
    numDimensions: function(_2) {
      return arguments.length ? (nDim = Math.min(MAX_DIMENSIONS, Math.max(1, Math.round(_2))), forces.forEach(initializeForce), simulation) : nDim;
    },
    nodes: function(_2) {
      return arguments.length ? (nodes = _2, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
    },
    alpha: function(_2) {
      return arguments.length ? (alpha = +_2, simulation) : alpha;
    },
    alphaMin: function(_2) {
      return arguments.length ? (alphaMin = +_2, simulation) : alphaMin;
    },
    alphaDecay: function(_2) {
      return arguments.length ? (alphaDecay = +_2, simulation) : +alphaDecay;
    },
    alphaTarget: function(_2) {
      return arguments.length ? (alphaTarget = +_2, simulation) : alphaTarget;
    },
    velocityDecay: function(_2) {
      return arguments.length ? (velocityDecay = 1 - _2, simulation) : 1 - velocityDecay;
    },
    randomSource: function(_2) {
      return arguments.length ? (random2 = _2, forces.forEach(initializeForce), simulation) : random2;
    },
    force: function(name, _2) {
      return arguments.length > 1 ? (_2 == null ? forces.delete(name) : forces.set(name, initializeForce(_2)), simulation) : forces.get(name);
    },
    find: function() {
      var args = Array.prototype.slice.call(arguments);
      var x3 = args.shift() || 0, y3 = (nDim > 1 ? args.shift() : null) || 0, z3 = (nDim > 2 ? args.shift() : null) || 0, radius = args.shift() || Infinity;
      var i2 = 0, n2 = nodes.length, dx, dy, dz, d22, node, closest;
      radius *= radius;
      for (i2 = 0; i2 < n2; ++i2) {
        node = nodes[i2];
        dx = x3 - node.x;
        dy = y3 - (node.y || 0);
        dz = z3 - (node.z || 0);
        d22 = dx * dx + dy * dy + dz * dz;
        if (d22 < radius) closest = node, radius = d22;
      }
      return closest;
    },
    on: function(name, _2) {
      return arguments.length > 1 ? (event.on(name, _2), simulation) : event.on(name);
    }
  };
}

// node_modules/d3-force-3d/src/manyBody.js
function manyBody_default() {
  var nodes, nDim, node, random2, alpha, strength = constant_default(-30), strengths, distanceMin2 = 1, distanceMax2 = Infinity, theta2 = 0.81;
  function force(_2) {
    var i2, n2 = nodes.length, tree = (nDim === 1 ? binarytree(nodes, x) : nDim === 2 ? quadtree(nodes, x, y) : nDim === 3 ? octree(nodes, x, y, z) : null).visitAfter(accumulate);
    for (alpha = _2, i2 = 0; i2 < n2; ++i2) node = nodes[i2], tree.visit(apply2);
  }
  function initialize() {
    if (!nodes) return;
    var i2, n2 = nodes.length, node2;
    strengths = new Array(n2);
    for (i2 = 0; i2 < n2; ++i2) node2 = nodes[i2], strengths[node2.index] = +strength(node2, i2, nodes);
  }
  function accumulate(treeNode) {
    var strength2 = 0, q2, c5, weight = 0, x3, y3, z3, i2;
    var numChildren = treeNode.length;
    if (numChildren) {
      for (x3 = y3 = z3 = i2 = 0; i2 < numChildren; ++i2) {
        if ((q2 = treeNode[i2]) && (c5 = Math.abs(q2.value))) {
          strength2 += q2.value, weight += c5, x3 += c5 * (q2.x || 0), y3 += c5 * (q2.y || 0), z3 += c5 * (q2.z || 0);
        }
      }
      strength2 *= Math.sqrt(4 / numChildren);
      treeNode.x = x3 / weight;
      if (nDim > 1) {
        treeNode.y = y3 / weight;
      }
      if (nDim > 2) {
        treeNode.z = z3 / weight;
      }
    } else {
      q2 = treeNode;
      q2.x = q2.data.x;
      if (nDim > 1) {
        q2.y = q2.data.y;
      }
      if (nDim > 2) {
        q2.z = q2.data.z;
      }
      do
        strength2 += strengths[q2.data.index];
      while (q2 = q2.next);
    }
    treeNode.value = strength2;
  }
  function apply2(treeNode, x1, arg1, arg2, arg3) {
    if (!treeNode.value) return true;
    var x22 = [arg1, arg2, arg3][nDim - 1];
    var x3 = treeNode.x - node.x, y3 = nDim > 1 ? treeNode.y - node.y : 0, z3 = nDim > 2 ? treeNode.z - node.z : 0, w4 = x22 - x1, l2 = x3 * x3 + y3 * y3 + z3 * z3;
    if (w4 * w4 / theta2 < l2) {
      if (l2 < distanceMax2) {
        if (x3 === 0) x3 = jiggle_default(random2), l2 += x3 * x3;
        if (nDim > 1 && y3 === 0) y3 = jiggle_default(random2), l2 += y3 * y3;
        if (nDim > 2 && z3 === 0) z3 = jiggle_default(random2), l2 += z3 * z3;
        if (l2 < distanceMin2) l2 = Math.sqrt(distanceMin2 * l2);
        node.vx += x3 * treeNode.value * alpha / l2;
        if (nDim > 1) {
          node.vy += y3 * treeNode.value * alpha / l2;
        }
        if (nDim > 2) {
          node.vz += z3 * treeNode.value * alpha / l2;
        }
      }
      return true;
    } else if (treeNode.length || l2 >= distanceMax2) return;
    if (treeNode.data !== node || treeNode.next) {
      if (x3 === 0) x3 = jiggle_default(random2), l2 += x3 * x3;
      if (nDim > 1 && y3 === 0) y3 = jiggle_default(random2), l2 += y3 * y3;
      if (nDim > 2 && z3 === 0) z3 = jiggle_default(random2), l2 += z3 * z3;
      if (l2 < distanceMin2) l2 = Math.sqrt(distanceMin2 * l2);
    }
    do
      if (treeNode.data !== node) {
        w4 = strengths[treeNode.data.index] * alpha / l2;
        node.vx += x3 * w4;
        if (nDim > 1) {
          node.vy += y3 * w4;
        }
        if (nDim > 2) {
          node.vz += z3 * w4;
        }
      }
    while (treeNode = treeNode.next);
  }
  force.initialize = function(_nodes, ...args) {
    nodes = _nodes;
    random2 = args.find((arg) => typeof arg === "function") || Math.random;
    nDim = args.find((arg) => [1, 2, 3].includes(arg)) || 2;
    initialize();
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default(+_2), initialize(), force) : strength;
  };
  force.distanceMin = function(_2) {
    return arguments.length ? (distanceMin2 = _2 * _2, force) : Math.sqrt(distanceMin2);
  };
  force.distanceMax = function(_2) {
    return arguments.length ? (distanceMax2 = _2 * _2, force) : Math.sqrt(distanceMax2);
  };
  force.theta = function(_2) {
    return arguments.length ? (theta2 = _2 * _2, force) : Math.sqrt(theta2);
  };
  return force;
}

// node_modules/d3-force-3d/src/radial.js
function radial_default(radius, x3, y3, z3) {
  var nodes, nDim, strength = constant_default(0.1), strengths, radiuses;
  if (typeof radius !== "function") radius = constant_default(+radius);
  if (x3 == null) x3 = 0;
  if (y3 == null) y3 = 0;
  if (z3 == null) z3 = 0;
  function force(alpha) {
    for (var i2 = 0, n2 = nodes.length; i2 < n2; ++i2) {
      var node = nodes[i2], dx = node.x - x3 || 1e-6, dy = (node.y || 0) - y3 || 1e-6, dz = (node.z || 0) - z3 || 1e-6, r2 = Math.sqrt(dx * dx + dy * dy + dz * dz), k2 = (radiuses[i2] - r2) * strengths[i2] * alpha / r2;
      node.vx += dx * k2;
      if (nDim > 1) {
        node.vy += dy * k2;
      }
      if (nDim > 2) {
        node.vz += dz * k2;
      }
    }
  }
  function initialize() {
    if (!nodes) return;
    var i2, n2 = nodes.length;
    strengths = new Array(n2);
    radiuses = new Array(n2);
    for (i2 = 0; i2 < n2; ++i2) {
      radiuses[i2] = +radius(nodes[i2], i2, nodes);
      strengths[i2] = isNaN(radiuses[i2]) ? 0 : +strength(nodes[i2], i2, nodes);
    }
  }
  force.initialize = function(initNodes, ...args) {
    nodes = initNodes;
    nDim = args.find((arg) => [1, 2, 3].includes(arg)) || 2;
    initialize();
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default(+_2), initialize(), force) : strength;
  };
  force.radius = function(_2) {
    return arguments.length ? (radius = typeof _2 === "function" ? _2 : constant_default(+_2), initialize(), force) : radius;
  };
  force.x = function(_2) {
    return arguments.length ? (x3 = +_2, force) : x3;
  };
  force.y = function(_2) {
    return arguments.length ? (y3 = +_2, force) : y3;
  };
  force.z = function(_2) {
    return arguments.length ? (z3 = +_2, force) : z3;
  };
  return force;
}

// node_modules/ngraph.events/index.js
function eventify(subject) {
  validateSubject(subject);
  const eventsStorage = createEventsStorage(subject);
  subject.on = eventsStorage.on;
  subject.off = eventsStorage.off;
  subject.fire = eventsStorage.fire;
  return subject;
}
function createEventsStorage(subject) {
  let registeredEvents = /* @__PURE__ */ Object.create(null);
  return {
    on: function(eventName, callback, ctx) {
      if (typeof callback !== "function") {
        throw new Error("callback is expected to be a function");
      }
      let handlers = registeredEvents[eventName];
      if (!handlers) {
        handlers = registeredEvents[eventName] = [];
      }
      handlers.push({ callback, ctx });
      return subject;
    },
    off: function(eventName, callback) {
      const wantToRemoveAll = typeof eventName === "undefined";
      if (wantToRemoveAll) {
        registeredEvents = /* @__PURE__ */ Object.create(null);
        return subject;
      }
      if (registeredEvents[eventName]) {
        const deleteAllCallbacksForEvent = typeof callback !== "function";
        if (deleteAllCallbacksForEvent) {
          delete registeredEvents[eventName];
        } else {
          const callbacks = registeredEvents[eventName];
          for (let i2 = 0; i2 < callbacks.length; ++i2) {
            if (callbacks[i2].callback === callback) {
              callbacks.splice(i2, 1);
            }
          }
        }
      }
      return subject;
    },
    fire: function(eventName) {
      const callbacks = registeredEvents[eventName];
      if (!callbacks) {
        return subject;
      }
      let fireArguments;
      if (arguments.length > 1) {
        fireArguments = Array.prototype.slice.call(arguments, 1);
      }
      for (let i2 = 0; i2 < callbacks.length; ++i2) {
        const callbackInfo = callbacks[i2];
        callbackInfo.callback.apply(callbackInfo.ctx, fireArguments);
      }
      return subject;
    }
  };
}
function validateSubject(subject) {
  if (!subject) {
    throw new Error("Eventify cannot use falsy object as events subject");
  }
  const reservedWords = ["on", "fire", "off"];
  for (let i2 = 0; i2 < reservedWords.length; ++i2) {
    if (subject.hasOwnProperty(reservedWords[i2])) {
      throw new Error("Subject cannot be eventified, since it already has property '" + reservedWords[i2] + "'");
    }
  }
}

// node_modules/ngraph.graph/index.js
var ngraph_default = createGraph;
function createGraph(options) {
  options = options || {};
  if ("uniqueLinkId" in options) {
    console.warn(
      "ngraph.graph: Starting from version 0.14 `uniqueLinkId` is deprecated.\nUse `multigraph` option instead\n",
      "\n",
      "Note: there is also change in default behavior: From now on each graph\nis considered to be not a multigraph by default (each edge is unique)."
    );
    options.multigraph = options.uniqueLinkId;
  }
  if (options.multigraph === void 0) options.multigraph = false;
  if (typeof Map !== "function") {
    throw new Error("ngraph.graph requires `Map` to be defined. Please polyfill it before using ngraph");
  }
  var nodes = /* @__PURE__ */ new Map();
  var links = /* @__PURE__ */ new Map();
  var multiEdges = {};
  var suspendEvents = 0;
  var createLink = options.multigraph ? createUniqueLink : createSingleLink, changes = [], recordLinkChange = noop3, recordNodeChange = noop3, enterModification = noop3, exitModification = noop3;
  var graphPart = {
    /**
     * Sometimes duck typing could be slow. Giving clients a hint about data structure
     * via explicit version number here:
     */
    version: 20,
    /**
     * Adds node to the graph. If node with given id already exists in the graph
     * its data is extended with whatever comes in 'data' argument.
     *
     * @param nodeId the node's identifier. A string or number is preferred.
     * @param [data] additional data for the node being added. If node already
     *   exists its data object is augmented with the new one.
     *
     * @return {node} The newly added node or node with given id if it already exists.
     */
    addNode,
    /**
     * Adds a link to the graph. The function always create a new
     * link between two nodes. If one of the nodes does not exists
     * a new node is created.
     *
     * @param fromId link start node id;
     * @param toId link end node id;
     * @param [data] additional data to be set on the new link;
     *
     * @return {link} The newly created link
     */
    addLink,
    /**
     * Removes link from the graph. If link does not exist does nothing.
     *
     * @param link - object returned by addLink() or getLinks() methods.
     *
     * @returns true if link was removed; false otherwise.
     */
    removeLink,
    /**
     * Removes node with given id from the graph. If node does not exist in the graph
     * does nothing.
     *
     * @param nodeId node's identifier passed to addNode() function.
     *
     * @returns true if node was removed; false otherwise.
     */
    removeNode: removeNode2,
    /**
     * Gets node with given identifier. If node does not exist undefined value is returned.
     *
     * @param nodeId requested node identifier;
     *
     * @return {node} in with requested identifier or undefined if no such node exists.
     */
    getNode,
    /**
     * Gets number of nodes in this graph.
     *
     * @return number of nodes in the graph.
     */
    getNodeCount,
    /**
     * Gets total number of links in the graph.
     */
    getLinkCount,
    /**
     * Synonym for `getLinkCount()`
     */
    getEdgeCount: getLinkCount,
    /**
     * Synonym for `getLinkCount()`
     */
    getLinksCount: getLinkCount,
    /**
     * Synonym for `getNodeCount()`
     */
    getNodesCount: getNodeCount,
    /**
     * Gets all links (inbound and outbound) from the node with given id.
     * If node with given id is not found null is returned.
     *
     * @param nodeId requested node identifier.
     *
     * @return Set of links from and to requested node if such node exists;
     *   otherwise null is returned.
     */
    getLinks,
    /**
     * Invokes callback on each node of the graph.
     *
     * @param {Function(node)} callback Function to be invoked. The function
     *   is passed one argument: visited node.
     */
    forEachNode,
    /**
     * Invokes callback on every linked (adjacent) node to the given one.
     *
     * @param nodeId Identifier of the requested node.
     * @param {Function(node, link)} callback Function to be called on all linked nodes.
     *   The function is passed two parameters: adjacent node and link object itself.
     * @param oriented if true graph treated as oriented.
     */
    forEachLinkedNode,
    /**
     * Enumerates all links in the graph
     *
     * @param {Function(link)} callback Function to be called on all links in the graph.
     *   The function is passed one parameter: graph's link object.
     *
     * Link object contains at least the following fields:
     *  fromId - node id where link starts;
     *  toId - node id where link ends,
     *  data - additional data passed to graph.addLink() method.
     */
    forEachLink,
    /**
     * Suspend all notifications about graph changes until
     * endUpdate is called.
     */
    beginUpdate: enterModification,
    /**
     * Resumes all notifications about graph changes and fires
     * graph 'changed' event in case there are any pending changes.
     */
    endUpdate: exitModification,
    /**
     * Removes all nodes and links from the graph.
     */
    clear,
    /**
     * Detects whether there is a link between two nodes.
     * Operation complexity is O(n) where n - number of links of a node.
     * NOTE: this function is synonym for getLink()
     *
     * @returns link if there is one. null otherwise.
     */
    hasLink: getLink,
    /**
     * Detects whether there is a node with given id
     * 
     * Operation complexity is O(1)
     * NOTE: this function is synonym for getNode()
     *
     * @returns node if there is one; Falsy value otherwise.
     */
    hasNode: getNode,
    /**
     * Gets an edge between two nodes.
     * Operation complexity is O(n) where n - number of links of a node.
     *
     * @param {string} fromId link start identifier
     * @param {string} toId link end identifier
     *
     * @returns link if there is one; undefined otherwise.
     */
    getLink,
    /**
     * Gets a link by its id.
     *
     * @param {string} linkId link identifier
     *
     * @returns link if there is one; undefined otherwise.
     */
    getLinkById
  };
  eventify(graphPart);
  monitorSubscribers();
  return graphPart;
  function monitorSubscribers() {
    var realOn = graphPart.on;
    graphPart.on = on;
    function on() {
      graphPart.beginUpdate = enterModification = enterModificationReal;
      graphPart.endUpdate = exitModification = exitModificationReal;
      recordLinkChange = recordLinkChangeReal;
      recordNodeChange = recordNodeChangeReal;
      graphPart.on = realOn;
      return realOn.apply(graphPart, arguments);
    }
  }
  function recordLinkChangeReal(link, changeType) {
    changes.push({
      link,
      changeType
    });
  }
  function recordNodeChangeReal(node, changeType) {
    changes.push({
      node,
      changeType
    });
  }
  function addNode(nodeId, data) {
    if (nodeId === void 0) {
      throw new Error("Invalid node identifier");
    }
    enterModification();
    var node = getNode(nodeId);
    if (!node) {
      node = new Node3(nodeId, data);
      recordNodeChange(node, "add");
    } else {
      node.data = data;
      recordNodeChange(node, "update");
    }
    nodes.set(nodeId, node);
    exitModification();
    return node;
  }
  function getNode(nodeId) {
    return nodes.get(nodeId);
  }
  function removeNode2(nodeId) {
    var node = getNode(nodeId);
    if (!node) {
      return false;
    }
    enterModification();
    var prevLinks = node.links;
    if (prevLinks) {
      prevLinks.forEach(removeLinkInstance);
      node.links = null;
    }
    nodes.delete(nodeId);
    recordNodeChange(node, "remove");
    exitModification();
    return true;
  }
  function addLink(fromId, toId, data) {
    enterModification();
    var fromNode = getNode(fromId) || addNode(fromId);
    var toNode = getNode(toId) || addNode(toId);
    var link = createLink(fromId, toId, data);
    var isUpdate = links.has(link.id);
    links.set(link.id, link);
    addLinkToNode(fromNode, link);
    if (fromId !== toId) {
      addLinkToNode(toNode, link);
    }
    recordLinkChange(link, isUpdate ? "update" : "add");
    exitModification();
    return link;
  }
  function createSingleLink(fromId, toId, data) {
    var linkId = makeLinkId(fromId, toId);
    var prevLink = links.get(linkId);
    if (prevLink) {
      prevLink.data = data;
      return prevLink;
    }
    return new Link(fromId, toId, data, linkId);
  }
  function createUniqueLink(fromId, toId, data) {
    var linkId = makeLinkId(fromId, toId);
    var isMultiEdge = multiEdges.hasOwnProperty(linkId);
    if (isMultiEdge || getLink(fromId, toId)) {
      if (!isMultiEdge) {
        multiEdges[linkId] = 0;
      }
      var suffix = "@" + ++multiEdges[linkId];
      linkId = makeLinkId(fromId + suffix, toId + suffix);
    }
    return new Link(fromId, toId, data, linkId);
  }
  function getNodeCount() {
    return nodes.size;
  }
  function getLinkCount() {
    return links.size;
  }
  function getLinks(nodeId) {
    var node = getNode(nodeId);
    return node ? node.links : null;
  }
  function removeLink(link, otherId) {
    if (otherId !== void 0) {
      link = getLink(link, otherId);
    }
    return removeLinkInstance(link);
  }
  function removeLinkInstance(link) {
    if (!link) {
      return false;
    }
    if (!links.get(link.id)) return false;
    enterModification();
    links.delete(link.id);
    var fromNode = getNode(link.fromId);
    var toNode = getNode(link.toId);
    if (fromNode) {
      fromNode.links.delete(link);
    }
    if (toNode) {
      toNode.links.delete(link);
    }
    recordLinkChange(link, "remove");
    exitModification();
    return true;
  }
  function getLink(fromNodeId, toNodeId) {
    if (fromNodeId === void 0 || toNodeId === void 0) return void 0;
    return links.get(makeLinkId(fromNodeId, toNodeId));
  }
  function getLinkById(linkId) {
    if (linkId === void 0) return void 0;
    return links.get(linkId);
  }
  function clear() {
    enterModification();
    forEachNode(function(node) {
      removeNode2(node.id);
    });
    exitModification();
  }
  function forEachLink(callback) {
    if (typeof callback === "function") {
      var valuesIterator = links.values();
      var nextValue = valuesIterator.next();
      while (!nextValue.done) {
        if (callback(nextValue.value)) {
          return true;
        }
        nextValue = valuesIterator.next();
      }
    }
  }
  function forEachLinkedNode(nodeId, callback, oriented) {
    var node = getNode(nodeId);
    if (node && node.links && typeof callback === "function") {
      if (oriented) {
        return forEachOrientedLink(node.links, nodeId, callback);
      } else {
        return forEachNonOrientedLink(node.links, nodeId, callback);
      }
    }
  }
  function forEachNonOrientedLink(links2, nodeId, callback) {
    var quitFast;
    var valuesIterator = links2.values();
    var nextValue = valuesIterator.next();
    while (!nextValue.done) {
      var link = nextValue.value;
      var linkedNodeId = link.fromId === nodeId ? link.toId : link.fromId;
      quitFast = callback(nodes.get(linkedNodeId), link);
      if (quitFast) {
        return true;
      }
      nextValue = valuesIterator.next();
    }
  }
  function forEachOrientedLink(links2, nodeId, callback) {
    var quitFast;
    var valuesIterator = links2.values();
    var nextValue = valuesIterator.next();
    while (!nextValue.done) {
      var link = nextValue.value;
      if (link.fromId === nodeId) {
        quitFast = callback(nodes.get(link.toId), link);
        if (quitFast) {
          return true;
        }
      }
      nextValue = valuesIterator.next();
    }
  }
  function noop3() {
  }
  function enterModificationReal() {
    suspendEvents += 1;
  }
  function exitModificationReal() {
    suspendEvents -= 1;
    if (suspendEvents === 0 && changes.length > 0) {
      graphPart.fire("changed", changes);
      changes.length = 0;
    }
  }
  function forEachNode(callback) {
    if (typeof callback !== "function") {
      throw new Error("Function is expected to iterate over graph nodes. You passed " + callback);
    }
    var valuesIterator = nodes.values();
    var nextValue = valuesIterator.next();
    while (!nextValue.done) {
      if (callback(nextValue.value)) {
        return true;
      }
      nextValue = valuesIterator.next();
    }
  }
}
function Node3(id2, data) {
  this.id = id2;
  this.links = null;
  this.data = data;
}
function addLinkToNode(node, link) {
  if (node.links) {
    node.links.add(link);
  } else {
    node.links = /* @__PURE__ */ new Set([link]);
  }
}
function Link(fromId, toId, data, id2) {
  this.fromId = fromId;
  this.toId = toId;
  this.data = data;
  this.id = id2;
}
function makeLinkId(fromId, toId) {
  return fromId.toString() + "ð " + toId.toString();
}

// node_modules/three-forcegraph/dist/three-forcegraph.mjs
var import_ngraph3 = __toESM(require_ngraph3(), 1);

// node_modules/lodash-es/isObject.js
function isObject(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_default = isObject;

// node_modules/lodash-es/_freeGlobal.js
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal_default = freeGlobal;

// node_modules/lodash-es/_root.js
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal_default || freeSelf || Function("return this")();
var root_default4 = root;

// node_modules/lodash-es/now.js
var now2 = function() {
  return root_default4.Date.now();
};
var now_default = now2;

// node_modules/lodash-es/_trimmedEndIndex.js
var reWhitespace = /\s/;
function trimmedEndIndex(string2) {
  var index8 = string2.length;
  while (index8-- && reWhitespace.test(string2.charAt(index8))) {
  }
  return index8;
}
var trimmedEndIndex_default = trimmedEndIndex;

// node_modules/lodash-es/_baseTrim.js
var reTrimStart = /^\s+/;
function baseTrim(string2) {
  return string2 ? string2.slice(0, trimmedEndIndex_default(string2) + 1).replace(reTrimStart, "") : string2;
}
var baseTrim_default = baseTrim;

// node_modules/lodash-es/_Symbol.js
var Symbol2 = root_default4.Symbol;
var Symbol_default = Symbol2;

// node_modules/lodash-es/_getRawTag.js
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var nativeObjectToString = objectProto.toString;
var symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
  try {
    value[symToStringTag] = void 0;
    var unmasked = true;
  } catch (e3) {
  }
  var result2 = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result2;
}
var getRawTag_default = getRawTag;

// node_modules/lodash-es/_objectToString.js
var objectProto2 = Object.prototype;
var nativeObjectToString2 = objectProto2.toString;
function objectToString(value) {
  return nativeObjectToString2.call(value);
}
var objectToString_default = objectToString;

// node_modules/lodash-es/_baseGetTag.js
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag_default(value) : objectToString_default(value);
}
var baseGetTag_default = baseGetTag;

// node_modules/lodash-es/isObjectLike.js
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_default = isObjectLike;

// node_modules/lodash-es/isSymbol.js
var symbolTag = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike_default(value) && baseGetTag_default(value) == symbolTag;
}
var isSymbol_default = isSymbol;

// node_modules/lodash-es/toNumber.js
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol_default(value)) {
    return NAN;
  }
  if (isObject_default(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject_default(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim_default(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var toNumber_default = toNumber;

// node_modules/lodash-es/debounce.js
var FUNC_ERROR_TEXT = "Expected a function";
var nativeMax = Math.max;
var nativeMin = Math.min;
function debounce(func, wait, options) {
  var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber_default(wait) || 0;
  if (isObject_default(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax(toNumber_default(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time3) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time3;
    result2 = func.apply(thisArg, args);
    return result2;
  }
  function leadingEdge(time3) {
    lastInvokeTime = time3;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time3) : result2;
  }
  function remainingWait(time3) {
    var timeSinceLastCall = time3 - lastCallTime, timeSinceLastInvoke = time3 - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time3) {
    var timeSinceLastCall = time3 - lastCallTime, timeSinceLastInvoke = time3 - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time3 = now_default();
    if (shouldInvoke(time3)) {
      return trailingEdge(time3);
    }
    timerId = setTimeout(timerExpired, remainingWait(time3));
  }
  function trailingEdge(time3) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time3);
    }
    lastArgs = lastThis = void 0;
    return result2;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result2 : trailingEdge(now_default());
  }
  function debounced() {
    var time3 = now_default(), isInvoking = shouldInvoke(time3);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time3;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result2;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
var debounce_default = debounce;

// node_modules/kapsule/dist/kapsule.mjs
function _arrayLikeToArray3(r2, a3) {
  (null == a3 || a3 > r2.length) && (a3 = r2.length);
  for (var e3 = 0, n2 = Array(a3); e3 < a3; e3++) n2[e3] = r2[e3];
  return n2;
}
function _arrayWithHoles3(r2) {
  if (Array.isArray(r2)) return r2;
}
function _classCallCheck(a3, n2) {
  if (!(a3 instanceof n2)) throw new TypeError("Cannot call a class as a function");
}
function _createClass(e3, r2, t5) {
  return Object.defineProperty(e3, "prototype", {
    writable: false
  }), e3;
}
function _iterableToArrayLimit3(r2, l2) {
  var t5 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t5) {
    var e3, n2, i2, u2, a3 = [], f3 = true, o2 = false;
    try {
      if (i2 = (t5 = t5.call(r2)).next, 0 === l2) ;
      else for (; !(f3 = (e3 = i2.call(t5)).done) && (a3.push(e3.value), a3.length !== l2); f3 = true) ;
    } catch (r3) {
      o2 = true, n2 = r3;
    } finally {
      try {
        if (!f3 && null != t5.return && (u2 = t5.return(), Object(u2) !== u2)) return;
      } finally {
        if (o2) throw n2;
      }
    }
    return a3;
  }
}
function _nonIterableRest3() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _slicedToArray3(r2, e3) {
  return _arrayWithHoles3(r2) || _iterableToArrayLimit3(r2, e3) || _unsupportedIterableToArray3(r2, e3) || _nonIterableRest3();
}
function _unsupportedIterableToArray3(r2, a3) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray3(r2, a3);
    var t5 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t5 && r2.constructor && (t5 = r2.constructor.name), "Map" === t5 || "Set" === t5 ? Array.from(r2) : "Arguments" === t5 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t5) ? _arrayLikeToArray3(r2, a3) : void 0;
  }
}
var Prop = _createClass(function Prop2(name, _ref) {
  var _ref$default = _ref["default"], defaultVal = _ref$default === void 0 ? null : _ref$default, _ref$triggerUpdate = _ref.triggerUpdate, triggerUpdate = _ref$triggerUpdate === void 0 ? true : _ref$triggerUpdate, _ref$onChange = _ref.onChange, onChange29 = _ref$onChange === void 0 ? function(newVal, state) {
  } : _ref$onChange;
  _classCallCheck(this, Prop2);
  this.name = name;
  this.defaultVal = defaultVal;
  this.triggerUpdate = triggerUpdate;
  this.onChange = onChange29;
});
function index3(_ref2) {
  var _ref2$stateInit = _ref2.stateInit, stateInit6 = _ref2$stateInit === void 0 ? function() {
    return {};
  } : _ref2$stateInit, _ref2$props = _ref2.props, rawProps = _ref2$props === void 0 ? {} : _ref2$props, _ref2$methods = _ref2.methods, methods = _ref2$methods === void 0 ? {} : _ref2$methods, _ref2$aliases = _ref2.aliases, aliases = _ref2$aliases === void 0 ? {} : _ref2$aliases, _ref2$init = _ref2.init, initFn = _ref2$init === void 0 ? function() {
  } : _ref2$init, _ref2$update = _ref2.update, updateFn2 = _ref2$update === void 0 ? function() {
  } : _ref2$update;
  var props = Object.keys(rawProps).map(function(propName) {
    return new Prop(propName, rawProps[propName]);
  });
  return function KapsuleComp() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var classMode = !!(this instanceof KapsuleComp ? this.constructor : void 0);
    var nodeElement = classMode ? args.shift() : void 0;
    var _args$ = args[0], options = _args$ === void 0 ? {} : _args$;
    var state = Object.assign(
      {},
      stateInit6 instanceof Function ? stateInit6(options) : stateInit6,
      // Support plain objects for backwards compatibility
      {
        initialised: false
      }
    );
    var changedProps = {};
    function comp(nodeElement2) {
      initStatic(nodeElement2, options);
      digest();
      return comp;
    }
    var initStatic = function initStatic2(nodeElement2, options2) {
      initFn.call(comp, nodeElement2, state, options2);
      state.initialised = true;
    };
    var digest = debounce_default(function() {
      if (!state.initialised) {
        return;
      }
      updateFn2.call(comp, state, changedProps);
      changedProps = {};
    }, 1);
    props.forEach(function(prop) {
      comp[prop.name] = getSetProp(prop);
      function getSetProp(_ref3) {
        var prop2 = _ref3.name, _ref3$triggerUpdate = _ref3.triggerUpdate, redigest = _ref3$triggerUpdate === void 0 ? false : _ref3$triggerUpdate, _ref3$onChange = _ref3.onChange, onChange29 = _ref3$onChange === void 0 ? function(newVal, state2) {
        } : _ref3$onChange, _ref3$defaultVal = _ref3.defaultVal, defaultVal = _ref3$defaultVal === void 0 ? null : _ref3$defaultVal;
        return function(_2) {
          var curVal = state[prop2];
          if (!arguments.length) {
            return curVal;
          }
          var val = _2 === void 0 ? defaultVal : _2;
          state[prop2] = val;
          onChange29.call(comp, val, state, curVal);
          !changedProps.hasOwnProperty(prop2) && (changedProps[prop2] = curVal);
          if (redigest) {
            digest();
          }
          return comp;
        };
      }
    });
    Object.keys(methods).forEach(function(methodName) {
      comp[methodName] = function() {
        var _methods$methodName;
        for (var _len2 = arguments.length, args2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args2[_key2] = arguments[_key2];
        }
        return (_methods$methodName = methods[methodName]).call.apply(_methods$methodName, [comp, state].concat(args2));
      };
    });
    Object.entries(aliases).forEach(function(_ref4) {
      var _ref5 = _slicedToArray3(_ref4, 2), alias = _ref5[0], target = _ref5[1];
      return comp[alias] = comp[target];
    });
    comp.resetProps = function() {
      props.forEach(function(prop) {
        comp[prop.name](prop.defaultVal);
      });
      return comp;
    };
    comp.resetProps();
    state._rerender = digest;
    classMode && nodeElement && comp(nodeElement);
    return comp;
  };
}

// node_modules/accessor-fn/dist/accessor-fn.mjs
var index4 = (function(p3) {
  return typeof p3 === "function" ? p3 : typeof p3 === "string" ? function(obj) {
    return obj[p3];
  } : function(obj) {
    return p3;
  };
});

// node_modules/d3-array/src/ascending.js
function ascending(a3, b) {
  return a3 == null || b == null ? NaN : a3 < b ? -1 : a3 > b ? 1 : a3 >= b ? 0 : NaN;
}

// node_modules/d3-array/src/descending.js
function descending(a3, b) {
  return a3 == null || b == null ? NaN : b < a3 ? -1 : b > a3 ? 1 : b >= a3 ? 0 : NaN;
}

// node_modules/d3-array/src/bisector.js
function bisector(f3) {
  let compare1, compare2, delta;
  if (f3.length !== 2) {
    compare1 = ascending;
    compare2 = (d3, x3) => ascending(f3(d3), x3);
    delta = (d3, x3) => f3(d3) - x3;
  } else {
    compare1 = f3 === ascending || f3 === descending ? f3 : zero;
    compare2 = f3;
    delta = f3;
  }
  function left(a3, x3, lo = 0, hi = a3.length) {
    if (lo < hi) {
      if (compare1(x3, x3) !== 0) return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a3[mid], x3) < 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function right(a3, x3, lo = 0, hi = a3.length) {
    if (lo < hi) {
      if (compare1(x3, x3) !== 0) return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a3[mid], x3) <= 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function center(a3, x3, lo = 0, hi = a3.length) {
    const i2 = left(a3, x3, lo, hi - 1);
    return i2 > lo && delta(a3[i2 - 1], x3) > -delta(a3[i2], x3) ? i2 - 1 : i2;
  }
  return { left, center, right };
}
function zero() {
  return 0;
}

// node_modules/d3-array/src/number.js
function number(x3) {
  return x3 === null ? NaN : +x3;
}

// node_modules/d3-array/src/bisect.js
var ascendingBisect = bisector(ascending);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
var bisectCenter = bisector(number).center;

// node_modules/d3-array/src/blur.js
var blur2 = Blur2(blurf);
var blurImage = Blur2(blurfImage);
function Blur2(blur4) {
  return function(data, rx, ry = rx) {
    if (!((rx = +rx) >= 0)) throw new RangeError("invalid rx");
    if (!((ry = +ry) >= 0)) throw new RangeError("invalid ry");
    let { data: values2, width, height } = data;
    if (!((width = Math.floor(width)) >= 0)) throw new RangeError("invalid width");
    if (!((height = Math.floor(height !== void 0 ? height : values2.length / width)) >= 0)) throw new RangeError("invalid height");
    if (!width || !height || !rx && !ry) return data;
    const blurx = rx && blur4(rx);
    const blury = ry && blur4(ry);
    const temp = values2.slice();
    if (blurx && blury) {
      blurh(blurx, temp, values2, width, height);
      blurh(blurx, values2, temp, width, height);
      blurh(blurx, temp, values2, width, height);
      blurv(blury, values2, temp, width, height);
      blurv(blury, temp, values2, width, height);
      blurv(blury, values2, temp, width, height);
    } else if (blurx) {
      blurh(blurx, values2, temp, width, height);
      blurh(blurx, temp, values2, width, height);
      blurh(blurx, values2, temp, width, height);
    } else if (blury) {
      blurv(blury, values2, temp, width, height);
      blurv(blury, temp, values2, width, height);
      blurv(blury, values2, temp, width, height);
    }
    return data;
  };
}
function blurh(blur4, T3, S2, w4, h2) {
  for (let y3 = 0, n2 = w4 * h2; y3 < n2; ) {
    blur4(T3, S2, y3, y3 += w4, 1);
  }
}
function blurv(blur4, T3, S2, w4, h2) {
  for (let x3 = 0, n2 = w4 * h2; x3 < w4; ++x3) {
    blur4(T3, S2, x3, x3 + n2, w4);
  }
}
function blurfImage(radius) {
  const blur4 = blurf(radius);
  return (T3, S2, start2, stop, step2) => {
    start2 <<= 2, stop <<= 2, step2 <<= 2;
    blur4(T3, S2, start2 + 0, stop + 0, step2);
    blur4(T3, S2, start2 + 1, stop + 1, step2);
    blur4(T3, S2, start2 + 2, stop + 2, step2);
    blur4(T3, S2, start2 + 3, stop + 3, step2);
  };
}
function blurf(radius) {
  const radius0 = Math.floor(radius);
  if (radius0 === radius) return bluri(radius);
  const t5 = radius - radius0;
  const w4 = 2 * radius + 1;
  return (T3, S2, start2, stop, step2) => {
    if (!((stop -= step2) >= start2)) return;
    let sum3 = radius0 * S2[start2];
    const s0 = step2 * radius0;
    const s1 = s0 + step2;
    for (let i2 = start2, j2 = start2 + s0; i2 < j2; i2 += step2) {
      sum3 += S2[Math.min(stop, i2)];
    }
    for (let i2 = start2, j2 = stop; i2 <= j2; i2 += step2) {
      sum3 += S2[Math.min(stop, i2 + s0)];
      T3[i2] = (sum3 + t5 * (S2[Math.max(start2, i2 - s1)] + S2[Math.min(stop, i2 + s1)])) / w4;
      sum3 -= S2[Math.max(start2, i2 - s0)];
    }
  };
}
function bluri(radius) {
  const w4 = 2 * radius + 1;
  return (T3, S2, start2, stop, step2) => {
    if (!((stop -= step2) >= start2)) return;
    let sum3 = radius * S2[start2];
    const s2 = step2 * radius;
    for (let i2 = start2, j2 = start2 + s2; i2 < j2; i2 += step2) {
      sum3 += S2[Math.min(stop, i2)];
    }
    for (let i2 = start2, j2 = stop; i2 <= j2; i2 += step2) {
      sum3 += S2[Math.min(stop, i2 + s2)];
      T3[i2] = sum3 / w4;
      sum3 -= S2[Math.max(start2, i2 - s2)];
    }
  };
}

// node_modules/internmap/src/index.js
var InternMap = class extends Map {
  constructor(entries, key = keyof) {
    super();
    Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
    if (entries != null) for (const [key2, value] of entries) this.set(key2, value);
  }
  get(key) {
    return super.get(intern_get(this, key));
  }
  has(key) {
    return super.has(intern_get(this, key));
  }
  set(key, value) {
    return super.set(intern_set(this, key), value);
  }
  delete(key) {
    return super.delete(intern_delete(this, key));
  }
};
function intern_get({ _intern, _key }, value) {
  const key = _key(value);
  return _intern.has(key) ? _intern.get(key) : value;
}
function intern_set({ _intern, _key }, value) {
  const key = _key(value);
  if (_intern.has(key)) return _intern.get(key);
  _intern.set(key, value);
  return value;
}
function intern_delete({ _intern, _key }, value) {
  const key = _key(value);
  if (_intern.has(key)) {
    value = _intern.get(key);
    _intern.delete(key);
  }
  return value;
}
function keyof(value) {
  return value !== null && typeof value === "object" ? value.valueOf() : value;
}

// node_modules/d3-array/src/array.js
var array = Array.prototype;
var slice2 = array.slice;
var map2 = array.map;

// node_modules/d3-array/src/ticks.js
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);
function tickSpec(start2, stop, count2) {
  const step2 = (stop - start2) / Math.max(0, count2), power = Math.floor(Math.log10(step2)), error2 = step2 / Math.pow(10, power), factor = error2 >= e10 ? 10 : error2 >= e5 ? 5 : error2 >= e2 ? 2 : 1;
  let i1, i2, inc;
  if (power < 0) {
    inc = Math.pow(10, -power) / factor;
    i1 = Math.round(start2 * inc);
    i2 = Math.round(stop * inc);
    if (i1 / inc < start2) ++i1;
    if (i2 / inc > stop) --i2;
    inc = -inc;
  } else {
    inc = Math.pow(10, power) * factor;
    i1 = Math.round(start2 / inc);
    i2 = Math.round(stop / inc);
    if (i1 * inc < start2) ++i1;
    if (i2 * inc > stop) --i2;
  }
  if (i2 < i1 && 0.5 <= count2 && count2 < 2) return tickSpec(start2, stop, count2 * 2);
  return [i1, i2, inc];
}
function tickIncrement(start2, stop, count2) {
  stop = +stop, start2 = +start2, count2 = +count2;
  return tickSpec(start2, stop, count2)[2];
}
function tickStep(start2, stop, count2) {
  stop = +stop, start2 = +start2, count2 = +count2;
  const reverse3 = stop < start2, inc = reverse3 ? tickIncrement(stop, start2, count2) : tickIncrement(start2, stop, count2);
  return (reverse3 ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
}

// node_modules/d3-array/src/max.js
function max2(values2, valueof) {
  let max6;
  if (valueof === void 0) {
    for (const value of values2) {
      if (value != null && (max6 < value || max6 === void 0 && value >= value)) {
        max6 = value;
      }
    }
  } else {
    let index8 = -1;
    for (let value of values2) {
      if ((value = valueof(value, ++index8, values2)) != null && (max6 < value || max6 === void 0 && value >= value)) {
        max6 = value;
      }
    }
  }
  return max6;
}

// node_modules/d3-array/src/min.js
function min(values2, valueof) {
  let min5;
  if (valueof === void 0) {
    for (const value of values2) {
      if (value != null && (min5 > value || min5 === void 0 && value >= value)) {
        min5 = value;
      }
    }
  } else {
    let index8 = -1;
    for (let value of values2) {
      if ((value = valueof(value, ++index8, values2)) != null && (min5 > value || min5 === void 0 && value >= value)) {
        min5 = value;
      }
    }
  }
  return min5;
}

// node_modules/d3-array/src/shuffle.js
var shuffle_default = shuffler(Math.random);
function shuffler(random2) {
  return function shuffle2(array4, i0 = 0, i1 = array4.length) {
    let m3 = i1 - (i0 = +i0);
    while (m3) {
      const i2 = random2() * m3-- | 0, t5 = array4[m3 + i0];
      array4[m3 + i0] = array4[i2 + i0];
      array4[i2 + i0] = t5;
    }
    return array4;
  };
}

// node_modules/d3-array/src/sum.js
function sum(values2, valueof) {
  let sum3 = 0;
  if (valueof === void 0) {
    for (let value of values2) {
      if (value = +value) {
        sum3 += value;
      }
    }
  } else {
    let index8 = -1;
    for (let value of values2) {
      if (value = +valueof(value, ++index8, values2)) {
        sum3 += value;
      }
    }
  }
  return sum3;
}

// node_modules/data-bind-mapper/dist/data-bind-mapper.mjs
function _arrayLikeToArray4(r2, a3) {
  (null == a3 || a3 > r2.length) && (a3 = r2.length);
  for (var e3 = 0, n2 = Array(a3); e3 < a3; e3++) n2[e3] = r2[e3];
  return n2;
}
function _arrayWithHoles4(r2) {
  if (Array.isArray(r2)) return r2;
}
function _arrayWithoutHoles3(r2) {
  if (Array.isArray(r2)) return _arrayLikeToArray4(r2);
}
function _assertClassBrand(e3, t5, n2) {
  if ("function" == typeof e3 ? e3 === t5 : e3.has(t5)) return arguments.length < 3 ? t5 : n2;
  throw new TypeError("Private element is not present on this object");
}
function _checkPrivateRedeclaration(e3, t5) {
  if (t5.has(e3)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function _classCallCheck2(a3, n2) {
  if (!(a3 instanceof n2)) throw new TypeError("Cannot call a class as a function");
}
function _classPrivateFieldGet2(s2, a3) {
  return s2.get(_assertClassBrand(s2, a3));
}
function _classPrivateFieldInitSpec(e3, t5, a3) {
  _checkPrivateRedeclaration(e3, t5), t5.set(e3, a3);
}
function _classPrivateFieldSet2(s2, a3, r2) {
  return s2.set(_assertClassBrand(s2, a3), r2), r2;
}
function _defineProperties(e3, r2) {
  for (var t5 = 0; t5 < r2.length; t5++) {
    var o2 = r2[t5];
    o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e3, _toPropertyKey2(o2.key), o2);
  }
}
function _createClass2(e3, r2, t5) {
  return r2 && _defineProperties(e3.prototype, r2), Object.defineProperty(e3, "prototype", {
    writable: false
  }), e3;
}
function _iterableToArray3(r2) {
  if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"]) return Array.from(r2);
}
function _iterableToArrayLimit4(r2, l2) {
  var t5 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t5) {
    var e3, n2, i2, u2, a3 = [], f3 = true, o2 = false;
    try {
      if (i2 = (t5 = t5.call(r2)).next, 0 === l2) ;
      else for (; !(f3 = (e3 = i2.call(t5)).done) && (a3.push(e3.value), a3.length !== l2); f3 = true) ;
    } catch (r3) {
      o2 = true, n2 = r3;
    } finally {
      try {
        if (!f3 && null != t5.return && (u2 = t5.return(), Object(u2) !== u2)) return;
      } finally {
        if (o2) throw n2;
      }
    }
    return a3;
  }
}
function _nonIterableRest4() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableSpread3() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _slicedToArray4(r2, e3) {
  return _arrayWithHoles4(r2) || _iterableToArrayLimit4(r2, e3) || _unsupportedIterableToArray4(r2, e3) || _nonIterableRest4();
}
function _toConsumableArray3(r2) {
  return _arrayWithoutHoles3(r2) || _iterableToArray3(r2) || _unsupportedIterableToArray4(r2) || _nonIterableSpread3();
}
function _toPrimitive2(t5, r2) {
  if ("object" != typeof t5 || !t5) return t5;
  var e3 = t5[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t5, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t5);
}
function _toPropertyKey2(t5) {
  var i2 = _toPrimitive2(t5, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _unsupportedIterableToArray4(r2, a3) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray4(r2, a3);
    var t5 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t5 && r2.constructor && (t5 = r2.constructor.name), "Map" === t5 || "Set" === t5 ? Array.from(r2) : "Arguments" === t5 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t5) ? _arrayLikeToArray4(r2, a3) : void 0;
  }
}
var _dataMap = /* @__PURE__ */ new WeakMap();
var _objMap = /* @__PURE__ */ new WeakMap();
var _id = /* @__PURE__ */ new WeakMap();
var _createObj = /* @__PURE__ */ new WeakMap();
var _updateObj = /* @__PURE__ */ new WeakMap();
var _removeObj = /* @__PURE__ */ new WeakMap();
var DataBindMapper = (function() {
  function DataBindMapper2() {
    _classCallCheck2(this, DataBindMapper2);
    _classPrivateFieldInitSpec(this, _dataMap, /* @__PURE__ */ new Map());
    _classPrivateFieldInitSpec(this, _objMap, /* @__PURE__ */ new Map());
    _classPrivateFieldInitSpec(this, _id, function(d3) {
      return d3;
    });
    _classPrivateFieldInitSpec(this, _createObj, function() {
      return {};
    });
    _classPrivateFieldInitSpec(this, _updateObj, function() {
    });
    _classPrivateFieldInitSpec(this, _removeObj, function() {
    });
  }
  return _createClass2(DataBindMapper2, [{
    key: "getObj",
    value: function getObj(d3) {
      return _classPrivateFieldGet2(_dataMap, this).get(_classPrivateFieldGet2(_id, this).call(this, d3));
    }
  }, {
    key: "getData",
    value: function getData4(o2) {
      return _classPrivateFieldGet2(_objMap, this).get(o2);
    }
  }, {
    key: "entries",
    value: function entries() {
      return _toConsumableArray3(_classPrivateFieldGet2(_objMap, this).entries()).map(function(_ref) {
        var _ref2 = _slicedToArray4(_ref, 2), o2 = _ref2[0], d3 = _ref2[1];
        return [d3, o2];
      });
    }
  }, {
    key: "id",
    value: function id2(p3) {
      _classPrivateFieldSet2(_id, this, index4(p3));
      return this;
    }
  }, {
    key: "onCreateObj",
    value: function onCreateObj(fn) {
      _classPrivateFieldSet2(_createObj, this, fn);
      return this;
    }
  }, {
    key: "onUpdateObj",
    value: function onUpdateObj(fn) {
      _classPrivateFieldSet2(_updateObj, this, fn);
      return this;
    }
  }, {
    key: "onRemoveObj",
    value: function onRemoveObj(fn) {
      _classPrivateFieldSet2(_removeObj, this, fn);
      return this;
    }
  }, {
    key: "digest",
    value: function digest(data) {
      var _this = this;
      data.filter(function(d3) {
        return !_classPrivateFieldGet2(_dataMap, _this).has(_classPrivateFieldGet2(_id, _this).call(_this, d3));
      }).forEach(function(d3) {
        var obj = _classPrivateFieldGet2(_createObj, _this).call(_this, d3);
        _classPrivateFieldGet2(_dataMap, _this).set(_classPrivateFieldGet2(_id, _this).call(_this, d3), obj);
        _classPrivateFieldGet2(_objMap, _this).set(obj, d3);
      });
      var dataIdsMap = new Map(data.map(function(d3) {
        return [_classPrivateFieldGet2(_id, _this).call(_this, d3), d3];
      }));
      _classPrivateFieldGet2(_dataMap, this).forEach(function(o2, dId) {
        if (!dataIdsMap.has(dId)) {
          _classPrivateFieldGet2(_removeObj, _this).call(_this, o2, dId);
          _classPrivateFieldGet2(_dataMap, _this)["delete"](dId);
          _classPrivateFieldGet2(_objMap, _this)["delete"](o2);
        } else {
          _classPrivateFieldGet2(_updateObj, _this).call(_this, o2, dataIdsMap.get(dId));
        }
      });
      return this;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.digest([]);
      return this;
    }
  }]);
})();

// node_modules/d3-scale/src/init.js
function initRange(domain, range4) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain);
      break;
    default:
      this.range(range4).domain(domain);
      break;
  }
  return this;
}

// node_modules/d3-scale/src/ordinal.js
var implicit = /* @__PURE__ */ Symbol("implicit");
function ordinal() {
  var index8 = new InternMap(), domain = [], range4 = [], unknown = implicit;
  function scale2(d3) {
    let i2 = index8.get(d3);
    if (i2 === void 0) {
      if (unknown !== implicit) return unknown;
      index8.set(d3, i2 = domain.push(d3) - 1);
    }
    return range4[i2 % range4.length];
  }
  scale2.domain = function(_2) {
    if (!arguments.length) return domain.slice();
    domain = [], index8 = new InternMap();
    for (const value of _2) {
      if (index8.has(value)) continue;
      index8.set(value, domain.push(value) - 1);
    }
    return scale2;
  };
  scale2.range = function(_2) {
    return arguments.length ? (range4 = Array.from(_2), scale2) : range4.slice();
  };
  scale2.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale2) : unknown;
  };
  scale2.copy = function() {
    return ordinal(domain, range4).unknown(unknown);
  };
  initRange.apply(scale2, arguments);
  return scale2;
}

// node_modules/d3-color/src/define.js
function define_default(constructor, factory2, prototype) {
  constructor.prototype = factory2.prototype = prototype;
  prototype.constructor = constructor;
}
function extend2(parent2, definition) {
  var prototype = Object.create(parent2.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}

// node_modules/d3-color/src/color.js
function Color3() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex = /^#([0-9a-f]{3,8})$/;
var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define_default(Color3, color, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format3) {
  var m3, l2;
  format3 = (format3 + "").trim().toLowerCase();
  return (m3 = reHex.exec(format3)) ? (l2 = m3[1].length, m3 = parseInt(m3[1], 16), l2 === 6 ? rgbn(m3) : l2 === 3 ? new Rgb(m3 >> 8 & 15 | m3 >> 4 & 240, m3 >> 4 & 15 | m3 & 240, (m3 & 15) << 4 | m3 & 15, 1) : l2 === 8 ? rgba(m3 >> 24 & 255, m3 >> 16 & 255, m3 >> 8 & 255, (m3 & 255) / 255) : l2 === 4 ? rgba(m3 >> 12 & 15 | m3 >> 8 & 240, m3 >> 8 & 15 | m3 >> 4 & 240, m3 >> 4 & 15 | m3 & 240, ((m3 & 15) << 4 | m3 & 15) / 255) : null) : (m3 = reRgbInteger.exec(format3)) ? new Rgb(m3[1], m3[2], m3[3], 1) : (m3 = reRgbPercent.exec(format3)) ? new Rgb(m3[1] * 255 / 100, m3[2] * 255 / 100, m3[3] * 255 / 100, 1) : (m3 = reRgbaInteger.exec(format3)) ? rgba(m3[1], m3[2], m3[3], m3[4]) : (m3 = reRgbaPercent.exec(format3)) ? rgba(m3[1] * 255 / 100, m3[2] * 255 / 100, m3[3] * 255 / 100, m3[4]) : (m3 = reHslPercent.exec(format3)) ? hsla(m3[1], m3[2] / 100, m3[3] / 100, 1) : (m3 = reHslaPercent.exec(format3)) ? hsla(m3[1], m3[2] / 100, m3[3] / 100, m3[4]) : named.hasOwnProperty(format3) ? rgbn(named[format3]) : format3 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n2) {
  return new Rgb(n2 >> 16 & 255, n2 >> 8 & 255, n2 & 255, 1);
}
function rgba(r2, g3, b, a3) {
  if (a3 <= 0) r2 = g3 = b = NaN;
  return new Rgb(r2, g3, b, a3);
}
function rgbConvert(o2) {
  if (!(o2 instanceof Color3)) o2 = color(o2);
  if (!o2) return new Rgb();
  o2 = o2.rgb();
  return new Rgb(o2.r, o2.g, o2.b, o2.opacity);
}
function rgb(r2, g3, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r2) : new Rgb(r2, g3, b, opacity == null ? 1 : opacity);
}
function Rgb(r2, g3, b, opacity) {
  this.r = +r2;
  this.g = +g3;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Rgb, rgb, extend2(Color3, {
  brighter(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  darker(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a3 = clampa(this.opacity);
  return `${a3 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a3 === 1 ? ")" : `, ${a3})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h2, s2, l2, a3) {
  if (a3 <= 0) h2 = s2 = l2 = NaN;
  else if (l2 <= 0 || l2 >= 1) h2 = s2 = NaN;
  else if (s2 <= 0) h2 = NaN;
  return new Hsl(h2, s2, l2, a3);
}
function hslConvert(o2) {
  if (o2 instanceof Hsl) return new Hsl(o2.h, o2.s, o2.l, o2.opacity);
  if (!(o2 instanceof Color3)) o2 = color(o2);
  if (!o2) return new Hsl();
  if (o2 instanceof Hsl) return o2;
  o2 = o2.rgb();
  var r2 = o2.r / 255, g3 = o2.g / 255, b = o2.b / 255, min5 = Math.min(r2, g3, b), max6 = Math.max(r2, g3, b), h2 = NaN, s2 = max6 - min5, l2 = (max6 + min5) / 2;
  if (s2) {
    if (r2 === max6) h2 = (g3 - b) / s2 + (g3 < b) * 6;
    else if (g3 === max6) h2 = (b - r2) / s2 + 2;
    else h2 = (r2 - g3) / s2 + 4;
    s2 /= l2 < 0.5 ? max6 + min5 : 2 - max6 - min5;
    h2 *= 60;
  } else {
    s2 = l2 > 0 && l2 < 1 ? 0 : h2;
  }
  return new Hsl(h2, s2, l2, o2.opacity);
}
function hsl(h2, s2, l2, opacity) {
  return arguments.length === 1 ? hslConvert(h2) : new Hsl(h2, s2, l2, opacity == null ? 1 : opacity);
}
function Hsl(h2, s2, l2, opacity) {
  this.h = +h2;
  this.s = +s2;
  this.l = +l2;
  this.opacity = +opacity;
}
define_default(Hsl, hsl, extend2(Color3, {
  brighter(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Hsl(this.h, this.s, this.l * k2, this.opacity);
  },
  darker(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Hsl(this.h, this.s, this.l * k2, this.opacity);
  },
  rgb() {
    var h2 = this.h % 360 + (this.h < 0) * 360, s2 = isNaN(h2) || isNaN(this.s) ? 0 : this.s, l2 = this.l, m22 = l2 + (l2 < 0.5 ? l2 : 1 - l2) * s2, m1 = 2 * l2 - m22;
    return new Rgb(
      hsl2rgb(h2 >= 240 ? h2 - 240 : h2 + 120, m1, m22),
      hsl2rgb(h2, m1, m22),
      hsl2rgb(h2 < 120 ? h2 + 240 : h2 - 120, m1, m22),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a3 = clampa(this.opacity);
    return `${a3 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a3 === 1 ? ")" : `, ${a3})`}`;
  }
}));
function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}
function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb(h2, m1, m22) {
  return (h2 < 60 ? m1 + (m22 - m1) * h2 / 60 : h2 < 180 ? m22 : h2 < 240 ? m1 + (m22 - m1) * (240 - h2) / 60 : m1) * 255;
}

// node_modules/d3-color/src/math.js
var radians2 = Math.PI / 180;
var degrees2 = 180 / Math.PI;

// node_modules/d3-color/src/lab.js
var K = 18;
var Xn = 0.96422;
var Yn = 1;
var Zn = 0.82521;
var t0 = 4 / 29;
var t1 = 6 / 29;
var t2 = 3 * t1 * t1;
var t3 = t1 * t1 * t1;
function labConvert(o2) {
  if (o2 instanceof Lab) return new Lab(o2.l, o2.a, o2.b, o2.opacity);
  if (o2 instanceof Hcl) return hcl2lab(o2);
  if (!(o2 instanceof Rgb)) o2 = rgbConvert(o2);
  var r2 = rgb2lrgb(o2.r), g3 = rgb2lrgb(o2.g), b = rgb2lrgb(o2.b), y3 = xyz2lab((0.2225045 * r2 + 0.7168786 * g3 + 0.0606169 * b) / Yn), x3, z3;
  if (r2 === g3 && g3 === b) x3 = z3 = y3;
  else {
    x3 = xyz2lab((0.4360747 * r2 + 0.3850649 * g3 + 0.1430804 * b) / Xn);
    z3 = xyz2lab((0.0139322 * r2 + 0.0971045 * g3 + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y3 - 16, 500 * (x3 - y3), 200 * (y3 - z3), o2.opacity);
}
function lab(l2, a3, b, opacity) {
  return arguments.length === 1 ? labConvert(l2) : new Lab(l2, a3, b, opacity == null ? 1 : opacity);
}
function Lab(l2, a3, b, opacity) {
  this.l = +l2;
  this.a = +a3;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Lab, lab, extend2(Color3, {
  brighter(k2) {
    return new Lab(this.l + K * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);
  },
  darker(k2) {
    return new Lab(this.l - K * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);
  },
  rgb() {
    var y3 = (this.l + 16) / 116, x3 = isNaN(this.a) ? y3 : y3 + this.a / 500, z3 = isNaN(this.b) ? y3 : y3 - this.b / 200;
    x3 = Xn * lab2xyz(x3);
    y3 = Yn * lab2xyz(y3);
    z3 = Zn * lab2xyz(z3);
    return new Rgb(
      lrgb2rgb(3.1338561 * x3 - 1.6168667 * y3 - 0.4906146 * z3),
      lrgb2rgb(-0.9787684 * x3 + 1.9161415 * y3 + 0.033454 * z3),
      lrgb2rgb(0.0719453 * x3 - 0.2289914 * y3 + 1.4052427 * z3),
      this.opacity
    );
  }
}));
function xyz2lab(t5) {
  return t5 > t3 ? Math.pow(t5, 1 / 3) : t5 / t2 + t0;
}
function lab2xyz(t5) {
  return t5 > t1 ? t5 * t5 * t5 : t2 * (t5 - t0);
}
function lrgb2rgb(x3) {
  return 255 * (x3 <= 31308e-7 ? 12.92 * x3 : 1.055 * Math.pow(x3, 1 / 2.4) - 0.055);
}
function rgb2lrgb(x3) {
  return (x3 /= 255) <= 0.04045 ? x3 / 12.92 : Math.pow((x3 + 0.055) / 1.055, 2.4);
}
function hclConvert(o2) {
  if (o2 instanceof Hcl) return new Hcl(o2.h, o2.c, o2.l, o2.opacity);
  if (!(o2 instanceof Lab)) o2 = labConvert(o2);
  if (o2.a === 0 && o2.b === 0) return new Hcl(NaN, 0 < o2.l && o2.l < 100 ? 0 : NaN, o2.l, o2.opacity);
  var h2 = Math.atan2(o2.b, o2.a) * degrees2;
  return new Hcl(h2 < 0 ? h2 + 360 : h2, Math.sqrt(o2.a * o2.a + o2.b * o2.b), o2.l, o2.opacity);
}
function hcl(h2, c5, l2, opacity) {
  return arguments.length === 1 ? hclConvert(h2) : new Hcl(h2, c5, l2, opacity == null ? 1 : opacity);
}
function Hcl(h2, c5, l2, opacity) {
  this.h = +h2;
  this.c = +c5;
  this.l = +l2;
  this.opacity = +opacity;
}
function hcl2lab(o2) {
  if (isNaN(o2.h)) return new Lab(o2.l, 0, 0, o2.opacity);
  var h2 = o2.h * radians2;
  return new Lab(o2.l, Math.cos(h2) * o2.c, Math.sin(h2) * o2.c, o2.opacity);
}
define_default(Hcl, hcl, extend2(Color3, {
  brighter(k2) {
    return new Hcl(this.h, this.c, this.l + K * (k2 == null ? 1 : k2), this.opacity);
  },
  darker(k2) {
    return new Hcl(this.h, this.c, this.l - K * (k2 == null ? 1 : k2), this.opacity);
  },
  rgb() {
    return hcl2lab(this).rgb();
  }
}));

// node_modules/d3-color/src/cubehelix.js
var A = -0.14861;
var B = 1.78277;
var C = -0.29227;
var D = -0.90649;
var E = 1.97294;
var ED = E * D;
var EB = E * B;
var BC_DA = B * C - D * A;
function cubehelixConvert(o2) {
  if (o2 instanceof Cubehelix) return new Cubehelix(o2.h, o2.s, o2.l, o2.opacity);
  if (!(o2 instanceof Rgb)) o2 = rgbConvert(o2);
  var r2 = o2.r / 255, g3 = o2.g / 255, b = o2.b / 255, l2 = (BC_DA * b + ED * r2 - EB * g3) / (BC_DA + ED - EB), bl = b - l2, k2 = (E * (g3 - l2) - C * bl) / D, s2 = Math.sqrt(k2 * k2 + bl * bl) / (E * l2 * (1 - l2)), h2 = s2 ? Math.atan2(k2, bl) * degrees2 - 120 : NaN;
  return new Cubehelix(h2 < 0 ? h2 + 360 : h2, s2, l2, o2.opacity);
}
function cubehelix(h2, s2, l2, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h2) : new Cubehelix(h2, s2, l2, opacity == null ? 1 : opacity);
}
function Cubehelix(h2, s2, l2, opacity) {
  this.h = +h2;
  this.s = +s2;
  this.l = +l2;
  this.opacity = +opacity;
}
define_default(Cubehelix, cubehelix, extend2(Color3, {
  brighter(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Cubehelix(this.h, this.s, this.l * k2, this.opacity);
  },
  darker(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Cubehelix(this.h, this.s, this.l * k2, this.opacity);
  },
  rgb() {
    var h2 = isNaN(this.h) ? 0 : (this.h + 120) * radians2, l2 = +this.l, a3 = isNaN(this.s) ? 0 : this.s * l2 * (1 - l2), cosh2 = Math.cos(h2), sinh2 = Math.sin(h2);
    return new Rgb(
      255 * (l2 + a3 * (A * cosh2 + B * sinh2)),
      255 * (l2 + a3 * (C * cosh2 + D * sinh2)),
      255 * (l2 + a3 * (E * cosh2)),
      this.opacity
    );
  }
}));

// node_modules/d3-interpolate/src/basis.js
function basis(t13, v0, v1, v2, v3) {
  var t22 = t13 * t13, t32 = t22 * t13;
  return ((1 - 3 * t13 + 3 * t22 - t32) * v0 + (4 - 6 * t22 + 3 * t32) * v1 + (1 + 3 * t13 + 3 * t22 - 3 * t32) * v2 + t32 * v3) / 6;
}
function basis_default(values2) {
  var n2 = values2.length - 1;
  return function(t5) {
    var i2 = t5 <= 0 ? t5 = 0 : t5 >= 1 ? (t5 = 1, n2 - 1) : Math.floor(t5 * n2), v1 = values2[i2], v2 = values2[i2 + 1], v0 = i2 > 0 ? values2[i2 - 1] : 2 * v1 - v2, v3 = i2 < n2 - 1 ? values2[i2 + 2] : 2 * v2 - v1;
    return basis((t5 - i2 / n2) * n2, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default(values2) {
  var n2 = values2.length;
  return function(t5) {
    var i2 = Math.floor(((t5 %= 1) < 0 ? ++t5 : t5) * n2), v0 = values2[(i2 + n2 - 1) % n2], v1 = values2[i2 % n2], v2 = values2[(i2 + 1) % n2], v3 = values2[(i2 + 2) % n2];
    return basis((t5 - i2 / n2) * n2, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/constant.js
var constant_default2 = (x3) => () => x3;

// node_modules/d3-interpolate/src/color.js
function linear(a3, d3) {
  return function(t5) {
    return a3 + t5 * d3;
  };
}
function exponential(a3, b, y3) {
  return a3 = Math.pow(a3, y3), b = Math.pow(b, y3) - a3, y3 = 1 / y3, function(t5) {
    return Math.pow(a3 + t5 * b, y3);
  };
}
function hue(a3, b) {
  var d3 = b - a3;
  return d3 ? linear(a3, d3 > 180 || d3 < -180 ? d3 - 360 * Math.round(d3 / 360) : d3) : constant_default2(isNaN(a3) ? b : a3);
}
function gamma(y3) {
  return (y3 = +y3) === 1 ? nogamma : function(a3, b) {
    return b - a3 ? exponential(a3, b, y3) : constant_default2(isNaN(a3) ? b : a3);
  };
}
function nogamma(a3, b) {
  var d3 = b - a3;
  return d3 ? linear(a3, d3) : constant_default2(isNaN(a3) ? b : a3);
}

// node_modules/d3-interpolate/src/rgb.js
var rgb_default = (function rgbGamma(y3) {
  var color3 = gamma(y3);
  function rgb3(start2, end) {
    var r2 = color3((start2 = rgb(start2)).r, (end = rgb(end)).r), g3 = color3(start2.g, end.g), b = color3(start2.b, end.b), opacity = nogamma(start2.opacity, end.opacity);
    return function(t5) {
      start2.r = r2(t5);
      start2.g = g3(t5);
      start2.b = b(t5);
      start2.opacity = opacity(t5);
      return start2 + "";
    };
  }
  rgb3.gamma = rgbGamma;
  return rgb3;
})(1);
function rgbSpline(spline) {
  return function(colors) {
    var n2 = colors.length, r2 = new Array(n2), g3 = new Array(n2), b = new Array(n2), i2, color3;
    for (i2 = 0; i2 < n2; ++i2) {
      color3 = rgb(colors[i2]);
      r2[i2] = color3.r || 0;
      g3[i2] = color3.g || 0;
      b[i2] = color3.b || 0;
    }
    r2 = spline(r2);
    g3 = spline(g3);
    b = spline(b);
    color3.opacity = 1;
    return function(t5) {
      color3.r = r2(t5);
      color3.g = g3(t5);
      color3.b = b(t5);
      return color3 + "";
    };
  };
}
var rgbBasis = rgbSpline(basis_default);
var rgbBasisClosed = rgbSpline(basisClosed_default);

// node_modules/d3-interpolate/src/number.js
function number_default(a3, b) {
  return a3 = +a3, b = +b, function(t5) {
    return a3 * (1 - t5) + b * t5;
  };
}

// node_modules/d3-interpolate/src/string.js
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");
function zero2(b) {
  return function() {
    return b;
  };
}
function one(b) {
  return function(t5) {
    return b(t5) + "";
  };
}
function string_default(a3, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i2 = -1, s2 = [], q2 = [];
  a3 = a3 + "", b = b + "";
  while ((am = reA.exec(a3)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      bs = b.slice(bi, bs);
      if (s2[i2]) s2[i2] += bs;
      else s2[++i2] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s2[i2]) s2[i2] += bm;
      else s2[++i2] = bm;
    } else {
      s2[++i2] = null;
      q2.push({ i: i2, x: number_default(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s2[i2]) s2[i2] += bs;
    else s2[++i2] = bs;
  }
  return s2.length < 2 ? q2[0] ? one(q2[0].x) : zero2(b) : (b = q2.length, function(t5) {
    for (var i3 = 0, o2; i3 < b; ++i3) s2[(o2 = q2[i3]).i] = o2.x(t5);
    return s2.join("");
  });
}

// node_modules/d3-interpolate/src/transform/decompose.js
var degrees3 = 180 / Math.PI;
var identity2 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose_default(a3, b, c5, d3, e3, f3) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a3 * a3 + b * b)) a3 /= scaleX, b /= scaleX;
  if (skewX = a3 * c5 + b * d3) c5 -= a3 * skewX, d3 -= b * skewX;
  if (scaleY = Math.sqrt(c5 * c5 + d3 * d3)) c5 /= scaleY, d3 /= scaleY, skewX /= scaleY;
  if (a3 * d3 < b * c5) a3 = -a3, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e3,
    translateY: f3,
    rotate: Math.atan2(b, a3) * degrees3,
    skewX: Math.atan(skewX) * degrees3,
    scaleX,
    scaleY
  };
}

// node_modules/d3-interpolate/src/transform/parse.js
var svgNode;
function parseCss(value) {
  const m3 = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m3.isIdentity ? identity2 : decompose_default(m3.a, m3.b, m3.c, m3.d, m3.e, m3.f);
}
function parseSvg(value) {
  if (value == null) return identity2;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return identity2;
  value = value.matrix;
  return decompose_default(value.a, value.b, value.c, value.d, value.e, value.f);
}

// node_modules/d3-interpolate/src/transform/index.js
function interpolateTransform(parse2, pxComma, pxParen, degParen) {
  function pop(s2) {
    return s2.length ? s2.pop() + " " : "";
  }
  function translate(xa, ya, xb, yb, s2, q2) {
    if (xa !== xb || ya !== yb) {
      var i2 = s2.push("translate(", null, pxComma, null, pxParen);
      q2.push({ i: i2 - 4, x: number_default(xa, xb) }, { i: i2 - 2, x: number_default(ya, yb) });
    } else if (xb || yb) {
      s2.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate2(a3, b, s2, q2) {
    if (a3 !== b) {
      if (a3 - b > 180) b += 360;
      else if (b - a3 > 180) a3 += 360;
      q2.push({ i: s2.push(pop(s2) + "rotate(", null, degParen) - 2, x: number_default(a3, b) });
    } else if (b) {
      s2.push(pop(s2) + "rotate(" + b + degParen);
    }
  }
  function skewX(a3, b, s2, q2) {
    if (a3 !== b) {
      q2.push({ i: s2.push(pop(s2) + "skewX(", null, degParen) - 2, x: number_default(a3, b) });
    } else if (b) {
      s2.push(pop(s2) + "skewX(" + b + degParen);
    }
  }
  function scale2(xa, ya, xb, yb, s2, q2) {
    if (xa !== xb || ya !== yb) {
      var i2 = s2.push(pop(s2) + "scale(", null, ",", null, ")");
      q2.push({ i: i2 - 4, x: number_default(xa, xb) }, { i: i2 - 2, x: number_default(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s2.push(pop(s2) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a3, b) {
    var s2 = [], q2 = [];
    a3 = parse2(a3), b = parse2(b);
    translate(a3.translateX, a3.translateY, b.translateX, b.translateY, s2, q2);
    rotate2(a3.rotate, b.rotate, s2, q2);
    skewX(a3.skewX, b.skewX, s2, q2);
    scale2(a3.scaleX, a3.scaleY, b.scaleX, b.scaleY, s2, q2);
    a3 = b = null;
    return function(t5) {
      var i2 = -1, n2 = q2.length, o2;
      while (++i2 < n2) s2[(o2 = q2[i2]).i] = o2.x(t5);
      return s2.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

// node_modules/d3-interpolate/src/zoom.js
var epsilon2 = 1e-12;
function cosh(x3) {
  return ((x3 = Math.exp(x3)) + 1 / x3) / 2;
}
function sinh(x3) {
  return ((x3 = Math.exp(x3)) - 1 / x3) / 2;
}
function tanh(x3) {
  return ((x3 = Math.exp(2 * x3)) - 1) / (x3 + 1);
}
var zoom_default = (function zoomRho(rho, rho2, rho4) {
  function zoom2(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w02 = p0[2], ux1 = p1[0], uy1 = p1[1], w12 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d22 = dx * dx + dy * dy, i2, S2;
    if (d22 < epsilon2) {
      S2 = Math.log(w12 / w02) / rho;
      i2 = function(t5) {
        return [
          ux0 + t5 * dx,
          uy0 + t5 * dy,
          w02 * Math.exp(rho * t5 * S2)
        ];
      };
    } else {
      var d1 = Math.sqrt(d22), b02 = (w12 * w12 - w02 * w02 + rho4 * d22) / (2 * w02 * rho2 * d1), b12 = (w12 * w12 - w02 * w02 - rho4 * d22) / (2 * w12 * rho2 * d1), r0 = Math.log(Math.sqrt(b02 * b02 + 1) - b02), r1 = Math.log(Math.sqrt(b12 * b12 + 1) - b12);
      S2 = (r1 - r0) / rho;
      i2 = function(t5) {
        var s2 = t5 * S2, coshr0 = cosh(r0), u2 = w02 / (rho2 * d1) * (coshr0 * tanh(rho * s2 + r0) - sinh(r0));
        return [
          ux0 + u2 * dx,
          uy0 + u2 * dy,
          w02 * coshr0 / cosh(rho * s2 + r0)
        ];
      };
    }
    i2.duration = S2 * 1e3 * rho / Math.SQRT2;
    return i2;
  }
  zoom2.rho = function(_2) {
    var _1 = Math.max(1e-3, +_2), _22 = _1 * _1, _4 = _22 * _22;
    return zoomRho(_1, _22, _4);
  };
  return zoom2;
})(Math.SQRT2, 2, 4);

// node_modules/d3-interpolate/src/hsl.js
function hsl2(hue3) {
  return function(start2, end) {
    var h2 = hue3((start2 = hsl(start2)).h, (end = hsl(end)).h), s2 = nogamma(start2.s, end.s), l2 = nogamma(start2.l, end.l), opacity = nogamma(start2.opacity, end.opacity);
    return function(t5) {
      start2.h = h2(t5);
      start2.s = s2(t5);
      start2.l = l2(t5);
      start2.opacity = opacity(t5);
      return start2 + "";
    };
  };
}
var hsl_default = hsl2(hue);
var hslLong = hsl2(nogamma);

// node_modules/d3-interpolate/src/hcl.js
function hcl2(hue3) {
  return function(start2, end) {
    var h2 = hue3((start2 = hcl(start2)).h, (end = hcl(end)).h), c5 = nogamma(start2.c, end.c), l2 = nogamma(start2.l, end.l), opacity = nogamma(start2.opacity, end.opacity);
    return function(t5) {
      start2.h = h2(t5);
      start2.c = c5(t5);
      start2.l = l2(t5);
      start2.opacity = opacity(t5);
      return start2 + "";
    };
  };
}
var hcl_default = hcl2(hue);
var hclLong = hcl2(nogamma);

// node_modules/d3-interpolate/src/cubehelix.js
function cubehelix2(hue3) {
  return (function cubehelixGamma(y3) {
    y3 = +y3;
    function cubehelix3(start2, end) {
      var h2 = hue3((start2 = cubehelix(start2)).h, (end = cubehelix(end)).h), s2 = nogamma(start2.s, end.s), l2 = nogamma(start2.l, end.l), opacity = nogamma(start2.opacity, end.opacity);
      return function(t5) {
        start2.h = h2(t5);
        start2.s = s2(t5);
        start2.l = l2(Math.pow(t5, y3));
        start2.opacity = opacity(t5);
        return start2 + "";
      };
    }
    cubehelix3.gamma = cubehelixGamma;
    return cubehelix3;
  })(1);
}
var cubehelix_default = cubehelix2(hue);
var cubehelixLong = cubehelix2(nogamma);

// node_modules/d3-format/src/formatDecimal.js
function formatDecimal_default(x3) {
  return Math.abs(x3 = Math.round(x3)) >= 1e21 ? x3.toLocaleString("en").replace(/,/g, "") : x3.toString(10);
}
function formatDecimalParts(x3, p3) {
  if (!isFinite(x3) || x3 === 0) return null;
  var i2 = (x3 = p3 ? x3.toExponential(p3 - 1) : x3.toExponential()).indexOf("e"), coefficient = x3.slice(0, i2);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x3.slice(i2 + 1)
  ];
}

// node_modules/d3-format/src/exponent.js
function exponent_default(x3) {
  return x3 = formatDecimalParts(Math.abs(x3)), x3 ? x3[1] : NaN;
}

// node_modules/d3-format/src/formatGroup.js
function formatGroup_default(grouping, thousands) {
  return function(value, width) {
    var i2 = value.length, t5 = [], j2 = 0, g3 = grouping[0], length2 = 0;
    while (i2 > 0 && g3 > 0) {
      if (length2 + g3 + 1 > width) g3 = Math.max(1, width - length2);
      t5.push(value.substring(i2 -= g3, i2 + g3));
      if ((length2 += g3 + 1) > width) break;
      g3 = grouping[j2 = (j2 + 1) % grouping.length];
    }
    return t5.reverse().join(thousands);
  };
}

// node_modules/d3-format/src/formatNumerals.js
function formatNumerals_default(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i2) {
      return numerals[+i2];
    });
  };
}

// node_modules/d3-format/src/formatSpecifier.js
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};

// node_modules/d3-format/src/formatTrim.js
function formatTrim_default(s2) {
  out: for (var n2 = s2.length, i2 = 1, i0 = -1, i1; i2 < n2; ++i2) {
    switch (s2[i2]) {
      case ".":
        i0 = i1 = i2;
        break;
      case "0":
        if (i0 === 0) i0 = i2;
        i1 = i2;
        break;
      default:
        if (!+s2[i2]) break out;
        if (i0 > 0) i0 = 0;
        break;
    }
  }
  return i0 > 0 ? s2.slice(0, i0) + s2.slice(i1 + 1) : s2;
}

// node_modules/d3-format/src/formatPrefixAuto.js
var prefixExponent;
function formatPrefixAuto_default(x3, p3) {
  var d3 = formatDecimalParts(x3, p3);
  if (!d3) return prefixExponent = void 0, x3.toPrecision(p3);
  var coefficient = d3[0], exponent2 = d3[1], i2 = exponent2 - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent2 / 3))) * 3) + 1, n2 = coefficient.length;
  return i2 === n2 ? coefficient : i2 > n2 ? coefficient + new Array(i2 - n2 + 1).join("0") : i2 > 0 ? coefficient.slice(0, i2) + "." + coefficient.slice(i2) : "0." + new Array(1 - i2).join("0") + formatDecimalParts(x3, Math.max(0, p3 + i2 - 1))[0];
}

// node_modules/d3-format/src/formatRounded.js
function formatRounded_default(x3, p3) {
  var d3 = formatDecimalParts(x3, p3);
  if (!d3) return x3 + "";
  var coefficient = d3[0], exponent2 = d3[1];
  return exponent2 < 0 ? "0." + new Array(-exponent2).join("0") + coefficient : coefficient.length > exponent2 + 1 ? coefficient.slice(0, exponent2 + 1) + "." + coefficient.slice(exponent2 + 1) : coefficient + new Array(exponent2 - coefficient.length + 2).join("0");
}

// node_modules/d3-format/src/formatTypes.js
var formatTypes_default = {
  "%": (x3, p3) => (x3 * 100).toFixed(p3),
  "b": (x3) => Math.round(x3).toString(2),
  "c": (x3) => x3 + "",
  "d": formatDecimal_default,
  "e": (x3, p3) => x3.toExponential(p3),
  "f": (x3, p3) => x3.toFixed(p3),
  "g": (x3, p3) => x3.toPrecision(p3),
  "o": (x3) => Math.round(x3).toString(8),
  "p": (x3, p3) => formatRounded_default(x3 * 100, p3),
  "r": formatRounded_default,
  "s": formatPrefixAuto_default,
  "X": (x3) => Math.round(x3).toString(16).toUpperCase(),
  "x": (x3) => Math.round(x3).toString(16)
};

// node_modules/d3-format/src/identity.js
function identity_default(x3) {
  return x3;
}

// node_modules/d3-format/src/locale.js
var map4 = Array.prototype.map;
var prefixes = ["y", "z", "a", "f", "p", "n", "Âµ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function locale_default(locale3) {
  var group2 = locale3.grouping === void 0 || locale3.thousands === void 0 ? identity_default : formatGroup_default(map4.call(locale3.grouping, Number), locale3.thousands + ""), currencyPrefix = locale3.currency === void 0 ? "" : locale3.currency[0] + "", currencySuffix = locale3.currency === void 0 ? "" : locale3.currency[1] + "", decimal = locale3.decimal === void 0 ? "." : locale3.decimal + "", numerals = locale3.numerals === void 0 ? identity_default : formatNumerals_default(map4.call(locale3.numerals, String)), percent = locale3.percent === void 0 ? "%" : locale3.percent + "", minus = locale3.minus === void 0 ? "â" : locale3.minus + "", nan = locale3.nan === void 0 ? "NaN" : locale3.nan + "";
  function newFormat(specifier, options) {
    specifier = formatSpecifier(specifier);
    var fill2 = specifier.fill, align = specifier.align, sign3 = specifier.sign, symbol = specifier.symbol, zero3 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim2 = specifier.trim, type = specifier.type;
    if (type === "n") comma = true, type = "g";
    else if (!formatTypes_default[type]) precision === void 0 && (precision = 12), trim2 = true, type = "g";
    if (zero3 || fill2 === "0" && align === "=") zero3 = true, fill2 = "0", align = "=";
    var prefix = (options && options.prefix !== void 0 ? options.prefix : "") + (symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : ""), suffix = (symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "") + (options && options.suffix !== void 0 ? options.suffix : "");
    var formatType = formatTypes_default[type], maybeSuffix = /[defgprs%]/.test(type);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format3(value) {
      var valuePrefix = prefix, valueSuffix = suffix, i2, n2, c5;
      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;
        var valueNegative = value < 0 || 1 / value < 0;
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
        if (trim2) value = formatTrim_default(value);
        if (valueNegative && +value === 0 && sign3 !== "+") valueNegative = false;
        valuePrefix = (valueNegative ? sign3 === "(" ? sign3 : minus : sign3 === "-" || sign3 === "(" ? "" : sign3) + valuePrefix;
        valueSuffix = (type === "s" && !isNaN(value) && prefixExponent !== void 0 ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign3 === "(" ? ")" : "");
        if (maybeSuffix) {
          i2 = -1, n2 = value.length;
          while (++i2 < n2) {
            if (c5 = value.charCodeAt(i2), 48 > c5 || c5 > 57) {
              valueSuffix = (c5 === 46 ? decimal + value.slice(i2 + 1) : value.slice(i2)) + valueSuffix;
              value = value.slice(0, i2);
              break;
            }
          }
        }
      }
      if (comma && !zero3) value = group2(value, Infinity);
      var length2 = valuePrefix.length + value.length + valueSuffix.length, padding = length2 < width ? new Array(width - length2 + 1).join(fill2) : "";
      if (comma && zero3) value = group2(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
      switch (align) {
        case "<":
          value = valuePrefix + value + valueSuffix + padding;
          break;
        case "=":
          value = valuePrefix + padding + value + valueSuffix;
          break;
        case "^":
          value = padding.slice(0, length2 = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length2);
          break;
        default:
          value = padding + valuePrefix + value + valueSuffix;
          break;
      }
      return numerals(value);
    }
    format3.toString = function() {
      return specifier + "";
    };
    return format3;
  }
  function formatPrefix2(specifier, value) {
    var e3 = Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3, k2 = Math.pow(10, -e3), f3 = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier), { suffix: prefixes[8 + e3 / 3] });
    return function(value2) {
      return f3(k2 * value2);
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}

// node_modules/d3-format/src/defaultLocale.js
var locale;
var format;
var formatPrefix;
defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale(definition) {
  locale = locale_default(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}

// node_modules/d3-time/src/interval.js
var t02 = /* @__PURE__ */ new Date();
var t12 = /* @__PURE__ */ new Date();
function timeInterval(floori, offseti, count2, field) {
  function interval2(date) {
    return floori(date = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date)), date;
  }
  interval2.floor = (date) => {
    return floori(date = /* @__PURE__ */ new Date(+date)), date;
  };
  interval2.ceil = (date) => {
    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
  };
  interval2.round = (date) => {
    const d0 = interval2(date), d1 = interval2.ceil(date);
    return date - d0 < d1 - date ? d0 : d1;
  };
  interval2.offset = (date, step2) => {
    return offseti(date = /* @__PURE__ */ new Date(+date), step2 == null ? 1 : Math.floor(step2)), date;
  };
  interval2.range = (start2, stop, step2) => {
    const range4 = [];
    start2 = interval2.ceil(start2);
    step2 = step2 == null ? 1 : Math.floor(step2);
    if (!(start2 < stop) || !(step2 > 0)) return range4;
    let previous;
    do
      range4.push(previous = /* @__PURE__ */ new Date(+start2)), offseti(start2, step2), floori(start2);
    while (previous < start2 && start2 < stop);
    return range4;
  };
  interval2.filter = (test) => {
    return timeInterval((date) => {
      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
    }, (date, step2) => {
      if (date >= date) {
        if (step2 < 0) while (++step2 <= 0) {
          while (offseti(date, -1), !test(date)) {
          }
        }
        else while (--step2 >= 0) {
          while (offseti(date, 1), !test(date)) {
          }
        }
      }
    });
  };
  if (count2) {
    interval2.count = (start2, end) => {
      t02.setTime(+start2), t12.setTime(+end);
      floori(t02), floori(t12);
      return Math.floor(count2(t02, t12));
    };
    interval2.every = (step2) => {
      step2 = Math.floor(step2);
      return !isFinite(step2) || !(step2 > 0) ? null : !(step2 > 1) ? interval2 : interval2.filter(field ? (d3) => field(d3) % step2 === 0 : (d3) => interval2.count(0, d3) % step2 === 0);
    };
  }
  return interval2;
}

// node_modules/d3-time/src/millisecond.js
var millisecond = timeInterval(() => {
}, (date, step2) => {
  date.setTime(+date + step2);
}, (start2, end) => {
  return end - start2;
});
millisecond.every = (k2) => {
  k2 = Math.floor(k2);
  if (!isFinite(k2) || !(k2 > 0)) return null;
  if (!(k2 > 1)) return millisecond;
  return timeInterval((date) => {
    date.setTime(Math.floor(date / k2) * k2);
  }, (date, step2) => {
    date.setTime(+date + step2 * k2);
  }, (start2, end) => {
    return (end - start2) / k2;
  });
};
var milliseconds = millisecond.range;

// node_modules/d3-time/src/duration.js
var durationSecond = 1e3;
var durationMinute = durationSecond * 60;
var durationHour = durationMinute * 60;
var durationDay = durationHour * 24;
var durationWeek = durationDay * 7;
var durationMonth = durationDay * 30;
var durationYear = durationDay * 365;

// node_modules/d3-time/src/second.js
var second = timeInterval((date) => {
  date.setTime(date - date.getMilliseconds());
}, (date, step2) => {
  date.setTime(+date + step2 * durationSecond);
}, (start2, end) => {
  return (end - start2) / durationSecond;
}, (date) => {
  return date.getUTCSeconds();
});
var seconds = second.range;

// node_modules/d3-time/src/minute.js
var timeMinute = timeInterval((date) => {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);
}, (date, step2) => {
  date.setTime(+date + step2 * durationMinute);
}, (start2, end) => {
  return (end - start2) / durationMinute;
}, (date) => {
  return date.getMinutes();
});
var timeMinutes = timeMinute.range;
var utcMinute = timeInterval((date) => {
  date.setUTCSeconds(0, 0);
}, (date, step2) => {
  date.setTime(+date + step2 * durationMinute);
}, (start2, end) => {
  return (end - start2) / durationMinute;
}, (date) => {
  return date.getUTCMinutes();
});
var utcMinutes = utcMinute.range;

// node_modules/d3-time/src/hour.js
var timeHour = timeInterval((date) => {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);
}, (date, step2) => {
  date.setTime(+date + step2 * durationHour);
}, (start2, end) => {
  return (end - start2) / durationHour;
}, (date) => {
  return date.getHours();
});
var timeHours = timeHour.range;
var utcHour = timeInterval((date) => {
  date.setUTCMinutes(0, 0, 0);
}, (date, step2) => {
  date.setTime(+date + step2 * durationHour);
}, (start2, end) => {
  return (end - start2) / durationHour;
}, (date) => {
  return date.getUTCHours();
});
var utcHours = utcHour.range;

// node_modules/d3-time/src/day.js
var timeDay = timeInterval(
  (date) => date.setHours(0, 0, 0, 0),
  (date, step2) => date.setDate(date.getDate() + step2),
  (start2, end) => (end - start2 - (end.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationDay,
  (date) => date.getDate() - 1
);
var timeDays = timeDay.range;
var utcDay = timeInterval((date) => {
  date.setUTCHours(0, 0, 0, 0);
}, (date, step2) => {
  date.setUTCDate(date.getUTCDate() + step2);
}, (start2, end) => {
  return (end - start2) / durationDay;
}, (date) => {
  return date.getUTCDate() - 1;
});
var utcDays = utcDay.range;
var unixDay = timeInterval((date) => {
  date.setUTCHours(0, 0, 0, 0);
}, (date, step2) => {
  date.setUTCDate(date.getUTCDate() + step2);
}, (start2, end) => {
  return (end - start2) / durationDay;
}, (date) => {
  return Math.floor(date / durationDay);
});
var unixDays = unixDay.range;

// node_modules/d3-time/src/week.js
function timeWeekday(i2) {
  return timeInterval((date) => {
    date.setDate(date.getDate() - (date.getDay() + 7 - i2) % 7);
    date.setHours(0, 0, 0, 0);
  }, (date, step2) => {
    date.setDate(date.getDate() + step2 * 7);
  }, (start2, end) => {
    return (end - start2 - (end.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}
var timeSunday = timeWeekday(0);
var timeMonday = timeWeekday(1);
var timeTuesday = timeWeekday(2);
var timeWednesday = timeWeekday(3);
var timeThursday = timeWeekday(4);
var timeFriday = timeWeekday(5);
var timeSaturday = timeWeekday(6);
var timeSundays = timeSunday.range;
var timeMondays = timeMonday.range;
var timeTuesdays = timeTuesday.range;
var timeWednesdays = timeWednesday.range;
var timeThursdays = timeThursday.range;
var timeFridays = timeFriday.range;
var timeSaturdays = timeSaturday.range;
function utcWeekday(i2) {
  return timeInterval((date) => {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i2) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, (date, step2) => {
    date.setUTCDate(date.getUTCDate() + step2 * 7);
  }, (start2, end) => {
    return (end - start2) / durationWeek;
  });
}
var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);
var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;

// node_modules/d3-time/src/month.js
var timeMonth = timeInterval((date) => {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, (date, step2) => {
  date.setMonth(date.getMonth() + step2);
}, (start2, end) => {
  return end.getMonth() - start2.getMonth() + (end.getFullYear() - start2.getFullYear()) * 12;
}, (date) => {
  return date.getMonth();
});
var timeMonths = timeMonth.range;
var utcMonth = timeInterval((date) => {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, (date, step2) => {
  date.setUTCMonth(date.getUTCMonth() + step2);
}, (start2, end) => {
  return end.getUTCMonth() - start2.getUTCMonth() + (end.getUTCFullYear() - start2.getUTCFullYear()) * 12;
}, (date) => {
  return date.getUTCMonth();
});
var utcMonths = utcMonth.range;

// node_modules/d3-time/src/year.js
var timeYear = timeInterval((date) => {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, (date, step2) => {
  date.setFullYear(date.getFullYear() + step2);
}, (start2, end) => {
  return end.getFullYear() - start2.getFullYear();
}, (date) => {
  return date.getFullYear();
});
timeYear.every = (k2) => {
  return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : timeInterval((date) => {
    date.setFullYear(Math.floor(date.getFullYear() / k2) * k2);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, (date, step2) => {
    date.setFullYear(date.getFullYear() + step2 * k2);
  });
};
var timeYears = timeYear.range;
var utcYear = timeInterval((date) => {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, (date, step2) => {
  date.setUTCFullYear(date.getUTCFullYear() + step2);
}, (start2, end) => {
  return end.getUTCFullYear() - start2.getUTCFullYear();
}, (date) => {
  return date.getUTCFullYear();
});
utcYear.every = (k2) => {
  return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : timeInterval((date) => {
    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k2) * k2);
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, (date, step2) => {
    date.setUTCFullYear(date.getUTCFullYear() + step2 * k2);
  });
};
var utcYears = utcYear.range;

// node_modules/d3-time/src/ticks.js
function ticker(year, month, week, day, hour, minute) {
  const tickIntervals = [
    [second, 1, durationSecond],
    [second, 5, 5 * durationSecond],
    [second, 15, 15 * durationSecond],
    [second, 30, 30 * durationSecond],
    [minute, 1, durationMinute],
    [minute, 5, 5 * durationMinute],
    [minute, 15, 15 * durationMinute],
    [minute, 30, 30 * durationMinute],
    [hour, 1, durationHour],
    [hour, 3, 3 * durationHour],
    [hour, 6, 6 * durationHour],
    [hour, 12, 12 * durationHour],
    [day, 1, durationDay],
    [day, 2, 2 * durationDay],
    [week, 1, durationWeek],
    [month, 1, durationMonth],
    [month, 3, 3 * durationMonth],
    [year, 1, durationYear]
  ];
  function ticks2(start2, stop, count2) {
    const reverse3 = stop < start2;
    if (reverse3) [start2, stop] = [stop, start2];
    const interval2 = count2 && typeof count2.range === "function" ? count2 : tickInterval(start2, stop, count2);
    const ticks3 = interval2 ? interval2.range(start2, +stop + 1) : [];
    return reverse3 ? ticks3.reverse() : ticks3;
  }
  function tickInterval(start2, stop, count2) {
    const target = Math.abs(stop - start2) / count2;
    const i2 = bisector(([, , step3]) => step3).right(tickIntervals, target);
    if (i2 === tickIntervals.length) return year.every(tickStep(start2 / durationYear, stop / durationYear, count2));
    if (i2 === 0) return millisecond.every(Math.max(tickStep(start2, stop, count2), 1));
    const [t5, step2] = tickIntervals[target / tickIntervals[i2 - 1][2] < tickIntervals[i2][2] / target ? i2 - 1 : i2];
    return t5.every(step2);
  }
  return [ticks2, tickInterval];
}
var [utcTicks, utcTickInterval] = ticker(utcYear, utcMonth, utcSunday, unixDay, utcHour, utcMinute);
var [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute);

// node_modules/d3-time-format/src/locale.js
function localDate(d3) {
  if (0 <= d3.y && d3.y < 100) {
    var date = new Date(-1, d3.m, d3.d, d3.H, d3.M, d3.S, d3.L);
    date.setFullYear(d3.y);
    return date;
  }
  return new Date(d3.y, d3.m, d3.d, d3.H, d3.M, d3.S, d3.L);
}
function utcDate(d3) {
  if (0 <= d3.y && d3.y < 100) {
    var date = new Date(Date.UTC(-1, d3.m, d3.d, d3.H, d3.M, d3.S, d3.L));
    date.setUTCFullYear(d3.y);
    return date;
  }
  return new Date(Date.UTC(d3.y, d3.m, d3.d, d3.H, d3.M, d3.S, d3.L));
}
function newDate(y3, m3, d3) {
  return { y: y3, m: m3, d: d3, H: 0, M: 0, S: 0, L: 0 };
}
function formatLocale(locale3) {
  var locale_dateTime = locale3.dateTime, locale_date = locale3.date, locale_time = locale3.time, locale_periods = locale3.periods, locale_weekdays = locale3.days, locale_shortWeekdays = locale3.shortDays, locale_months = locale3.months, locale_shortMonths = locale3.shortMonths;
  var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "g": formatYearISO,
    "G": formatFullYearISO,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };
  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "g": formatUTCYearISO,
    "G": formatUTCFullYearISO,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };
  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "g": parseYear,
    "G": parseFullYear,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);
  function newFormat(specifier, formats2) {
    return function(date) {
      var string2 = [], i2 = -1, j2 = 0, n2 = specifier.length, c5, pad4, format3;
      if (!(date instanceof Date)) date = /* @__PURE__ */ new Date(+date);
      while (++i2 < n2) {
        if (specifier.charCodeAt(i2) === 37) {
          string2.push(specifier.slice(j2, i2));
          if ((pad4 = pads[c5 = specifier.charAt(++i2)]) != null) c5 = specifier.charAt(++i2);
          else pad4 = c5 === "e" ? " " : "0";
          if (format3 = formats2[c5]) c5 = format3(date, pad4);
          string2.push(c5);
          j2 = i2 + 1;
        }
      }
      string2.push(specifier.slice(j2, i2));
      return string2.join("");
    };
  }
  function newParse(specifier, Z) {
    return function(string2) {
      var d3 = newDate(1900, void 0, 1), i2 = parseSpecifier(d3, specifier, string2 += "", 0), week, day;
      if (i2 != string2.length) return null;
      if ("Q" in d3) return new Date(d3.Q);
      if ("s" in d3) return new Date(d3.s * 1e3 + ("L" in d3 ? d3.L : 0));
      if (Z && !("Z" in d3)) d3.Z = 0;
      if ("p" in d3) d3.H = d3.H % 12 + d3.p * 12;
      if (d3.m === void 0) d3.m = "q" in d3 ? d3.q : 0;
      if ("V" in d3) {
        if (d3.V < 1 || d3.V > 53) return null;
        if (!("w" in d3)) d3.w = 1;
        if ("Z" in d3) {
          week = utcDate(newDate(d3.y, 0, 1)), day = week.getUTCDay();
          week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);
          week = utcDay.offset(week, (d3.V - 1) * 7);
          d3.y = week.getUTCFullYear();
          d3.m = week.getUTCMonth();
          d3.d = week.getUTCDate() + (d3.w + 6) % 7;
        } else {
          week = localDate(newDate(d3.y, 0, 1)), day = week.getDay();
          week = day > 4 || day === 0 ? timeMonday.ceil(week) : timeMonday(week);
          week = timeDay.offset(week, (d3.V - 1) * 7);
          d3.y = week.getFullYear();
          d3.m = week.getMonth();
          d3.d = week.getDate() + (d3.w + 6) % 7;
        }
      } else if ("W" in d3 || "U" in d3) {
        if (!("w" in d3)) d3.w = "u" in d3 ? d3.u % 7 : "W" in d3 ? 1 : 0;
        day = "Z" in d3 ? utcDate(newDate(d3.y, 0, 1)).getUTCDay() : localDate(newDate(d3.y, 0, 1)).getDay();
        d3.m = 0;
        d3.d = "W" in d3 ? (d3.w + 6) % 7 + d3.W * 7 - (day + 5) % 7 : d3.w + d3.U * 7 - (day + 6) % 7;
      }
      if ("Z" in d3) {
        d3.H += d3.Z / 100 | 0;
        d3.M += d3.Z % 100;
        return utcDate(d3);
      }
      return localDate(d3);
    };
  }
  function parseSpecifier(d3, specifier, string2, j2) {
    var i2 = 0, n2 = specifier.length, m3 = string2.length, c5, parse2;
    while (i2 < n2) {
      if (j2 >= m3) return -1;
      c5 = specifier.charCodeAt(i2++);
      if (c5 === 37) {
        c5 = specifier.charAt(i2++);
        parse2 = parses[c5 in pads ? specifier.charAt(i2++) : c5];
        if (!parse2 || (j2 = parse2(d3, string2, j2)) < 0) return -1;
      } else if (c5 != string2.charCodeAt(j2++)) {
        return -1;
      }
    }
    return j2;
  }
  function parsePeriod(d3, string2, i2) {
    var n2 = periodRe.exec(string2.slice(i2));
    return n2 ? (d3.p = periodLookup.get(n2[0].toLowerCase()), i2 + n2[0].length) : -1;
  }
  function parseShortWeekday(d3, string2, i2) {
    var n2 = shortWeekdayRe.exec(string2.slice(i2));
    return n2 ? (d3.w = shortWeekdayLookup.get(n2[0].toLowerCase()), i2 + n2[0].length) : -1;
  }
  function parseWeekday(d3, string2, i2) {
    var n2 = weekdayRe.exec(string2.slice(i2));
    return n2 ? (d3.w = weekdayLookup.get(n2[0].toLowerCase()), i2 + n2[0].length) : -1;
  }
  function parseShortMonth(d3, string2, i2) {
    var n2 = shortMonthRe.exec(string2.slice(i2));
    return n2 ? (d3.m = shortMonthLookup.get(n2[0].toLowerCase()), i2 + n2[0].length) : -1;
  }
  function parseMonth(d3, string2, i2) {
    var n2 = monthRe.exec(string2.slice(i2));
    return n2 ? (d3.m = monthLookup.get(n2[0].toLowerCase()), i2 + n2[0].length) : -1;
  }
  function parseLocaleDateTime(d3, string2, i2) {
    return parseSpecifier(d3, locale_dateTime, string2, i2);
  }
  function parseLocaleDate(d3, string2, i2) {
    return parseSpecifier(d3, locale_date, string2, i2);
  }
  function parseLocaleTime(d3, string2, i2) {
    return parseSpecifier(d3, locale_time, string2, i2);
  }
  function formatShortWeekday(d3) {
    return locale_shortWeekdays[d3.getDay()];
  }
  function formatWeekday(d3) {
    return locale_weekdays[d3.getDay()];
  }
  function formatShortMonth(d3) {
    return locale_shortMonths[d3.getMonth()];
  }
  function formatMonth(d3) {
    return locale_months[d3.getMonth()];
  }
  function formatPeriod(d3) {
    return locale_periods[+(d3.getHours() >= 12)];
  }
  function formatQuarter(d3) {
    return 1 + ~~(d3.getMonth() / 3);
  }
  function formatUTCShortWeekday(d3) {
    return locale_shortWeekdays[d3.getUTCDay()];
  }
  function formatUTCWeekday(d3) {
    return locale_weekdays[d3.getUTCDay()];
  }
  function formatUTCShortMonth(d3) {
    return locale_shortMonths[d3.getUTCMonth()];
  }
  function formatUTCMonth(d3) {
    return locale_months[d3.getUTCMonth()];
  }
  function formatUTCPeriod(d3) {
    return locale_periods[+(d3.getUTCHours() >= 12)];
  }
  function formatUTCQuarter(d3) {
    return 1 + ~~(d3.getUTCMonth() / 3);
  }
  return {
    format: function(specifier) {
      var f3 = newFormat(specifier += "", formats);
      f3.toString = function() {
        return specifier;
      };
      return f3;
    },
    parse: function(specifier) {
      var p3 = newParse(specifier += "", false);
      p3.toString = function() {
        return specifier;
      };
      return p3;
    },
    utcFormat: function(specifier) {
      var f3 = newFormat(specifier += "", utcFormats);
      f3.toString = function() {
        return specifier;
      };
      return f3;
    },
    utcParse: function(specifier) {
      var p3 = newParse(specifier += "", true);
      p3.toString = function() {
        return specifier;
      };
      return p3;
    }
  };
}
var pads = { "-": "", "_": " ", "0": "0" };
var numberRe = /^\s*\d+/;
var percentRe = /^%/;
var requoteRe = /[\\^$*+?|[\]().{}]/g;
function pad(value, fill2, width) {
  var sign3 = value < 0 ? "-" : "", string2 = (sign3 ? -value : value) + "", length2 = string2.length;
  return sign3 + (length2 < width ? new Array(width - length2 + 1).join(fill2) + string2 : string2);
}
function requote(s2) {
  return s2.replace(requoteRe, "\\$&");
}
function formatRe(names2) {
  return new RegExp("^(?:" + names2.map(requote).join("|") + ")", "i");
}
function formatLookup(names2) {
  return new Map(names2.map((name, i2) => [name.toLowerCase(), i2]));
}
function parseWeekdayNumberSunday(d3, string2, i2) {
  var n2 = numberRe.exec(string2.slice(i2, i2 + 1));
  return n2 ? (d3.w = +n2[0], i2 + n2[0].length) : -1;
}
function parseWeekdayNumberMonday(d3, string2, i2) {
  var n2 = numberRe.exec(string2.slice(i2, i2 + 1));
  return n2 ? (d3.u = +n2[0], i2 + n2[0].length) : -1;
}
function parseWeekNumberSunday(d3, string2, i2) {
  var n2 = numberRe.exec(string2.slice(i2, i2 + 2));
  return n2 ? (d3.U = +n2[0], i2 + n2[0].length) : -1;
}
function parseWeekNumberISO(d3, string2, i2) {
  var n2 = numberRe.exec(string2.slice(i2, i2 + 2));
  return n2 ? (d3.V = +n2[0], i2 + n2[0].length) : -1;
}
function parseWeekNumberMonday(d3, string2, i2) {
  var n2 = numberRe.exec(string2.slice(i2, i2 + 2));
  return n2 ? (d3.W = +n2[0], i2 + n2[0].length) : -1;
}
function parseFullYear(d3, string2, i2) {
  var n2 = numberRe.exec(string2.slice(i2, i2 + 4));
  return n2 ? (d3.y = +n2[0], i2 + n2[0].length) : -1;
}
function parseYear(d3, string2, i2) {
  var n2 = numberRe.exec(string2.slice(i2, i2 + 2));
  return n2 ? (d3.y = +n2[0] + (+n2[0] > 68 ? 1900 : 2e3), i2 + n2[0].length) : -1;
}
function parseZone(d3, string2, i2) {
  var n2 = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string2.slice(i2, i2 + 6));
  return n2 ? (d3.Z = n2[1] ? 0 : -(n2[2] + (n2[3] || "00")), i2 + n2[0].length) : -1;
}
function parseQuarter(d3, string2, i2) {
  var n2 = numberRe.exec(string2.slice(i2, i2 + 1));
  return n2 ? (d3.q = n2[0] * 3 - 3, i2 + n2[0].length) : -1;
}
function parseMonthNumber(d3, string2, i2) {
  var n2 = numberRe.exec(string2.slice(i2, i2 + 2));
  return n2 ? (d3.m = n2[0] - 1, i2 + n2[0].length) : -1;
}
function parseDayOfMonth(d3, string2, i2) {
  var n2 = numberRe.exec(string2.slice(i2, i2 + 2));
  return n2 ? (d3.d = +n2[0], i2 + n2[0].length) : -1;
}
function parseDayOfYear(d3, string2, i2) {
  var n2 = numberRe.exec(string2.slice(i2, i2 + 3));
  return n2 ? (d3.m = 0, d3.d = +n2[0], i2 + n2[0].length) : -1;
}
function parseHour24(d3, string2, i2) {
  var n2 = numberRe.exec(string2.slice(i2, i2 + 2));
  return n2 ? (d3.H = +n2[0], i2 + n2[0].length) : -1;
}
function parseMinutes(d3, string2, i2) {
  var n2 = numberRe.exec(string2.slice(i2, i2 + 2));
  return n2 ? (d3.M = +n2[0], i2 + n2[0].length) : -1;
}
function parseSeconds(d3, string2, i2) {
  var n2 = numberRe.exec(string2.slice(i2, i2 + 2));
  return n2 ? (d3.S = +n2[0], i2 + n2[0].length) : -1;
}
function parseMilliseconds(d3, string2, i2) {
  var n2 = numberRe.exec(string2.slice(i2, i2 + 3));
  return n2 ? (d3.L = +n2[0], i2 + n2[0].length) : -1;
}
function parseMicroseconds(d3, string2, i2) {
  var n2 = numberRe.exec(string2.slice(i2, i2 + 6));
  return n2 ? (d3.L = Math.floor(n2[0] / 1e3), i2 + n2[0].length) : -1;
}
function parseLiteralPercent(d3, string2, i2) {
  var n2 = percentRe.exec(string2.slice(i2, i2 + 1));
  return n2 ? i2 + n2[0].length : -1;
}
function parseUnixTimestamp(d3, string2, i2) {
  var n2 = numberRe.exec(string2.slice(i2));
  return n2 ? (d3.Q = +n2[0], i2 + n2[0].length) : -1;
}
function parseUnixTimestampSeconds(d3, string2, i2) {
  var n2 = numberRe.exec(string2.slice(i2));
  return n2 ? (d3.s = +n2[0], i2 + n2[0].length) : -1;
}
function formatDayOfMonth(d3, p3) {
  return pad(d3.getDate(), p3, 2);
}
function formatHour24(d3, p3) {
  return pad(d3.getHours(), p3, 2);
}
function formatHour12(d3, p3) {
  return pad(d3.getHours() % 12 || 12, p3, 2);
}
function formatDayOfYear(d3, p3) {
  return pad(1 + timeDay.count(timeYear(d3), d3), p3, 3);
}
function formatMilliseconds(d3, p3) {
  return pad(d3.getMilliseconds(), p3, 3);
}
function formatMicroseconds(d3, p3) {
  return formatMilliseconds(d3, p3) + "000";
}
function formatMonthNumber(d3, p3) {
  return pad(d3.getMonth() + 1, p3, 2);
}
function formatMinutes(d3, p3) {
  return pad(d3.getMinutes(), p3, 2);
}
function formatSeconds(d3, p3) {
  return pad(d3.getSeconds(), p3, 2);
}
function formatWeekdayNumberMonday(d3) {
  var day = d3.getDay();
  return day === 0 ? 7 : day;
}
function formatWeekNumberSunday(d3, p3) {
  return pad(timeSunday.count(timeYear(d3) - 1, d3), p3, 2);
}
function dISO(d3) {
  var day = d3.getDay();
  return day >= 4 || day === 0 ? timeThursday(d3) : timeThursday.ceil(d3);
}
function formatWeekNumberISO(d3, p3) {
  d3 = dISO(d3);
  return pad(timeThursday.count(timeYear(d3), d3) + (timeYear(d3).getDay() === 4), p3, 2);
}
function formatWeekdayNumberSunday(d3) {
  return d3.getDay();
}
function formatWeekNumberMonday(d3, p3) {
  return pad(timeMonday.count(timeYear(d3) - 1, d3), p3, 2);
}
function formatYear(d3, p3) {
  return pad(d3.getFullYear() % 100, p3, 2);
}
function formatYearISO(d3, p3) {
  d3 = dISO(d3);
  return pad(d3.getFullYear() % 100, p3, 2);
}
function formatFullYear(d3, p3) {
  return pad(d3.getFullYear() % 1e4, p3, 4);
}
function formatFullYearISO(d3, p3) {
  var day = d3.getDay();
  d3 = day >= 4 || day === 0 ? timeThursday(d3) : timeThursday.ceil(d3);
  return pad(d3.getFullYear() % 1e4, p3, 4);
}
function formatZone(d3) {
  var z3 = d3.getTimezoneOffset();
  return (z3 > 0 ? "-" : (z3 *= -1, "+")) + pad(z3 / 60 | 0, "0", 2) + pad(z3 % 60, "0", 2);
}
function formatUTCDayOfMonth(d3, p3) {
  return pad(d3.getUTCDate(), p3, 2);
}
function formatUTCHour24(d3, p3) {
  return pad(d3.getUTCHours(), p3, 2);
}
function formatUTCHour12(d3, p3) {
  return pad(d3.getUTCHours() % 12 || 12, p3, 2);
}
function formatUTCDayOfYear(d3, p3) {
  return pad(1 + utcDay.count(utcYear(d3), d3), p3, 3);
}
function formatUTCMilliseconds(d3, p3) {
  return pad(d3.getUTCMilliseconds(), p3, 3);
}
function formatUTCMicroseconds(d3, p3) {
  return formatUTCMilliseconds(d3, p3) + "000";
}
function formatUTCMonthNumber(d3, p3) {
  return pad(d3.getUTCMonth() + 1, p3, 2);
}
function formatUTCMinutes(d3, p3) {
  return pad(d3.getUTCMinutes(), p3, 2);
}
function formatUTCSeconds(d3, p3) {
  return pad(d3.getUTCSeconds(), p3, 2);
}
function formatUTCWeekdayNumberMonday(d3) {
  var dow = d3.getUTCDay();
  return dow === 0 ? 7 : dow;
}
function formatUTCWeekNumberSunday(d3, p3) {
  return pad(utcSunday.count(utcYear(d3) - 1, d3), p3, 2);
}
function UTCdISO(d3) {
  var day = d3.getUTCDay();
  return day >= 4 || day === 0 ? utcThursday(d3) : utcThursday.ceil(d3);
}
function formatUTCWeekNumberISO(d3, p3) {
  d3 = UTCdISO(d3);
  return pad(utcThursday.count(utcYear(d3), d3) + (utcYear(d3).getUTCDay() === 4), p3, 2);
}
function formatUTCWeekdayNumberSunday(d3) {
  return d3.getUTCDay();
}
function formatUTCWeekNumberMonday(d3, p3) {
  return pad(utcMonday.count(utcYear(d3) - 1, d3), p3, 2);
}
function formatUTCYear(d3, p3) {
  return pad(d3.getUTCFullYear() % 100, p3, 2);
}
function formatUTCYearISO(d3, p3) {
  d3 = UTCdISO(d3);
  return pad(d3.getUTCFullYear() % 100, p3, 2);
}
function formatUTCFullYear(d3, p3) {
  return pad(d3.getUTCFullYear() % 1e4, p3, 4);
}
function formatUTCFullYearISO(d3, p3) {
  var day = d3.getUTCDay();
  d3 = day >= 4 || day === 0 ? utcThursday(d3) : utcThursday.ceil(d3);
  return pad(d3.getUTCFullYear() % 1e4, p3, 4);
}
function formatUTCZone() {
  return "+0000";
}
function formatLiteralPercent() {
  return "%";
}
function formatUnixTimestamp(d3) {
  return +d3;
}
function formatUnixTimestampSeconds(d3) {
  return Math.floor(+d3 / 1e3);
}

// node_modules/d3-time-format/src/defaultLocale.js
var locale2;
var timeFormat;
var timeParse;
var utcFormat;
var utcParse;
defaultLocale2({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function defaultLocale2(definition) {
  locale2 = formatLocale(definition);
  timeFormat = locale2.format;
  timeParse = locale2.parse;
  utcFormat = locale2.utcFormat;
  utcParse = locale2.utcParse;
  return locale2;
}

// node_modules/d3-time-format/src/isoFormat.js
var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";
function formatIsoNative(date) {
  return date.toISOString();
}
var formatIso = Date.prototype.toISOString ? formatIsoNative : utcFormat(isoSpecifier);

// node_modules/d3-time-format/src/isoParse.js
function parseIsoNative(string2) {
  var date = new Date(string2);
  return isNaN(date) ? null : date;
}
var parseIso = +/* @__PURE__ */ new Date("2000-01-01T00:00:00.000Z") ? parseIsoNative : utcParse(isoSpecifier);

// node_modules/d3-scale-chromatic/src/colors.js
function colors_default(specifier) {
  var n2 = specifier.length / 6 | 0, colors = new Array(n2), i2 = 0;
  while (i2 < n2) colors[i2] = "#" + specifier.slice(i2 * 6, ++i2 * 6);
  return colors;
}

// node_modules/d3-scale-chromatic/src/categorical/category10.js
var category10_default = colors_default("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

// node_modules/d3-scale-chromatic/src/categorical/Accent.js
var Accent_default = colors_default("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");

// node_modules/d3-scale-chromatic/src/categorical/Dark2.js
var Dark2_default = colors_default("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");

// node_modules/d3-scale-chromatic/src/categorical/observable10.js
var observable10_default = colors_default("4269d0efb118ff725c6cc5b03ca951ff8ab7a463f297bbf59c6b4e9498a0");

// node_modules/d3-scale-chromatic/src/categorical/Paired.js
var Paired_default = colors_default("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");

// node_modules/d3-scale-chromatic/src/categorical/Pastel1.js
var Pastel1_default = colors_default("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");

// node_modules/d3-scale-chromatic/src/categorical/Pastel2.js
var Pastel2_default = colors_default("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");

// node_modules/d3-scale-chromatic/src/categorical/Set1.js
var Set1_default = colors_default("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");

// node_modules/d3-scale-chromatic/src/categorical/Set2.js
var Set2_default = colors_default("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");

// node_modules/d3-scale-chromatic/src/categorical/Set3.js
var Set3_default = colors_default("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");

// node_modules/d3-scale-chromatic/src/categorical/Tableau10.js
var Tableau10_default = colors_default("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");

// node_modules/d3-scale-chromatic/src/ramp.js
var ramp_default = (scheme28) => rgbBasis(scheme28[scheme28.length - 1]);

// node_modules/d3-scale-chromatic/src/diverging/BrBG.js
var scheme = new Array(3).concat(
  "d8b365f5f5f55ab4ac",
  "a6611adfc27d80cdc1018571",
  "a6611adfc27df5f5f580cdc1018571",
  "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
  "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
  "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
  "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
  "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
  "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
).map(colors_default);
var BrBG_default = ramp_default(scheme);

// node_modules/d3-scale-chromatic/src/diverging/PRGn.js
var scheme2 = new Array(3).concat(
  "af8dc3f7f7f77fbf7b",
  "7b3294c2a5cfa6dba0008837",
  "7b3294c2a5cff7f7f7a6dba0008837",
  "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
  "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
  "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
  "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
  "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
  "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
).map(colors_default);
var PRGn_default = ramp_default(scheme2);

// node_modules/d3-scale-chromatic/src/diverging/PiYG.js
var scheme3 = new Array(3).concat(
  "e9a3c9f7f7f7a1d76a",
  "d01c8bf1b6dab8e1864dac26",
  "d01c8bf1b6daf7f7f7b8e1864dac26",
  "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
  "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
  "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
  "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
  "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
  "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
).map(colors_default);
var PiYG_default = ramp_default(scheme3);

// node_modules/d3-scale-chromatic/src/diverging/PuOr.js
var scheme4 = new Array(3).concat(
  "998ec3f7f7f7f1a340",
  "5e3c99b2abd2fdb863e66101",
  "5e3c99b2abd2f7f7f7fdb863e66101",
  "542788998ec3d8daebfee0b6f1a340b35806",
  "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
  "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
  "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
  "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
  "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
).map(colors_default);
var PuOr_default = ramp_default(scheme4);

// node_modules/d3-scale-chromatic/src/diverging/RdBu.js
var scheme5 = new Array(3).concat(
  "ef8a62f7f7f767a9cf",
  "ca0020f4a58292c5de0571b0",
  "ca0020f4a582f7f7f792c5de0571b0",
  "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
  "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
  "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
  "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
  "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
  "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
).map(colors_default);
var RdBu_default = ramp_default(scheme5);

// node_modules/d3-scale-chromatic/src/diverging/RdGy.js
var scheme6 = new Array(3).concat(
  "ef8a62ffffff999999",
  "ca0020f4a582bababa404040",
  "ca0020f4a582ffffffbababa404040",
  "b2182bef8a62fddbc7e0e0e09999994d4d4d",
  "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
  "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
  "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
  "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
  "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
).map(colors_default);
var RdGy_default = ramp_default(scheme6);

// node_modules/d3-scale-chromatic/src/diverging/RdYlBu.js
var scheme7 = new Array(3).concat(
  "fc8d59ffffbf91bfdb",
  "d7191cfdae61abd9e92c7bb6",
  "d7191cfdae61ffffbfabd9e92c7bb6",
  "d73027fc8d59fee090e0f3f891bfdb4575b4",
  "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
  "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
  "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
  "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
  "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
).map(colors_default);
var RdYlBu_default = ramp_default(scheme7);

// node_modules/d3-scale-chromatic/src/diverging/RdYlGn.js
var scheme8 = new Array(3).concat(
  "fc8d59ffffbf91cf60",
  "d7191cfdae61a6d96a1a9641",
  "d7191cfdae61ffffbfa6d96a1a9641",
  "d73027fc8d59fee08bd9ef8b91cf601a9850",
  "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
  "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
  "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
  "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
  "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
).map(colors_default);
var RdYlGn_default = ramp_default(scheme8);

// node_modules/d3-scale-chromatic/src/diverging/Spectral.js
var scheme9 = new Array(3).concat(
  "fc8d59ffffbf99d594",
  "d7191cfdae61abdda42b83ba",
  "d7191cfdae61ffffbfabdda42b83ba",
  "d53e4ffc8d59fee08be6f59899d5943288bd",
  "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
  "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
  "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
  "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
  "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
).map(colors_default);
var Spectral_default = ramp_default(scheme9);

// node_modules/d3-scale-chromatic/src/sequential-multi/BuGn.js
var scheme10 = new Array(3).concat(
  "e5f5f999d8c92ca25f",
  "edf8fbb2e2e266c2a4238b45",
  "edf8fbb2e2e266c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
).map(colors_default);
var BuGn_default = ramp_default(scheme10);

// node_modules/d3-scale-chromatic/src/sequential-multi/BuPu.js
var scheme11 = new Array(3).concat(
  "e0ecf49ebcda8856a7",
  "edf8fbb3cde38c96c688419d",
  "edf8fbb3cde38c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
).map(colors_default);
var BuPu_default = ramp_default(scheme11);

// node_modules/d3-scale-chromatic/src/sequential-multi/GnBu.js
var scheme12 = new Array(3).concat(
  "e0f3dba8ddb543a2ca",
  "f0f9e8bae4bc7bccc42b8cbe",
  "f0f9e8bae4bc7bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
).map(colors_default);
var GnBu_default = ramp_default(scheme12);

// node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js
var scheme13 = new Array(3).concat(
  "fee8c8fdbb84e34a33",
  "fef0d9fdcc8afc8d59d7301f",
  "fef0d9fdcc8afc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
).map(colors_default);
var OrRd_default = ramp_default(scheme13);

// node_modules/d3-scale-chromatic/src/sequential-multi/PuBuGn.js
var scheme14 = new Array(3).concat(
  "ece2f0a6bddb1c9099",
  "f6eff7bdc9e167a9cf02818a",
  "f6eff7bdc9e167a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
).map(colors_default);
var PuBuGn_default = ramp_default(scheme14);

// node_modules/d3-scale-chromatic/src/sequential-multi/PuBu.js
var scheme15 = new Array(3).concat(
  "ece7f2a6bddb2b8cbe",
  "f1eef6bdc9e174a9cf0570b0",
  "f1eef6bdc9e174a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
).map(colors_default);
var PuBu_default = ramp_default(scheme15);

// node_modules/d3-scale-chromatic/src/sequential-multi/PuRd.js
var scheme16 = new Array(3).concat(
  "e7e1efc994c7dd1c77",
  "f1eef6d7b5d8df65b0ce1256",
  "f1eef6d7b5d8df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
).map(colors_default);
var PuRd_default = ramp_default(scheme16);

// node_modules/d3-scale-chromatic/src/sequential-multi/RdPu.js
var scheme17 = new Array(3).concat(
  "fde0ddfa9fb5c51b8a",
  "feebe2fbb4b9f768a1ae017e",
  "feebe2fbb4b9f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
).map(colors_default);
var RdPu_default = ramp_default(scheme17);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js
var scheme18 = new Array(3).concat(
  "edf8b17fcdbb2c7fb8",
  "ffffcca1dab441b6c4225ea8",
  "ffffcca1dab441b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
).map(colors_default);
var YlGnBu_default = ramp_default(scheme18);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlGn.js
var scheme19 = new Array(3).concat(
  "f7fcb9addd8e31a354",
  "ffffccc2e69978c679238443",
  "ffffccc2e69978c67931a354006837",
  "ffffccd9f0a3addd8e78c67931a354006837",
  "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
).map(colors_default);
var YlGn_default = ramp_default(scheme19);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlOrBr.js
var scheme20 = new Array(3).concat(
  "fff7bcfec44fd95f0e",
  "ffffd4fed98efe9929cc4c02",
  "ffffd4fed98efe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
).map(colors_default);
var YlOrBr_default = ramp_default(scheme20);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlOrRd.js
var scheme21 = new Array(3).concat(
  "ffeda0feb24cf03b20",
  "ffffb2fecc5cfd8d3ce31a1c",
  "ffffb2fecc5cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
).map(colors_default);
var YlOrRd_default = ramp_default(scheme21);

// node_modules/d3-scale-chromatic/src/sequential-single/Blues.js
var scheme22 = new Array(3).concat(
  "deebf79ecae13182bd",
  "eff3ffbdd7e76baed62171b5",
  "eff3ffbdd7e76baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
).map(colors_default);
var Blues_default = ramp_default(scheme22);

// node_modules/d3-scale-chromatic/src/sequential-single/Greens.js
var scheme23 = new Array(3).concat(
  "e5f5e0a1d99b31a354",
  "edf8e9bae4b374c476238b45",
  "edf8e9bae4b374c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
).map(colors_default);
var Greens_default = ramp_default(scheme23);

// node_modules/d3-scale-chromatic/src/sequential-single/Greys.js
var scheme24 = new Array(3).concat(
  "f0f0f0bdbdbd636363",
  "f7f7f7cccccc969696525252",
  "f7f7f7cccccc969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
).map(colors_default);
var Greys_default = ramp_default(scheme24);

// node_modules/d3-scale-chromatic/src/sequential-single/Purples.js
var scheme25 = new Array(3).concat(
  "efedf5bcbddc756bb1",
  "f2f0f7cbc9e29e9ac86a51a3",
  "f2f0f7cbc9e29e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
).map(colors_default);
var Purples_default = ramp_default(scheme25);

// node_modules/d3-scale-chromatic/src/sequential-single/Reds.js
var scheme26 = new Array(3).concat(
  "fee0d2fc9272de2d26",
  "fee5d9fcae91fb6a4acb181d",
  "fee5d9fcae91fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
).map(colors_default);
var Reds_default = ramp_default(scheme26);

// node_modules/d3-scale-chromatic/src/sequential-single/Oranges.js
var scheme27 = new Array(3).concat(
  "fee6cefdae6be6550d",
  "feeddefdbe85fd8d3cd94701",
  "feeddefdbe85fd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
).map(colors_default);
var Oranges_default = ramp_default(scheme27);

// node_modules/d3-scale-chromatic/src/sequential-multi/cubehelix.js
var cubehelix_default2 = cubehelixLong(cubehelix(300, 0.5, 0), cubehelix(-240, 0.5, 1));

// node_modules/d3-scale-chromatic/src/sequential-multi/rainbow.js
var warm = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
var cool = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
var c2 = cubehelix();

// node_modules/d3-scale-chromatic/src/sequential-multi/sinebow.js
var c3 = rgb();
var pi_1_3 = Math.PI / 3;
var pi_2_3 = Math.PI * 2 / 3;

// node_modules/d3-scale-chromatic/src/sequential-multi/viridis.js
function ramp(range4) {
  var n2 = range4.length;
  return function(t5) {
    return range4[Math.max(0, Math.min(n2 - 1, Math.floor(t5 * n2)))];
  };
}
var viridis_default = ramp(colors_default("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
var magma = ramp(colors_default("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));
var inferno = ramp(colors_default("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));
var plasma = ramp(colors_default("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

// node_modules/tinycolor2/esm/tinycolor.js
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
var trimLeft = /^\s+/;
var trimRight = /\s+$/;
function tinycolor(color3, opts) {
  color3 = color3 ? color3 : "";
  opts = opts || {};
  if (color3 instanceof tinycolor) {
    return color3;
  }
  if (!(this instanceof tinycolor)) {
    return new tinycolor(color3, opts);
  }
  var rgb3 = inputToRGB(color3);
  this._originalInput = color3, this._r = rgb3.r, this._g = rgb3.g, this._b = rgb3.b, this._a = rgb3.a, this._roundA = Math.round(100 * this._a) / 100, this._format = opts.format || rgb3.format;
  this._gradientType = opts.gradientType;
  if (this._r < 1) this._r = Math.round(this._r);
  if (this._g < 1) this._g = Math.round(this._g);
  if (this._b < 1) this._b = Math.round(this._b);
  this._ok = rgb3.ok;
}
tinycolor.prototype = {
  isDark: function isDark() {
    return this.getBrightness() < 128;
  },
  isLight: function isLight() {
    return !this.isDark();
  },
  isValid: function isValid() {
    return this._ok;
  },
  getOriginalInput: function getOriginalInput() {
    return this._originalInput;
  },
  getFormat: function getFormat() {
    return this._format;
  },
  getAlpha: function getAlpha() {
    return this._a;
  },
  getBrightness: function getBrightness() {
    var rgb3 = this.toRgb();
    return (rgb3.r * 299 + rgb3.g * 587 + rgb3.b * 114) / 1e3;
  },
  getLuminance: function getLuminance() {
    var rgb3 = this.toRgb();
    var RsRGB, GsRGB, BsRGB, R, G2, B4;
    RsRGB = rgb3.r / 255;
    GsRGB = rgb3.g / 255;
    BsRGB = rgb3.b / 255;
    if (RsRGB <= 0.03928) R = RsRGB / 12.92;
    else R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
    if (GsRGB <= 0.03928) G2 = GsRGB / 12.92;
    else G2 = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
    if (BsRGB <= 0.03928) B4 = BsRGB / 12.92;
    else B4 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
    return 0.2126 * R + 0.7152 * G2 + 0.0722 * B4;
  },
  setAlpha: function setAlpha(value) {
    this._a = boundAlpha(value);
    this._roundA = Math.round(100 * this._a) / 100;
    return this;
  },
  toHsv: function toHsv() {
    var hsv = rgbToHsv(this._r, this._g, this._b);
    return {
      h: hsv.h * 360,
      s: hsv.s,
      v: hsv.v,
      a: this._a
    };
  },
  toHsvString: function toHsvString() {
    var hsv = rgbToHsv(this._r, this._g, this._b);
    var h2 = Math.round(hsv.h * 360), s2 = Math.round(hsv.s * 100), v2 = Math.round(hsv.v * 100);
    return this._a == 1 ? "hsv(" + h2 + ", " + s2 + "%, " + v2 + "%)" : "hsva(" + h2 + ", " + s2 + "%, " + v2 + "%, " + this._roundA + ")";
  },
  toHsl: function toHsl() {
    var hsl4 = rgbToHsl(this._r, this._g, this._b);
    return {
      h: hsl4.h * 360,
      s: hsl4.s,
      l: hsl4.l,
      a: this._a
    };
  },
  toHslString: function toHslString() {
    var hsl4 = rgbToHsl(this._r, this._g, this._b);
    var h2 = Math.round(hsl4.h * 360), s2 = Math.round(hsl4.s * 100), l2 = Math.round(hsl4.l * 100);
    return this._a == 1 ? "hsl(" + h2 + ", " + s2 + "%, " + l2 + "%)" : "hsla(" + h2 + ", " + s2 + "%, " + l2 + "%, " + this._roundA + ")";
  },
  toHex: function toHex(allow3Char) {
    return rgbToHex(this._r, this._g, this._b, allow3Char);
  },
  toHexString: function toHexString(allow3Char) {
    return "#" + this.toHex(allow3Char);
  },
  toHex8: function toHex8(allow4Char) {
    return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
  },
  toHex8String: function toHex8String(allow4Char) {
    return "#" + this.toHex8(allow4Char);
  },
  toRgb: function toRgb() {
    return {
      r: Math.round(this._r),
      g: Math.round(this._g),
      b: Math.round(this._b),
      a: this._a
    };
  },
  toRgbString: function toRgbString() {
    return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
  },
  toPercentageRgb: function toPercentageRgb() {
    return {
      r: Math.round(bound01(this._r, 255) * 100) + "%",
      g: Math.round(bound01(this._g, 255) * 100) + "%",
      b: Math.round(bound01(this._b, 255) * 100) + "%",
      a: this._a
    };
  },
  toPercentageRgbString: function toPercentageRgbString() {
    return this._a == 1 ? "rgb(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
  },
  toName: function toName() {
    if (this._a === 0) {
      return "transparent";
    }
    if (this._a < 1) {
      return false;
    }
    return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
  },
  toFilter: function toFilter(secondColor) {
    var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
    var secondHex8String = hex8String;
    var gradientType = this._gradientType ? "GradientType = 1, " : "";
    if (secondColor) {
      var s2 = tinycolor(secondColor);
      secondHex8String = "#" + rgbaToArgbHex(s2._r, s2._g, s2._b, s2._a);
    }
    return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
  },
  toString: function toString(format3) {
    var formatSet = !!format3;
    format3 = format3 || this._format;
    var formattedString = false;
    var hasAlpha = this._a < 1 && this._a >= 0;
    var needsAlphaFormat = !formatSet && hasAlpha && (format3 === "hex" || format3 === "hex6" || format3 === "hex3" || format3 === "hex4" || format3 === "hex8" || format3 === "name");
    if (needsAlphaFormat) {
      if (format3 === "name" && this._a === 0) {
        return this.toName();
      }
      return this.toRgbString();
    }
    if (format3 === "rgb") {
      formattedString = this.toRgbString();
    }
    if (format3 === "prgb") {
      formattedString = this.toPercentageRgbString();
    }
    if (format3 === "hex" || format3 === "hex6") {
      formattedString = this.toHexString();
    }
    if (format3 === "hex3") {
      formattedString = this.toHexString(true);
    }
    if (format3 === "hex4") {
      formattedString = this.toHex8String(true);
    }
    if (format3 === "hex8") {
      formattedString = this.toHex8String();
    }
    if (format3 === "name") {
      formattedString = this.toName();
    }
    if (format3 === "hsl") {
      formattedString = this.toHslString();
    }
    if (format3 === "hsv") {
      formattedString = this.toHsvString();
    }
    return formattedString || this.toHexString();
  },
  clone: function clone() {
    return tinycolor(this.toString());
  },
  _applyModification: function _applyModification(fn, args) {
    var color3 = fn.apply(null, [this].concat([].slice.call(args)));
    this._r = color3._r;
    this._g = color3._g;
    this._b = color3._b;
    this.setAlpha(color3._a);
    return this;
  },
  lighten: function lighten() {
    return this._applyModification(_lighten, arguments);
  },
  brighten: function brighten() {
    return this._applyModification(_brighten, arguments);
  },
  darken: function darken() {
    return this._applyModification(_darken, arguments);
  },
  desaturate: function desaturate() {
    return this._applyModification(_desaturate, arguments);
  },
  saturate: function saturate() {
    return this._applyModification(_saturate, arguments);
  },
  greyscale: function greyscale() {
    return this._applyModification(_greyscale, arguments);
  },
  spin: function spin() {
    return this._applyModification(_spin, arguments);
  },
  _applyCombination: function _applyCombination(fn, args) {
    return fn.apply(null, [this].concat([].slice.call(args)));
  },
  analogous: function analogous() {
    return this._applyCombination(_analogous, arguments);
  },
  complement: function complement() {
    return this._applyCombination(_complement, arguments);
  },
  monochromatic: function monochromatic() {
    return this._applyCombination(_monochromatic, arguments);
  },
  splitcomplement: function splitcomplement() {
    return this._applyCombination(_splitcomplement, arguments);
  },
  // Disabled until https://github.com/bgrins/TinyColor/issues/254
  // polyad: function (number) {
  //   return this._applyCombination(polyad, [number]);
  // },
  triad: function triad() {
    return this._applyCombination(polyad, [3]);
  },
  tetrad: function tetrad() {
    return this._applyCombination(polyad, [4]);
  }
};
tinycolor.fromRatio = function(color3, opts) {
  if (_typeof(color3) == "object") {
    var newColor = {};
    for (var i2 in color3) {
      if (color3.hasOwnProperty(i2)) {
        if (i2 === "a") {
          newColor[i2] = color3[i2];
        } else {
          newColor[i2] = convertToPercentage(color3[i2]);
        }
      }
    }
    color3 = newColor;
  }
  return tinycolor(color3, opts);
};
function inputToRGB(color3) {
  var rgb3 = {
    r: 0,
    g: 0,
    b: 0
  };
  var a3 = 1;
  var s2 = null;
  var v2 = null;
  var l2 = null;
  var ok = false;
  var format3 = false;
  if (typeof color3 == "string") {
    color3 = stringInputToObject(color3);
  }
  if (_typeof(color3) == "object") {
    if (isValidCSSUnit(color3.r) && isValidCSSUnit(color3.g) && isValidCSSUnit(color3.b)) {
      rgb3 = rgbToRgb(color3.r, color3.g, color3.b);
      ok = true;
      format3 = String(color3.r).substr(-1) === "%" ? "prgb" : "rgb";
    } else if (isValidCSSUnit(color3.h) && isValidCSSUnit(color3.s) && isValidCSSUnit(color3.v)) {
      s2 = convertToPercentage(color3.s);
      v2 = convertToPercentage(color3.v);
      rgb3 = hsvToRgb(color3.h, s2, v2);
      ok = true;
      format3 = "hsv";
    } else if (isValidCSSUnit(color3.h) && isValidCSSUnit(color3.s) && isValidCSSUnit(color3.l)) {
      s2 = convertToPercentage(color3.s);
      l2 = convertToPercentage(color3.l);
      rgb3 = hslToRgb(color3.h, s2, l2);
      ok = true;
      format3 = "hsl";
    }
    if (color3.hasOwnProperty("a")) {
      a3 = color3.a;
    }
  }
  a3 = boundAlpha(a3);
  return {
    ok,
    format: color3.format || format3,
    r: Math.min(255, Math.max(rgb3.r, 0)),
    g: Math.min(255, Math.max(rgb3.g, 0)),
    b: Math.min(255, Math.max(rgb3.b, 0)),
    a: a3
  };
}
function rgbToRgb(r2, g3, b) {
  return {
    r: bound01(r2, 255) * 255,
    g: bound01(g3, 255) * 255,
    b: bound01(b, 255) * 255
  };
}
function rgbToHsl(r2, g3, b) {
  r2 = bound01(r2, 255);
  g3 = bound01(g3, 255);
  b = bound01(b, 255);
  var max6 = Math.max(r2, g3, b), min5 = Math.min(r2, g3, b);
  var h2, s2, l2 = (max6 + min5) / 2;
  if (max6 == min5) {
    h2 = s2 = 0;
  } else {
    var d3 = max6 - min5;
    s2 = l2 > 0.5 ? d3 / (2 - max6 - min5) : d3 / (max6 + min5);
    switch (max6) {
      case r2:
        h2 = (g3 - b) / d3 + (g3 < b ? 6 : 0);
        break;
      case g3:
        h2 = (b - r2) / d3 + 2;
        break;
      case b:
        h2 = (r2 - g3) / d3 + 4;
        break;
    }
    h2 /= 6;
  }
  return {
    h: h2,
    s: s2,
    l: l2
  };
}
function hslToRgb(h2, s2, l2) {
  var r2, g3, b;
  h2 = bound01(h2, 360);
  s2 = bound01(s2, 100);
  l2 = bound01(l2, 100);
  function hue2rgb2(p4, q3, t5) {
    if (t5 < 0) t5 += 1;
    if (t5 > 1) t5 -= 1;
    if (t5 < 1 / 6) return p4 + (q3 - p4) * 6 * t5;
    if (t5 < 1 / 2) return q3;
    if (t5 < 2 / 3) return p4 + (q3 - p4) * (2 / 3 - t5) * 6;
    return p4;
  }
  if (s2 === 0) {
    r2 = g3 = b = l2;
  } else {
    var q2 = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
    var p3 = 2 * l2 - q2;
    r2 = hue2rgb2(p3, q2, h2 + 1 / 3);
    g3 = hue2rgb2(p3, q2, h2);
    b = hue2rgb2(p3, q2, h2 - 1 / 3);
  }
  return {
    r: r2 * 255,
    g: g3 * 255,
    b: b * 255
  };
}
function rgbToHsv(r2, g3, b) {
  r2 = bound01(r2, 255);
  g3 = bound01(g3, 255);
  b = bound01(b, 255);
  var max6 = Math.max(r2, g3, b), min5 = Math.min(r2, g3, b);
  var h2, s2, v2 = max6;
  var d3 = max6 - min5;
  s2 = max6 === 0 ? 0 : d3 / max6;
  if (max6 == min5) {
    h2 = 0;
  } else {
    switch (max6) {
      case r2:
        h2 = (g3 - b) / d3 + (g3 < b ? 6 : 0);
        break;
      case g3:
        h2 = (b - r2) / d3 + 2;
        break;
      case b:
        h2 = (r2 - g3) / d3 + 4;
        break;
    }
    h2 /= 6;
  }
  return {
    h: h2,
    s: s2,
    v: v2
  };
}
function hsvToRgb(h2, s2, v2) {
  h2 = bound01(h2, 360) * 6;
  s2 = bound01(s2, 100);
  v2 = bound01(v2, 100);
  var i2 = Math.floor(h2), f3 = h2 - i2, p3 = v2 * (1 - s2), q2 = v2 * (1 - f3 * s2), t5 = v2 * (1 - (1 - f3) * s2), mod2 = i2 % 6, r2 = [v2, q2, p3, p3, t5, v2][mod2], g3 = [t5, v2, v2, q2, p3, p3][mod2], b = [p3, p3, t5, v2, v2, q2][mod2];
  return {
    r: r2 * 255,
    g: g3 * 255,
    b: b * 255
  };
}
function rgbToHex(r2, g3, b, allow3Char) {
  var hex2 = [pad2(Math.round(r2).toString(16)), pad2(Math.round(g3).toString(16)), pad2(Math.round(b).toString(16))];
  if (allow3Char && hex2[0].charAt(0) == hex2[0].charAt(1) && hex2[1].charAt(0) == hex2[1].charAt(1) && hex2[2].charAt(0) == hex2[2].charAt(1)) {
    return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0);
  }
  return hex2.join("");
}
function rgbaToHex(r2, g3, b, a3, allow4Char) {
  var hex2 = [pad2(Math.round(r2).toString(16)), pad2(Math.round(g3).toString(16)), pad2(Math.round(b).toString(16)), pad2(convertDecimalToHex(a3))];
  if (allow4Char && hex2[0].charAt(0) == hex2[0].charAt(1) && hex2[1].charAt(0) == hex2[1].charAt(1) && hex2[2].charAt(0) == hex2[2].charAt(1) && hex2[3].charAt(0) == hex2[3].charAt(1)) {
    return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0) + hex2[3].charAt(0);
  }
  return hex2.join("");
}
function rgbaToArgbHex(r2, g3, b, a3) {
  var hex2 = [pad2(convertDecimalToHex(a3)), pad2(Math.round(r2).toString(16)), pad2(Math.round(g3).toString(16)), pad2(Math.round(b).toString(16))];
  return hex2.join("");
}
tinycolor.equals = function(color1, color22) {
  if (!color1 || !color22) return false;
  return tinycolor(color1).toRgbString() == tinycolor(color22).toRgbString();
};
tinycolor.random = function() {
  return tinycolor.fromRatio({
    r: Math.random(),
    g: Math.random(),
    b: Math.random()
  });
};
function _desaturate(color3, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl4 = tinycolor(color3).toHsl();
  hsl4.s -= amount / 100;
  hsl4.s = clamp01(hsl4.s);
  return tinycolor(hsl4);
}
function _saturate(color3, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl4 = tinycolor(color3).toHsl();
  hsl4.s += amount / 100;
  hsl4.s = clamp01(hsl4.s);
  return tinycolor(hsl4);
}
function _greyscale(color3) {
  return tinycolor(color3).desaturate(100);
}
function _lighten(color3, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl4 = tinycolor(color3).toHsl();
  hsl4.l += amount / 100;
  hsl4.l = clamp01(hsl4.l);
  return tinycolor(hsl4);
}
function _brighten(color3, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var rgb3 = tinycolor(color3).toRgb();
  rgb3.r = Math.max(0, Math.min(255, rgb3.r - Math.round(255 * -(amount / 100))));
  rgb3.g = Math.max(0, Math.min(255, rgb3.g - Math.round(255 * -(amount / 100))));
  rgb3.b = Math.max(0, Math.min(255, rgb3.b - Math.round(255 * -(amount / 100))));
  return tinycolor(rgb3);
}
function _darken(color3, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl4 = tinycolor(color3).toHsl();
  hsl4.l -= amount / 100;
  hsl4.l = clamp01(hsl4.l);
  return tinycolor(hsl4);
}
function _spin(color3, amount) {
  var hsl4 = tinycolor(color3).toHsl();
  var hue3 = (hsl4.h + amount) % 360;
  hsl4.h = hue3 < 0 ? 360 + hue3 : hue3;
  return tinycolor(hsl4);
}
function _complement(color3) {
  var hsl4 = tinycolor(color3).toHsl();
  hsl4.h = (hsl4.h + 180) % 360;
  return tinycolor(hsl4);
}
function polyad(color3, number3) {
  if (isNaN(number3) || number3 <= 0) {
    throw new Error("Argument to polyad must be a positive number");
  }
  var hsl4 = tinycolor(color3).toHsl();
  var result2 = [tinycolor(color3)];
  var step2 = 360 / number3;
  for (var i2 = 1; i2 < number3; i2++) {
    result2.push(tinycolor({
      h: (hsl4.h + i2 * step2) % 360,
      s: hsl4.s,
      l: hsl4.l
    }));
  }
  return result2;
}
function _splitcomplement(color3) {
  var hsl4 = tinycolor(color3).toHsl();
  var h2 = hsl4.h;
  return [tinycolor(color3), tinycolor({
    h: (h2 + 72) % 360,
    s: hsl4.s,
    l: hsl4.l
  }), tinycolor({
    h: (h2 + 216) % 360,
    s: hsl4.s,
    l: hsl4.l
  })];
}
function _analogous(color3, results, slices) {
  results = results || 6;
  slices = slices || 30;
  var hsl4 = tinycolor(color3).toHsl();
  var part = 360 / slices;
  var ret = [tinycolor(color3)];
  for (hsl4.h = (hsl4.h - (part * results >> 1) + 720) % 360; --results; ) {
    hsl4.h = (hsl4.h + part) % 360;
    ret.push(tinycolor(hsl4));
  }
  return ret;
}
function _monochromatic(color3, results) {
  results = results || 6;
  var hsv = tinycolor(color3).toHsv();
  var h2 = hsv.h, s2 = hsv.s, v2 = hsv.v;
  var ret = [];
  var modification = 1 / results;
  while (results--) {
    ret.push(tinycolor({
      h: h2,
      s: s2,
      v: v2
    }));
    v2 = (v2 + modification) % 1;
  }
  return ret;
}
tinycolor.mix = function(color1, color22, amount) {
  amount = amount === 0 ? 0 : amount || 50;
  var rgb1 = tinycolor(color1).toRgb();
  var rgb22 = tinycolor(color22).toRgb();
  var p3 = amount / 100;
  var rgba3 = {
    r: (rgb22.r - rgb1.r) * p3 + rgb1.r,
    g: (rgb22.g - rgb1.g) * p3 + rgb1.g,
    b: (rgb22.b - rgb1.b) * p3 + rgb1.b,
    a: (rgb22.a - rgb1.a) * p3 + rgb1.a
  };
  return tinycolor(rgba3);
};
tinycolor.readability = function(color1, color22) {
  var c1 = tinycolor(color1);
  var c22 = tinycolor(color22);
  return (Math.max(c1.getLuminance(), c22.getLuminance()) + 0.05) / (Math.min(c1.getLuminance(), c22.getLuminance()) + 0.05);
};
tinycolor.isReadable = function(color1, color22, wcag2) {
  var readability = tinycolor.readability(color1, color22);
  var wcag2Parms, out;
  out = false;
  wcag2Parms = validateWCAG2Parms(wcag2);
  switch (wcag2Parms.level + wcag2Parms.size) {
    case "AAsmall":
    case "AAAlarge":
      out = readability >= 4.5;
      break;
    case "AAlarge":
      out = readability >= 3;
      break;
    case "AAAsmall":
      out = readability >= 7;
      break;
  }
  return out;
};
tinycolor.mostReadable = function(baseColor, colorList, args) {
  var bestColor = null;
  var bestScore = 0;
  var readability;
  var includeFallbackColors, level, size2;
  args = args || {};
  includeFallbackColors = args.includeFallbackColors;
  level = args.level;
  size2 = args.size;
  for (var i2 = 0; i2 < colorList.length; i2++) {
    readability = tinycolor.readability(baseColor, colorList[i2]);
    if (readability > bestScore) {
      bestScore = readability;
      bestColor = tinycolor(colorList[i2]);
    }
  }
  if (tinycolor.isReadable(baseColor, bestColor, {
    level,
    size: size2
  }) || !includeFallbackColors) {
    return bestColor;
  } else {
    args.includeFallbackColors = false;
    return tinycolor.mostReadable(baseColor, ["#fff", "#000"], args);
  }
};
var names = tinycolor.names = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "0ff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "00f",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  burntsienna: "ea7e5d",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "0ff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "f0f",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "663399",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
};
var hexNames = tinycolor.hexNames = flip(names);
function flip(o2) {
  var flipped = {};
  for (var i2 in o2) {
    if (o2.hasOwnProperty(i2)) {
      flipped[o2[i2]] = i2;
    }
  }
  return flipped;
}
function boundAlpha(a3) {
  a3 = parseFloat(a3);
  if (isNaN(a3) || a3 < 0 || a3 > 1) {
    a3 = 1;
  }
  return a3;
}
function bound01(n2, max6) {
  if (isOnePointZero(n2)) n2 = "100%";
  var processPercent = isPercentage(n2);
  n2 = Math.min(max6, Math.max(0, parseFloat(n2)));
  if (processPercent) {
    n2 = parseInt(n2 * max6, 10) / 100;
  }
  if (Math.abs(n2 - max6) < 1e-6) {
    return 1;
  }
  return n2 % max6 / parseFloat(max6);
}
function clamp01(val) {
  return Math.min(1, Math.max(0, val));
}
function parseIntFromHex(val) {
  return parseInt(val, 16);
}
function isOnePointZero(n2) {
  return typeof n2 == "string" && n2.indexOf(".") != -1 && parseFloat(n2) === 1;
}
function isPercentage(n2) {
  return typeof n2 === "string" && n2.indexOf("%") != -1;
}
function pad2(c5) {
  return c5.length == 1 ? "0" + c5 : "" + c5;
}
function convertToPercentage(n2) {
  if (n2 <= 1) {
    n2 = n2 * 100 + "%";
  }
  return n2;
}
function convertDecimalToHex(d3) {
  return Math.round(parseFloat(d3) * 255).toString(16);
}
function convertHexToDecimal(h2) {
  return parseIntFromHex(h2) / 255;
}
var matchers = (function() {
  var CSS_INTEGER = "[-\\+]?\\d+%?";
  var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
  var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
  var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  return {
    CSS_UNIT: new RegExp(CSS_UNIT),
    rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
    rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
    hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
    hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
    hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
    hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
  };
})();
function isValidCSSUnit(color3) {
  return !!matchers.CSS_UNIT.exec(color3);
}
function stringInputToObject(color3) {
  color3 = color3.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
  var named2 = false;
  if (names[color3]) {
    color3 = names[color3];
    named2 = true;
  } else if (color3 == "transparent") {
    return {
      r: 0,
      g: 0,
      b: 0,
      a: 0,
      format: "name"
    };
  }
  var match;
  if (match = matchers.rgb.exec(color3)) {
    return {
      r: match[1],
      g: match[2],
      b: match[3]
    };
  }
  if (match = matchers.rgba.exec(color3)) {
    return {
      r: match[1],
      g: match[2],
      b: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hsl.exec(color3)) {
    return {
      h: match[1],
      s: match[2],
      l: match[3]
    };
  }
  if (match = matchers.hsla.exec(color3)) {
    return {
      h: match[1],
      s: match[2],
      l: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hsv.exec(color3)) {
    return {
      h: match[1],
      s: match[2],
      v: match[3]
    };
  }
  if (match = matchers.hsva.exec(color3)) {
    return {
      h: match[1],
      s: match[2],
      v: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hex8.exec(color3)) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      a: convertHexToDecimal(match[4]),
      format: named2 ? "name" : "hex8"
    };
  }
  if (match = matchers.hex6.exec(color3)) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      format: named2 ? "name" : "hex"
    };
  }
  if (match = matchers.hex4.exec(color3)) {
    return {
      r: parseIntFromHex(match[1] + "" + match[1]),
      g: parseIntFromHex(match[2] + "" + match[2]),
      b: parseIntFromHex(match[3] + "" + match[3]),
      a: convertHexToDecimal(match[4] + "" + match[4]),
      format: named2 ? "name" : "hex8"
    };
  }
  if (match = matchers.hex3.exec(color3)) {
    return {
      r: parseIntFromHex(match[1] + "" + match[1]),
      g: parseIntFromHex(match[2] + "" + match[2]),
      b: parseIntFromHex(match[3] + "" + match[3]),
      format: named2 ? "name" : "hex"
    };
  }
  return false;
}
function validateWCAG2Parms(parms) {
  var level, size2;
  parms = parms || {
    level: "AA",
    size: "small"
  };
  level = (parms.level || "AA").toUpperCase();
  size2 = (parms.size || "small").toLowerCase();
  if (level !== "AA" && level !== "AAA") {
    level = "AA";
  }
  if (size2 !== "small" && size2 !== "large") {
    size2 = "small";
  }
  return {
    level,
    size: size2
  };
}

// node_modules/three-forcegraph/dist/three-forcegraph.mjs
function _arrayLikeToArray5(r2, a3) {
  (null == a3 || a3 > r2.length) && (a3 = r2.length);
  for (var e3 = 0, n2 = Array(a3); e3 < a3; e3++) n2[e3] = r2[e3];
  return n2;
}
function _arrayWithHoles5(r2) {
  if (Array.isArray(r2)) return r2;
}
function _arrayWithoutHoles4(r2) {
  if (Array.isArray(r2)) return _arrayLikeToArray5(r2);
}
function _assertClassBrand2(e3, t5, n2) {
  if ("function" == typeof e3 ? e3 === t5 : e3.has(t5)) return arguments.length < 3 ? t5 : n2;
  throw new TypeError("Private element is not present on this object");
}
function _assertThisInitialized(e3) {
  if (void 0 === e3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e3;
}
function _callSuper(t5, o2, e3) {
  return o2 = _getPrototypeOf(o2), _possibleConstructorReturn(t5, _isNativeReflectConstruct() ? Reflect.construct(o2, e3 || [], _getPrototypeOf(t5).constructor) : o2.apply(t5, e3));
}
function _checkPrivateRedeclaration2(e3, t5) {
  if (t5.has(e3)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function _classCallCheck3(a3, n2) {
  if (!(a3 instanceof n2)) throw new TypeError("Cannot call a class as a function");
}
function _classPrivateFieldGet22(s2, a3) {
  return s2.get(_assertClassBrand2(s2, a3));
}
function _classPrivateFieldInitSpec2(e3, t5, a3) {
  _checkPrivateRedeclaration2(e3, t5), t5.set(e3, a3);
}
function _classPrivateFieldSet22(s2, a3, r2) {
  return s2.set(_assertClassBrand2(s2, a3), r2), r2;
}
function _construct(t5, e3, r2) {
  if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
  var o2 = [null];
  o2.push.apply(o2, e3);
  var p3 = new (t5.bind.apply(t5, o2))();
  return p3;
}
function _defineProperties2(e3, r2) {
  for (var t5 = 0; t5 < r2.length; t5++) {
    var o2 = r2[t5];
    o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e3, _toPropertyKey3(o2.key), o2);
  }
}
function _createClass3(e3, r2, t5) {
  return r2 && _defineProperties2(e3.prototype, r2), Object.defineProperty(e3, "prototype", {
    writable: false
  }), e3;
}
function _defineProperty2(e3, r2, t5) {
  return (r2 = _toPropertyKey3(r2)) in e3 ? Object.defineProperty(e3, r2, {
    value: t5,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e3[r2] = t5, e3;
}
function _get() {
  return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(e3, t5, r2) {
    var p3 = _superPropBase(e3, t5);
    if (p3) {
      var n2 = Object.getOwnPropertyDescriptor(p3, t5);
      return n2.get ? n2.get.call(arguments.length < 3 ? e3 : r2) : n2.value;
    }
  }, _get.apply(null, arguments);
}
function _getPrototypeOf(t5) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t6) {
    return t6.__proto__ || Object.getPrototypeOf(t6);
  }, _getPrototypeOf(t5);
}
function _inherits(t5, e3) {
  if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function");
  t5.prototype = Object.create(e3 && e3.prototype, {
    constructor: {
      value: t5,
      writable: true,
      configurable: true
    }
  }), Object.defineProperty(t5, "prototype", {
    writable: false
  }), e3 && _setPrototypeOf(t5, e3);
}
function _isNativeReflectConstruct() {
  try {
    var t5 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t6) {
  }
  return (_isNativeReflectConstruct = function() {
    return !!t5;
  })();
}
function _iterableToArray4(r2) {
  if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"]) return Array.from(r2);
}
function _iterableToArrayLimit5(r2, l2) {
  var t5 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t5) {
    var e3, n2, i2, u2, a3 = [], f3 = true, o2 = false;
    try {
      if (i2 = (t5 = t5.call(r2)).next, 0 === l2) ;
      else for (; !(f3 = (e3 = i2.call(t5)).done) && (a3.push(e3.value), a3.length !== l2); f3 = true) ;
    } catch (r3) {
      o2 = true, n2 = r3;
    } finally {
      try {
        if (!f3 && null != t5.return && (u2 = t5.return(), Object(u2) !== u2)) return;
      } finally {
        if (o2) throw n2;
      }
    }
    return a3;
  }
}
function _nonIterableRest5() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableSpread4() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function ownKeys(e3, r2) {
  var t5 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t5.push.apply(t5, o2);
  }
  return t5;
}
function _objectSpread2(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t5 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys(Object(t5), true).forEach(function(r3) {
      _defineProperty2(e3, r3, t5[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t5)) : ownKeys(Object(t5)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t5, r3));
    });
  }
  return e3;
}
function _possibleConstructorReturn(t5, e3) {
  if (e3 && ("object" == typeof e3 || "function" == typeof e3)) return e3;
  if (void 0 !== e3) throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(t5);
}
function _setPrototypeOf(t5, e3) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t6, e4) {
    return t6.__proto__ = e4, t6;
  }, _setPrototypeOf(t5, e3);
}
function _slicedToArray5(r2, e3) {
  return _arrayWithHoles5(r2) || _iterableToArrayLimit5(r2, e3) || _unsupportedIterableToArray5(r2, e3) || _nonIterableRest5();
}
function _superPropBase(t5, o2) {
  for (; !{}.hasOwnProperty.call(t5, o2) && null !== (t5 = _getPrototypeOf(t5)); ) ;
  return t5;
}
function _superPropGet(t5, o2, e3, r2) {
  var p3 = _get(_getPrototypeOf(t5.prototype), o2, e3);
  return "function" == typeof p3 ? function(t6) {
    return p3.apply(e3, t6);
  } : p3;
}
function _toConsumableArray4(r2) {
  return _arrayWithoutHoles4(r2) || _iterableToArray4(r2) || _unsupportedIterableToArray5(r2) || _nonIterableSpread4();
}
function _toPrimitive3(t5, r2) {
  if ("object" != typeof t5 || !t5) return t5;
  var e3 = t5[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t5, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t5);
}
function _toPropertyKey3(t5) {
  var i2 = _toPrimitive3(t5, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _typeof2(o2) {
  "@babel/helpers - typeof";
  return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof2(o2);
}
function _unsupportedIterableToArray5(r2, a3) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray5(r2, a3);
    var t5 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t5 && r2.constructor && (t5 = r2.constructor.name), "Map" === t5 || "Set" === t5 ? Array.from(r2) : "Arguments" === t5 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t5) ? _arrayLikeToArray5(r2, a3) : void 0;
  }
}
var _materialDispose = function materialDispose(material) {
  if (material instanceof Array) {
    material.forEach(_materialDispose);
  } else {
    if (material.map) {
      material.map.dispose();
    }
    material.dispose();
  }
};
var _deallocate = function deallocate(obj) {
  if (obj.geometry) {
    obj.geometry.dispose();
  }
  if (obj.material) {
    _materialDispose(obj.material);
  }
  if (obj.texture) {
    obj.texture.dispose();
  }
  if (obj.children) {
    obj.children.forEach(_deallocate);
  }
};
var emptyObject = function emptyObject2(obj) {
  while (obj.children.length) {
    var childObj = obj.children[0];
    obj.remove(childObj);
    _deallocate(childObj);
  }
};
var _dataBindAttr = /* @__PURE__ */ new WeakMap();
var _objBindAttr = /* @__PURE__ */ new WeakMap();
var ThreeDigest = (function(_DataBindMapper) {
  function ThreeDigest2(scene3) {
    var _this;
    var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$dataBindAttr = _ref.dataBindAttr, dataBindAttr = _ref$dataBindAttr === void 0 ? "__data" : _ref$dataBindAttr, _ref$objBindAttr = _ref.objBindAttr, objBindAttr = _ref$objBindAttr === void 0 ? "__threeObj" : _ref$objBindAttr;
    _classCallCheck3(this, ThreeDigest2);
    _this = _callSuper(this, ThreeDigest2);
    _defineProperty2(_this, "scene", void 0);
    _classPrivateFieldInitSpec2(_this, _dataBindAttr, void 0);
    _classPrivateFieldInitSpec2(_this, _objBindAttr, void 0);
    _this.scene = scene3;
    _classPrivateFieldSet22(_dataBindAttr, _this, dataBindAttr);
    _classPrivateFieldSet22(_objBindAttr, _this, objBindAttr);
    _this.onRemoveObj(function() {
    });
    return _this;
  }
  _inherits(ThreeDigest2, _DataBindMapper);
  return _createClass3(ThreeDigest2, [{
    key: "onCreateObj",
    value: function onCreateObj(fn) {
      var _this2 = this;
      _superPropGet(ThreeDigest2, "onCreateObj", this)([function(d3) {
        var obj = fn(d3);
        d3[_classPrivateFieldGet22(_objBindAttr, _this2)] = obj;
        obj[_classPrivateFieldGet22(_dataBindAttr, _this2)] = d3;
        _this2.scene.add(obj);
        return obj;
      }]);
      return this;
    }
  }, {
    key: "onRemoveObj",
    value: function onRemoveObj(fn) {
      var _this3 = this;
      _superPropGet(ThreeDigest2, "onRemoveObj", this)([function(obj, dId) {
        var d3 = _superPropGet(ThreeDigest2, "getData", _this3)([obj]);
        fn(obj, dId);
        _this3.scene.remove(obj);
        emptyObject(obj);
        delete d3[_classPrivateFieldGet22(_objBindAttr, _this3)];
      }]);
      return this;
    }
  }]);
})(DataBindMapper);
var colorStr2Hex = function colorStr2Hex2(str) {
  return isNaN(str) ? parseInt(tinycolor(str).toHex(), 16) : str;
};
var colorAlpha = function colorAlpha2(str) {
  return isNaN(str) ? tinycolor(str).getAlpha() : 1;
};
var autoColorScale = ordinal(Paired_default);
function autoColorObjects(objects, colorByAccessor, colorField) {
  if (!colorByAccessor || typeof colorField !== "string") return;
  objects.filter(function(obj) {
    return !obj[colorField];
  }).forEach(function(obj) {
    obj[colorField] = autoColorScale(colorByAccessor(obj));
  });
}
function getDagDepths(_ref, idAccessor) {
  var nodes = _ref.nodes, links = _ref.links;
  var _ref2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, _ref2$nodeFilter = _ref2.nodeFilter, nodeFilter = _ref2$nodeFilter === void 0 ? function() {
    return true;
  } : _ref2$nodeFilter, _ref2$onLoopError = _ref2.onLoopError, onLoopError = _ref2$onLoopError === void 0 ? function(loopIds) {
    throw "Invalid DAG structure! Found cycle in node path: ".concat(loopIds.join(" -> "), ".");
  } : _ref2$onLoopError;
  var graph = {};
  nodes.forEach(function(node) {
    return graph[idAccessor(node)] = {
      data: node,
      out: [],
      depth: -1,
      skip: !nodeFilter(node)
    };
  });
  links.forEach(function(_ref3) {
    var source = _ref3.source, target = _ref3.target;
    var sourceId = getNodeId(source);
    var targetId = getNodeId(target);
    if (!graph.hasOwnProperty(sourceId)) throw "Missing source node with id: ".concat(sourceId);
    if (!graph.hasOwnProperty(targetId)) throw "Missing target node with id: ".concat(targetId);
    var sourceNode = graph[sourceId];
    var targetNode = graph[targetId];
    sourceNode.out.push(targetNode);
    function getNodeId(node) {
      return _typeof2(node) === "object" ? idAccessor(node) : node;
    }
  });
  var foundLoops = [];
  traverse(Object.values(graph));
  var nodeDepths = Object.assign.apply(Object, [{}].concat(_toConsumableArray4(Object.entries(graph).filter(function(_ref4) {
    var _ref5 = _slicedToArray5(_ref4, 2), node = _ref5[1];
    return !node.skip;
  }).map(function(_ref6) {
    var _ref7 = _slicedToArray5(_ref6, 2), id2 = _ref7[0], node = _ref7[1];
    return _defineProperty2({}, id2, node.depth);
  }))));
  return nodeDepths;
  function traverse(nodes2) {
    var nodeStack = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    var currentDepth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    var _loop = function _loop2() {
      var node = nodes2[i2];
      if (nodeStack.indexOf(node) !== -1) {
        var loop = [].concat(_toConsumableArray4(nodeStack.slice(nodeStack.indexOf(node))), [node]).map(function(d3) {
          return idAccessor(d3.data);
        });
        if (!foundLoops.some(function(foundLoop) {
          return foundLoop.length === loop.length && foundLoop.every(function(id2, idx) {
            return id2 === loop[idx];
          });
        })) {
          foundLoops.push(loop);
          onLoopError(loop);
        }
        return 1;
      }
      if (currentDepth > node.depth) {
        node.depth = currentDepth;
        traverse(node.out, [].concat(_toConsumableArray4(nodeStack), [node]), currentDepth + (node.skip ? 0 : 1));
      }
    };
    for (var i2 = 0, l2 = nodes2.length; i2 < l2; i2++) {
      if (_loop()) continue;
    }
  }
}
var three$1 = window.THREE ? window.THREE : {
  Group,
  Mesh,
  MeshLambertMaterial,
  Color,
  BufferGeometry,
  BufferAttribute,
  Matrix4,
  Vector3,
  SphereGeometry,
  CylinderGeometry,
  TubeGeometry,
  ConeGeometry,
  Line,
  LineBasicMaterial,
  QuadraticBezierCurve3,
  CubicBezierCurve3,
  Box3
};
var ngraph = {
  graph: ngraph_default,
  forcelayout: import_ngraph3.default
};
var DAG_LEVEL_NODE_RATIO = 2;
var setAttributeFn = new three$1.BufferGeometry().setAttribute ? "setAttribute" : "addAttribute";
var applyMatrix4Fn = new three$1.BufferGeometry().applyMatrix4 ? "applyMatrix4" : "applyMatrix";
var ForceGraph = index3({
  props: {
    jsonUrl: {
      onChange: function onChange(jsonUrl, state) {
        var _this = this;
        if (jsonUrl && !state.fetchingJson) {
          state.fetchingJson = true;
          state.onLoading();
          fetch(jsonUrl).then(function(r2) {
            return r2.json();
          }).then(function(json) {
            state.fetchingJson = false;
            state.onFinishLoading(json);
            _this.graphData(json);
          });
        }
      },
      triggerUpdate: false
    },
    graphData: {
      "default": {
        nodes: [],
        links: []
      },
      onChange: function onChange2(graphData, state) {
        state.engineRunning = false;
      }
    },
    numDimensions: {
      "default": 3,
      onChange: function onChange3(numDim, state) {
        var chargeForce = state.d3ForceLayout.force("charge");
        if (chargeForce) {
          chargeForce.strength(numDim > 2 ? -60 : -30);
        }
        if (numDim < 3) {
          eraseDimension(state.graphData.nodes, "z");
        }
        if (numDim < 2) {
          eraseDimension(state.graphData.nodes, "y");
        }
        function eraseDimension(nodes, dim) {
          nodes.forEach(function(d3) {
            delete d3[dim];
            delete d3["v".concat(dim)];
          });
        }
      }
    },
    dagMode: {
      onChange: function onChange4(dagMode, state) {
        !dagMode && state.forceEngine === "d3" && (state.graphData.nodes || []).forEach(function(n2) {
          return n2.fx = n2.fy = n2.fz = void 0;
        });
      }
    },
    dagLevelDistance: {},
    dagNodeFilter: {
      "default": function _default(node) {
        return true;
      }
    },
    onDagError: {
      triggerUpdate: false
    },
    nodeRelSize: {
      "default": 4
    },
    // volume per val unit
    nodeId: {
      "default": "id"
    },
    nodeVal: {
      "default": "val"
    },
    nodeResolution: {
      "default": 8
    },
    // how many slice segments in the sphere's circumference
    nodeColor: {
      "default": "color"
    },
    nodeAutoColorBy: {},
    nodeOpacity: {
      "default": 0.75
    },
    nodeVisibility: {
      "default": true
    },
    nodeThreeObject: {},
    nodeThreeObjectExtend: {
      "default": false
    },
    nodePositionUpdate: {
      triggerUpdate: false
    },
    // custom function to call for updating the node's position. Signature: (threeObj, { x, y, z}, node). If the function returns a truthy value, the regular node position update will not run.
    linkSource: {
      "default": "source"
    },
    linkTarget: {
      "default": "target"
    },
    linkVisibility: {
      "default": true
    },
    linkColor: {
      "default": "color"
    },
    linkAutoColorBy: {},
    linkOpacity: {
      "default": 0.2
    },
    linkWidth: {},
    // Rounded to nearest decimal. For falsy values use dimensionless line with 1px regardless of distance.
    linkResolution: {
      "default": 6
    },
    // how many radial segments in each line tube's geometry
    linkCurvature: {
      "default": 0,
      triggerUpdate: false
    },
    // line curvature radius (0: straight, 1: semi-circle)
    linkCurveRotation: {
      "default": 0,
      triggerUpdate: false
    },
    // line curve rotation along the line axis (0: interection with XY plane, PI: upside down)
    linkMaterial: {},
    linkThreeObject: {},
    linkThreeObjectExtend: {
      "default": false
    },
    linkPositionUpdate: {
      triggerUpdate: false
    },
    // custom function to call for updating the link's position. Signature: (threeObj, { start: { x, y, z},  end: { x, y, z }}, link). If the function returns a truthy value, the regular link position update will not run.
    linkDirectionalArrowLength: {
      "default": 0
    },
    linkDirectionalArrowColor: {},
    linkDirectionalArrowRelPos: {
      "default": 0.5,
      triggerUpdate: false
    },
    // value between 0<>1 indicating the relative pos along the (exposed) line
    linkDirectionalArrowResolution: {
      "default": 8
    },
    // how many slice segments in the arrow's conic circumference
    linkDirectionalParticles: {
      "default": 0
    },
    // animate photons travelling in the link direction
    linkDirectionalParticleSpeed: {
      "default": 0.01,
      triggerUpdate: false
    },
    // in link length ratio per frame
    linkDirectionalParticleOffset: {
      "default": 0,
      triggerUpdate: false
    },
    // starting position offset along the link's length, like a pre-delay. Values between [0, 1]
    linkDirectionalParticleWidth: {
      "default": 0.5
    },
    linkDirectionalParticleColor: {},
    linkDirectionalParticleResolution: {
      "default": 4
    },
    // how many slice segments in the particle sphere's circumference
    linkDirectionalParticleThreeObject: {},
    forceEngine: {
      "default": "d3"
    },
    // d3 or ngraph
    d3AlphaMin: {
      "default": 0
    },
    d3AlphaDecay: {
      "default": 0.0228,
      triggerUpdate: false,
      onChange: function onChange5(alphaDecay, state) {
        state.d3ForceLayout.alphaDecay(alphaDecay);
      }
    },
    d3AlphaTarget: {
      "default": 0,
      triggerUpdate: false,
      onChange: function onChange6(alphaTarget, state) {
        state.d3ForceLayout.alphaTarget(alphaTarget);
      }
    },
    d3VelocityDecay: {
      "default": 0.4,
      triggerUpdate: false,
      onChange: function onChange7(velocityDecay, state) {
        state.d3ForceLayout.velocityDecay(velocityDecay);
      }
    },
    ngraphPhysics: {
      "default": {
        // defaults from https://github.com/anvaka/ngraph.physics.simulator/blob/master/index.js
        timeStep: 20,
        gravity: -1.2,
        theta: 0.8,
        springLength: 30,
        springCoefficient: 8e-4,
        dragCoefficient: 0.02
      }
    },
    warmupTicks: {
      "default": 0,
      triggerUpdate: false
    },
    // how many times to tick the force engine at init before starting to render
    cooldownTicks: {
      "default": Infinity,
      triggerUpdate: false
    },
    cooldownTime: {
      "default": 15e3,
      triggerUpdate: false
    },
    // ms
    onLoading: {
      "default": function _default2() {
      },
      triggerUpdate: false
    },
    onFinishLoading: {
      "default": function _default3() {
      },
      triggerUpdate: false
    },
    onUpdate: {
      "default": function _default4() {
      },
      triggerUpdate: false
    },
    onFinishUpdate: {
      "default": function _default5() {
      },
      triggerUpdate: false
    },
    onEngineTick: {
      "default": function _default6() {
      },
      triggerUpdate: false
    },
    onEngineStop: {
      "default": function _default7() {
      },
      triggerUpdate: false
    }
  },
  methods: {
    refresh: function refresh(state) {
      state._flushObjects = true;
      state._rerender();
      return this;
    },
    // Expose d3 forces for external manipulation
    d3Force: function d3Force(state, forceName, forceFn) {
      if (forceFn === void 0) {
        return state.d3ForceLayout.force(forceName);
      }
      state.d3ForceLayout.force(forceName, forceFn);
      return this;
    },
    d3ReheatSimulation: function d3ReheatSimulation(state) {
      state.d3ForceLayout.alpha(1);
      this.resetCountdown();
      return this;
    },
    // reset cooldown state
    resetCountdown: function resetCountdown(state) {
      state.cntTicks = 0;
      state.startTickTime = /* @__PURE__ */ new Date();
      state.engineRunning = true;
      return this;
    },
    tickFrame: function tickFrame(state) {
      var isD3Sim = state.forceEngine !== "ngraph";
      if (state.engineRunning) {
        layoutTick();
      }
      updateArrows();
      updatePhotons();
      return this;
      function layoutTick() {
        if (++state.cntTicks > state.cooldownTicks || /* @__PURE__ */ new Date() - state.startTickTime > state.cooldownTime || isD3Sim && state.d3AlphaMin > 0 && state.d3ForceLayout.alpha() < state.d3AlphaMin) {
          state.engineRunning = false;
          state.onEngineStop();
        } else {
          state.layout[isD3Sim ? "tick" : "step"]();
          state.onEngineTick();
        }
        var nodeThreeObjectExtendAccessor = index4(state.nodeThreeObjectExtend);
        state.nodeDataMapper.entries().forEach(function(_ref) {
          var _ref2 = _slicedToArray5(_ref, 2), node = _ref2[0], obj = _ref2[1];
          if (!obj) return;
          var pos = isD3Sim ? node : state.layout.getNodePosition(node[state.nodeId]);
          var extendedObj = nodeThreeObjectExtendAccessor(node);
          if (!state.nodePositionUpdate || !state.nodePositionUpdate(extendedObj ? obj.children[0] : obj, {
            x: pos.x,
            y: pos.y,
            z: pos.z
          }, node) || extendedObj) {
            obj.position.x = pos.x;
            obj.position.y = pos.y || 0;
            obj.position.z = pos.z || 0;
          }
        });
        var linkWidthAccessor = index4(state.linkWidth);
        var linkCurvatureAccessor = index4(state.linkCurvature);
        var linkCurveRotationAccessor = index4(state.linkCurveRotation);
        var linkThreeObjectExtendAccessor = index4(state.linkThreeObjectExtend);
        state.linkDataMapper.entries().forEach(function(_ref3) {
          var _ref4 = _slicedToArray5(_ref3, 2), link = _ref4[0], lineObj = _ref4[1];
          if (!lineObj) return;
          var pos = isD3Sim ? link : state.layout.getLinkPosition(state.layout.graph.getLink(link.source, link.target).id);
          var start2 = pos[isD3Sim ? "source" : "from"];
          var end = pos[isD3Sim ? "target" : "to"];
          if (!start2 || !end || !start2.hasOwnProperty("x") || !end.hasOwnProperty("x")) return;
          calcLinkCurve(link);
          var extendedObj = linkThreeObjectExtendAccessor(link);
          if (state.linkPositionUpdate && state.linkPositionUpdate(
            extendedObj ? lineObj.children[1] : lineObj,
            // pass child custom object if extending the default
            {
              start: {
                x: start2.x,
                y: start2.y,
                z: start2.z
              },
              end: {
                x: end.x,
                y: end.y,
                z: end.z
              }
            },
            link
          ) && !extendedObj) {
            return;
          }
          var curveResolution = 30;
          var curve = link.__curve;
          var line = lineObj.children.length ? lineObj.children[0] : lineObj;
          if (line.type === "Line") {
            if (!curve) {
              var linePos = line.geometry.getAttribute("position");
              if (!linePos || !linePos.array || linePos.array.length !== 6) {
                line.geometry[setAttributeFn]("position", linePos = new three$1.BufferAttribute(new Float32Array(2 * 3), 3));
              }
              linePos.array[0] = start2.x;
              linePos.array[1] = start2.y || 0;
              linePos.array[2] = start2.z || 0;
              linePos.array[3] = end.x;
              linePos.array[4] = end.y || 0;
              linePos.array[5] = end.z || 0;
              linePos.needsUpdate = true;
            } else {
              var curvePnts = curve.getPoints(curveResolution);
              if (line.geometry.getAttribute("position").array.length !== curvePnts.length * 3) {
                line.geometry[setAttributeFn]("position", new three$1.BufferAttribute(new Float32Array(curvePnts.length * 3), 3));
              }
              line.geometry.setFromPoints(curvePnts);
            }
            line.geometry.computeBoundingSphere();
          } else if (line.type === "Mesh") {
            if (!curve) {
              if (!line.geometry.type.match(/^Cylinder(Buffer)?Geometry$/)) {
                var linkWidth = Math.ceil(linkWidthAccessor(link) * 10) / 10;
                var r2 = linkWidth / 2;
                var geometry = new three$1.CylinderGeometry(r2, r2, 1, state.linkResolution, 1, false);
                geometry[applyMatrix4Fn](new three$1.Matrix4().makeTranslation(0, 1 / 2, 0));
                geometry[applyMatrix4Fn](new three$1.Matrix4().makeRotationX(Math.PI / 2));
                line.geometry.dispose();
                line.geometry = geometry;
              }
              var vStart = new three$1.Vector3(start2.x, start2.y || 0, start2.z || 0);
              var vEnd = new three$1.Vector3(end.x, end.y || 0, end.z || 0);
              var distance4 = vStart.distanceTo(vEnd);
              line.position.x = vStart.x;
              line.position.y = vStart.y;
              line.position.z = vStart.z;
              line.scale.z = distance4;
              line.parent.localToWorld(vEnd);
              line.lookAt(vEnd);
            } else {
              if (!line.geometry.type.match(/^Tube(Buffer)?Geometry$/)) {
                line.position.set(0, 0, 0);
                line.rotation.set(0, 0, 0);
                line.scale.set(1, 1, 1);
              }
              var _linkWidth = Math.ceil(linkWidthAccessor(link) * 10) / 10;
              var _r = _linkWidth / 2;
              var _geometry3 = new three$1.TubeGeometry(curve, curveResolution, _r, state.linkResolution, false);
              line.geometry.dispose();
              line.geometry = _geometry3;
            }
          }
        });
        function calcLinkCurve(link) {
          var pos = isD3Sim ? link : state.layout.getLinkPosition(state.layout.graph.getLink(link.source, link.target).id);
          var start2 = pos[isD3Sim ? "source" : "from"];
          var end = pos[isD3Sim ? "target" : "to"];
          if (!start2 || !end || !start2.hasOwnProperty("x") || !end.hasOwnProperty("x")) return;
          var curvature = linkCurvatureAccessor(link);
          if (!curvature) {
            link.__curve = null;
          } else {
            var vStart = new three$1.Vector3(start2.x, start2.y || 0, start2.z || 0);
            var vEnd = new three$1.Vector3(end.x, end.y || 0, end.z || 0);
            var l2 = vStart.distanceTo(vEnd);
            var curve;
            var curveRotation = linkCurveRotationAccessor(link);
            if (l2 > 0) {
              var dx = end.x - start2.x;
              var dy = end.y - start2.y || 0;
              var vLine = new three$1.Vector3().subVectors(vEnd, vStart);
              var cp = vLine.clone().multiplyScalar(curvature).cross(dx !== 0 || dy !== 0 ? new three$1.Vector3(0, 0, 1) : new three$1.Vector3(0, 1, 0)).applyAxisAngle(vLine.normalize(), curveRotation).add(new three$1.Vector3().addVectors(vStart, vEnd).divideScalar(2));
              curve = new three$1.QuadraticBezierCurve3(vStart, cp, vEnd);
            } else {
              var d3 = curvature * 70;
              var endAngle = -curveRotation;
              var startAngle = endAngle + Math.PI / 2;
              curve = new three$1.CubicBezierCurve3(vStart, new three$1.Vector3(d3 * Math.cos(startAngle), d3 * Math.sin(startAngle), 0).add(vStart), new three$1.Vector3(d3 * Math.cos(endAngle), d3 * Math.sin(endAngle), 0).add(vStart), vEnd);
            }
            link.__curve = curve;
          }
        }
      }
      function updateArrows() {
        var arrowRelPosAccessor = index4(state.linkDirectionalArrowRelPos);
        var arrowLengthAccessor = index4(state.linkDirectionalArrowLength);
        var nodeValAccessor = index4(state.nodeVal);
        state.arrowDataMapper.entries().forEach(function(_ref5) {
          var _ref6 = _slicedToArray5(_ref5, 2), link = _ref6[0], arrowObj = _ref6[1];
          if (!arrowObj) return;
          var pos = isD3Sim ? link : state.layout.getLinkPosition(state.layout.graph.getLink(link.source, link.target).id);
          var start2 = pos[isD3Sim ? "source" : "from"];
          var end = pos[isD3Sim ? "target" : "to"];
          if (!start2 || !end || !start2.hasOwnProperty("x") || !end.hasOwnProperty("x")) return;
          var startR = Math.cbrt(Math.max(0, nodeValAccessor(start2) || 1)) * state.nodeRelSize;
          var endR = Math.cbrt(Math.max(0, nodeValAccessor(end) || 1)) * state.nodeRelSize;
          var arrowLength = arrowLengthAccessor(link);
          var arrowRelPos = arrowRelPosAccessor(link);
          var getPosAlongLine = link.__curve ? function(t5) {
            return link.__curve.getPoint(t5);
          } : function(t5) {
            var iplt = function iplt2(dim, start3, end2, t6) {
              return start3[dim] + (end2[dim] - start3[dim]) * t6 || 0;
            };
            return {
              x: iplt("x", start2, end, t5),
              y: iplt("y", start2, end, t5),
              z: iplt("z", start2, end, t5)
            };
          };
          var lineLen = link.__curve ? link.__curve.getLength() : Math.sqrt(["x", "y", "z"].map(function(dim) {
            return Math.pow((end[dim] || 0) - (start2[dim] || 0), 2);
          }).reduce(function(acc, v2) {
            return acc + v2;
          }, 0));
          var posAlongLine = startR + arrowLength + (lineLen - startR - endR - arrowLength) * arrowRelPos;
          var arrowHead = getPosAlongLine(posAlongLine / lineLen);
          var arrowTail = getPosAlongLine((posAlongLine - arrowLength) / lineLen);
          ["x", "y", "z"].forEach(function(dim) {
            return arrowObj.position[dim] = arrowTail[dim];
          });
          var headVec = _construct(three$1.Vector3, _toConsumableArray4(["x", "y", "z"].map(function(c5) {
            return arrowHead[c5];
          })));
          arrowObj.parent.localToWorld(headVec);
          arrowObj.lookAt(headVec);
        });
      }
      function updatePhotons() {
        var particleSpeedAccessor = index4(state.linkDirectionalParticleSpeed);
        var particleOffsetAccessor = index4(state.linkDirectionalParticleOffset);
        state.graphData.links.forEach(function(link) {
          var photonsObj = state.particlesDataMapper.getObj(link);
          var cyclePhotons = photonsObj && photonsObj.children;
          var singleHopPhotons = link.__singleHopPhotonsObj && link.__singleHopPhotonsObj.children;
          if ((!singleHopPhotons || !singleHopPhotons.length) && (!cyclePhotons || !cyclePhotons.length)) return;
          var pos = isD3Sim ? link : state.layout.getLinkPosition(state.layout.graph.getLink(link.source, link.target).id);
          var start2 = pos[isD3Sim ? "source" : "from"];
          var end = pos[isD3Sim ? "target" : "to"];
          if (!start2 || !end || !start2.hasOwnProperty("x") || !end.hasOwnProperty("x")) return;
          var particleSpeed = particleSpeedAccessor(link);
          var particleOffset = Math.abs(particleOffsetAccessor(link));
          var getPhotonPos = link.__curve ? function(t5) {
            return link.__curve.getPoint(t5);
          } : function(t5) {
            var iplt = function iplt2(dim, start3, end2, t6) {
              return start3[dim] + (end2[dim] - start3[dim]) * t6 || 0;
            };
            return {
              x: iplt("x", start2, end, t5),
              y: iplt("y", start2, end, t5),
              z: iplt("z", start2, end, t5)
            };
          };
          var photons = [].concat(_toConsumableArray4(cyclePhotons || []), _toConsumableArray4(singleHopPhotons || []));
          photons.forEach(function(photon, idx) {
            var singleHop = photon.parent.__linkThreeObjType === "singleHopPhotons";
            if (!photon.hasOwnProperty("__progressRatio")) {
              photon.__progressRatio = singleHop ? 0 : (idx + particleOffset) / cyclePhotons.length;
            }
            photon.__progressRatio += particleSpeed;
            if (photon.__progressRatio >= 1) {
              if (!singleHop) {
                photon.__progressRatio = photon.__progressRatio % 1;
              } else {
                photon.parent.remove(photon);
                emptyObject(photon);
                return;
              }
            }
            var photonPosRatio = photon.__progressRatio;
            var pos2 = getPhotonPos(photonPosRatio);
            photon.geometry.type !== "SphereGeometry" && photon.lookAt(pos2.x, pos2.y, pos2.z);
            ["x", "y", "z"].forEach(function(dim) {
              return photon.position[dim] = pos2[dim];
            });
          });
        });
      }
    },
    emitParticle: function emitParticle(state, link) {
      if (link && state.graphData.links.includes(link)) {
        if (!link.__singleHopPhotonsObj) {
          var obj = new three$1.Group();
          obj.__linkThreeObjType = "singleHopPhotons";
          link.__singleHopPhotonsObj = obj;
          state.graphScene.add(obj);
        }
        var particleObj = index4(state.linkDirectionalParticleThreeObject)(link);
        if (particleObj && state.linkDirectionalParticleThreeObject === particleObj) {
          particleObj = particleObj.clone();
        }
        if (!particleObj) {
          var particleWidthAccessor = index4(state.linkDirectionalParticleWidth);
          var photonR = Math.ceil(particleWidthAccessor(link) * 10) / 10 / 2;
          var numSegments = state.linkDirectionalParticleResolution;
          var particleGeometry = new three$1.SphereGeometry(photonR, numSegments, numSegments);
          var linkColorAccessor = index4(state.linkColor);
          var particleColorAccessor = index4(state.linkDirectionalParticleColor);
          var photonColor = particleColorAccessor(link) || linkColorAccessor(link) || "#f0f0f0";
          var materialColor2 = new three$1.Color(colorStr2Hex(photonColor));
          var opacity = state.linkOpacity * 3;
          var particleMaterial = new three$1.MeshLambertMaterial({
            color: materialColor2,
            transparent: true,
            opacity
          });
          particleObj = new three$1.Mesh(particleGeometry, particleMaterial);
        }
        link.__singleHopPhotonsObj.add(particleObj);
      }
      return this;
    },
    getGraphBbox: function getGraphBbox(state) {
      var nodeFilter = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
        return true;
      };
      if (!state.initialised) return null;
      var bboxes = (function getBboxes(obj) {
        var bboxes2 = [];
        if (obj.geometry) {
          obj.geometry.computeBoundingBox();
          var box = new three$1.Box3();
          box.copy(obj.geometry.boundingBox).applyMatrix4(obj.matrixWorld);
          bboxes2.push(box);
        }
        return bboxes2.concat.apply(bboxes2, _toConsumableArray4((obj.children || []).filter(
          function(obj2) {
            return !obj2.hasOwnProperty("__graphObjType") || obj2.__graphObjType === "node" && nodeFilter(obj2.__data);
          }
          // exclude filtered out nodes
        ).map(getBboxes)));
      })(state.graphScene);
      if (!bboxes.length) return null;
      return Object.assign.apply(Object, _toConsumableArray4(["x", "y", "z"].map(function(c5) {
        return _defineProperty2({}, c5, [min(bboxes, function(bb) {
          return bb.min[c5];
        }), max2(bboxes, function(bb) {
          return bb.max[c5];
        })]);
      })));
    }
  },
  stateInit: function stateInit() {
    return {
      d3ForceLayout: simulation_default().force("link", link_default()).force("charge", manyBody_default()).force("center", center_default()).force("dagRadial", null).stop(),
      engineRunning: false
    };
  },
  init: function init(threeObj, state) {
    state.graphScene = threeObj;
    state.nodeDataMapper = new ThreeDigest(threeObj, {
      objBindAttr: "__threeObj"
    });
    state.linkDataMapper = new ThreeDigest(threeObj, {
      objBindAttr: "__lineObj"
    });
    state.arrowDataMapper = new ThreeDigest(threeObj, {
      objBindAttr: "__arrowObj"
    });
    state.particlesDataMapper = new ThreeDigest(threeObj, {
      objBindAttr: "__photonsObj"
    });
  },
  update: function update(state, changedProps) {
    var hasAnyPropChanged = function hasAnyPropChanged2(propList) {
      return propList.some(function(p3) {
        return changedProps.hasOwnProperty(p3);
      });
    };
    state.engineRunning = false;
    typeof state.onUpdate === "function" && state.onUpdate();
    if (state.nodeAutoColorBy !== null && hasAnyPropChanged(["nodeAutoColorBy", "graphData", "nodeColor"])) {
      autoColorObjects(state.graphData.nodes, index4(state.nodeAutoColorBy), state.nodeColor);
    }
    if (state.linkAutoColorBy !== null && hasAnyPropChanged(["linkAutoColorBy", "graphData", "linkColor"])) {
      autoColorObjects(state.graphData.links, index4(state.linkAutoColorBy), state.linkColor);
    }
    if (state._flushObjects || hasAnyPropChanged(["graphData", "nodeThreeObject", "nodeThreeObjectExtend", "nodeVal", "nodeColor", "nodeVisibility", "nodeRelSize", "nodeResolution", "nodeOpacity"])) {
      var customObjectAccessor = index4(state.nodeThreeObject);
      var customObjectExtendAccessor = index4(state.nodeThreeObjectExtend);
      var valAccessor = index4(state.nodeVal);
      var colorAccessor = index4(state.nodeColor);
      var visibilityAccessor = index4(state.nodeVisibility);
      var sphereGeometries = {};
      var sphereMaterials = {};
      if (state._flushObjects || hasAnyPropChanged([
        // recreate objects if any of these props have changed
        "nodeThreeObject",
        "nodeThreeObjectExtend"
      ])) state.nodeDataMapper.clear();
      state.nodeDataMapper.onCreateObj(function(node) {
        var customObj = customObjectAccessor(node);
        var extendObj = customObjectExtendAccessor(node);
        if (customObj && state.nodeThreeObject === customObj) {
          customObj = customObj.clone();
        }
        var obj;
        if (customObj && !extendObj) {
          obj = customObj;
        } else {
          obj = new three$1.Mesh();
          obj.__graphDefaultObj = true;
          if (customObj && extendObj) {
            obj.add(customObj);
          }
        }
        obj.__graphObjType = "node";
        return obj;
      }).onUpdateObj(function(obj, node) {
        if (obj.__graphDefaultObj) {
          var val = valAccessor(node) || 1;
          var radius = Math.cbrt(val) * state.nodeRelSize;
          var numSegments = state.nodeResolution;
          if (!obj.geometry.type.match(/^Sphere(Buffer)?Geometry$/) || obj.geometry.parameters.radius !== radius || obj.geometry.parameters.widthSegments !== numSegments) {
            if (!sphereGeometries.hasOwnProperty(val)) {
              sphereGeometries[val] = new three$1.SphereGeometry(radius, numSegments, numSegments);
            }
            obj.geometry.dispose();
            obj.geometry = sphereGeometries[val];
          }
          var color3 = colorAccessor(node);
          var materialColor2 = new three$1.Color(colorStr2Hex(color3 || "#ffffaa"));
          var opacity = state.nodeOpacity * colorAlpha(color3);
          if (obj.material.type !== "MeshLambertMaterial" || !obj.material.color.equals(materialColor2) || obj.material.opacity !== opacity) {
            if (!sphereMaterials.hasOwnProperty(color3)) {
              sphereMaterials[color3] = new three$1.MeshLambertMaterial({
                color: materialColor2,
                transparent: true,
                opacity
              });
            }
            obj.material.dispose();
            obj.material = sphereMaterials[color3];
          }
        }
      }).digest(state.graphData.nodes.filter(visibilityAccessor));
    }
    if (state._flushObjects || hasAnyPropChanged(["graphData", "linkThreeObject", "linkThreeObjectExtend", "linkMaterial", "linkColor", "linkWidth", "linkVisibility", "linkResolution", "linkOpacity", "linkDirectionalArrowLength", "linkDirectionalArrowColor", "linkDirectionalArrowResolution", "linkDirectionalParticles", "linkDirectionalParticleWidth", "linkDirectionalParticleColor", "linkDirectionalParticleResolution", "linkDirectionalParticleThreeObject"])) {
      var _customObjectAccessor = index4(state.linkThreeObject);
      var _customObjectExtendAccessor = index4(state.linkThreeObjectExtend);
      var customMaterialAccessor = index4(state.linkMaterial);
      var _visibilityAccessor = index4(state.linkVisibility);
      var _colorAccessor = index4(state.linkColor);
      var widthAccessor = index4(state.linkWidth);
      var cylinderGeometries = {};
      var lambertLineMaterials = {};
      var basicLineMaterials = {};
      var visibleLinks = state.graphData.links.filter(_visibilityAccessor);
      if (state._flushObjects || hasAnyPropChanged([
        // recreate objects if any of these props have changed
        "linkThreeObject",
        "linkThreeObjectExtend",
        "linkWidth"
      ])) state.linkDataMapper.clear();
      state.linkDataMapper.onRemoveObj(function(obj) {
        var singlePhotonsObj = obj.__data && obj.__data.__singleHopPhotonsObj;
        if (singlePhotonsObj) {
          singlePhotonsObj.parent.remove(singlePhotonsObj);
          emptyObject(singlePhotonsObj);
          delete obj.__data.__singleHopPhotonsObj;
        }
      }).onCreateObj(function(link) {
        var customObj = _customObjectAccessor(link);
        var extendObj = _customObjectExtendAccessor(link);
        if (customObj && state.linkThreeObject === customObj) {
          customObj = customObj.clone();
        }
        var defaultObj;
        if (!customObj || extendObj) {
          var useCylinder = !!widthAccessor(link);
          if (useCylinder) {
            defaultObj = new three$1.Mesh();
          } else {
            var lineGeometry = new three$1.BufferGeometry();
            lineGeometry[setAttributeFn]("position", new three$1.BufferAttribute(new Float32Array(2 * 3), 3));
            defaultObj = new three$1.Line(lineGeometry);
          }
        }
        var obj;
        if (!customObj) {
          obj = defaultObj;
          obj.__graphDefaultObj = true;
        } else {
          if (!extendObj) {
            obj = customObj;
          } else {
            obj = new three$1.Group();
            obj.__graphDefaultObj = true;
            obj.add(defaultObj);
            obj.add(customObj);
          }
        }
        obj.renderOrder = 10;
        obj.__graphObjType = "link";
        return obj;
      }).onUpdateObj(function(updObj, link) {
        if (updObj.__graphDefaultObj) {
          var obj = updObj.children.length ? updObj.children[0] : updObj;
          var linkWidth = Math.ceil(widthAccessor(link) * 10) / 10;
          var useCylinder = !!linkWidth;
          if (useCylinder) {
            var r2 = linkWidth / 2;
            var numSegments = state.linkResolution;
            if (!obj.geometry.type.match(/^Cylinder(Buffer)?Geometry$/) || obj.geometry.parameters.radiusTop !== r2 || obj.geometry.parameters.radialSegments !== numSegments) {
              if (!cylinderGeometries.hasOwnProperty(linkWidth)) {
                var geometry = new three$1.CylinderGeometry(r2, r2, 1, numSegments, 1, false);
                geometry[applyMatrix4Fn](new three$1.Matrix4().makeTranslation(0, 1 / 2, 0));
                geometry[applyMatrix4Fn](new three$1.Matrix4().makeRotationX(Math.PI / 2));
                cylinderGeometries[linkWidth] = geometry;
              }
              obj.geometry.dispose();
              obj.geometry = cylinderGeometries[linkWidth];
            }
          }
          var customMaterial = customMaterialAccessor(link);
          if (customMaterial) {
            obj.material = customMaterial;
          } else {
            var color3 = _colorAccessor(link);
            var materialColor2 = new three$1.Color(colorStr2Hex(color3 || "#f0f0f0"));
            var opacity = state.linkOpacity * colorAlpha(color3);
            var materialType = useCylinder ? "MeshLambertMaterial" : "LineBasicMaterial";
            if (obj.material.type !== materialType || !obj.material.color.equals(materialColor2) || obj.material.opacity !== opacity) {
              var lineMaterials = useCylinder ? lambertLineMaterials : basicLineMaterials;
              if (!lineMaterials.hasOwnProperty(color3)) {
                lineMaterials[color3] = new three$1[materialType]({
                  color: materialColor2,
                  transparent: opacity < 1,
                  opacity,
                  depthWrite: opacity >= 1
                  // Prevent transparency issues
                });
              }
              obj.material.dispose();
              obj.material = lineMaterials[color3];
            }
          }
        }
      }).digest(visibleLinks);
      if (state.linkDirectionalArrowLength || changedProps.hasOwnProperty("linkDirectionalArrowLength")) {
        var arrowLengthAccessor = index4(state.linkDirectionalArrowLength);
        var arrowColorAccessor = index4(state.linkDirectionalArrowColor);
        state.arrowDataMapper.onCreateObj(function() {
          var obj = new three$1.Mesh(void 0, new three$1.MeshLambertMaterial({
            transparent: true
          }));
          obj.__linkThreeObjType = "arrow";
          return obj;
        }).onUpdateObj(function(obj, link) {
          var arrowLength = arrowLengthAccessor(link);
          var numSegments = state.linkDirectionalArrowResolution;
          if (!obj.geometry.type.match(/^Cone(Buffer)?Geometry$/) || obj.geometry.parameters.height !== arrowLength || obj.geometry.parameters.radialSegments !== numSegments) {
            var coneGeometry = new three$1.ConeGeometry(arrowLength * 0.25, arrowLength, numSegments);
            coneGeometry.translate(0, arrowLength / 2, 0);
            coneGeometry.rotateX(Math.PI / 2);
            obj.geometry.dispose();
            obj.geometry = coneGeometry;
          }
          var arrowColor = arrowColorAccessor(link) || _colorAccessor(link) || "#f0f0f0";
          obj.material.color = new three$1.Color(colorStr2Hex(arrowColor));
          obj.material.opacity = state.linkOpacity * 3 * colorAlpha(arrowColor);
        }).digest(visibleLinks.filter(arrowLengthAccessor));
      }
      if (state.linkDirectionalParticles || changedProps.hasOwnProperty("linkDirectionalParticles")) {
        var particlesAccessor = index4(state.linkDirectionalParticles);
        var particleWidthAccessor = index4(state.linkDirectionalParticleWidth);
        var particleColorAccessor = index4(state.linkDirectionalParticleColor);
        var particleObjectAccessor = index4(state.linkDirectionalParticleThreeObject);
        var particleMaterials = {};
        var particleGeometries = {};
        state.particlesDataMapper.onCreateObj(function() {
          var obj = new three$1.Group();
          obj.__linkThreeObjType = "photons";
          obj.__photonDataMapper = new ThreeDigest(obj);
          return obj;
        }).onUpdateObj(function(obj, link) {
          var curPhoton = !!obj.children.length && obj.children[0];
          var customObj = particleObjectAccessor(link);
          var particleGeometry, particleMaterial;
          if (customObj) {
            particleGeometry = customObj.geometry;
            particleMaterial = customObj.material;
          } else {
            var photonR = Math.ceil(particleWidthAccessor(link) * 10) / 10 / 2;
            var numSegments = state.linkDirectionalParticleResolution;
            if (curPhoton && curPhoton.geometry.parameters.radius === photonR && curPhoton.geometry.parameters.widthSegments === numSegments) {
              particleGeometry = curPhoton.geometry;
            } else {
              if (!particleGeometries.hasOwnProperty(photonR)) {
                particleGeometries[photonR] = new three$1.SphereGeometry(photonR, numSegments, numSegments);
              }
              particleGeometry = particleGeometries[photonR];
            }
            var photonColor = particleColorAccessor(link) || _colorAccessor(link) || "#f0f0f0";
            var materialColor2 = new three$1.Color(colorStr2Hex(photonColor));
            var opacity = state.linkOpacity * 3;
            if (curPhoton && curPhoton.material.color.equals(materialColor2) && curPhoton.material.opacity === opacity) {
              particleMaterial = curPhoton.material;
            } else {
              if (!particleMaterials.hasOwnProperty(photonColor)) {
                particleMaterials[photonColor] = new three$1.MeshLambertMaterial({
                  color: materialColor2,
                  transparent: true,
                  opacity
                });
              }
              particleMaterial = particleMaterials[photonColor];
            }
          }
          if (curPhoton) {
            curPhoton.geometry !== particleGeometry && curPhoton.geometry.dispose();
            curPhoton.material !== particleMaterial && curPhoton.material.dispose();
          }
          var numPhotons = Math.round(Math.abs(particlesAccessor(link)));
          obj.__photonDataMapper.id(function(d3) {
            return d3.idx;
          }).onCreateObj(function() {
            return new three$1.Mesh(particleGeometry, particleMaterial);
          }).onUpdateObj(function(obj2) {
            obj2.geometry = particleGeometry;
            obj2.material = particleMaterial;
          }).digest(_toConsumableArray4(new Array(numPhotons)).map(function(_2, idx) {
            return {
              idx
            };
          }));
        }).digest(visibleLinks.filter(particlesAccessor));
      }
    }
    state._flushObjects = false;
    if (hasAnyPropChanged(["graphData", "nodeId", "linkSource", "linkTarget", "numDimensions", "forceEngine", "dagMode", "dagNodeFilter", "dagLevelDistance"])) {
      state.engineRunning = false;
      state.graphData.links.forEach(function(link) {
        link.source = link[state.linkSource];
        link.target = link[state.linkTarget];
      });
      var isD3Sim = state.forceEngine !== "ngraph";
      var layout;
      if (isD3Sim) {
        (layout = state.d3ForceLayout).stop().alpha(1).numDimensions(state.numDimensions).nodes(state.graphData.nodes);
        var linkForce = state.d3ForceLayout.force("link");
        if (linkForce) {
          linkForce.id(function(d3) {
            return d3[state.nodeId];
          }).links(state.graphData.links);
        }
        var nodeDepths = state.dagMode && getDagDepths(state.graphData, function(node) {
          return node[state.nodeId];
        }, {
          nodeFilter: state.dagNodeFilter,
          onLoopError: state.onDagError || void 0
        });
        var maxDepth = Math.max.apply(Math, _toConsumableArray4(Object.values(nodeDepths || [])));
        var dagLevelDistance = state.dagLevelDistance || state.graphData.nodes.length / (maxDepth || 1) * DAG_LEVEL_NODE_RATIO * (["radialin", "radialout"].indexOf(state.dagMode) !== -1 ? 0.7 : 1);
        if (["lr", "rl", "td", "bu", "zin", "zout"].includes(changedProps.dagMode)) {
          var resetProp = ["lr", "rl"].includes(changedProps.dagMode) ? "fx" : ["td", "bu"].includes(changedProps.dagMode) ? "fy" : "fz";
          state.graphData.nodes.filter(state.dagNodeFilter).forEach(function(node) {
            return delete node[resetProp];
          });
        }
        if (["lr", "rl", "td", "bu", "zin", "zout"].includes(state.dagMode)) {
          var invert2 = ["rl", "td", "zout"].includes(state.dagMode);
          var fixFn = function fixFn2(node) {
            return (nodeDepths[node[state.nodeId]] - maxDepth / 2) * dagLevelDistance * (invert2 ? -1 : 1);
          };
          var _resetProp = ["lr", "rl"].includes(state.dagMode) ? "fx" : ["td", "bu"].includes(state.dagMode) ? "fy" : "fz";
          state.graphData.nodes.filter(state.dagNodeFilter).forEach(function(node) {
            return node[_resetProp] = fixFn(node);
          });
        }
        state.d3ForceLayout.force("dagRadial", ["radialin", "radialout"].indexOf(state.dagMode) !== -1 ? radial_default(function(node) {
          var nodeDepth = nodeDepths[node[state.nodeId]] || -1;
          return (state.dagMode === "radialin" ? maxDepth - nodeDepth : nodeDepth) * dagLevelDistance;
        }).strength(function(node) {
          return state.dagNodeFilter(node) ? 1 : 0;
        }) : null);
      } else {
        var _graph = ngraph.graph();
        state.graphData.nodes.forEach(function(node) {
          _graph.addNode(node[state.nodeId]);
        });
        state.graphData.links.forEach(function(link) {
          _graph.addLink(link.source, link.target);
        });
        layout = ngraph.forcelayout(_graph, _objectSpread2({
          dimensions: state.numDimensions
        }, state.ngraphPhysics));
        layout.graph = _graph;
      }
      for (var i2 = 0; i2 < state.warmupTicks && !(isD3Sim && state.d3AlphaMin > 0 && state.d3ForceLayout.alpha() < state.d3AlphaMin); i2++) {
        layout[isD3Sim ? "tick" : "step"]();
      }
      state.layout = layout;
      this.resetCountdown();
    }
    state.engineRunning = true;
    state.onFinishUpdate();
  }
});
function fromKapsule(kapsule) {
  var baseClass = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Object;
  var initKapsuleWithSelf = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var ForceGraph2 = (function(_baseClass) {
    function ForceGraph3() {
      var _this;
      _classCallCheck3(this, ForceGraph3);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _callSuper(this, ForceGraph3, [].concat(args));
      _this.__kapsuleInstance = _construct(kapsule, [].concat(_toConsumableArray4(initKapsuleWithSelf ? [_this] : []), args));
      return _this;
    }
    _inherits(ForceGraph3, _baseClass);
    return _createClass3(ForceGraph3);
  })(baseClass);
  Object.keys(kapsule()).forEach(function(m3) {
    return ForceGraph2.prototype[m3] = function() {
      var _this$__kapsuleInstan;
      var returnVal = (_this$__kapsuleInstan = this.__kapsuleInstance)[m3].apply(_this$__kapsuleInstan, arguments);
      return returnVal === this.__kapsuleInstance ? this : returnVal;
    };
  });
  return ForceGraph2;
}
var three = window.THREE ? window.THREE : {
  Group
};
var threeForcegraph = fromKapsule(ForceGraph, three.Group, true);

// node_modules/aframe-forcegraph-component/dist/aframe-forcegraph-component.mjs
if (typeof AFRAME === "undefined") {
  throw new Error("Component attempted to register before AFRAME was available.");
}
var parseJson = function parseJson2(prop) {
  return typeof prop === "string" ? JSON.parse(prop) : prop;
};
var parseFn = function parseFn2(prop) {
  if (typeof prop === "function") return prop;
  var geval = eval;
  try {
    var evalled = geval("(" + prop + ")");
    return evalled;
  } catch (e3) {
  }
  return null;
};
var parseAccessor = function parseAccessor2(prop) {
  if (!isNaN(parseFloat(prop))) {
    return parseFloat(prop);
  }
  if (parseFn(prop)) {
    return parseFn(prop);
  }
  return prop;
};
if (!AFRAME.components.hasOwnProperty("forcegraph")) {
  AFRAME.registerComponent("forcegraph", {
    schema: {
      jsonUrl: {
        type: "string",
        "default": ""
      },
      nodes: {
        parse: parseJson,
        "default": []
      },
      links: {
        parse: parseJson,
        "default": []
      },
      numDimensions: {
        type: "number",
        "default": 3
      },
      dagMode: {
        type: "string",
        "default": ""
      },
      dagLevelDistance: {
        type: "number",
        "default": 0
      },
      dagNodeFilter: {
        parse: parseFn,
        "default": function _default25() {
          return true;
        }
      },
      onDagError: {
        parse: parseFn,
        "default": void 0
      },
      nodeRelSize: {
        type: "number",
        "default": 4
      },
      // volume per val unit
      nodeId: {
        type: "string",
        "default": "id"
      },
      nodeVal: {
        parse: parseAccessor,
        "default": "val"
      },
      nodeResolution: {
        type: "number",
        "default": 8
      },
      // how many slice segments in the sphere's circumference
      nodeVisibility: {
        parse: parseAccessor,
        "default": true
      },
      nodeColor: {
        parse: parseAccessor,
        "default": "color"
      },
      nodeAutoColorBy: {
        parse: parseAccessor,
        "default": ""
      },
      // color nodes with the same field equally
      nodeOpacity: {
        type: "number",
        "default": 0.75
      },
      nodeThreeObject: {
        parse: parseAccessor,
        "default": null
      },
      nodeThreeObjectExtend: {
        parse: parseAccessor,
        "default": false
      },
      linkSource: {
        type: "string",
        "default": "source"
      },
      linkTarget: {
        type: "string",
        "default": "target"
      },
      linkVisibility: {
        parse: parseAccessor,
        "default": true
      },
      linkColor: {
        parse: parseAccessor,
        "default": "color"
      },
      linkAutoColorBy: {
        parse: parseAccessor,
        "default": ""
      },
      // color links with the same field equally
      linkOpacity: {
        type: "number",
        "default": 0.2
      },
      linkWidth: {
        parse: parseAccessor,
        "default": 0
      },
      linkResolution: {
        type: "number",
        "default": 6
      },
      // how many radial segments in each line cylinder's geometry
      linkCurvature: {
        parse: parseAccessor,
        "default": 0
      },
      linkCurveRotation: {
        parse: parseAccessor,
        "default": 0
      },
      linkMaterial: {
        parse: parseAccessor,
        "default": null
      },
      linkThreeObject: {
        parse: parseAccessor,
        "default": null
      },
      linkThreeObjectExtend: {
        parse: parseAccessor,
        "default": false
      },
      linkPositionUpdate: {
        parse: parseFn,
        "default": null
      },
      linkDirectionalArrowLength: {
        parse: parseAccessor,
        "default": 0
      },
      linkDirectionalArrowColor: {
        parse: parseAccessor,
        "default": null
      },
      linkDirectionalArrowRelPos: {
        parse: parseAccessor,
        "default": 0.5
      },
      // value between 0<>1 indicating the relative pos along the (exposed) line
      linkDirectionalArrowResolution: {
        type: "number",
        "default": 8
      },
      // how many slice segments in the arrow's conic circumference
      linkDirectionalParticles: {
        parse: parseAccessor,
        "default": 0
      },
      // animate photons travelling in the link direction
      linkDirectionalParticleSpeed: {
        parse: parseAccessor,
        "default": 0.01
      },
      // in link length ratio per frame
      linkDirectionalParticleOffset: {
        parse: parseAccessor,
        "default": 0
      },
      linkDirectionalParticleWidth: {
        parse: parseAccessor,
        "default": 0.5
      },
      linkDirectionalParticleColor: {
        parse: parseAccessor,
        "default": null
      },
      linkDirectionalParticleResolution: {
        type: "number",
        "default": 4
      },
      // how many slice segments in the particle sphere's circumference
      linkDirectionalParticleThreeObject: {
        parse: parseAccessor,
        "default": null
      },
      onNodeHover: {
        parse: parseFn,
        "default": function _default25() {
        }
      },
      onLinkHover: {
        parse: parseFn,
        "default": function _default25() {
        }
      },
      onNodeClick: {
        parse: parseFn,
        "default": function _default25() {
        }
      },
      onLinkClick: {
        parse: parseFn,
        "default": function _default25() {
        }
      },
      forceEngine: {
        type: "string",
        "default": "d3"
      },
      // 'd3' or 'ngraph'
      d3AlphaMin: {
        type: "number",
        "default": 0
      },
      d3AlphaDecay: {
        type: "number",
        "default": 0.0228
      },
      d3VelocityDecay: {
        type: "number",
        "default": 0.4
      },
      ngraphPhysics: {
        parse: parseJson,
        "default": null
      },
      warmupTicks: {
        type: "int",
        "default": 0
      },
      // how many times to tick the force engine at init before starting to render
      cooldownTicks: {
        type: "int",
        "default": 1e18
      },
      // Simulate infinity (int parser doesn't accept Infinity object)
      cooldownTime: {
        type: "int",
        "default": 15e3
      },
      // ms
      onEngineTick: {
        parse: parseFn,
        "default": function _default25() {
        }
      },
      onEngineStop: {
        parse: parseFn,
        "default": function _default25() {
        }
      }
    },
    // Bind component methods
    getGraphBbox: function getGraphBbox3(nodeFilterFn) {
      if (!this.forceGraph) {
        this.forceGraph = new threeForcegraph();
      }
      return this.forceGraph.getGraphBbox(nodeFilterFn);
    },
    emitParticle: function emitParticle3() {
      if (!this.forceGraph) {
        this.forceGraph = new threeForcegraph();
      }
      var forceGraph2 = this.forceGraph;
      var returnVal = forceGraph2.emitParticle.apply(forceGraph2, arguments);
      return returnVal === forceGraph2 ? this : returnVal;
    },
    d3Force: function d3Force3() {
      if (!this.forceGraph) {
        this.forceGraph = new threeForcegraph();
      }
      var forceGraph2 = this.forceGraph;
      var returnVal = forceGraph2.d3Force.apply(forceGraph2, arguments);
      return returnVal === forceGraph2 ? this : returnVal;
    },
    d3ReheatSimulation: function d3ReheatSimulation3() {
      this.forceGraph && this.forceGraph.d3ReheatSimulation();
      return this;
    },
    refresh: function refresh2() {
      this.forceGraph && this.forceGraph.refresh();
      return this;
    },
    init: function init10() {
      var _this = this;
      var state = this.state = {};
      state.infoEl = document.createElement("a-text");
      state.infoEl.setAttribute("position", "0 -0.1 -1");
      state.infoEl.setAttribute("width", 1);
      state.infoEl.setAttribute("align", "center");
      state.infoEl.setAttribute("color", "lavender");
      var cameraEl = document.querySelector("a-entity[camera], a-camera");
      cameraEl.appendChild(state.infoEl);
      state.cameraObj = cameraEl.object3D.children.filter(function(child) {
        return child.type === "PerspectiveCamera";
      })[0];
      this.el.sceneEl.addEventListener("camera-set-active", function(evt) {
        state.cameraObj = evt.detail.cameraEl.components.camera.camera;
      });
      if (!this.forceGraph) this.forceGraph = new threeForcegraph();
      this.forceGraph.onFinishUpdate(function() {
        return _this.el.setObject3D("forcegraphGroup", _this.forceGraph);
      }).onLoading(function() {
        return state.infoEl.setAttribute("value", "Loading...");
      }).onFinishLoading(function() {
        return state.infoEl.setAttribute("value", "");
      });
      this.el.addEventListener("raycaster-intersected", function(ev) {
        return state.hoverDetail = ev.detail;
      });
      this.el.addEventListener("raycaster-intersected-cleared", function(ev) {
        return state.hoverDetail = ev.detail;
      });
      this.el.addEventListener("click", function() {
        return state.hoverObj && _this.data["on" + (state.hoverObj.__graphObjType === "node" ? "Node" : "Link") + "Click"](state.hoverObj.__data);
      });
    },
    remove: function remove4() {
      this.state.infoEl.remove();
      this.el.removeObject3D("forcegraphGroup");
    },
    update: function update9(oldData) {
      var comp = this;
      var elData = this.data;
      var diff = AFRAME.utils.diff(elData, oldData);
      var fgProps = ["jsonUrl", "numDimensions", "dagMode", "dagLevelDistance", "dagNodeFilter", "onDagError", "nodeRelSize", "nodeId", "nodeVal", "nodeResolution", "nodeVisibility", "nodeColor", "nodeAutoColorBy", "nodeOpacity", "nodeThreeObject", "nodeThreeObjectExtend", "linkSource", "linkTarget", "linkVisibility", "linkColor", "linkAutoColorBy", "linkOpacity", "linkWidth", "linkResolution", "linkCurvature", "linkCurveRotation", "linkMaterial", "linkThreeObject", "linkThreeObjectExtend", "linkPositionUpdate", "linkDirectionalArrowLength", "linkDirectionalArrowColor", "linkDirectionalArrowRelPos", "linkDirectionalArrowResolution", "linkDirectionalParticles", "linkDirectionalParticleSpeed", "linkDirectionalParticleOffset", "linkDirectionalParticleWidth", "linkDirectionalParticleColor", "linkDirectionalParticleResolution", "linkDirectionalParticleThreeObject", "forceEngine", "d3AlphaMin", "d3AphaDecay", "d3VelocityDecay", "ngraphPhysics", "warmupTicks", "cooldownTicks", "cooldownTime", "onEngineTick", "onEngineStop"];
      fgProps.filter(function(p3) {
        return p3 in diff;
      }).forEach(function(p3) {
        comp.forceGraph[p3](elData[p3] !== "" ? elData[p3] : null);
      });
      if ("nodes" in diff || "links" in diff) {
        comp.forceGraph.graphData({
          nodes: elData.nodes,
          links: elData.links
        });
      }
    },
    tick: function tick2(t5, td2) {
      var state = this.state;
      var props = this.data;
      var intersection3 = state.hoverDetail ? state.hoverDetail.getIntersection ? state.hoverDetail.getIntersection(this.el) : state.hoverDetail.intersection || void 0 : void 0;
      var topObject = intersection3 ? intersection3.object : void 0;
      while (topObject && !topObject.hasOwnProperty("__graphObjType")) topObject = topObject.parent;
      if (topObject !== state.hoverObj) {
        var prevObjType = state.hoverObj ? state.hoverObj.__graphObjType : null;
        var prevObjData = state.hoverObj ? state.hoverObj.__data : null;
        var objType = topObject ? topObject.__graphObjType : null;
        var objData = topObject ? topObject.__data : null;
        if (prevObjType && prevObjType !== objType) {
          props["on" + (prevObjType === "node" ? "Node" : "Link") + "Hover"](null, prevObjData);
        }
        if (objType) {
          props["on" + (objType === "node" ? "Node" : "Link") + "Hover"](objData, prevObjType === objType ? prevObjData : null);
        }
        state.hoverObj = topObject;
      }
      this.forceGraph.tickFrame();
    }
  });
}

// node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e3 = 1; e3 < arguments.length; e3++) {
      var t5 = arguments[e3];
      for (var r2 in t5) ({}).hasOwnProperty.call(t5, r2) && (n2[r2] = t5[r2]);
    }
    return n2;
  }, _extends.apply(null, arguments);
}

// node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized2(e3) {
  if (void 0 === e3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e3;
}

// node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf2(t5, e3) {
  return _setPrototypeOf2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t6, e4) {
    return t6.__proto__ = e4, t6;
  }, _setPrototypeOf2(t5, e3);
}

// node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
function _inheritsLoose(t5, o2) {
  t5.prototype = Object.create(o2.prototype), t5.prototype.constructor = t5, _setPrototypeOf2(t5, o2);
}

// node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
function _getPrototypeOf2(t5) {
  return _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t6) {
    return t6.__proto__ || Object.getPrototypeOf(t6);
  }, _getPrototypeOf2(t5);
}

// node_modules/@babel/runtime/helpers/esm/isNativeFunction.js
function _isNativeFunction(t5) {
  try {
    return -1 !== Function.toString.call(t5).indexOf("[native code]");
  } catch (n2) {
    return "function" == typeof t5;
  }
}

// node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js
function _isNativeReflectConstruct2() {
  try {
    var t5 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t6) {
  }
  return (_isNativeReflectConstruct2 = function _isNativeReflectConstruct4() {
    return !!t5;
  })();
}

// node_modules/@babel/runtime/helpers/esm/construct.js
function _construct2(t5, e3, r2) {
  if (_isNativeReflectConstruct2()) return Reflect.construct.apply(null, arguments);
  var o2 = [null];
  o2.push.apply(o2, e3);
  var p3 = new (t5.bind.apply(t5, o2))();
  return r2 && _setPrototypeOf2(p3, r2.prototype), p3;
}

// node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js
function _wrapNativeSuper(t5) {
  var r2 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
  return _wrapNativeSuper = function _wrapNativeSuper2(t6) {
    if (null === t6 || !_isNativeFunction(t6)) return t6;
    if ("function" != typeof t6) throw new TypeError("Super expression must either be null or a function");
    if (void 0 !== r2) {
      if (r2.has(t6)) return r2.get(t6);
      r2.set(t6, Wrapper);
    }
    function Wrapper() {
      return _construct2(t6, arguments, _getPrototypeOf2(this).constructor);
    }
    return Wrapper.prototype = Object.create(t6.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    }), _setPrototypeOf2(Wrapper, t6);
  }, _wrapNativeSuper(t5);
}

// node_modules/polished/dist/polished.esm.js
var ERRORS = {
  "1": "Passed invalid arguments to hsl, please pass multiple numbers e.g. hsl(360, 0.75, 0.4) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75 }).\n\n",
  "2": "Passed invalid arguments to hsla, please pass multiple numbers e.g. hsla(360, 0.75, 0.4, 0.7) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75, alpha: 0.7 }).\n\n",
  "3": "Passed an incorrect argument to a color function, please pass a string representation of a color.\n\n",
  "4": "Couldn't generate valid rgb string from %s, it returned %s.\n\n",
  "5": "Couldn't parse the color string. Please provide the color as a string in hex, rgb, rgba, hsl or hsla notation.\n\n",
  "6": "Passed invalid arguments to rgb, please pass multiple numbers e.g. rgb(255, 205, 100) or an object e.g. rgb({ red: 255, green: 205, blue: 100 }).\n\n",
  "7": "Passed invalid arguments to rgba, please pass multiple numbers e.g. rgb(255, 205, 100, 0.75) or an object e.g. rgb({ red: 255, green: 205, blue: 100, alpha: 0.75 }).\n\n",
  "8": "Passed invalid argument to toColorString, please pass a RgbColor, RgbaColor, HslColor or HslaColor object.\n\n",
  "9": "Please provide a number of steps to the modularScale helper.\n\n",
  "10": "Please pass a number or one of the predefined scales to the modularScale helper as the ratio.\n\n",
  "11": 'Invalid value passed as base to modularScale, expected number or em string but got "%s"\n\n',
  "12": 'Expected a string ending in "px" or a number passed as the first argument to %s(), got "%s" instead.\n\n',
  "13": 'Expected a string ending in "px" or a number passed as the second argument to %s(), got "%s" instead.\n\n',
  "14": 'Passed invalid pixel value ("%s") to %s(), please pass a value like "12px" or 12.\n\n',
  "15": 'Passed invalid base value ("%s") to %s(), please pass a value like "12px" or 12.\n\n',
  "16": "You must provide a template to this method.\n\n",
  "17": "You passed an unsupported selector state to this method.\n\n",
  "18": "minScreen and maxScreen must be provided as stringified numbers with the same units.\n\n",
  "19": "fromSize and toSize must be provided as stringified numbers with the same units.\n\n",
  "20": "expects either an array of objects or a single object with the properties prop, fromSize, and toSize.\n\n",
  "21": "expects the objects in the first argument array to have the properties `prop`, `fromSize`, and `toSize`.\n\n",
  "22": "expects the first argument object to have the properties `prop`, `fromSize`, and `toSize`.\n\n",
  "23": "fontFace expects a name of a font-family.\n\n",
  "24": "fontFace expects either the path to the font file(s) or a name of a local copy.\n\n",
  "25": "fontFace expects localFonts to be an array.\n\n",
  "26": "fontFace expects fileFormats to be an array.\n\n",
  "27": "radialGradient requries at least 2 color-stops to properly render.\n\n",
  "28": "Please supply a filename to retinaImage() as the first argument.\n\n",
  "29": "Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.\n\n",
  "30": "Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\n\n",
  "31": "The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation\n\n",
  "32": "To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])\nTo pass a single animation please supply them in simple values, e.g. animation('rotate', '2s')\n\n",
  "33": "The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation\n\n",
  "34": "borderRadius expects a radius value as a string or number as the second argument.\n\n",
  "35": 'borderRadius expects one of "top", "bottom", "left" or "right" as the first argument.\n\n',
  "36": "Property must be a string value.\n\n",
  "37": "Syntax Error at %s.\n\n",
  "38": "Formula contains a function that needs parentheses at %s.\n\n",
  "39": "Formula is missing closing parenthesis at %s.\n\n",
  "40": "Formula has too many closing parentheses at %s.\n\n",
  "41": "All values in a formula must have the same unit or be unitless.\n\n",
  "42": "Please provide a number of steps to the modularScale helper.\n\n",
  "43": "Please pass a number or one of the predefined scales to the modularScale helper as the ratio.\n\n",
  "44": "Invalid value passed as base to modularScale, expected number or em/rem string but got %s.\n\n",
  "45": "Passed invalid argument to hslToColorString, please pass a HslColor or HslaColor object.\n\n",
  "46": "Passed invalid argument to rgbToColorString, please pass a RgbColor or RgbaColor object.\n\n",
  "47": "minScreen and maxScreen must be provided as stringified numbers with the same units.\n\n",
  "48": "fromSize and toSize must be provided as stringified numbers with the same units.\n\n",
  "49": "Expects either an array of objects or a single object with the properties prop, fromSize, and toSize.\n\n",
  "50": "Expects the objects in the first argument array to have the properties prop, fromSize, and toSize.\n\n",
  "51": "Expects the first argument object to have the properties prop, fromSize, and toSize.\n\n",
  "52": "fontFace expects either the path to the font file(s) or a name of a local copy.\n\n",
  "53": "fontFace expects localFonts to be an array.\n\n",
  "54": "fontFace expects fileFormats to be an array.\n\n",
  "55": "fontFace expects a name of a font-family.\n\n",
  "56": "linearGradient requries at least 2 color-stops to properly render.\n\n",
  "57": "radialGradient requries at least 2 color-stops to properly render.\n\n",
  "58": "Please supply a filename to retinaImage() as the first argument.\n\n",
  "59": "Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.\n\n",
  "60": "Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\n\n",
  "61": "Property must be a string value.\n\n",
  "62": "borderRadius expects a radius value as a string or number as the second argument.\n\n",
  "63": 'borderRadius expects one of "top", "bottom", "left" or "right" as the first argument.\n\n',
  "64": "The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation.\n\n",
  "65": "To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])\\nTo pass a single animation please supply them in simple values, e.g. animation('rotate', '2s').\n\n",
  "66": "The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation.\n\n",
  "67": "You must provide a template to this method.\n\n",
  "68": "You passed an unsupported selector state to this method.\n\n",
  "69": 'Expected a string ending in "px" or a number passed as the first argument to %s(), got %s instead.\n\n',
  "70": 'Expected a string ending in "px" or a number passed as the second argument to %s(), got %s instead.\n\n',
  "71": 'Passed invalid pixel value %s to %s(), please pass a value like "12px" or 12.\n\n',
  "72": 'Passed invalid base value %s to %s(), please pass a value like "12px" or 12.\n\n',
  "73": "Please provide a valid CSS variable.\n\n",
  "74": "CSS variable not found and no default was provided.\n\n",
  "75": "important requires a valid style object, got a %s instead.\n\n",
  "76": "fromSize and toSize must be provided as stringified numbers with the same units as minScreen and maxScreen.\n\n",
  "77": 'remToPx expects a value in "rem" but you provided it in "%s".\n\n',
  "78": 'base must be set in "px" or "%" but you set it in "%s".\n'
};
function format2() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  var a3 = args[0];
  var b = [];
  var c5;
  for (c5 = 1; c5 < args.length; c5 += 1) {
    b.push(args[c5]);
  }
  b.forEach(function(d3) {
    a3 = a3.replace(/%[a-z]/, d3);
  });
  return a3;
}
var PolishedError = (function(_Error) {
  _inheritsLoose(PolishedError2, _Error);
  function PolishedError2(code2) {
    var _this;
    if (false) {
      _this = _Error.call(this, "An error occurred. See https://github.com/styled-components/polished/blob/main/src/internalHelpers/errors.md#" + code2 + " for more information.") || this;
    } else {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      _this = _Error.call(this, format2.apply(void 0, [ERRORS[code2]].concat(args))) || this;
    }
    return _assertThisInitialized2(_this);
  }
  return PolishedError2;
})(_wrapNativeSuper(Error));
function endsWith(string2, suffix) {
  return string2.substr(-suffix.length) === suffix;
}
var cssRegex$1 = /^([+-]?(?:\d+|\d*\.\d+))([a-z]*|%)$/;
function stripUnit(value) {
  if (typeof value !== "string") return value;
  var matchedValue = value.match(cssRegex$1);
  return matchedValue ? parseFloat(value) : value;
}
var pxtoFactory = function pxtoFactory2(to) {
  return function(pxval, base) {
    if (base === void 0) {
      base = "16px";
    }
    var newPxval = pxval;
    var newBase = base;
    if (typeof pxval === "string") {
      if (!endsWith(pxval, "px")) {
        throw new PolishedError(69, to, pxval);
      }
      newPxval = stripUnit(pxval);
    }
    if (typeof base === "string") {
      if (!endsWith(base, "px")) {
        throw new PolishedError(70, to, base);
      }
      newBase = stripUnit(base);
    }
    if (typeof newPxval === "string") {
      throw new PolishedError(71, pxval, to);
    }
    if (typeof newBase === "string") {
      throw new PolishedError(72, base, to);
    }
    return "" + newPxval / newBase + to;
  };
};
var pixelsto = pxtoFactory;
var em = pixelsto("em");
var rem = pixelsto("rem");
function colorToInt(color3) {
  return Math.round(color3 * 255);
}
function convertToInt(red, green, blue) {
  return colorToInt(red) + "," + colorToInt(green) + "," + colorToInt(blue);
}
function hslToRgb2(hue3, saturation2, lightness, convert2) {
  if (convert2 === void 0) {
    convert2 = convertToInt;
  }
  if (saturation2 === 0) {
    return convert2(lightness, lightness, lightness);
  }
  var huePrime = (hue3 % 360 + 360) % 360 / 60;
  var chroma = (1 - Math.abs(2 * lightness - 1)) * saturation2;
  var secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
  var red = 0;
  var green = 0;
  var blue = 0;
  if (huePrime >= 0 && huePrime < 1) {
    red = chroma;
    green = secondComponent;
  } else if (huePrime >= 1 && huePrime < 2) {
    red = secondComponent;
    green = chroma;
  } else if (huePrime >= 2 && huePrime < 3) {
    green = chroma;
    blue = secondComponent;
  } else if (huePrime >= 3 && huePrime < 4) {
    green = secondComponent;
    blue = chroma;
  } else if (huePrime >= 4 && huePrime < 5) {
    red = secondComponent;
    blue = chroma;
  } else if (huePrime >= 5 && huePrime < 6) {
    red = chroma;
    blue = secondComponent;
  }
  var lightnessModification = lightness - chroma / 2;
  var finalRed = red + lightnessModification;
  var finalGreen = green + lightnessModification;
  var finalBlue = blue + lightnessModification;
  return convert2(finalRed, finalGreen, finalBlue);
}
var namedColorMap = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "00ffff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "0000ff",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "00ffff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "ff00ff",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "639",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
};
function nameToHex(color3) {
  if (typeof color3 !== "string") return color3;
  var normalizedColorName = color3.toLowerCase();
  return namedColorMap[normalizedColorName] ? "#" + namedColorMap[normalizedColorName] : color3;
}
var hexRegex = /^#[a-fA-F0-9]{6}$/;
var hexRgbaRegex = /^#[a-fA-F0-9]{8}$/;
var reducedHexRegex = /^#[a-fA-F0-9]{3}$/;
var reducedRgbaHexRegex = /^#[a-fA-F0-9]{4}$/;
var rgbRegex = /^rgb\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*\)$/i;
var rgbaRegex = /^rgb(?:a)?\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i;
var hslRegex = /^hsl\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*\)$/i;
var hslaRegex = /^hsl(?:a)?\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i;
function parseToRgb(color3) {
  if (typeof color3 !== "string") {
    throw new PolishedError(3);
  }
  var normalizedColor = nameToHex(color3);
  if (normalizedColor.match(hexRegex)) {
    return {
      red: parseInt("" + normalizedColor[1] + normalizedColor[2], 16),
      green: parseInt("" + normalizedColor[3] + normalizedColor[4], 16),
      blue: parseInt("" + normalizedColor[5] + normalizedColor[6], 16)
    };
  }
  if (normalizedColor.match(hexRgbaRegex)) {
    var alpha = parseFloat((parseInt("" + normalizedColor[7] + normalizedColor[8], 16) / 255).toFixed(2));
    return {
      red: parseInt("" + normalizedColor[1] + normalizedColor[2], 16),
      green: parseInt("" + normalizedColor[3] + normalizedColor[4], 16),
      blue: parseInt("" + normalizedColor[5] + normalizedColor[6], 16),
      alpha
    };
  }
  if (normalizedColor.match(reducedHexRegex)) {
    return {
      red: parseInt("" + normalizedColor[1] + normalizedColor[1], 16),
      green: parseInt("" + normalizedColor[2] + normalizedColor[2], 16),
      blue: parseInt("" + normalizedColor[3] + normalizedColor[3], 16)
    };
  }
  if (normalizedColor.match(reducedRgbaHexRegex)) {
    var _alpha = parseFloat((parseInt("" + normalizedColor[4] + normalizedColor[4], 16) / 255).toFixed(2));
    return {
      red: parseInt("" + normalizedColor[1] + normalizedColor[1], 16),
      green: parseInt("" + normalizedColor[2] + normalizedColor[2], 16),
      blue: parseInt("" + normalizedColor[3] + normalizedColor[3], 16),
      alpha: _alpha
    };
  }
  var rgbMatched = rgbRegex.exec(normalizedColor);
  if (rgbMatched) {
    return {
      red: parseInt("" + rgbMatched[1], 10),
      green: parseInt("" + rgbMatched[2], 10),
      blue: parseInt("" + rgbMatched[3], 10)
    };
  }
  var rgbaMatched = rgbaRegex.exec(normalizedColor.substring(0, 50));
  if (rgbaMatched) {
    return {
      red: parseInt("" + rgbaMatched[1], 10),
      green: parseInt("" + rgbaMatched[2], 10),
      blue: parseInt("" + rgbaMatched[3], 10),
      alpha: parseFloat("" + rgbaMatched[4]) > 1 ? parseFloat("" + rgbaMatched[4]) / 100 : parseFloat("" + rgbaMatched[4])
    };
  }
  var hslMatched = hslRegex.exec(normalizedColor);
  if (hslMatched) {
    var hue3 = parseInt("" + hslMatched[1], 10);
    var saturation2 = parseInt("" + hslMatched[2], 10) / 100;
    var lightness = parseInt("" + hslMatched[3], 10) / 100;
    var rgbColorString = "rgb(" + hslToRgb2(hue3, saturation2, lightness) + ")";
    var hslRgbMatched = rgbRegex.exec(rgbColorString);
    if (!hslRgbMatched) {
      throw new PolishedError(4, normalizedColor, rgbColorString);
    }
    return {
      red: parseInt("" + hslRgbMatched[1], 10),
      green: parseInt("" + hslRgbMatched[2], 10),
      blue: parseInt("" + hslRgbMatched[3], 10)
    };
  }
  var hslaMatched = hslaRegex.exec(normalizedColor.substring(0, 50));
  if (hslaMatched) {
    var _hue = parseInt("" + hslaMatched[1], 10);
    var _saturation = parseInt("" + hslaMatched[2], 10) / 100;
    var _lightness = parseInt("" + hslaMatched[3], 10) / 100;
    var _rgbColorString = "rgb(" + hslToRgb2(_hue, _saturation, _lightness) + ")";
    var _hslRgbMatched = rgbRegex.exec(_rgbColorString);
    if (!_hslRgbMatched) {
      throw new PolishedError(4, normalizedColor, _rgbColorString);
    }
    return {
      red: parseInt("" + _hslRgbMatched[1], 10),
      green: parseInt("" + _hslRgbMatched[2], 10),
      blue: parseInt("" + _hslRgbMatched[3], 10),
      alpha: parseFloat("" + hslaMatched[4]) > 1 ? parseFloat("" + hslaMatched[4]) / 100 : parseFloat("" + hslaMatched[4])
    };
  }
  throw new PolishedError(5);
}
function rgbToHsl2(color3) {
  var red = color3.red / 255;
  var green = color3.green / 255;
  var blue = color3.blue / 255;
  var max6 = Math.max(red, green, blue);
  var min5 = Math.min(red, green, blue);
  var lightness = (max6 + min5) / 2;
  if (max6 === min5) {
    if (color3.alpha !== void 0) {
      return {
        hue: 0,
        saturation: 0,
        lightness,
        alpha: color3.alpha
      };
    } else {
      return {
        hue: 0,
        saturation: 0,
        lightness
      };
    }
  }
  var hue3;
  var delta = max6 - min5;
  var saturation2 = lightness > 0.5 ? delta / (2 - max6 - min5) : delta / (max6 + min5);
  switch (max6) {
    case red:
      hue3 = (green - blue) / delta + (green < blue ? 6 : 0);
      break;
    case green:
      hue3 = (blue - red) / delta + 2;
      break;
    default:
      hue3 = (red - green) / delta + 4;
      break;
  }
  hue3 *= 60;
  if (color3.alpha !== void 0) {
    return {
      hue: hue3,
      saturation: saturation2,
      lightness,
      alpha: color3.alpha
    };
  }
  return {
    hue: hue3,
    saturation: saturation2,
    lightness
  };
}
function parseToHsl(color3) {
  return rgbToHsl2(parseToRgb(color3));
}
var reduceHexValue = function reduceHexValue2(value) {
  if (value.length === 7 && value[1] === value[2] && value[3] === value[4] && value[5] === value[6]) {
    return "#" + value[1] + value[3] + value[5];
  }
  return value;
};
var reduceHexValue$1 = reduceHexValue;
function numberToHex(value) {
  var hex2 = value.toString(16);
  return hex2.length === 1 ? "0" + hex2 : hex2;
}
function colorToHex(color3) {
  return numberToHex(Math.round(color3 * 255));
}
function convertToHex(red, green, blue) {
  return reduceHexValue$1("#" + colorToHex(red) + colorToHex(green) + colorToHex(blue));
}
function hslToHex(hue3, saturation2, lightness) {
  return hslToRgb2(hue3, saturation2, lightness, convertToHex);
}
function hsl3(value, saturation2, lightness) {
  if (typeof value === "number" && typeof saturation2 === "number" && typeof lightness === "number") {
    return hslToHex(value, saturation2, lightness);
  } else if (typeof value === "object" && saturation2 === void 0 && lightness === void 0) {
    return hslToHex(value.hue, value.saturation, value.lightness);
  }
  throw new PolishedError(1);
}
function hsla2(value, saturation2, lightness, alpha) {
  if (typeof value === "number" && typeof saturation2 === "number" && typeof lightness === "number" && typeof alpha === "number") {
    return alpha >= 1 ? hslToHex(value, saturation2, lightness) : "rgba(" + hslToRgb2(value, saturation2, lightness) + "," + alpha + ")";
  } else if (typeof value === "object" && saturation2 === void 0 && lightness === void 0 && alpha === void 0) {
    return value.alpha >= 1 ? hslToHex(value.hue, value.saturation, value.lightness) : "rgba(" + hslToRgb2(value.hue, value.saturation, value.lightness) + "," + value.alpha + ")";
  }
  throw new PolishedError(2);
}
function rgb2(value, green, blue) {
  if (typeof value === "number" && typeof green === "number" && typeof blue === "number") {
    return reduceHexValue$1("#" + numberToHex(value) + numberToHex(green) + numberToHex(blue));
  } else if (typeof value === "object" && green === void 0 && blue === void 0) {
    return reduceHexValue$1("#" + numberToHex(value.red) + numberToHex(value.green) + numberToHex(value.blue));
  }
  throw new PolishedError(6);
}
function rgba2(firstValue, secondValue, thirdValue, fourthValue) {
  if (typeof firstValue === "string" && typeof secondValue === "number") {
    var rgbValue = parseToRgb(firstValue);
    return "rgba(" + rgbValue.red + "," + rgbValue.green + "," + rgbValue.blue + "," + secondValue + ")";
  } else if (typeof firstValue === "number" && typeof secondValue === "number" && typeof thirdValue === "number" && typeof fourthValue === "number") {
    return fourthValue >= 1 ? rgb2(firstValue, secondValue, thirdValue) : "rgba(" + firstValue + "," + secondValue + "," + thirdValue + "," + fourthValue + ")";
  } else if (typeof firstValue === "object" && secondValue === void 0 && thirdValue === void 0 && fourthValue === void 0) {
    return firstValue.alpha >= 1 ? rgb2(firstValue.red, firstValue.green, firstValue.blue) : "rgba(" + firstValue.red + "," + firstValue.green + "," + firstValue.blue + "," + firstValue.alpha + ")";
  }
  throw new PolishedError(7);
}
var isRgb = function isRgb2(color3) {
  return typeof color3.red === "number" && typeof color3.green === "number" && typeof color3.blue === "number" && (typeof color3.alpha !== "number" || typeof color3.alpha === "undefined");
};
var isRgba = function isRgba2(color3) {
  return typeof color3.red === "number" && typeof color3.green === "number" && typeof color3.blue === "number" && typeof color3.alpha === "number";
};
var isHsl = function isHsl2(color3) {
  return typeof color3.hue === "number" && typeof color3.saturation === "number" && typeof color3.lightness === "number" && (typeof color3.alpha !== "number" || typeof color3.alpha === "undefined");
};
var isHsla = function isHsla2(color3) {
  return typeof color3.hue === "number" && typeof color3.saturation === "number" && typeof color3.lightness === "number" && typeof color3.alpha === "number";
};
function toColorString(color3) {
  if (typeof color3 !== "object") throw new PolishedError(8);
  if (isRgba(color3)) return rgba2(color3);
  if (isRgb(color3)) return rgb2(color3);
  if (isHsla(color3)) return hsla2(color3);
  if (isHsl(color3)) return hsl3(color3);
  throw new PolishedError(8);
}
function curried(f3, length2, acc) {
  return function fn() {
    var combined = acc.concat(Array.prototype.slice.call(arguments));
    return combined.length >= length2 ? f3.apply(this, combined) : curried(f3, length2, combined);
  };
}
function curry(f3) {
  return curried(f3, f3.length, []);
}
function adjustHue(degree, color3) {
  if (color3 === "transparent") return color3;
  var hslColor = parseToHsl(color3);
  return toColorString(_extends({}, hslColor, {
    hue: hslColor.hue + parseFloat(degree)
  }));
}
var curriedAdjustHue = curry(adjustHue);
function guard(lowerBoundary, upperBoundary, value) {
  return Math.max(lowerBoundary, Math.min(upperBoundary, value));
}
function darken2(amount, color3) {
  if (color3 === "transparent") return color3;
  var hslColor = parseToHsl(color3);
  return toColorString(_extends({}, hslColor, {
    lightness: guard(0, 1, hslColor.lightness - parseFloat(amount))
  }));
}
var curriedDarken = curry(darken2);
function desaturate2(amount, color3) {
  if (color3 === "transparent") return color3;
  var hslColor = parseToHsl(color3);
  return toColorString(_extends({}, hslColor, {
    saturation: guard(0, 1, hslColor.saturation - parseFloat(amount))
  }));
}
var curriedDesaturate = curry(desaturate2);
function lighten2(amount, color3) {
  if (color3 === "transparent") return color3;
  var hslColor = parseToHsl(color3);
  return toColorString(_extends({}, hslColor, {
    lightness: guard(0, 1, hslColor.lightness + parseFloat(amount))
  }));
}
var curriedLighten = curry(lighten2);
function mix(weight, color3, otherColor) {
  if (color3 === "transparent") return otherColor;
  if (otherColor === "transparent") return color3;
  if (weight === 0) return otherColor;
  var parsedColor1 = parseToRgb(color3);
  var color1 = _extends({}, parsedColor1, {
    alpha: typeof parsedColor1.alpha === "number" ? parsedColor1.alpha : 1
  });
  var parsedColor2 = parseToRgb(otherColor);
  var color22 = _extends({}, parsedColor2, {
    alpha: typeof parsedColor2.alpha === "number" ? parsedColor2.alpha : 1
  });
  var alphaDelta = color1.alpha - color22.alpha;
  var x3 = parseFloat(weight) * 2 - 1;
  var y3 = x3 * alphaDelta === -1 ? x3 : x3 + alphaDelta;
  var z3 = 1 + x3 * alphaDelta;
  var weight1 = (y3 / z3 + 1) / 2;
  var weight2 = 1 - weight1;
  var mixedColor = {
    red: Math.floor(color1.red * weight1 + color22.red * weight2),
    green: Math.floor(color1.green * weight1 + color22.green * weight2),
    blue: Math.floor(color1.blue * weight1 + color22.blue * weight2),
    alpha: color1.alpha * parseFloat(weight) + color22.alpha * (1 - parseFloat(weight))
  };
  return rgba2(mixedColor);
}
var curriedMix = curry(mix);
var mix$1 = curriedMix;
function opacify(amount, color3) {
  if (color3 === "transparent") return color3;
  var parsedColor = parseToRgb(color3);
  var alpha = typeof parsedColor.alpha === "number" ? parsedColor.alpha : 1;
  var colorWithAlpha = _extends({}, parsedColor, {
    alpha: guard(0, 1, (alpha * 100 + parseFloat(amount) * 100) / 100)
  });
  return rgba2(colorWithAlpha);
}
var curriedOpacify = curry(opacify);
var curriedOpacify$1 = curriedOpacify;
function saturate2(amount, color3) {
  if (color3 === "transparent") return color3;
  var hslColor = parseToHsl(color3);
  return toColorString(_extends({}, hslColor, {
    saturation: guard(0, 1, hslColor.saturation + parseFloat(amount))
  }));
}
var curriedSaturate = curry(saturate2);
function setHue(hue3, color3) {
  if (color3 === "transparent") return color3;
  return toColorString(_extends({}, parseToHsl(color3), {
    hue: parseFloat(hue3)
  }));
}
var curriedSetHue = curry(setHue);
function setLightness(lightness, color3) {
  if (color3 === "transparent") return color3;
  return toColorString(_extends({}, parseToHsl(color3), {
    lightness: parseFloat(lightness)
  }));
}
var curriedSetLightness = curry(setLightness);
function setSaturation(saturation2, color3) {
  if (color3 === "transparent") return color3;
  return toColorString(_extends({}, parseToHsl(color3), {
    saturation: parseFloat(saturation2)
  }));
}
var curriedSetSaturation = curry(setSaturation);
function shade(percentage, color3) {
  if (color3 === "transparent") return color3;
  return mix$1(parseFloat(percentage), "rgb(0, 0, 0)", color3);
}
var curriedShade = curry(shade);
function tint(percentage, color3) {
  if (color3 === "transparent") return color3;
  return mix$1(parseFloat(percentage), "rgb(255, 255, 255)", color3);
}
var curriedTint = curry(tint);
function transparentize(amount, color3) {
  if (color3 === "transparent") return color3;
  var parsedColor = parseToRgb(color3);
  var alpha = typeof parsedColor.alpha === "number" ? parsedColor.alpha : 1;
  var colorWithAlpha = _extends({}, parsedColor, {
    alpha: guard(0, 1, +(alpha * 100 - parseFloat(amount) * 100).toFixed(2) / 100)
  });
  return rgba2(colorWithAlpha);
}
var curriedTransparentize = curry(transparentize);

// node_modules/3d-force-graph-vr/dist/3d-force-graph-vr.mjs
function styleInject(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;
  if (typeof document === "undefined") {
    return;
  }
  var head2 = document.head || document.getElementsByTagName("head")[0];
  var style = document.createElement("style");
  style.type = "text/css";
  if (insertAt === "top") {
    if (head2.firstChild) {
      head2.insertBefore(style, head2.firstChild);
    } else {
      head2.appendChild(style);
    }
  } else {
    head2.appendChild(style);
  }
  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}
var css_248z = ".graph-nav-info {\n  position: absolute;\n  bottom: 5px;\n  width: 100%;\n  text-align: center;\n  color: slategrey;\n  opacity: 0.7;\n  font-size: 10px;\n  font-family: Sans-serif;\n  z-index: 1000;\n}";
styleInject(css_248z);
function _arrayLikeToArray6(r2, a3) {
  (null == a3 || a3 > r2.length) && (a3 = r2.length);
  for (var e3 = 0, n2 = Array(a3); e3 < a3; e3++) n2[e3] = r2[e3];
  return n2;
}
function _arrayWithHoles6(r2) {
  if (Array.isArray(r2)) return r2;
}
function _arrayWithoutHoles5(r2) {
  if (Array.isArray(r2)) return _arrayLikeToArray6(r2);
}
function _defineProperty3(e3, r2, t5) {
  return (r2 = _toPropertyKey4(r2)) in e3 ? Object.defineProperty(e3, r2, {
    value: t5,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e3[r2] = t5, e3;
}
function _iterableToArray5(r2) {
  if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"]) return Array.from(r2);
}
function _iterableToArrayLimit6(r2, l2) {
  var t5 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t5) {
    var e3, n2, i2, u2, a3 = [], f3 = true, o2 = false;
    try {
      if (i2 = (t5 = t5.call(r2)).next, 0 === l2) ;
      else for (; !(f3 = (e3 = i2.call(t5)).done) && (a3.push(e3.value), a3.length !== l2); f3 = true) ;
    } catch (r3) {
      o2 = true, n2 = r3;
    } finally {
      try {
        if (!f3 && null != t5.return && (u2 = t5.return(), Object(u2) !== u2)) return;
      } finally {
        if (o2) throw n2;
      }
    }
    return a3;
  }
}
function _nonIterableRest6() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableSpread5() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function ownKeys2(e3, r2) {
  var t5 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t5.push.apply(t5, o2);
  }
  return t5;
}
function _objectSpread22(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t5 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys2(Object(t5), true).forEach(function(r3) {
      _defineProperty3(e3, r3, t5[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t5)) : ownKeys2(Object(t5)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t5, r3));
    });
  }
  return e3;
}
function _slicedToArray6(r2, e3) {
  return _arrayWithHoles6(r2) || _iterableToArrayLimit6(r2, e3) || _unsupportedIterableToArray6(r2, e3) || _nonIterableRest6();
}
function _toConsumableArray5(r2) {
  return _arrayWithoutHoles5(r2) || _iterableToArray5(r2) || _unsupportedIterableToArray6(r2) || _nonIterableSpread5();
}
function _toPrimitive4(t5, r2) {
  if ("object" != typeof t5 || !t5) return t5;
  var e3 = t5[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t5, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t5);
}
function _toPropertyKey4(t5) {
  var i2 = _toPrimitive4(t5, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _unsupportedIterableToArray6(r2, a3) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray6(r2, a3);
    var t5 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t5 && r2.constructor && (t5 = r2.constructor.name), "Map" === t5 || "Set" === t5 ? Array.from(r2) : "Arguments" === t5 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t5) ? _arrayLikeToArray6(r2, a3) : void 0;
  }
}
var _3dForceGraphVr = index3({
  props: {
    width: {
      "default": window.innerWidth,
      triggerUpdate: false,
      onChange: function onChange8(width, state) {
        if (state.container) state.container.style.width = "".concat(width, "px");
      }
    },
    height: {
      "default": window.innerHeight,
      triggerUpdate: false,
      onChange: function onChange9(height, state) {
        if (state.container) state.container.style.height = "".concat(height, "px");
      }
    },
    jsonUrl: {},
    graphData: {
      "default": {
        nodes: [],
        links: []
      }
    },
    numDimensions: {
      "default": 3
    },
    dagMode: {},
    dagLevelDistance: {},
    dagNodeFilter: {
      "default": function _default8() {
        return true;
      }
    },
    onDagError: {
      "default": void 0
    },
    backgroundColor: {
      "default": "#002"
    },
    showNavInfo: {
      "default": true
    },
    nodeRelSize: {
      "default": 4
    },
    // volume per val unit
    nodeId: {
      "default": "id"
    },
    nodeLabel: {
      "default": "name"
    },
    nodeDesc: {
      "default": "desc"
    },
    onNodeHover: {},
    onNodeClick: {},
    nodeVal: {
      "default": "val"
    },
    nodeResolution: {
      "default": 8
    },
    // how many slice segments in the sphere's circumference
    nodeVisibility: {
      "default": true
    },
    nodeColor: {
      "default": "color"
    },
    nodeAutoColorBy: {},
    nodeOpacity: {
      "default": 0.75
    },
    nodeThreeObject: {},
    nodeThreeObjectExtend: {
      "default": false
    },
    linkSource: {
      "default": "source"
    },
    linkTarget: {
      "default": "target"
    },
    linkLabel: {
      "default": "name"
    },
    linkDesc: {
      "default": "desc"
    },
    onLinkHover: {},
    onLinkClick: {},
    linkVisibility: {
      "default": true
    },
    linkColor: {
      "default": "color"
    },
    linkAutoColorBy: {},
    linkOpacity: {
      "default": 0.2
    },
    linkWidth: {
      "default": 0
    },
    linkResolution: {
      "default": 6
    },
    // how many radial segments in each line cylinder's geometry
    linkCurvature: {
      "default": 0
    },
    linkCurveRotation: {
      "default": 0
    },
    linkMaterial: {},
    linkThreeObject: {},
    linkThreeObjectExtend: {
      "default": false
    },
    linkPositionUpdate: {},
    linkDirectionalArrowLength: {
      "default": 0
    },
    linkDirectionalArrowColor: {},
    linkDirectionalArrowRelPos: {
      "default": 0.5
    },
    // value between 0<>1 indicating the relative pos along the (exposed) line
    linkDirectionalArrowResolution: {
      "default": 8
    },
    // how many slice segments in the arrow's conic circumference
    linkDirectionalParticles: {
      "default": 0
    },
    // animate photons travelling in the link direction
    linkDirectionalParticleSpeed: {
      "default": 0.01
    },
    // in link length ratio per frame
    linkDirectionalParticleOffset: {
      "default": 0
    },
    linkDirectionalParticleWidth: {
      "default": 0.5
    },
    linkDirectionalParticleColor: {},
    linkDirectionalParticleResolution: {
      "default": 4
    },
    // how many slice segments in the particle sphere's circumference
    linkDirectionalParticleThreeObject: {},
    forceEngine: {
      "default": "d3"
    },
    // d3 or ngraph
    d3AlphaMin: {
      "default": 0
    },
    d3AlphaDecay: {
      "default": 0.0228
    },
    d3VelocityDecay: {
      "default": 0.4
    },
    ngraphPhysics: {},
    warmupTicks: {
      "default": 0
    },
    // how many times to tick the force engine at init before starting to render
    cooldownTicks: {},
    cooldownTime: {
      "default": 15e3
    },
    // ms
    onEngineTick: {},
    onEngineStop: {}
  },
  methods: _objectSpread22(_objectSpread22({}, Object.assign.apply(Object, [{}].concat(_toConsumableArray5(["getGraphBbox", "emitParticle", "d3Force", "d3ReheatSimulation", "refresh"].map(function(method2) {
    return _defineProperty3({}, method2, function(state) {
      var aframeComp = state.forcegraph.components.forcegraph;
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      var returnVal = aframeComp[method2].apply(aframeComp, args);
      return returnVal === aframeComp ? this : returnVal;
    });
  }))))), {}, {
    _destructor: function _destructor() {
      this.graphData({
        nodes: [],
        links: []
      });
    }
  }),
  init: function init2(domNode, state) {
    domNode.innerHTML = "";
    state.container = document.createElement("div");
    domNode.appendChild(state.container);
    state.container.style.position = "relative";
    state.container.style.width = "".concat(state.width, "px");
    state.container.style.height = "".concat(state.height, "px");
    state.container.appendChild(state.navInfo = document.createElement("div"));
    state.navInfo.className = "graph-nav-info";
    state.navInfo.textContent = "Mouse drag: look, gamepad/arrow/wasd keys: move";
    var scene3 = document.createElement("a-scene");
    scene3.setAttribute("embedded", "");
    scene3.appendChild(state.sky = document.createElement("a-sky"));
    state.sky.setAttribute("radius", 3e3);
    var cameraG;
    scene3.appendChild(cameraG = document.createElement("a-entity"));
    cameraG.setAttribute("position", "0 0 300");
    cameraG.setAttribute("movement-controls", "controls: gamepad, touch; fly: true; speed: 7");
    var camera3;
    cameraG.appendChild(camera3 = document.createElement("a-entity"));
    camera3.setAttribute("camera", "");
    camera3.setAttribute("position", "0 0 0");
    camera3.setAttribute("look-controls", "pointerLockEnabled: false");
    camera3.setAttribute("wasd-controls", "fly: true; acceleration: 700");
    var tooltipEl;
    camera3.appendChild(tooltipEl = document.createElement("a-text"));
    tooltipEl.setAttribute("position", "0 -0.3 -1");
    tooltipEl.setAttribute("width", 2);
    tooltipEl.setAttribute("align", "center");
    tooltipEl.setAttribute("color", "lavender");
    tooltipEl.setAttribute("value", "");
    var subTooltipEl;
    camera3.appendChild(subTooltipEl = document.createElement("a-text"));
    subTooltipEl.setAttribute("position", "0 -0.4 -1");
    subTooltipEl.setAttribute("width", 1.3);
    subTooltipEl.setAttribute("align", "center");
    subTooltipEl.setAttribute("color", "lavender");
    subTooltipEl.setAttribute("value", "");
    state.raycasterEls = [];
    var mouseCursor;
    scene3.appendChild(mouseCursor = document.createElement("a-entity"));
    mouseCursor.setAttribute("cursor", "rayOrigin: mouse; mouseCursorStylesEnabled: true");
    mouseCursor.setAttribute("raycaster", "objects: [forcegraph]; interval: 100");
    state.raycasterEls.push(mouseCursor);
    ["left", "right"].forEach(function(hand) {
      var laser;
      cameraG.appendChild(laser = document.createElement("a-entity"));
      laser.setAttribute("laser-controls", "hand: ".concat(hand, "; model: false;"));
      laser.setAttribute("raycaster", "objects: [forcegraph]; interval: 100; lineColor: steelblue; lineOpacity: 0.85");
      state.raycasterEls.push(laser);
    });
    scene3.appendChild(state.forcegraph = document.createElement("a-entity"));
    state.forcegraph.setAttribute("forcegraph", null);
    state.container.appendChild(scene3);
    state.forcegraph.setAttribute("forcegraph", Object.assign.apply(Object, _toConsumableArray5(["node", "link"].map(function(t5) {
      var cct = {
        node: "Node",
        link: "Link"
      }[t5];
      return _defineProperty3({}, "on".concat(cct, "Hover"), function onHover(obj, prevObj) {
        var label2 = obj ? index4(state["".concat(t5, "Label")])(obj) || "" : "";
        var subLabel = obj ? index4(state["".concat(t5, "Desc")])(obj) || "" : "";
        tooltipEl.setAttribute("value", label2);
        subTooltipEl.setAttribute("value", subLabel);
        state["on".concat(cct, "Hover")] && state["on".concat(cct, "Hover")](obj, prevObj);
      });
    }))));
  },
  update: function update2(state, changedProps) {
    if (changedProps.hasOwnProperty("backgroundColor")) {
      var alpha = parseToRgb(state.backgroundColor).alpha;
      if (alpha === void 0) alpha = 1;
      state.sky.setAttribute("color", curriedOpacify$1(1, state.backgroundColor));
      state.sky.setAttribute("opacity", alpha);
    }
    changedProps.hasOwnProperty("showNavInfo") && (state.navInfo.style.display = state.showNavInfo ? null : "none");
    var isInteractive = ["onNodeHover", "onLinkHover", "onNodeClick", "onLinkClick"].some(function(p3) {
      return state[p3];
    }) || ["nodeLabel", "linkLabel"].some(function(p3) {
      return state[p3] !== "name";
    }) || ["nodeDesc", "linkDesc"].some(function(p3) {
      return state[p3] !== "desc";
    });
    state.raycasterEls.forEach(function(el) {
      return el.setAttribute("raycaster", isInteractive ? "objects: [forcegraph]; interval: 100" : "objects: __none__");
    });
    var passThroughProps = ["jsonUrl", "numDimensions", "dagMode", "dagLevelDistance", "dagNodeFilter", "onDagError", "nodeRelSize", "nodeId", "onNodeClick", "nodeVal", "nodeResolution", "nodeVisibility", "nodeColor", "nodeAutoColorBy", "nodeOpacity", "nodeThreeObject", "nodeThreeObjectExtend", "linkSource", "linkTarget", "onLinkClick", "linkVisibility", "linkColor", "linkAutoColorBy", "linkOpacity", "linkWidth", "linkResolution", "linkCurvature", "linkCurveRotation", "linkMaterial", "linkThreeObject", "linkThreeObjectExtend", "linkPositionUpdate", "linkDirectionalArrowLength", "linkDirectionalArrowColor", "linkDirectionalArrowRelPos", "linkDirectionalArrowResolution", "linkDirectionalParticles", "linkDirectionalParticleSpeed", "linkDirectionalParticleOffset", "linkDirectionalParticleWidth", "linkDirectionalParticleColor", "linkDirectionalParticleResolution", "linkDirectionalParticleThreeObject", "forceEngine", "d3AlphaMin", "d3AlphaDecay", "d3VelocityDecay", "ngraphPhysics", "warmupTicks", "cooldownTicks", "cooldownTime", "onEngineTick", "onEngineStop"];
    var newProps = Object.assign.apply(Object, [{}].concat(_toConsumableArray5(Object.entries(state).filter(function(_ref3) {
      var _ref4 = _slicedToArray6(_ref3, 2), prop = _ref4[0], val = _ref4[1];
      return changedProps.hasOwnProperty(prop) && passThroughProps.indexOf(prop) !== -1 && val !== void 0 && val !== null;
    }).map(function(_ref5) {
      var _ref6 = _slicedToArray6(_ref5, 2), key = _ref6[0], val = _ref6[1];
      return _defineProperty3({}, key, val);
    })), _toConsumableArray5(Object.entries(state.graphData).map(function(_ref8) {
      var _ref9 = _slicedToArray6(_ref8, 2), key = _ref9[0], val = _ref9[1];
      return _defineProperty3({}, key, val);
    }))));
    state.forcegraph.setAttribute("forcegraph", newProps);
  }
});

// node_modules/react-force-graph/dist/react-force-graph.mjs
var import_prop_types = __toESM(require_prop_types(), 1);

// node_modules/3d-force-graph-ar/dist/3d-force-graph-ar.mjs
function _arrayLikeToArray7(r2, a3) {
  (null == a3 || a3 > r2.length) && (a3 = r2.length);
  for (var e3 = 0, n2 = Array(a3); e3 < a3; e3++) n2[e3] = r2[e3];
  return n2;
}
function _arrayWithHoles7(r2) {
  if (Array.isArray(r2)) return r2;
}
function _arrayWithoutHoles6(r2) {
  if (Array.isArray(r2)) return _arrayLikeToArray7(r2);
}
function _defineProperty4(e3, r2, t5) {
  return (r2 = _toPropertyKey5(r2)) in e3 ? Object.defineProperty(e3, r2, {
    value: t5,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e3[r2] = t5, e3;
}
function _iterableToArray6(r2) {
  if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"]) return Array.from(r2);
}
function _iterableToArrayLimit7(r2, l2) {
  var t5 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t5) {
    var e3, n2, i2, u2, a3 = [], f3 = true, o2 = false;
    try {
      if (i2 = (t5 = t5.call(r2)).next, 0 === l2) ;
      else for (; !(f3 = (e3 = i2.call(t5)).done) && (a3.push(e3.value), a3.length !== l2); f3 = true) ;
    } catch (r3) {
      o2 = true, n2 = r3;
    } finally {
      try {
        if (!f3 && null != t5.return && (u2 = t5.return(), Object(u2) !== u2)) return;
      } finally {
        if (o2) throw n2;
      }
    }
    return a3;
  }
}
function _nonIterableRest7() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableSpread6() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function ownKeys3(e3, r2) {
  var t5 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t5.push.apply(t5, o2);
  }
  return t5;
}
function _objectSpread23(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t5 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys3(Object(t5), true).forEach(function(r3) {
      _defineProperty4(e3, r3, t5[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t5)) : ownKeys3(Object(t5)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t5, r3));
    });
  }
  return e3;
}
function _slicedToArray7(r2, e3) {
  return _arrayWithHoles7(r2) || _iterableToArrayLimit7(r2, e3) || _unsupportedIterableToArray7(r2, e3) || _nonIterableRest7();
}
function _toConsumableArray6(r2) {
  return _arrayWithoutHoles6(r2) || _iterableToArray6(r2) || _unsupportedIterableToArray7(r2) || _nonIterableSpread6();
}
function _toPrimitive5(t5, r2) {
  if ("object" != typeof t5 || !t5) return t5;
  var e3 = t5[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t5, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t5);
}
function _toPropertyKey5(t5) {
  var i2 = _toPrimitive5(t5, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _unsupportedIterableToArray7(r2, a3) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray7(r2, a3);
    var t5 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t5 && r2.constructor && (t5 = r2.constructor.name), "Map" === t5 || "Set" === t5 ? Array.from(r2) : "Arguments" === t5 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t5) ? _arrayLikeToArray7(r2, a3) : void 0;
  }
}
var _3dForceGraphAr = index3({
  props: {
    width: {},
    height: {},
    yOffset: {
      "default": 1.5
    },
    // marker size units
    glScale: {
      "default": 200
    },
    // gl units per marker width
    jsonUrl: {},
    graphData: {
      "default": {
        nodes: [],
        links: []
      }
    },
    numDimensions: {
      "default": 3
    },
    dagMode: {},
    dagLevelDistance: {},
    dagNodeFilter: {
      "default": function _default9() {
        return true;
      }
    },
    onDagError: {
      "default": void 0
    },
    nodeRelSize: {
      "default": 4
    },
    // volume per val unit
    nodeId: {
      "default": "id"
    },
    nodeVal: {
      "default": "val"
    },
    nodeResolution: {
      "default": 8
    },
    // how many slice segments in the sphere's circumference
    nodeVisibility: {
      "default": true
    },
    nodeColor: {
      "default": "color"
    },
    nodeAutoColorBy: {},
    nodeOpacity: {
      "default": 0.75
    },
    nodeThreeObject: {},
    nodeThreeObjectExtend: {
      "default": false
    },
    linkSource: {
      "default": "source"
    },
    linkTarget: {
      "default": "target"
    },
    linkVisibility: {
      "default": true
    },
    linkColor: {
      "default": "color"
    },
    linkAutoColorBy: {},
    linkOpacity: {
      "default": 0.2
    },
    linkWidth: {
      "default": 0
    },
    linkResolution: {
      "default": 6
    },
    // how many radial segments in each line cylinder's geometry
    linkCurvature: {
      "default": 0
    },
    linkCurveRotation: {
      "default": 0
    },
    linkMaterial: {},
    linkThreeObject: {},
    linkThreeObjectExtend: {
      "default": false
    },
    linkPositionUpdate: {},
    linkDirectionalArrowLength: {
      "default": 0
    },
    linkDirectionalArrowColor: {},
    linkDirectionalArrowRelPos: {
      "default": 0.5
    },
    // value between 0<>1 indicating the relative pos along the (exposed) line
    linkDirectionalArrowResolution: {
      "default": 8
    },
    // how many slice segments in the arrow's conic circumference
    linkDirectionalParticles: {
      "default": 0
    },
    // animate photons travelling in the link direction
    linkDirectionalParticleSpeed: {
      "default": 0.01
    },
    // in link length ratio per frame
    linkDirectionalParticleOffset: {
      "default": 0
    },
    linkDirectionalParticleWidth: {
      "default": 0.5
    },
    linkDirectionalParticleColor: {},
    linkDirectionalParticleResolution: {
      "default": 4
    },
    // how many slice segments in the particle sphere's circumference
    linkDirectionalParticleThreeObject: {},
    onNodeHover: {},
    onNodeClick: {},
    onLinkHover: {},
    onLinkClick: {},
    forceEngine: {
      "default": "d3"
    },
    // d3 or ngraph
    d3AlphaMin: {
      "default": 0
    },
    d3AlphaDecay: {
      "default": 0.0228
    },
    d3VelocityDecay: {
      "default": 0.4
    },
    ngraphPhysics: {},
    warmupTicks: {
      "default": 0
    },
    // how many times to tick the force engine at init before starting to render
    cooldownTicks: {},
    cooldownTime: {
      "default": 15e3
    },
    // ms
    onEngineTick: {},
    onEngineStop: {}
  },
  methods: _objectSpread23(_objectSpread23({}, Object.assign.apply(Object, [{}].concat(_toConsumableArray6(["getGraphBbox", "emitParticle", "d3Force", "d3ReheatSimulation", "refresh"].map(function(method2) {
    return _defineProperty4({}, method2, function(state) {
      var aframeComp = state.forcegraph.components.forcegraph;
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      var returnVal = aframeComp[method2].apply(aframeComp, args);
      return returnVal === aframeComp ? this : returnVal;
    });
  }))))), {}, {
    _destructor: function _destructor2() {
      this.graphData({
        nodes: [],
        links: []
      });
    }
  }),
  init: function init3(domNode, state) {
    var _ref2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, _ref2$markerAttrs = _ref2.markerAttrs, markerAttrs = _ref2$markerAttrs === void 0 ? {
      preset: "hiro"
    } : _ref2$markerAttrs;
    domNode.innerHTML = "";
    state.container = document.createElement("div");
    domNode.appendChild(state.container);
    var scene3 = document.createElement("a-scene");
    scene3.setAttribute("embedded", "");
    scene3.setAttribute("vr-mode-ui", "enabled: false");
    scene3.setAttribute("arjs", "debugUIEnabled: false;");
    var arMarker = document.createElement("a-marker");
    Object.entries(markerAttrs).forEach(function(_ref3) {
      var _ref4 = _slicedToArray7(_ref3, 2), attr = _ref4[0], val = _ref4[1];
      return arMarker.setAttribute(attr, val);
    });
    scene3.appendChild(arMarker);
    var mouseCursor;
    scene3.appendChild(mouseCursor = document.createElement("a-entity"));
    mouseCursor.setAttribute(
      "cursor"
      /*, 'rayOrigin: mouse'*/
    );
    mouseCursor.setAttribute("raycaster", "objects: [forcegraph]");
    state.forcegraph = document.createElement("a-entity");
    state.forcegraph.setAttribute("forcegraph", null);
    arMarker.appendChild(state.forcegraph);
    var cameraEntity = document.createElement("a-entity");
    cameraEntity.setAttribute("camera", "");
    scene3.appendChild(cameraEntity);
    state.container.appendChild(scene3);
  },
  update: function update3(state, changedProps) {
    changedProps.hasOwnProperty("width") && state.width && (state.container.style.width = "".concat(state.width, "px"));
    changedProps.hasOwnProperty("height") && state.height && (state.container.style.height = "".concat(state.height, "px"));
    changedProps.hasOwnProperty("glScale") && state.forcegraph.setAttribute("scale", _toConsumableArray6(new Array(3)).map(function() {
      return 1 / state.glScale;
    }).join(" "));
    changedProps.hasOwnProperty("yOffset") && state.forcegraph.setAttribute("position", "0 ".concat(state.yOffset, " 0"));
    var passThroughProps = ["jsonUrl", "numDimensions", "dagMode", "dagLevelDistance", "dagNodeFilter", "onDagError", "nodeRelSize", "nodeId", "nodeVal", "nodeResolution", "nodeVisibility", "nodeColor", "nodeAutoColorBy", "nodeOpacity", "nodeThreeObject", "nodeThreeObjectExtend", "linkSource", "linkTarget", "linkVisibility", "linkColor", "linkAutoColorBy", "linkOpacity", "linkWidth", "linkResolution", "linkCurvature", "linkCurveRotation", "linkMaterial", "linkThreeObject", "linkThreeObjectExtend", "linkPositionUpdate", "linkDirectionalArrowLength", "linkDirectionalArrowColor", "linkDirectionalArrowRelPos", "linkDirectionalArrowResolution", "linkDirectionalParticles", "linkDirectionalParticleSpeed", "linkDirectionalParticleOffset", "linkDirectionalParticleWidth", "linkDirectionalParticleColor", "linkDirectionalParticleResolution", "linkDirectionalParticleThreeObject", "onNodeHover", "onNodeClick", "onLinkHover", "onLinkClick", "forceEngine", "d3AlphaMin", "d3AlphaDecay", "d3VelocityDecay", "ngraphPhysics", "warmupTicks", "cooldownTicks", "cooldownTime", "onEngineTick", "onEngineStop"];
    var newProps = Object.assign.apply(Object, [{}].concat(_toConsumableArray6(Object.entries(state).filter(function(_ref5) {
      var _ref6 = _slicedToArray7(_ref5, 2), prop = _ref6[0], val = _ref6[1];
      return changedProps.hasOwnProperty(prop) && passThroughProps.indexOf(prop) !== -1 && val !== void 0 && val !== null;
    }).map(function(_ref7) {
      var _ref8 = _slicedToArray7(_ref7, 2), key = _ref8[0], val = _ref8[1];
      return _defineProperty4({}, key, val);
    })), _toConsumableArray6(Object.entries(state.graphData).map(function(_ref0) {
      var _ref1 = _slicedToArray7(_ref0, 2), key = _ref1[0], val = _ref1[1];
      return _defineProperty4({}, key, val);
    }))));
    state.forcegraph.setAttribute("forcegraph", newProps);
  }
});

// node_modules/three/examples/jsm/controls/DragControls.js
var _plane = new Plane();
var _pointer = new Vector2();
var _offset2 = new Vector3();
var _diff2 = new Vector2();
var _previousPointer = new Vector2();
var _intersection = new Vector3();
var _worldPosition = new Vector3();
var _inverseMatrix2 = new Matrix4();
var _up = new Vector3();
var _right = new Vector3();
var _selected = null;
var _hovered = null;
var _intersections = [];
var STATE = {
  NONE: -1,
  PAN: 0,
  ROTATE: 1
};
var DragControls = class extends Controls {
  /**
   * Constructs a new controls instance.
   *
   * @param {Array<Object3D>} objects - An array of draggable 3D objects.
   * @param {Camera} camera - The camera of the rendered scene.
   * @param {?HTMLElement} [domElement=null] - The HTML DOM element used for event listeners.
   */
  constructor(objects, camera3, domElement = null) {
    super(camera3, domElement);
    this.objects = objects;
    this.recursive = true;
    this.transformGroup = false;
    this.rotateSpeed = 1;
    this.raycaster = new Raycaster();
    this.mouseButtons = { LEFT: MOUSE.PAN, MIDDLE: MOUSE.PAN, RIGHT: MOUSE.ROTATE };
    this.touches = { ONE: TOUCH.PAN };
    this._onPointerMove = onPointerMove.bind(this);
    this._onPointerDown = onPointerDown.bind(this);
    this._onPointerCancel = onPointerCancel.bind(this);
    this._onContextMenu = onContextMenu.bind(this);
    if (domElement !== null) {
      this.connect(domElement);
    }
  }
  connect(element2) {
    super.connect(element2);
    this.domElement.addEventListener("pointermove", this._onPointerMove);
    this.domElement.addEventListener("pointerdown", this._onPointerDown);
    this.domElement.addEventListener("pointerup", this._onPointerCancel);
    this.domElement.addEventListener("pointerleave", this._onPointerCancel);
    this.domElement.addEventListener("contextmenu", this._onContextMenu);
    this.domElement.style.touchAction = "none";
  }
  disconnect() {
    this.domElement.removeEventListener("pointermove", this._onPointerMove);
    this.domElement.removeEventListener("pointerdown", this._onPointerDown);
    this.domElement.removeEventListener("pointerup", this._onPointerCancel);
    this.domElement.removeEventListener("pointerleave", this._onPointerCancel);
    this.domElement.removeEventListener("contextmenu", this._onContextMenu);
    this.domElement.style.touchAction = "auto";
    this.domElement.style.cursor = "";
  }
  dispose() {
    this.disconnect();
  }
  _updatePointer(event) {
    const rect = this.domElement.getBoundingClientRect();
    _pointer.x = (event.clientX - rect.left) / rect.width * 2 - 1;
    _pointer.y = -(event.clientY - rect.top) / rect.height * 2 + 1;
  }
  _updateState(event) {
    let action;
    if (event.pointerType === "touch") {
      action = this.touches.ONE;
    } else {
      switch (event.button) {
        case 0:
          action = this.mouseButtons.LEFT;
          break;
        case 1:
          action = this.mouseButtons.MIDDLE;
          break;
        case 2:
          action = this.mouseButtons.RIGHT;
          break;
        default:
          action = null;
      }
    }
    switch (action) {
      case MOUSE.PAN:
      case TOUCH.PAN:
        this.state = STATE.PAN;
        break;
      case MOUSE.ROTATE:
      case TOUCH.ROTATE:
        this.state = STATE.ROTATE;
        break;
      default:
        this.state = STATE.NONE;
    }
  }
};
function onPointerMove(event) {
  const camera3 = this.object;
  const domElement = this.domElement;
  const raycaster = this.raycaster;
  if (this.enabled === false) return;
  this._updatePointer(event);
  raycaster.setFromCamera(_pointer, camera3);
  if (_selected) {
    if (this.state === STATE.PAN) {
      if (raycaster.ray.intersectPlane(_plane, _intersection)) {
        _selected.position.copy(_intersection.sub(_offset2).applyMatrix4(_inverseMatrix2));
        this.dispatchEvent({ type: "drag", object: _selected });
      }
    } else if (this.state === STATE.ROTATE) {
      _diff2.subVectors(_pointer, _previousPointer).multiplyScalar(this.rotateSpeed);
      _selected.rotateOnWorldAxis(_up, _diff2.x);
      _selected.rotateOnWorldAxis(_right.normalize(), -_diff2.y);
      this.dispatchEvent({ type: "drag", object: _selected });
    }
    _previousPointer.copy(_pointer);
  } else {
    if (event.pointerType === "mouse" || event.pointerType === "pen") {
      _intersections.length = 0;
      raycaster.setFromCamera(_pointer, camera3);
      raycaster.intersectObjects(this.objects, this.recursive, _intersections);
      if (_intersections.length > 0) {
        const object = _intersections[0].object;
        _plane.setFromNormalAndCoplanarPoint(camera3.getWorldDirection(_plane.normal), _worldPosition.setFromMatrixPosition(object.matrixWorld));
        if (_hovered !== object && _hovered !== null) {
          this.dispatchEvent({ type: "hoveroff", object: _hovered });
          domElement.style.cursor = "auto";
          _hovered = null;
        }
        if (_hovered !== object) {
          this.dispatchEvent({ type: "hoveron", object });
          domElement.style.cursor = "pointer";
          _hovered = object;
        }
      } else {
        if (_hovered !== null) {
          this.dispatchEvent({ type: "hoveroff", object: _hovered });
          domElement.style.cursor = "auto";
          _hovered = null;
        }
      }
    }
  }
  _previousPointer.copy(_pointer);
}
function onPointerDown(event) {
  const camera3 = this.object;
  const domElement = this.domElement;
  const raycaster = this.raycaster;
  if (this.enabled === false) return;
  this._updatePointer(event);
  this._updateState(event);
  _intersections.length = 0;
  raycaster.setFromCamera(_pointer, camera3);
  raycaster.intersectObjects(this.objects, this.recursive, _intersections);
  if (_intersections.length > 0) {
    if (this.transformGroup === true) {
      _selected = findGroup(_intersections[0].object);
    } else {
      _selected = _intersections[0].object;
    }
    _plane.setFromNormalAndCoplanarPoint(camera3.getWorldDirection(_plane.normal), _worldPosition.setFromMatrixPosition(_selected.matrixWorld));
    if (raycaster.ray.intersectPlane(_plane, _intersection)) {
      if (this.state === STATE.PAN) {
        _inverseMatrix2.copy(_selected.parent.matrixWorld).invert();
        _offset2.copy(_intersection).sub(_worldPosition.setFromMatrixPosition(_selected.matrixWorld));
        domElement.style.cursor = "move";
        this.dispatchEvent({ type: "dragstart", object: _selected });
      } else if (this.state === STATE.ROTATE) {
        _up.set(0, 1, 0).applyQuaternion(camera3.quaternion).normalize();
        _right.set(1, 0, 0).applyQuaternion(camera3.quaternion).normalize();
        domElement.style.cursor = "move";
        this.dispatchEvent({ type: "dragstart", object: _selected });
      }
    }
  }
  _previousPointer.copy(_pointer);
}
function onPointerCancel() {
  if (this.enabled === false) return;
  if (_selected) {
    this.dispatchEvent({ type: "dragend", object: _selected });
    _selected = null;
  }
  this.domElement.style.cursor = _hovered ? "pointer" : "auto";
  this.state = STATE.NONE;
}
function onContextMenu(event) {
  if (this.enabled === false) return;
  event.preventDefault();
}
function findGroup(obj, group2 = null) {
  if (obj.isGroup) group2 = obj;
  if (obj.parent === null) return group2;
  return findGroup(obj.parent, group2);
}

// node_modules/three/build/three.webgpu.js
var refreshUniforms = [
  "alphaMap",
  "alphaTest",
  "anisotropy",
  "anisotropyMap",
  "anisotropyRotation",
  "aoMap",
  "aoMapIntensity",
  "attenuationColor",
  "attenuationDistance",
  "bumpMap",
  "clearcoat",
  "clearcoatMap",
  "clearcoatNormalMap",
  "clearcoatNormalScale",
  "clearcoatRoughness",
  "color",
  "dispersion",
  "displacementMap",
  "emissive",
  "emissiveIntensity",
  "emissiveMap",
  "envMap",
  "envMapIntensity",
  "gradientMap",
  "ior",
  "iridescence",
  "iridescenceIOR",
  "iridescenceMap",
  "iridescenceThicknessMap",
  "lightMap",
  "lightMapIntensity",
  "map",
  "matcap",
  "metalness",
  "metalnessMap",
  "normalMap",
  "normalScale",
  "opacity",
  "roughness",
  "roughnessMap",
  "sheen",
  "sheenColor",
  "sheenColorMap",
  "sheenRoughnessMap",
  "shininess",
  "specular",
  "specularColor",
  "specularColorMap",
  "specularIntensity",
  "specularIntensityMap",
  "specularMap",
  "thickness",
  "transmission",
  "transmissionMap"
];
var _lightsCache = /* @__PURE__ */ new WeakMap();
var NodeMaterialObserver = class {
  /**
   * Constructs a new node material observer.
   *
   * @param {NodeBuilder} builder - The node builder.
   */
  constructor(builder) {
    this.renderObjects = /* @__PURE__ */ new WeakMap();
    this.hasNode = this.containsNode(builder);
    this.hasAnimation = builder.object.isSkinnedMesh === true;
    this.refreshUniforms = refreshUniforms;
    this.renderId = 0;
  }
  /**
   * Returns `true` if the given render object is verified for the first time of this observer.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {boolean} Whether the given render object is verified for the first time of this observer.
   */
  firstInitialization(renderObject) {
    const hasInitialized = this.renderObjects.has(renderObject);
    if (hasInitialized === false) {
      this.getRenderObjectData(renderObject);
      return true;
    }
    return false;
  }
  /**
   * Returns `true` if the current rendering produces motion vectors.
   *
   * @param {Renderer} renderer - The renderer.
   * @return {boolean} Whether the current rendering produces motion vectors or not.
   */
  needsVelocity(renderer3) {
    const mrt2 = renderer3.getMRT();
    return mrt2 !== null && mrt2.has("velocity");
  }
  /**
   * Returns monitoring data for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {Object} The monitoring data.
   */
  getRenderObjectData(renderObject) {
    let data = this.renderObjects.get(renderObject);
    if (data === void 0) {
      const { geometry, material, object } = renderObject;
      data = {
        material: this.getMaterialData(material),
        geometry: {
          id: geometry.id,
          attributes: this.getAttributesData(geometry.attributes),
          indexVersion: geometry.index ? geometry.index.version : null,
          drawRange: { start: geometry.drawRange.start, count: geometry.drawRange.count }
        },
        worldMatrix: object.matrixWorld.clone()
      };
      if (object.center) {
        data.center = object.center.clone();
      }
      if (object.morphTargetInfluences) {
        data.morphTargetInfluences = object.morphTargetInfluences.slice();
      }
      if (renderObject.bundle !== null) {
        data.version = renderObject.bundle.version;
      }
      if (data.material.transmission > 0) {
        const { width, height } = renderObject.context;
        data.bufferWidth = width;
        data.bufferHeight = height;
      }
      data.lights = this.getLightsData(renderObject.lightsNode.getLights());
      this.renderObjects.set(renderObject, data);
    }
    return data;
  }
  /**
   * Returns an attribute data structure holding the attributes versions for
   * monitoring.
   *
   * @param {Object} attributes - The geometry attributes.
   * @return {Object} An object for monitoring the versions of attributes.
   */
  getAttributesData(attributes) {
    const attributesData = {};
    for (const name in attributes) {
      const attribute2 = attributes[name];
      attributesData[name] = {
        version: attribute2.version
      };
    }
    return attributesData;
  }
  /**
   * Returns `true` if the node builder's material uses
   * node properties.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {boolean} Whether the node builder's material uses node properties or not.
   */
  containsNode(builder) {
    const material = builder.material;
    for (const property3 in material) {
      if (material[property3] && material[property3].isNode)
        return true;
    }
    if (builder.context.modelViewMatrix || builder.context.modelNormalViewMatrix || builder.context.getAO || builder.context.getShadow)
      return true;
    return false;
  }
  /**
   * Returns a material data structure holding the material property values for
   * monitoring.
   *
   * @param {Material} material - The material.
   * @return {Object} An object for monitoring material properties.
   */
  getMaterialData(material) {
    const data = {};
    for (const property3 of this.refreshUniforms) {
      const value = material[property3];
      if (value === null || value === void 0) continue;
      if (typeof value === "object" && value.clone !== void 0) {
        if (value.isTexture === true) {
          data[property3] = { id: value.id, version: value.version };
        } else {
          data[property3] = value.clone();
        }
      } else {
        data[property3] = value;
      }
    }
    return data;
  }
  /**
   * Returns `true` if the given render object has not changed its state.
   *
   * @param {RenderObject} renderObject - The render object.
   * @param {Array<Light>} lightsData - The current material lights.
   * @return {boolean} Whether the given render object has changed its state or not.
   */
  equals(renderObject, lightsData) {
    const { object, material, geometry } = renderObject;
    const renderObjectData = this.getRenderObjectData(renderObject);
    if (renderObjectData.worldMatrix.equals(object.matrixWorld) !== true) {
      renderObjectData.worldMatrix.copy(object.matrixWorld);
      return false;
    }
    const materialData = renderObjectData.material;
    for (const property3 in materialData) {
      const value = materialData[property3];
      const mtlValue = material[property3];
      if (value.equals !== void 0) {
        if (value.equals(mtlValue) === false) {
          value.copy(mtlValue);
          return false;
        }
      } else if (mtlValue.isTexture === true) {
        if (value.id !== mtlValue.id || value.version !== mtlValue.version) {
          value.id = mtlValue.id;
          value.version = mtlValue.version;
          return false;
        }
      } else if (value !== mtlValue) {
        materialData[property3] = mtlValue;
        return false;
      }
    }
    if (materialData.transmission > 0) {
      const { width, height } = renderObject.context;
      if (renderObjectData.bufferWidth !== width || renderObjectData.bufferHeight !== height) {
        renderObjectData.bufferWidth = width;
        renderObjectData.bufferHeight = height;
        return false;
      }
    }
    const storedGeometryData = renderObjectData.geometry;
    const attributes = geometry.attributes;
    const storedAttributes = storedGeometryData.attributes;
    const storedAttributeNames = Object.keys(storedAttributes);
    const currentAttributeNames = Object.keys(attributes);
    if (storedGeometryData.id !== geometry.id) {
      storedGeometryData.id = geometry.id;
      return false;
    }
    if (storedAttributeNames.length !== currentAttributeNames.length) {
      renderObjectData.geometry.attributes = this.getAttributesData(attributes);
      return false;
    }
    for (const name of storedAttributeNames) {
      const storedAttributeData = storedAttributes[name];
      const attribute2 = attributes[name];
      if (attribute2 === void 0) {
        delete storedAttributes[name];
        return false;
      }
      if (storedAttributeData.version !== attribute2.version) {
        storedAttributeData.version = attribute2.version;
        return false;
      }
    }
    const index8 = geometry.index;
    const storedIndexVersion = storedGeometryData.indexVersion;
    const currentIndexVersion = index8 ? index8.version : null;
    if (storedIndexVersion !== currentIndexVersion) {
      storedGeometryData.indexVersion = currentIndexVersion;
      return false;
    }
    if (storedGeometryData.drawRange.start !== geometry.drawRange.start || storedGeometryData.drawRange.count !== geometry.drawRange.count) {
      storedGeometryData.drawRange.start = geometry.drawRange.start;
      storedGeometryData.drawRange.count = geometry.drawRange.count;
      return false;
    }
    if (renderObjectData.morphTargetInfluences) {
      let morphChanged = false;
      for (let i2 = 0; i2 < renderObjectData.morphTargetInfluences.length; i2++) {
        if (renderObjectData.morphTargetInfluences[i2] !== object.morphTargetInfluences[i2]) {
          renderObjectData.morphTargetInfluences[i2] = object.morphTargetInfluences[i2];
          morphChanged = true;
        }
      }
      if (morphChanged) return false;
    }
    if (renderObjectData.lights) {
      for (let i2 = 0; i2 < lightsData.length; i2++) {
        if (renderObjectData.lights[i2].map !== lightsData[i2].map) {
          return false;
        }
      }
    }
    if (renderObjectData.center) {
      if (renderObjectData.center.equals(object.center) === false) {
        renderObjectData.center.copy(object.center);
        return true;
      }
    }
    if (renderObject.bundle !== null) {
      renderObjectData.version = renderObject.bundle.version;
    }
    return true;
  }
  /**
   * Returns the lights data for the given material lights.
   *
   * @param {Array<Light>} materialLights - The material lights.
   * @return {Array<Object>} The lights data for the given material lights.
   */
  getLightsData(materialLights) {
    const lights2 = [];
    for (const light of materialLights) {
      if (light.isSpotLight === true && light.map !== null) {
        lights2.push({ map: light.map.version });
      }
    }
    return lights2;
  }
  /**
   * Returns the lights for the given lights node and render ID.
   *
   * @param {LightsNode} lightsNode - The lights node.
   * @param {number} renderId - The render ID.
   * @return {Array<Object>} The lights for the given lights node and render ID.
   */
  getLights(lightsNode, renderId) {
    if (_lightsCache.has(lightsNode)) {
      const cached = _lightsCache.get(lightsNode);
      if (cached.renderId === renderId) {
        return cached.lightsData;
      }
    }
    const lightsData = this.getLightsData(lightsNode.getLights());
    _lightsCache.set(lightsNode, { renderId, lightsData });
    return lightsData;
  }
  /**
   * Checks if the given render object requires a refresh.
   *
   * @param {RenderObject} renderObject - The render object.
   * @param {NodeFrame} nodeFrame - The current node frame.
   * @return {boolean} Whether the given render object requires a refresh or not.
   */
  needsRefresh(renderObject, nodeFrame) {
    if (this.hasNode || this.hasAnimation || this.firstInitialization(renderObject) || this.needsVelocity(nodeFrame.renderer))
      return true;
    const { renderId } = nodeFrame;
    if (this.renderId !== renderId) {
      this.renderId = renderId;
      return true;
    }
    const isStatic = renderObject.object.static === true;
    const isBundle = renderObject.bundle !== null && renderObject.bundle.static === true && this.getRenderObjectData(renderObject).version === renderObject.bundle.version;
    if (isStatic || isBundle)
      return false;
    const lightsData = this.getLights(renderObject.lightsNode, renderId);
    const notEqual2 = this.equals(renderObject, lightsData) !== true;
    return notEqual2;
  }
};
function cyrb53(value, seed = 0) {
  let h12 = 3735928559 ^ seed, h2 = 1103547991 ^ seed;
  if (value instanceof Array) {
    for (let i2 = 0, val; i2 < value.length; i2++) {
      val = value[i2];
      h12 = Math.imul(h12 ^ val, 2654435761);
      h2 = Math.imul(h2 ^ val, 1597334677);
    }
  } else {
    for (let i2 = 0, ch3; i2 < value.length; i2++) {
      ch3 = value.charCodeAt(i2);
      h12 = Math.imul(h12 ^ ch3, 2654435761);
      h2 = Math.imul(h2 ^ ch3, 1597334677);
    }
  }
  h12 = Math.imul(h12 ^ h12 >>> 16, 2246822507);
  h12 ^= Math.imul(h2 ^ h2 >>> 13, 3266489909);
  h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507);
  h2 ^= Math.imul(h12 ^ h12 >>> 13, 3266489909);
  return 4294967296 * (2097151 & h2) + (h12 >>> 0);
}
var hashString = (str) => cyrb53(str);
var hashArray = (array4) => cyrb53(array4);
var hash$1 = (...params) => cyrb53(params);
var typeFromLength = /* @__PURE__ */ new Map([
  [1, "float"],
  [2, "vec2"],
  [3, "vec3"],
  [4, "vec4"],
  [9, "mat3"],
  [16, "mat4"]
]);
var dataFromObject = /* @__PURE__ */ new WeakMap();
function getTypeFromLength(length2) {
  return typeFromLength.get(length2);
}
function getTypedArrayFromType(type) {
  if (/[iu]?vec\d/.test(type)) {
    if (type.startsWith("ivec")) return Int32Array;
    if (type.startsWith("uvec")) return Uint32Array;
    return Float32Array;
  }
  if (/mat\d/.test(type)) return Float32Array;
  if (/float/.test(type)) return Float32Array;
  if (/uint/.test(type)) return Uint32Array;
  if (/int/.test(type)) return Int32Array;
  throw new Error(`THREE.NodeUtils: Unsupported type: ${type}`);
}
function getLengthFromType(type) {
  if (/float|int|uint/.test(type)) return 1;
  if (/vec2/.test(type)) return 2;
  if (/vec3/.test(type)) return 3;
  if (/vec4/.test(type)) return 4;
  if (/mat2/.test(type)) return 4;
  if (/mat3/.test(type)) return 9;
  if (/mat4/.test(type)) return 16;
  error("TSL: Unsupported type:", type);
}
function getMemoryLengthFromType(type) {
  if (/float|int|uint/.test(type)) return 1;
  if (/vec2/.test(type)) return 2;
  if (/vec3/.test(type)) return 3;
  if (/vec4/.test(type)) return 4;
  if (/mat2/.test(type)) return 4;
  if (/mat3/.test(type)) return 12;
  if (/mat4/.test(type)) return 16;
  error("TSL: Unsupported type:", type);
}
function getAlignmentFromType(type) {
  if (/float|int|uint/.test(type)) return 4;
  if (/vec2/.test(type)) return 8;
  if (/vec3/.test(type)) return 16;
  if (/vec4/.test(type)) return 16;
  if (/mat2/.test(type)) return 8;
  if (/mat3/.test(type)) return 16;
  if (/mat4/.test(type)) return 16;
  error("TSL: Unsupported type:", type);
}
function getValueType(value) {
  if (value === void 0 || value === null) return null;
  const typeOf = typeof value;
  if (value.isNode === true) {
    return "node";
  } else if (typeOf === "number") {
    return "float";
  } else if (typeOf === "boolean") {
    return "bool";
  } else if (typeOf === "string") {
    return "string";
  } else if (typeOf === "function") {
    return "shader";
  } else if (value.isVector2 === true) {
    return "vec2";
  } else if (value.isVector3 === true) {
    return "vec3";
  } else if (value.isVector4 === true) {
    return "vec4";
  } else if (value.isMatrix2 === true) {
    return "mat2";
  } else if (value.isMatrix3 === true) {
    return "mat3";
  } else if (value.isMatrix4 === true) {
    return "mat4";
  } else if (value.isColor === true) {
    return "color";
  } else if (value instanceof ArrayBuffer) {
    return "ArrayBuffer";
  }
  return null;
}
function getValueFromType(type, ...params) {
  const last4 = type ? type.slice(-4) : void 0;
  if (params.length === 1) {
    if (last4 === "vec2") params = [params[0], params[0]];
    else if (last4 === "vec3") params = [params[0], params[0], params[0]];
    else if (last4 === "vec4") params = [params[0], params[0], params[0], params[0]];
  }
  if (type === "color") {
    return new Color(...params);
  } else if (last4 === "vec2") {
    return new Vector2(...params);
  } else if (last4 === "vec3") {
    return new Vector3(...params);
  } else if (last4 === "vec4") {
    return new Vector4(...params);
  } else if (last4 === "mat2") {
    return new Matrix2(...params);
  } else if (last4 === "mat3") {
    return new Matrix3(...params);
  } else if (last4 === "mat4") {
    return new Matrix4(...params);
  } else if (type === "bool") {
    return params[0] || false;
  } else if (type === "float" || type === "int" || type === "uint") {
    return params[0] || 0;
  } else if (type === "string") {
    return params[0] || "";
  } else if (type === "ArrayBuffer") {
    return base64ToArrayBuffer(params[0]);
  }
  return null;
}
function getDataFromObject(object) {
  let data = dataFromObject.get(object);
  if (data === void 0) {
    data = {};
    dataFromObject.set(object, data);
  }
  return data;
}
function arrayBufferToBase64(arrayBuffer2) {
  let chars = "";
  const array4 = new Uint8Array(arrayBuffer2);
  for (let i2 = 0; i2 < array4.length; i2++) {
    chars += String.fromCharCode(array4[i2]);
  }
  return btoa(chars);
}
function base64ToArrayBuffer(base64) {
  return Uint8Array.from(atob(base64), (c5) => c5.charCodeAt(0)).buffer;
}
var NodeUtils = Object.freeze({
  __proto__: null,
  arrayBufferToBase64,
  base64ToArrayBuffer,
  getAlignmentFromType,
  getDataFromObject,
  getLengthFromType,
  getMemoryLengthFromType,
  getTypeFromLength,
  getTypedArrayFromType,
  getValueFromType,
  getValueType,
  hash: hash$1,
  hashArray,
  hashString
});
var NodeShaderStage = {
  VERTEX: "vertex",
  FRAGMENT: "fragment"
};
var NodeUpdateType = {
  NONE: "none",
  FRAME: "frame",
  RENDER: "render",
  OBJECT: "object"
};
var NodeType = {
  BOOLEAN: "bool",
  INTEGER: "int",
  FLOAT: "float",
  VECTOR2: "vec2",
  VECTOR3: "vec3",
  VECTOR4: "vec4",
  MATRIX2: "mat2",
  MATRIX3: "mat3",
  MATRIX4: "mat4"
};
var NodeAccess = {
  READ_ONLY: "readOnly",
  WRITE_ONLY: "writeOnly",
  READ_WRITE: "readWrite"
};
var defaultShaderStages = ["fragment", "vertex"];
var defaultBuildStages = ["setup", "analyze", "generate"];
var shaderStages = [...defaultShaderStages, "compute"];
var vectorComponents = ["x", "y", "z", "w"];
var _parentBuildStage = {
  analyze: "setup",
  generate: "analyze"
};
var _nodeId = 0;
var Node4 = class extends EventDispatcher {
  static get type() {
    return "Node";
  }
  /**
   * Constructs a new node.
   *
   * @param {?string} nodeType - The node type.
   */
  constructor(nodeType = null) {
    super();
    this.nodeType = nodeType;
    this.updateType = NodeUpdateType.NONE;
    this.updateBeforeType = NodeUpdateType.NONE;
    this.updateAfterType = NodeUpdateType.NONE;
    this.uuid = MathUtils.generateUUID();
    this.version = 0;
    this.name = "";
    this.global = false;
    this.parents = false;
    this.isNode = true;
    this._beforeNodes = null;
    this._cacheKey = null;
    this._cacheKeyVersion = 0;
    Object.defineProperty(this, "id", { value: _nodeId++ });
  }
  /**
   * Set this property to `true` when the node should be regenerated.
   *
   * @type {boolean}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(value) {
    if (value === true) {
      this.version++;
    }
  }
  /**
   * The type of the class. The value is usually the constructor name.
   *
   * @type {string}
  	 * @readonly
   */
  get type() {
    return this.constructor.type;
  }
  /**
   * Convenient method for defining {@link Node#update}.
   *
   * @param {Function} callback - The update method.
   * @param {string} updateType - The update type.
   * @return {Node} A reference to this node.
   */
  onUpdate(callback, updateType) {
    this.updateType = updateType;
    this.update = callback.bind(this);
    return this;
  }
  /**
   * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but
   * this method automatically sets the update type to `FRAME`.
   *
   * @param {Function} callback - The update method.
   * @return {Node} A reference to this node.
   */
  onFrameUpdate(callback) {
    return this.onUpdate(callback, NodeUpdateType.FRAME);
  }
  /**
   * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but
   * this method automatically sets the update type to `RENDER`.
   *
   * @param {Function} callback - The update method.
   * @return {Node} A reference to this node.
   */
  onRenderUpdate(callback) {
    return this.onUpdate(callback, NodeUpdateType.RENDER);
  }
  /**
   * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but
   * this method automatically sets the update type to `OBJECT`.
   *
   * @param {Function} callback - The update method.
   * @return {Node} A reference to this node.
   */
  onObjectUpdate(callback) {
    return this.onUpdate(callback, NodeUpdateType.OBJECT);
  }
  /**
   * Convenient method for defining {@link Node#updateReference}.
   *
   * @param {Function} callback - The update method.
   * @return {Node} A reference to this node.
   */
  onReference(callback) {
    this.updateReference = callback.bind(this);
    return this;
  }
  /**
   * Nodes might refer to other objects like materials. This method allows to dynamically update the reference
   * to such objects based on a given state (e.g. the current node frame or builder).
   *
   * @param {any} state - This method can be invocated in different contexts so `state` can refer to any object type.
   * @return {any} The updated reference.
   */
  updateReference() {
    return this;
  }
  /**
   * By default this method returns the value of the {@link Node#global} flag. This method
   * can be overwritten in derived classes if an analytical way is required to determine the
   * global cache referring to the current shader-stage.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {boolean} Whether this node is global or not.
   */
  isGlobal() {
    return this.global;
  }
  /**
   * Generator function that can be used to iterate over the child nodes.
   *
   * @generator
   * @yields {Node} A child node.
   */
  *getChildren() {
    for (const { childNode } of this._getChildren()) {
      yield childNode;
    }
  }
  /**
   * Calling this method dispatches the `dispose` event. This event can be used
   * to register event listeners for clean up tasks.
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  /**
   * Callback for {@link Node#traverse}.
   *
   * @callback traverseCallback
   * @param {Node} node - The current node.
   */
  /**
   * Can be used to traverse through the node's hierarchy.
   *
   * @param {traverseCallback} callback - A callback that is executed per node.
   */
  traverse(callback) {
    callback(this);
    for (const childNode of this.getChildren()) {
      childNode.traverse(callback);
    }
  }
  /**
   * Returns the child nodes of this node.
   *
   * @private
   * @param {Set<Node>} [ignores=new Set()] - A set of nodes to ignore during the search to avoid circular references.
   * @returns {Array<Object>} An array of objects describing the child nodes.
   */
  _getChildren(ignores = /* @__PURE__ */ new Set()) {
    const children2 = [];
    ignores.add(this);
    for (const property3 of Object.getOwnPropertyNames(this)) {
      const object = this[property3];
      if (property3.startsWith("_") === true || ignores.has(object)) continue;
      if (Array.isArray(object) === true) {
        for (let i2 = 0; i2 < object.length; i2++) {
          const child = object[i2];
          if (child && child.isNode === true) {
            children2.push({ property: property3, index: i2, childNode: child });
          }
        }
      } else if (object && object.isNode === true) {
        children2.push({ property: property3, childNode: object });
      } else if (object && Object.getPrototypeOf(object) === Object.prototype) {
        for (const subProperty in object) {
          if (subProperty.startsWith("_") === true) continue;
          const child = object[subProperty];
          if (child && child.isNode === true) {
            children2.push({ property: property3, index: subProperty, childNode: child });
          }
        }
      }
    }
    return children2;
  }
  /**
   * Returns the cache key for this node.
   *
   * @param {boolean} [force=false] - When set to `true`, a recomputation of the cache key is forced.
   * @param {Set<Node>} [ignores=null] - A set of nodes to ignore during the computation of the cache key.
   * @return {number} The cache key of the node.
   */
  getCacheKey(force = false, ignores = null) {
    force = force || this.version !== this._cacheKeyVersion;
    if (force === true || this._cacheKey === null) {
      if (ignores === null) ignores = /* @__PURE__ */ new Set();
      const values2 = [];
      for (const { property: property3, childNode } of this._getChildren(ignores)) {
        values2.push(hashString(property3.slice(0, -4)), childNode.getCacheKey(force, ignores));
      }
      this._cacheKey = hash$1(hashArray(values2), this.customCacheKey());
      this._cacheKeyVersion = this.version;
    }
    return this._cacheKey;
  }
  /**
   * Generate a custom cache key for this node.
   *
   * @return {number} The cache key of the node.
   */
  customCacheKey() {
    return this.id;
  }
  /**
   * Returns the references to this node which is by default `this`.
   *
   * @return {Node} A reference to this node.
   */
  getScope() {
    return this;
  }
  /**
   * Returns the hash of the node which is used to identify the node. By default it's
   * the {@link Node#uuid} however derived node classes might have to overwrite this method
   * depending on their implementation.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The hash.
   */
  getHash() {
    return this.uuid;
  }
  /**
   * Returns the update type of {@link Node#update}.
   *
   * @return {NodeUpdateType} The update type.
   */
  getUpdateType() {
    return this.updateType;
  }
  /**
   * Returns the update type of {@link Node#updateBefore}.
   *
   * @return {NodeUpdateType} The update type.
   */
  getUpdateBeforeType() {
    return this.updateBeforeType;
  }
  /**
   * Returns the update type of {@link Node#updateAfter}.
   *
   * @return {NodeUpdateType} The update type.
   */
  getUpdateAfterType() {
    return this.updateAfterType;
  }
  /**
   * Certain types are composed of multiple elements. For example a `vec3`
   * is composed of three `float` values. This method returns the type of
   * these elements.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The type of the node.
   */
  getElementType(builder) {
    const type = this.getNodeType(builder);
    const elementType = builder.getElementType(type);
    return elementType;
  }
  /**
   * Returns the node member type for the given name.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} name - The name of the member.
   * @return {string} The type of the node.
   */
  getMemberType() {
    return "void";
  }
  /**
   * Returns the node's type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The type of the node.
   */
  getNodeType(builder) {
    const nodeProperties = builder.getNodeProperties(this);
    if (nodeProperties.outputNode) {
      return nodeProperties.outputNode.getNodeType(builder);
    }
    return this.nodeType;
  }
  /**
   * This method is used during the build process of a node and ensures
   * equal nodes are not built multiple times but just once. For example if
   * `attribute( 'uv' )` is used multiple times by the user, the build
   * process makes sure to process just the first node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node} The shared node if possible. Otherwise `this` is returned.
   */
  getShared(builder) {
    const hash2 = this.getHash(builder);
    const nodeFromHash = builder.getNodeFromHash(hash2);
    return nodeFromHash || this;
  }
  /**
   * Returns the number of elements in the node array.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {?number} The number of elements in the node array.
   */
  getArrayCount() {
    return null;
  }
  /**
   * Represents the setup stage which is the first step of the build process, see {@link Node#build} method.
   * This method is often overwritten in derived modules to prepare the node which is used as a node's output/result.
   * If an output node is prepared, then it must be returned in the `return` statement of the derived module's setup function.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {?Node} The output node.
   */
  setup(builder) {
    const nodeProperties = builder.getNodeProperties(this);
    let index8 = 0;
    for (const childNode of this.getChildren()) {
      nodeProperties["node" + index8++] = childNode;
    }
    return nodeProperties.outputNode || null;
  }
  /**
   * Represents the analyze stage which is the second step of the build process, see {@link Node#build} method.
   * This stage analyzes the node hierarchy and ensures descendent nodes are built.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {?Node} output - The target output node.
   */
  analyze(builder, output2 = null) {
    const usageCount = builder.increaseUsage(this);
    if (this.parents === true) {
      const nodeData = builder.getDataFromNode(this, "any");
      nodeData.stages = nodeData.stages || {};
      nodeData.stages[builder.shaderStage] = nodeData.stages[builder.shaderStage] || [];
      nodeData.stages[builder.shaderStage].push(output2);
    }
    if (usageCount === 1) {
      const nodeProperties = builder.getNodeProperties(this);
      for (const childNode of Object.values(nodeProperties)) {
        if (childNode && childNode.isNode === true) {
          childNode.build(builder, this);
        }
      }
    }
  }
  /**
   * Represents the generate stage which is the third step of the build process, see {@link Node#build} method.
   * This state builds the output node and returns the resulting shader string.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {?string} [output] - Can be used to define the output type.
   * @return {?string} The generated shader string.
   */
  generate(builder, output2) {
    const { outputNode } = builder.getNodeProperties(this);
    if (outputNode && outputNode.isNode === true) {
      return outputNode.build(builder, output2);
    }
  }
  /**
   * The method can be implemented to update the node's internal state before it is used to render an object.
   * The {@link Node#updateBeforeType} property defines how often the update is executed.
   *
   * @abstract
   * @param {NodeFrame} frame - A reference to the current node frame.
   * @return {?boolean} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).
   */
  updateBefore() {
    warn("Abstract function.");
  }
  /**
   * The method can be implemented to update the node's internal state after it was used to render an object.
   * The {@link Node#updateAfterType} property defines how often the update is executed.
   *
   * @abstract
   * @param {NodeFrame} frame - A reference to the current node frame.
   * @return {?boolean} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).
   */
  updateAfter() {
    warn("Abstract function.");
  }
  /**
   * The method can be implemented to update the node's internal state when it is used to render an object.
   * The {@link Node#updateType} property defines how often the update is executed.
   *
   * @abstract
   * @param {NodeFrame} frame - A reference to the current node frame.
   * @return {?boolean} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).
   */
  update() {
    warn("Abstract function.");
  }
  before(node) {
    if (this._beforeNodes === null) this._beforeNodes = [];
    this._beforeNodes.push(node);
    return this;
  }
  /**
   * This method performs the build of a node. The behavior and return value depend on the current build stage:
   * - **setup**: Prepares the node and its children for the build process. This process can also create new nodes. Returns the node itself or a variant.
   * - **analyze**: Analyzes the node hierarchy for optimizations in the code generation stage. Returns `null`.
   * - **generate**: Generates the shader code for the node. Returns the generated shader string.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {?(string|Node)} [output=null] - Can be used to define the output type.
   * @return {?(Node|string)} The result of the build process, depending on the build stage.
   */
  build(builder, output2 = null) {
    const refNode = this.getShared(builder);
    if (this !== refNode) {
      return refNode.build(builder, output2);
    }
    if (this._beforeNodes !== null) {
      const currentBeforeNodes = this._beforeNodes;
      this._beforeNodes = null;
      for (const beforeNode of currentBeforeNodes) {
        beforeNode.build(builder, output2);
      }
      this._beforeNodes = currentBeforeNodes;
    }
    const nodeData = builder.getDataFromNode(this);
    nodeData.buildStages = nodeData.buildStages || {};
    nodeData.buildStages[builder.buildStage] = true;
    const parentBuildStage = _parentBuildStage[builder.buildStage];
    if (parentBuildStage && nodeData.buildStages[parentBuildStage] !== true) {
      const previousBuildStage = builder.getBuildStage();
      builder.setBuildStage(parentBuildStage);
      this.build(builder);
      builder.setBuildStage(previousBuildStage);
    }
    builder.addNode(this);
    builder.addChain(this);
    let result2 = null;
    const buildStage = builder.getBuildStage();
    if (buildStage === "setup") {
      this.updateReference(builder);
      const properties = builder.getNodeProperties(this);
      if (properties.initialized !== true) {
        properties.initialized = true;
        properties.outputNode = this.setup(builder) || properties.outputNode || null;
        for (const childNode of Object.values(properties)) {
          if (childNode && childNode.isNode === true) {
            if (childNode.parents === true) {
              const childProperties = builder.getNodeProperties(childNode);
              childProperties.parents = childProperties.parents || [];
              childProperties.parents.push(this);
            }
            childNode.build(builder);
          }
        }
      }
      result2 = properties.outputNode;
    } else if (buildStage === "analyze") {
      this.analyze(builder, output2);
    } else if (buildStage === "generate") {
      const isGenerateOnce = this.generate.length < 2;
      if (isGenerateOnce) {
        const type = this.getNodeType(builder);
        const nodeData2 = builder.getDataFromNode(this);
        result2 = nodeData2.snippet;
        if (result2 === void 0) {
          if (nodeData2.generated === void 0) {
            nodeData2.generated = true;
            result2 = this.generate(builder) || "";
            nodeData2.snippet = result2;
          } else {
            warn("Node: Recursion detected.", this);
            result2 = "/* Recursion detected. */";
          }
        } else if (nodeData2.flowCodes !== void 0 && builder.context.nodeBlock !== void 0) {
          builder.addFlowCodeHierarchy(this, builder.context.nodeBlock);
        }
        result2 = builder.format(result2, type, output2);
      } else {
        result2 = this.generate(builder, output2) || "";
      }
      if (result2 === "" && output2 !== null && output2 !== "void" && output2 !== "OutputType") {
        error(`TSL: Invalid generated code, expected a "${output2}".`);
        result2 = builder.generateConst(output2);
      }
    }
    builder.removeChain(this);
    builder.addSequentialNode(this);
    return result2;
  }
  /**
   * Returns the child nodes as a JSON object.
   *
   * @return {Generator<Object>} An iterable list of serialized child objects as JSON.
   */
  getSerializeChildren() {
    return this._getChildren();
  }
  /**
   * Serializes the node to JSON.
   *
   * @param {Object} json - The output JSON object.
   */
  serialize(json) {
    const nodeChildren = this.getSerializeChildren();
    const inputNodes = {};
    for (const { property: property3, index: index8, childNode } of nodeChildren) {
      if (index8 !== void 0) {
        if (inputNodes[property3] === void 0) {
          inputNodes[property3] = Number.isInteger(index8) ? [] : {};
        }
        inputNodes[property3][index8] = childNode.toJSON(json.meta).uuid;
      } else {
        inputNodes[property3] = childNode.toJSON(json.meta).uuid;
      }
    }
    if (Object.keys(inputNodes).length > 0) {
      json.inputNodes = inputNodes;
    }
  }
  /**
   * Deserializes the node from the given JSON.
   *
   * @param {Object} json - The JSON object.
   */
  deserialize(json) {
    if (json.inputNodes !== void 0) {
      const nodes = json.meta.nodes;
      for (const property3 in json.inputNodes) {
        if (Array.isArray(json.inputNodes[property3])) {
          const inputArray = [];
          for (const uuid of json.inputNodes[property3]) {
            inputArray.push(nodes[uuid]);
          }
          this[property3] = inputArray;
        } else if (typeof json.inputNodes[property3] === "object") {
          const inputObject = {};
          for (const subProperty in json.inputNodes[property3]) {
            const uuid = json.inputNodes[property3][subProperty];
            inputObject[subProperty] = nodes[uuid];
          }
          this[property3] = inputObject;
        } else {
          const uuid = json.inputNodes[property3];
          this[property3] = nodes[uuid];
        }
      }
    }
  }
  /**
   * Serializes the node into the three.js JSON Object/Scene format.
   *
   * @param {?Object} meta - An optional JSON object that already holds serialized data from other scene objects.
   * @return {Object} The serialized node.
   */
  toJSON(meta) {
    const { uuid, type } = this;
    const isRoot = meta === void 0 || typeof meta === "string";
    if (isRoot) {
      meta = {
        textures: {},
        images: {},
        nodes: {}
      };
    }
    let data = meta.nodes[uuid];
    if (data === void 0) {
      data = {
        uuid,
        type,
        meta,
        metadata: {
          version: 4.7,
          type: "Node",
          generator: "Node.toJSON"
        }
      };
      if (isRoot !== true) meta.nodes[data.uuid] = data;
      this.serialize(data);
      delete data.meta;
    }
    function extractFromCache(cache2) {
      const values2 = [];
      for (const key in cache2) {
        const data2 = cache2[key];
        delete data2.metadata;
        values2.push(data2);
      }
      return values2;
    }
    if (isRoot) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const nodes = extractFromCache(meta.nodes);
      if (textures.length > 0) data.textures = textures;
      if (images.length > 0) data.images = images;
      if (nodes.length > 0) data.nodes = nodes;
    }
    return data;
  }
};
var ArrayElementNode = class extends Node4 {
  // @TODO: If extending from TempNode it breaks webgpu_compute
  static get type() {
    return "ArrayElementNode";
  }
  /**
   * Constructs an array element node.
   *
   * @param {Node} node - The array-like node.
   * @param {Node} indexNode - The index node that defines the element access.
   */
  constructor(node, indexNode) {
    super();
    this.node = node;
    this.indexNode = indexNode;
    this.isArrayElementNode = true;
  }
  /**
   * This method is overwritten since the node type is inferred from the array-like node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    return this.node.getElementType(builder);
  }
  /**
   * This method is overwritten since the member type is inferred from the array-like node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} name - The member name.
   * @return {string} The member type.
   */
  getMemberType(builder, name) {
    return this.node.getMemberType(builder, name);
  }
  generate(builder) {
    const indexType = this.indexNode.getNodeType(builder);
    const nodeSnippet = this.node.build(builder);
    const indexSnippet = this.indexNode.build(builder, !builder.isVector(indexType) && builder.isInteger(indexType) ? indexType : "uint");
    return `${nodeSnippet}[ ${indexSnippet} ]`;
  }
};
var ConvertNode = class extends Node4 {
  static get type() {
    return "ConvertNode";
  }
  /**
   * Constructs a new convert node.
   *
   * @param {Node} node - The node which type should be converted.
   * @param {string} convertTo - The target node type. Multiple types can be defined by separating them with a `|` sign.
   */
  constructor(node, convertTo) {
    super();
    this.node = node;
    this.convertTo = convertTo;
  }
  /**
   * This method is overwritten since the implementation tries to infer the best
   * matching type from the {@link ConvertNode#convertTo} property.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    const requestType = this.node.getNodeType(builder);
    let convertTo = null;
    for (const overloadingType of this.convertTo.split("|")) {
      if (convertTo === null || builder.getTypeLength(requestType) === builder.getTypeLength(overloadingType)) {
        convertTo = overloadingType;
      }
    }
    return convertTo;
  }
  serialize(data) {
    super.serialize(data);
    data.convertTo = this.convertTo;
  }
  deserialize(data) {
    super.deserialize(data);
    this.convertTo = data.convertTo;
  }
  generate(builder, output2) {
    const node = this.node;
    const type = this.getNodeType(builder);
    const snippet = node.build(builder, type);
    return builder.format(snippet, type, output2);
  }
};
var TempNode = class extends Node4 {
  static get type() {
    return "TempNode";
  }
  /**
   * Constructs a temp node.
   *
   * @param {?string} nodeType - The node type.
   */
  constructor(nodeType = null) {
    super(nodeType);
    this.isTempNode = true;
  }
  /**
   * Whether this node is used more than once in context of other nodes.
   *
   * @param {NodeBuilder} builder - The node builder.
   * @return {boolean} A flag that indicates if there is more than one dependency to other nodes.
   */
  hasDependencies(builder) {
    return builder.getDataFromNode(this).usageCount > 1;
  }
  build(builder, output2) {
    const buildStage = builder.getBuildStage();
    if (buildStage === "generate") {
      const type = builder.getVectorType(this.getNodeType(builder, output2));
      const nodeData = builder.getDataFromNode(this);
      if (nodeData.propertyName !== void 0) {
        return builder.format(nodeData.propertyName, type, output2);
      } else if (type !== "void" && output2 !== "void" && this.hasDependencies(builder)) {
        const snippet = super.build(builder, type);
        const nodeVar = builder.getVarFromNode(this, null, type);
        const propertyName = builder.getPropertyName(nodeVar);
        builder.addLineFlowCode(`${propertyName} = ${snippet}`, this);
        nodeData.snippet = snippet;
        nodeData.propertyName = propertyName;
        return builder.format(nodeData.propertyName, type, output2);
      }
    }
    return super.build(builder, output2);
  }
};
var JoinNode = class extends TempNode {
  static get type() {
    return "JoinNode";
  }
  /**
   * Constructs a new join node.
   *
   * @param {Array<Node>} nodes - An array of nodes that should be joined.
   * @param {?string} [nodeType=null] - The node type.
   */
  constructor(nodes = [], nodeType = null) {
    super(nodeType);
    this.nodes = nodes;
  }
  /**
   * This method is overwritten since the node type must be inferred from the
   * joined data length if not explicitly defined.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    if (this.nodeType !== null) {
      return builder.getVectorType(this.nodeType);
    }
    return builder.getTypeFromLength(this.nodes.reduce((count2, cur) => count2 + builder.getTypeLength(cur.getNodeType(builder)), 0));
  }
  generate(builder, output2) {
    const type = this.getNodeType(builder);
    const maxLength = builder.getTypeLength(type);
    const nodes = this.nodes;
    const primitiveType = builder.getComponentType(type);
    const snippetValues = [];
    let length2 = 0;
    for (const input of nodes) {
      if (length2 >= maxLength) {
        error(`TSL: Length of parameters exceeds maximum length of function '${type}()' type.`);
        break;
      }
      let inputType = input.getNodeType(builder);
      let inputTypeLength = builder.getTypeLength(inputType);
      let inputSnippet;
      if (length2 + inputTypeLength > maxLength) {
        error(`TSL: Length of '${type}()' data exceeds maximum length of output type.`);
        inputTypeLength = maxLength - length2;
        inputType = builder.getTypeFromLength(inputTypeLength);
      }
      length2 += inputTypeLength;
      inputSnippet = input.build(builder, inputType);
      const inputPrimitiveType = builder.getComponentType(inputType);
      if (inputPrimitiveType !== primitiveType) {
        const targetType = builder.getTypeFromLength(inputTypeLength, primitiveType);
        inputSnippet = builder.format(inputSnippet, inputType, targetType);
      }
      snippetValues.push(inputSnippet);
    }
    const snippet = `${builder.getType(type)}( ${snippetValues.join(", ")} )`;
    return builder.format(snippet, type, output2);
  }
};
var _stringVectorComponents = vectorComponents.join("");
var SplitNode = class extends Node4 {
  static get type() {
    return "SplitNode";
  }
  /**
   * Constructs a new split node.
   *
   * @param {Node} node - The node that should be accessed.
   * @param {string} [components='x'] - The components that should be accessed.
   */
  constructor(node, components = "x") {
    super();
    this.node = node;
    this.components = components;
    this.isSplitNode = true;
  }
  /**
   * Returns the vector length which is computed based on the requested components.
   *
   * @return {number} The vector length.
   */
  getVectorLength() {
    let vectorLength = this.components.length;
    for (const c5 of this.components) {
      vectorLength = Math.max(vectorComponents.indexOf(c5) + 1, vectorLength);
    }
    return vectorLength;
  }
  /**
   * Returns the component type of the node's type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The component type.
   */
  getComponentType(builder) {
    return builder.getComponentType(this.node.getNodeType(builder));
  }
  /**
   * This method is overwritten since the node type is inferred from requested components.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    return builder.getTypeFromLength(this.components.length, this.getComponentType(builder));
  }
  /**
   * Returns the scope of the node.
   *
   * @return {Node} The scope of the node.
   */
  getScope() {
    return this.node.getScope();
  }
  generate(builder, output2) {
    const node = this.node;
    const nodeTypeLength = builder.getTypeLength(node.getNodeType(builder));
    let snippet = null;
    if (nodeTypeLength > 1) {
      let type = null;
      const componentsLength = this.getVectorLength();
      if (componentsLength >= nodeTypeLength) {
        type = builder.getTypeFromLength(this.getVectorLength(), this.getComponentType(builder));
      }
      const nodeSnippet = node.build(builder, type);
      if (this.components.length === nodeTypeLength && this.components === _stringVectorComponents.slice(0, this.components.length)) {
        snippet = builder.format(nodeSnippet, type, output2);
      } else {
        snippet = builder.format(`${nodeSnippet}.${this.components}`, this.getNodeType(builder), output2);
      }
    } else {
      snippet = node.build(builder, output2);
    }
    return snippet;
  }
  serialize(data) {
    super.serialize(data);
    data.components = this.components;
  }
  deserialize(data) {
    super.deserialize(data);
    this.components = data.components;
  }
};
var SetNode = class extends TempNode {
  static get type() {
    return "SetNode";
  }
  /**
   * Constructs a new set node.
   *
   * @param {Node} sourceNode - The node that should be updated.
   * @param {string} components - The components that should be updated.
   * @param {Node} targetNode - The value node.
   */
  constructor(sourceNode, components, targetNode) {
    super();
    this.sourceNode = sourceNode;
    this.components = components;
    this.targetNode = targetNode;
  }
  /**
   * This method is overwritten since the node type is inferred from {@link SetNode#sourceNode}.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    return this.sourceNode.getNodeType(builder);
  }
  generate(builder) {
    const { sourceNode, components, targetNode } = this;
    const sourceType = this.getNodeType(builder);
    const componentType = builder.getComponentType(targetNode.getNodeType(builder));
    const targetType = builder.getTypeFromLength(components.length, componentType);
    const targetSnippet = targetNode.build(builder, targetType);
    const sourceSnippet = sourceNode.build(builder, sourceType);
    const length2 = builder.getTypeLength(sourceType);
    const snippetValues = [];
    for (let i2 = 0; i2 < length2; i2++) {
      const component = vectorComponents[i2];
      if (component === components[0]) {
        snippetValues.push(targetSnippet);
        i2 += components.length - 1;
      } else {
        snippetValues.push(sourceSnippet + "." + component);
      }
    }
    return `${builder.getType(sourceType)}( ${snippetValues.join(", ")} )`;
  }
};
var FlipNode = class extends TempNode {
  static get type() {
    return "FlipNode";
  }
  /**
   * Constructs a new flip node.
   *
   * @param {Node} sourceNode - The node which component(s) should be flipped.
   * @param {string} components - The components that should be flipped e.g. `'x'` or `'xy'`.
   */
  constructor(sourceNode, components) {
    super();
    this.sourceNode = sourceNode;
    this.components = components;
  }
  /**
   * This method is overwritten since the node type is inferred from the source node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    return this.sourceNode.getNodeType(builder);
  }
  generate(builder) {
    const { components, sourceNode } = this;
    const sourceType = this.getNodeType(builder);
    const sourceSnippet = sourceNode.build(builder);
    const sourceCache = builder.getVarFromNode(this);
    const sourceProperty = builder.getPropertyName(sourceCache);
    builder.addLineFlowCode(sourceProperty + " = " + sourceSnippet, this);
    const length2 = builder.getTypeLength(sourceType);
    const snippetValues = [];
    let componentIndex = 0;
    for (let i2 = 0; i2 < length2; i2++) {
      const component = vectorComponents[i2];
      if (component === components[componentIndex]) {
        snippetValues.push("1.0 - " + (sourceProperty + "." + component));
        componentIndex++;
      } else {
        snippetValues.push(sourceProperty + "." + component);
      }
    }
    return `${builder.getType(sourceType)}( ${snippetValues.join(", ")} )`;
  }
};
var InputNode = class extends Node4 {
  static get type() {
    return "InputNode";
  }
  /**
   * Constructs a new input node.
   *
   * @param {any} value - The value of this node. This can be any JS primitive, functions, array buffers or even three.js objects (vector, matrices, colors).
   * @param {?string} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.
   */
  constructor(value, nodeType = null) {
    super(nodeType);
    this.isInputNode = true;
    this.value = value;
    this.precision = null;
  }
  getNodeType() {
    if (this.nodeType === null) {
      return getValueType(this.value);
    }
    return this.nodeType;
  }
  /**
   * Returns the input type of the node which is by default the node type. Derived modules
   * might overwrite this method and use a fixed type or compute one analytically.
   *
   * A typical example for different input and node types are textures. The input type of a
   * normal RGBA texture is `texture` whereas its node type is `vec4`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType(builder) {
    return this.getNodeType(builder);
  }
  /**
   * Sets the precision to the given value. The method can be
   * overwritten in derived classes if the final precision must be computed
   * analytically.
   *
   * @param {('low'|'medium'|'high')} precision - The precision of the input value in the shader.
   * @return {InputNode} A reference to this node.
   */
  setPrecision(precision) {
    this.precision = precision;
    return this;
  }
  serialize(data) {
    super.serialize(data);
    data.value = this.value;
    if (this.value && this.value.toArray) data.value = this.value.toArray();
    data.valueType = getValueType(this.value);
    data.nodeType = this.nodeType;
    if (data.valueType === "ArrayBuffer") data.value = arrayBufferToBase64(data.value);
    data.precision = this.precision;
  }
  deserialize(data) {
    super.deserialize(data);
    this.nodeType = data.nodeType;
    this.value = Array.isArray(data.value) ? getValueFromType(data.valueType, ...data.value) : data.value;
    this.precision = data.precision || null;
    if (this.value && this.value.fromArray) this.value = this.value.fromArray(data.value);
  }
  generate() {
    warn("Abstract function.");
  }
};
var _regNum = /float|u?int/;
var ConstNode = class extends InputNode {
  static get type() {
    return "ConstNode";
  }
  /**
   * Constructs a new input node.
   *
   * @param {any} value - The value of this node. Usually a JS primitive or three.js object (vector, matrix, color).
   * @param {?string} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.
   */
  constructor(value, nodeType = null) {
    super(value, nodeType);
    this.isConstNode = true;
  }
  /**
   * Generates the shader string of the value with the current node builder.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The generated value as a shader string.
   */
  generateConst(builder) {
    return builder.generateConst(this.getNodeType(builder), this.value);
  }
  generate(builder, output2) {
    const type = this.getNodeType(builder);
    if (_regNum.test(type) && _regNum.test(output2)) {
      return builder.generateConst(output2, this.value);
    }
    return builder.format(this.generateConst(builder), type, output2);
  }
};
var MemberNode = class extends Node4 {
  static get type() {
    return "MemberNode";
  }
  /**
   * Constructs a member node.
   *
   * @param {Node} structNode - The struct node.
   * @param {string} property - The property name.
   */
  constructor(structNode, property3) {
    super();
    this.structNode = structNode;
    this.property = property3;
    this.isMemberNode = true;
  }
  hasMember(builder) {
    if (this.structNode.isMemberNode) {
      if (this.structNode.hasMember(builder) === false) {
        return false;
      }
    }
    return this.structNode.getMemberType(builder, this.property) !== "void";
  }
  getNodeType(builder) {
    if (this.hasMember(builder) === false) {
      return "float";
    }
    return this.structNode.getMemberType(builder, this.property);
  }
  getMemberType(builder, name) {
    if (this.hasMember(builder) === false) {
      return "float";
    }
    const type = this.getNodeType(builder);
    const struct2 = builder.getStructTypeNode(type);
    return struct2.getMemberType(builder, name);
  }
  generate(builder) {
    if (this.hasMember(builder) === false) {
      warn(`TSL: Member "${this.property}" does not exist in struct.`);
      const type = this.getNodeType(builder);
      return builder.generateConst(type);
    }
    const propertyName = this.structNode.build(builder);
    return propertyName + "." + this.property;
  }
};
var currentStack = null;
var NodeElements = /* @__PURE__ */ new Map();
function addMethodChaining(name, nodeElement) {
  if (NodeElements.has(name)) {
    warn(`TSL: Redefinition of method chaining '${name}'.`);
    return;
  }
  if (typeof nodeElement !== "function") throw new Error(`THREE.TSL: Node element ${name} is not a function`);
  NodeElements.set(name, nodeElement);
  if (name !== "assign") {
    Node4.prototype[name] = function(...params) {
      return this.isStackNode ? this.addToStack(nodeElement(...params)) : nodeElement(this, ...params);
    };
    Node4.prototype[name + "Assign"] = function(...params) {
      return this.isStackNode ? this.assign(params[0], nodeElement(...params)) : this.assign(nodeElement(this, ...params));
    };
  }
}
var parseSwizzle = (props) => props.replace(/r|s/g, "x").replace(/g|t/g, "y").replace(/b|p/g, "z").replace(/a|q/g, "w");
var parseSwizzleAndSort = (props) => parseSwizzle(props).split("").sort().join("");
Node4.prototype.assign = function(...params) {
  if (this.isStackNode !== true) {
    if (currentStack !== null) {
      currentStack.assign(this, ...params);
    } else {
      error("TSL: No stack defined for assign operation. Make sure the assign is inside a Fn().");
    }
    return this;
  } else {
    const nodeElement = NodeElements.get("assign");
    return this.addToStack(nodeElement(...params));
  }
};
Node4.prototype.toVarIntent = function() {
  return this;
};
Node4.prototype.get = function(value) {
  return new MemberNode(this, value);
};
var proto = {};
function setProtoSwizzle(property3, altA, altB) {
  proto[property3] = proto[altA] = proto[altB] = {
    get() {
      this._cache = this._cache || {};
      let split3 = this._cache[property3];
      if (split3 === void 0) {
        split3 = new SplitNode(this, property3);
        this._cache[property3] = split3;
      }
      return split3;
    },
    set(value) {
      this[property3].assign(nodeObject(value));
    }
  };
  const propUpper = property3.toUpperCase();
  const altAUpper = altA.toUpperCase();
  const altBUpper = altB.toUpperCase();
  Node4.prototype["set" + propUpper] = Node4.prototype["set" + altAUpper] = Node4.prototype["set" + altBUpper] = function(value) {
    const swizzle = parseSwizzleAndSort(property3);
    return new SetNode(this, swizzle, nodeObject(value));
  };
  Node4.prototype["flip" + propUpper] = Node4.prototype["flip" + altAUpper] = Node4.prototype["flip" + altBUpper] = function() {
    const swizzle = parseSwizzleAndSort(property3);
    return new FlipNode(this, swizzle);
  };
}
var swizzleA = ["x", "y", "z", "w"];
var swizzleB = ["r", "g", "b", "a"];
var swizzleC = ["s", "t", "p", "q"];
for (let a3 = 0; a3 < 4; a3++) {
  let prop = swizzleA[a3];
  let altA = swizzleB[a3];
  let altB = swizzleC[a3];
  setProtoSwizzle(prop, altA, altB);
  for (let b = 0; b < 4; b++) {
    prop = swizzleA[a3] + swizzleA[b];
    altA = swizzleB[a3] + swizzleB[b];
    altB = swizzleC[a3] + swizzleC[b];
    setProtoSwizzle(prop, altA, altB);
    for (let c5 = 0; c5 < 4; c5++) {
      prop = swizzleA[a3] + swizzleA[b] + swizzleA[c5];
      altA = swizzleB[a3] + swizzleB[b] + swizzleB[c5];
      altB = swizzleC[a3] + swizzleC[b] + swizzleC[c5];
      setProtoSwizzle(prop, altA, altB);
      for (let d3 = 0; d3 < 4; d3++) {
        prop = swizzleA[a3] + swizzleA[b] + swizzleA[c5] + swizzleA[d3];
        altA = swizzleB[a3] + swizzleB[b] + swizzleB[c5] + swizzleB[d3];
        altB = swizzleC[a3] + swizzleC[b] + swizzleC[c5] + swizzleC[d3];
        setProtoSwizzle(prop, altA, altB);
      }
    }
  }
}
for (let i2 = 0; i2 < 32; i2++) {
  proto[i2] = {
    get() {
      this._cache = this._cache || {};
      let element2 = this._cache[i2];
      if (element2 === void 0) {
        element2 = new ArrayElementNode(this, new ConstNode(i2, "uint"));
        this._cache[i2] = element2;
      }
      return element2;
    },
    set(value) {
      this[i2].assign(nodeObject(value));
    }
  };
}
Object.defineProperties(Node4.prototype, proto);
var nodeBuilderFunctionsCacheMap = /* @__PURE__ */ new WeakMap();
var ShaderNodeObject = function(obj, altType = null) {
  const type = getValueType(obj);
  if (type === "node") {
    return obj;
  } else if (altType === null && (type === "float" || type === "boolean") || type && type !== "shader" && type !== "string") {
    return nodeObject(getConstNode(obj, altType));
  } else if (type === "shader") {
    return obj.isFn ? obj : Fn(obj);
  }
  return obj;
};
var ShaderNodeObjects = function(objects, altType = null) {
  for (const name in objects) {
    objects[name] = nodeObject(objects[name], altType);
  }
  return objects;
};
var ShaderNodeArray = function(array4, altType = null) {
  const len = array4.length;
  for (let i2 = 0; i2 < len; i2++) {
    array4[i2] = nodeObject(array4[i2], altType);
  }
  return array4;
};
var ShaderNodeProxy = function(NodeClass, scope = null, factor = null, settings = null) {
  function assignNode(node) {
    if (settings !== null) {
      node = nodeObject(Object.assign(node, settings));
      if (settings.intent === true) {
        node = node.toVarIntent();
      }
    } else {
      node = nodeObject(node);
    }
    return node;
  }
  let fn, name = scope, minParams, maxParams;
  function verifyParamsLimit(params) {
    let tslName;
    if (name) tslName = /[a-z]/i.test(name) ? name + "()" : name;
    else tslName = NodeClass.type;
    if (minParams !== void 0 && params.length < minParams) {
      error(`TSL: "${tslName}" parameter length is less than minimum required.`);
      return params.concat(new Array(minParams - params.length).fill(0));
    } else if (maxParams !== void 0 && params.length > maxParams) {
      error(`TSL: "${tslName}" parameter length exceeds limit.`);
      return params.slice(0, maxParams);
    }
    return params;
  }
  if (scope === null) {
    fn = (...params) => {
      return assignNode(new NodeClass(...nodeArray(verifyParamsLimit(params))));
    };
  } else if (factor !== null) {
    factor = nodeObject(factor);
    fn = (...params) => {
      return assignNode(new NodeClass(scope, ...nodeArray(verifyParamsLimit(params)), factor));
    };
  } else {
    fn = (...params) => {
      return assignNode(new NodeClass(scope, ...nodeArray(verifyParamsLimit(params))));
    };
  }
  fn.setParameterLength = (...params) => {
    if (params.length === 1) minParams = maxParams = params[0];
    else if (params.length === 2) [minParams, maxParams] = params;
    return fn;
  };
  fn.setName = (value) => {
    name = value;
    return fn;
  };
  return fn;
};
var ShaderNodeImmutable = function(NodeClass, ...params) {
  return new NodeClass(...nodeArray(params));
};
var ShaderCallNodeInternal = class extends Node4 {
  constructor(shaderNode, rawInputs) {
    super();
    this.shaderNode = shaderNode;
    this.rawInputs = rawInputs;
    this.isShaderCallNodeInternal = true;
  }
  getNodeType(builder) {
    return this.shaderNode.nodeType || this.getOutputNode(builder).getNodeType(builder);
  }
  getElementType(builder) {
    return this.getOutputNode(builder).getElementType(builder);
  }
  getMemberType(builder, name) {
    return this.getOutputNode(builder).getMemberType(builder, name);
  }
  call(builder) {
    const { shaderNode, rawInputs } = this;
    const properties = builder.getNodeProperties(shaderNode);
    const subBuild2 = builder.getClosestSubBuild(shaderNode.subBuilds) || "";
    const subBuildProperty = subBuild2 || "default";
    if (properties[subBuildProperty]) {
      return properties[subBuildProperty];
    }
    const previousSubBuildFn = builder.subBuildFn;
    const previousFnCall = builder.fnCall;
    builder.subBuildFn = subBuild2;
    builder.fnCall = this;
    let result2 = null;
    if (shaderNode.layout) {
      let functionNodesCacheMap = nodeBuilderFunctionsCacheMap.get(builder.constructor);
      if (functionNodesCacheMap === void 0) {
        functionNodesCacheMap = /* @__PURE__ */ new WeakMap();
        nodeBuilderFunctionsCacheMap.set(builder.constructor, functionNodesCacheMap);
      }
      let functionNode = functionNodesCacheMap.get(shaderNode);
      if (functionNode === void 0) {
        functionNode = nodeObject(builder.buildFunctionNode(shaderNode));
        functionNodesCacheMap.set(shaderNode, functionNode);
      }
      builder.addInclude(functionNode);
      const inputs = rawInputs ? getLayoutParameters(rawInputs) : null;
      result2 = nodeObject(functionNode.call(inputs));
    } else {
      const secureNodeBuilder = new Proxy(builder, {
        get: (target, property3, receiver) => {
          let value;
          if (Symbol.iterator === property3) {
            value = function* () {
              yield void 0;
            };
          } else {
            value = Reflect.get(target, property3, receiver);
          }
          return value;
        }
      });
      const inputs = rawInputs ? getProxyParameters(rawInputs) : null;
      const hasParameters = Array.isArray(rawInputs) ? rawInputs.length > 0 : rawInputs !== null;
      const jsFunc = shaderNode.jsFunc;
      const outputNode = hasParameters || jsFunc.length > 1 ? jsFunc(inputs, secureNodeBuilder) : jsFunc(secureNodeBuilder);
      result2 = nodeObject(outputNode);
    }
    builder.subBuildFn = previousSubBuildFn;
    builder.fnCall = previousFnCall;
    if (shaderNode.once) {
      properties[subBuildProperty] = result2;
    }
    return result2;
  }
  setupOutput(builder) {
    builder.addStack();
    builder.stack.outputNode = this.call(builder);
    return builder.removeStack();
  }
  getOutputNode(builder) {
    const properties = builder.getNodeProperties(this);
    const subBuildOutput = builder.getSubBuildOutput(this);
    properties[subBuildOutput] = properties[subBuildOutput] || this.setupOutput(builder);
    properties[subBuildOutput].subBuild = builder.getClosestSubBuild(this);
    return properties[subBuildOutput];
  }
  build(builder, output2 = null) {
    let result2 = null;
    const buildStage = builder.getBuildStage();
    const properties = builder.getNodeProperties(this);
    const subBuildOutput = builder.getSubBuildOutput(this);
    const outputNode = this.getOutputNode(builder);
    const previousFnCall = builder.fnCall;
    builder.fnCall = this;
    if (buildStage === "setup") {
      const subBuildInitialized = builder.getSubBuildProperty("initialized", this);
      if (properties[subBuildInitialized] !== true) {
        properties[subBuildInitialized] = true;
        properties[subBuildOutput] = this.getOutputNode(builder);
        properties[subBuildOutput].build(builder);
        if (this.shaderNode.subBuilds) {
          for (const node of builder.chaining) {
            const nodeData = builder.getDataFromNode(node, "any");
            nodeData.subBuilds = nodeData.subBuilds || /* @__PURE__ */ new Set();
            for (const subBuild2 of this.shaderNode.subBuilds) {
              nodeData.subBuilds.add(subBuild2);
            }
          }
        }
      }
      result2 = properties[subBuildOutput];
    } else if (buildStage === "analyze") {
      outputNode.build(builder, output2);
    } else if (buildStage === "generate") {
      result2 = outputNode.build(builder, output2) || "";
    }
    builder.fnCall = previousFnCall;
    return result2;
  }
};
function getLayoutParameters(params) {
  let output2;
  nodeObjects(params);
  const isArrayAsParameter = params[0] && (params[0].isNode || Object.getPrototypeOf(params[0]) !== Object.prototype);
  if (isArrayAsParameter) {
    output2 = [...params];
  } else {
    output2 = params[0];
  }
  return output2;
}
function getProxyParameters(params) {
  let index8 = 0;
  nodeObjects(params);
  return new Proxy(params, {
    get: (target, property3, receiver) => {
      let value;
      if (property3 === "length") {
        value = params.length;
        return value;
      }
      if (Symbol.iterator === property3) {
        value = function* () {
          for (const inputNode of params) {
            yield nodeObject(inputNode);
          }
        };
      } else {
        if (params.length > 0) {
          if (Object.getPrototypeOf(params[0]) === Object.prototype) {
            const objectTarget = params[0];
            if (objectTarget[property3] === void 0) {
              value = objectTarget[index8++];
            } else {
              value = Reflect.get(objectTarget, property3, receiver);
            }
          } else if (params[0] instanceof Node4) {
            if (params[property3] === void 0) {
              value = params[index8++];
            } else {
              value = Reflect.get(params, property3, receiver);
            }
          }
        } else {
          value = Reflect.get(target, property3, receiver);
        }
        value = nodeObject(value);
      }
      return value;
    }
  });
}
var ShaderNodeInternal = class extends Node4 {
  constructor(jsFunc, nodeType) {
    super(nodeType);
    this.jsFunc = jsFunc;
    this.layout = null;
    this.global = true;
    this.once = false;
  }
  setLayout(layout) {
    this.layout = layout;
    return this;
  }
  getLayout() {
    return this.layout;
  }
  call(rawInputs = null) {
    return new ShaderCallNodeInternal(this, rawInputs);
  }
  setup() {
    return this.call();
  }
};
var bools = [false, true];
var uints = [0, 1, 2, 3];
var ints = [-1, -2];
var floats = [0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / (Math.PI * 2), Math.PI / 2];
var boolsCacheMap = /* @__PURE__ */ new Map();
for (const bool2 of bools) boolsCacheMap.set(bool2, new ConstNode(bool2));
var uintsCacheMap = /* @__PURE__ */ new Map();
for (const uint2 of uints) uintsCacheMap.set(uint2, new ConstNode(uint2, "uint"));
var intsCacheMap = new Map([...uintsCacheMap].map((el) => new ConstNode(el.value, "int")));
for (const int2 of ints) intsCacheMap.set(int2, new ConstNode(int2, "int"));
var floatsCacheMap = new Map([...intsCacheMap].map((el) => new ConstNode(el.value)));
for (const float2 of floats) floatsCacheMap.set(float2, new ConstNode(float2));
for (const float2 of floats) floatsCacheMap.set(-float2, new ConstNode(-float2));
var cacheMaps = { bool: boolsCacheMap, uint: uintsCacheMap, ints: intsCacheMap, float: floatsCacheMap };
var constNodesCacheMap = new Map([...boolsCacheMap, ...floatsCacheMap]);
var getConstNode = (value, type) => {
  if (constNodesCacheMap.has(value)) {
    return constNodesCacheMap.get(value);
  } else if (value.isNode === true) {
    return value;
  } else {
    return new ConstNode(value, type);
  }
};
var ConvertType = function(type, cacheMap = null) {
  return (...params) => {
    for (const param of params) {
      if (param === void 0) {
        error(`TSL: Invalid parameter for the type "${type}".`);
        return new ConstNode(0, type);
      }
    }
    if (params.length === 0 || !["bool", "float", "int", "uint"].includes(type) && params.every((param) => {
      const paramType = typeof param;
      return paramType !== "object" && paramType !== "function";
    })) {
      params = [getValueFromType(type, ...params)];
    }
    if (params.length === 1 && cacheMap !== null && cacheMap.has(params[0])) {
      return nodeObjectIntent(cacheMap.get(params[0]));
    }
    if (params.length === 1) {
      const node = getConstNode(params[0], type);
      if (node.nodeType === type) return nodeObjectIntent(node);
      return nodeObjectIntent(new ConvertNode(node, type));
    }
    const nodes = params.map((param) => getConstNode(param));
    return nodeObjectIntent(new JoinNode(nodes, type));
  };
};
var defined = (v2) => typeof v2 === "object" && v2 !== null ? v2.value : v2;
var getConstNodeType = (value) => value !== void 0 && value !== null ? value.nodeType || value.convertTo || (typeof value === "string" ? value : null) : null;
function ShaderNode(jsFunc, nodeType) {
  return new ShaderNodeInternal(jsFunc, nodeType);
}
var nodeObject = (val, altType = null) => (
  /* new */
  ShaderNodeObject(val, altType)
);
var nodeObjectIntent = (val, altType = null) => (
  /* new */
  nodeObject(val, altType).toVarIntent()
);
var nodeObjects = (val, altType = null) => new ShaderNodeObjects(val, altType);
var nodeArray = (val, altType = null) => new ShaderNodeArray(val, altType);
var nodeProxy = (NodeClass, scope = null, factor = null, settings = null) => new ShaderNodeProxy(NodeClass, scope, factor, settings);
var nodeImmutable = (NodeClass, ...params) => new ShaderNodeImmutable(NodeClass, ...params);
var nodeProxyIntent = (NodeClass, scope = null, factor = null, settings = {}) => new ShaderNodeProxy(NodeClass, scope, factor, { ...settings, intent: true });
var fnId = 0;
var FnNode = class extends Node4 {
  constructor(jsFunc, layout = null) {
    super();
    let nodeType = null;
    if (layout !== null) {
      if (typeof layout === "object") {
        nodeType = layout.return;
      } else {
        if (typeof layout === "string") {
          nodeType = layout;
        } else {
          error("TSL: Invalid layout type.");
        }
        layout = null;
      }
    }
    this.shaderNode = new ShaderNode(jsFunc, nodeType);
    if (layout !== null) {
      this.setLayout(layout);
    }
    this.isFn = true;
  }
  setLayout(layout) {
    const nodeType = this.shaderNode.nodeType;
    if (typeof layout.inputs !== "object") {
      const fullLayout = {
        name: "fn" + fnId++,
        type: nodeType,
        inputs: []
      };
      for (const name in layout) {
        if (name === "return") continue;
        fullLayout.inputs.push({
          name,
          type: layout[name]
        });
      }
      layout = fullLayout;
    }
    this.shaderNode.setLayout(layout);
    return this;
  }
  getNodeType(builder) {
    return this.shaderNode.getNodeType(builder) || "float";
  }
  call(...params) {
    const fnCall = this.shaderNode.call(params);
    if (this.shaderNode.nodeType === "void") fnCall.toStack();
    return fnCall.toVarIntent();
  }
  once(subBuilds = null) {
    this.shaderNode.once = true;
    this.shaderNode.subBuilds = subBuilds;
    return this;
  }
  generate(builder) {
    const type = this.getNodeType(builder);
    error('TSL: "Fn()" was declared but not invoked. Try calling it like "Fn()( ...params )".');
    return builder.generateConst(type);
  }
};
function Fn(jsFunc, layout = null) {
  const instance2 = new FnNode(jsFunc, layout);
  return new Proxy(() => {
  }, {
    apply(target, thisArg, params) {
      return instance2.call(...params);
    },
    get(target, prop, receiver) {
      return Reflect.get(instance2, prop, receiver);
    },
    set(target, prop, value, receiver) {
      return Reflect.set(instance2, prop, value, receiver);
    }
  });
}
var setCurrentStack = (stack2) => {
  currentStack = stack2;
};
var getCurrentStack = () => currentStack;
var If = (...params) => currentStack.If(...params);
var Switch = (...params) => currentStack.Switch(...params);
function Stack(node) {
  if (currentStack) currentStack.addToStack(node);
  return node;
}
addMethodChaining("toStack", Stack);
var color2 = new ConvertType("color");
var float = new ConvertType("float", cacheMaps.float);
var int = new ConvertType("int", cacheMaps.ints);
var uint = new ConvertType("uint", cacheMaps.uint);
var bool = new ConvertType("bool", cacheMaps.bool);
var vec2 = new ConvertType("vec2");
var ivec2 = new ConvertType("ivec2");
var uvec2 = new ConvertType("uvec2");
var bvec2 = new ConvertType("bvec2");
var vec3 = new ConvertType("vec3");
var ivec3 = new ConvertType("ivec3");
var uvec3 = new ConvertType("uvec3");
var bvec3 = new ConvertType("bvec3");
var vec4 = new ConvertType("vec4");
var ivec4 = new ConvertType("ivec4");
var uvec4 = new ConvertType("uvec4");
var bvec4 = new ConvertType("bvec4");
var mat2 = new ConvertType("mat2");
var mat3 = new ConvertType("mat3");
var mat4 = new ConvertType("mat4");
var string = (value = "") => new ConstNode(value, "string");
var arrayBuffer = (value) => new ConstNode(value, "ArrayBuffer");
addMethodChaining("toColor", color2);
addMethodChaining("toFloat", float);
addMethodChaining("toInt", int);
addMethodChaining("toUint", uint);
addMethodChaining("toBool", bool);
addMethodChaining("toVec2", vec2);
addMethodChaining("toIVec2", ivec2);
addMethodChaining("toUVec2", uvec2);
addMethodChaining("toBVec2", bvec2);
addMethodChaining("toVec3", vec3);
addMethodChaining("toIVec3", ivec3);
addMethodChaining("toUVec3", uvec3);
addMethodChaining("toBVec3", bvec3);
addMethodChaining("toVec4", vec4);
addMethodChaining("toIVec4", ivec4);
addMethodChaining("toUVec4", uvec4);
addMethodChaining("toBVec4", bvec4);
addMethodChaining("toMat2", mat2);
addMethodChaining("toMat3", mat3);
addMethodChaining("toMat4", mat4);
var element = nodeProxy(ArrayElementNode).setParameterLength(2);
var convert = (node, types) => nodeObject(new ConvertNode(nodeObject(node), types));
var split = (node, channels) => nodeObject(new SplitNode(nodeObject(node), channels));
addMethodChaining("element", element);
addMethodChaining("convert", convert);
var append2 = (node) => {
  warn("TSL: append() has been renamed to Stack().");
  return Stack(node);
};
addMethodChaining("append", (node) => {
  warn("TSL: .append() has been renamed to .toStack().");
  return Stack(node);
});
var PropertyNode = class extends Node4 {
  static get type() {
    return "PropertyNode";
  }
  /**
   * Constructs a new property node.
   *
   * @param {string} nodeType - The type of the node.
   * @param {?string} [name=null] - The name of the property in the shader.
   * @param {boolean} [varying=false] - Whether this property is a varying or not.
   */
  constructor(nodeType, name = null, varying2 = false) {
    super(nodeType);
    this.name = name;
    this.varying = varying2;
    this.isPropertyNode = true;
    this.global = true;
  }
  customCacheKey() {
    return hashString(this.type + ":" + (this.name || "") + ":" + (this.varying ? "1" : "0"));
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  generate(builder) {
    let nodeVar;
    if (this.varying === true) {
      nodeVar = builder.getVaryingFromNode(this, this.name);
      nodeVar.needsInterpolation = true;
    } else {
      nodeVar = builder.getVarFromNode(this, this.name);
    }
    return builder.getPropertyName(nodeVar);
  }
};
var property = (type, name) => new PropertyNode(type, name);
var varyingProperty = (type, name) => new PropertyNode(type, name, true);
var diffuseColor = nodeImmutable(PropertyNode, "vec4", "DiffuseColor");
var diffuseContribution = nodeImmutable(PropertyNode, "vec3", "DiffuseContribution");
var emissive = nodeImmutable(PropertyNode, "vec3", "EmissiveColor");
var roughness = nodeImmutable(PropertyNode, "float", "Roughness");
var metalness = nodeImmutable(PropertyNode, "float", "Metalness");
var clearcoat = nodeImmutable(PropertyNode, "float", "Clearcoat");
var clearcoatRoughness = nodeImmutable(PropertyNode, "float", "ClearcoatRoughness");
var sheen = nodeImmutable(PropertyNode, "vec3", "Sheen");
var sheenRoughness = nodeImmutable(PropertyNode, "float", "SheenRoughness");
var iridescence = nodeImmutable(PropertyNode, "float", "Iridescence");
var iridescenceIOR = nodeImmutable(PropertyNode, "float", "IridescenceIOR");
var iridescenceThickness = nodeImmutable(PropertyNode, "float", "IridescenceThickness");
var alphaT = nodeImmutable(PropertyNode, "float", "AlphaT");
var anisotropy = nodeImmutable(PropertyNode, "float", "Anisotropy");
var anisotropyT = nodeImmutable(PropertyNode, "vec3", "AnisotropyT");
var anisotropyB = nodeImmutable(PropertyNode, "vec3", "AnisotropyB");
var specularColor = nodeImmutable(PropertyNode, "color", "SpecularColor");
var specularColorBlended = nodeImmutable(PropertyNode, "color", "SpecularColorBlended");
var specularF90 = nodeImmutable(PropertyNode, "float", "SpecularF90");
var shininess = nodeImmutable(PropertyNode, "float", "Shininess");
var output = nodeImmutable(PropertyNode, "vec4", "Output");
var dashSize = nodeImmutable(PropertyNode, "float", "dashSize");
var gapSize = nodeImmutable(PropertyNode, "float", "gapSize");
var pointWidth = nodeImmutable(PropertyNode, "float", "pointWidth");
var ior = nodeImmutable(PropertyNode, "float", "IOR");
var transmission = nodeImmutable(PropertyNode, "float", "Transmission");
var thickness = nodeImmutable(PropertyNode, "float", "Thickness");
var attenuationDistance = nodeImmutable(PropertyNode, "float", "AttenuationDistance");
var attenuationColor = nodeImmutable(PropertyNode, "color", "AttenuationColor");
var dispersion = nodeImmutable(PropertyNode, "float", "Dispersion");
var UniformGroupNode = class extends Node4 {
  static get type() {
    return "UniformGroupNode";
  }
  /**
   * Constructs a new uniform group node.
   *
   * @param {string} name - The name of the uniform group node.
   * @param {boolean} [shared=false] - Whether this uniform group node is shared or not.
   * @param {number} [order=1] - Influences the internal sorting.
   */
  constructor(name, shared = false, order = 1) {
    super("string");
    this.name = name;
    this.shared = shared;
    this.order = order;
    this.isUniformGroup = true;
  }
  serialize(data) {
    super.serialize(data);
    data.name = this.name;
    data.version = this.version;
    data.shared = this.shared;
  }
  deserialize(data) {
    super.deserialize(data);
    this.name = data.name;
    this.version = data.version;
    this.shared = data.shared;
  }
};
var uniformGroup = (name) => new UniformGroupNode(name);
var sharedUniformGroup = (name, order = 0) => new UniformGroupNode(name, true, order);
var frameGroup = sharedUniformGroup("frame");
var renderGroup = sharedUniformGroup("render");
var objectGroup = uniformGroup("object");
var UniformNode = class extends InputNode {
  static get type() {
    return "UniformNode";
  }
  /**
   * Constructs a new uniform node.
   *
   * @param {any} value - The value of this node. Usually a JS primitive or three.js object (vector, matrix, color, texture).
   * @param {?string} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.
   */
  constructor(value, nodeType = null) {
    super(value, nodeType);
    this.isUniformNode = true;
    this.name = "";
    this.groupNode = objectGroup;
  }
  /**
   * Sets the {@link UniformNode#name} property.
   *
   * @param {string} name - The name of the uniform.
   * @return {UniformNode} A reference to this node.
   */
  setName(name) {
    this.name = name;
    return this;
  }
  /**
   * Sets the {@link UniformNode#name} property.
   *
   * @deprecated
   * @param {string} name - The name of the uniform.
   * @return {UniformNode} A reference to this node.
   */
  label(name) {
    warn('TSL: "label()" has been deprecated. Use "setName()" instead.');
    return this.setName(name);
  }
  /**
   * Sets the {@link UniformNode#groupNode} property.
   *
   * @param {UniformGroupNode} group - The uniform group.
   * @return {UniformNode} A reference to this node.
   */
  setGroup(group2) {
    this.groupNode = group2;
    return this;
  }
  /**
   * Returns the {@link UniformNode#groupNode}.
   *
   * @return {UniformGroupNode} The uniform group.
   */
  getGroup() {
    return this.groupNode;
  }
  /**
   * By default, this method returns the result of {@link Node#getHash} but derived
   * classes might overwrite this method with a different implementation.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The uniform hash.
   */
  getUniformHash(builder) {
    return this.getHash(builder);
  }
  onUpdate(callback, updateType) {
    callback = callback.bind(this);
    return super.onUpdate((frame2) => {
      const value = callback(frame2, this);
      if (value !== void 0) {
        this.value = value;
      }
    }, updateType);
  }
  getInputType(builder) {
    let type = super.getInputType(builder);
    if (type === "bool") {
      type = "uint";
    }
    return type;
  }
  generate(builder, output2) {
    const type = this.getNodeType(builder);
    const hash2 = this.getUniformHash(builder);
    let sharedNode = builder.getNodeFromHash(hash2);
    if (sharedNode === void 0) {
      builder.setHashNode(this, hash2);
      sharedNode = this;
    }
    const sharedNodeType = sharedNode.getInputType(builder);
    const nodeUniform = builder.getUniformFromNode(sharedNode, sharedNodeType, builder.shaderStage, this.name || builder.context.nodeName);
    const uniformName = builder.getPropertyName(nodeUniform);
    if (builder.context.nodeName !== void 0) delete builder.context.nodeName;
    let snippet = uniformName;
    if (type === "bool") {
      const nodeData = builder.getDataFromNode(this);
      let propertyName = nodeData.propertyName;
      if (propertyName === void 0) {
        const nodeVar = builder.getVarFromNode(this, null, "bool");
        propertyName = builder.getPropertyName(nodeVar);
        nodeData.propertyName = propertyName;
        snippet = builder.format(uniformName, sharedNodeType, type);
        builder.addLineFlowCode(`${propertyName} = ${snippet}`, this);
      }
      snippet = propertyName;
    }
    return builder.format(snippet, type, output2);
  }
};
var uniform = (value, type) => {
  const nodeType = getConstNodeType(type || value);
  if (nodeType === value) {
    value = getValueFromType(nodeType);
  }
  if (value && value.isNode === true) {
    let v2 = value.value;
    value.traverse((n2) => {
      if (n2.isConstNode === true) {
        v2 = n2.value;
      }
    });
    value = v2;
  }
  return new UniformNode(value, nodeType);
};
var ArrayNode = class extends TempNode {
  static get type() {
    return "ArrayNode";
  }
  /**
   * Constructs a new array node.
   *
   * @param {?string} nodeType - The data type of the elements.
   * @param {number} count - Size of the array.
   * @param {?Array<Node>} [values=null] - Array default values.
   */
  constructor(nodeType, count2, values2 = null) {
    super(nodeType);
    this.count = count2;
    this.values = values2;
    this.isArrayNode = true;
  }
  /**
   * Returns the number of elements in the node array.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {number} The number of elements in the node array.
   */
  getArrayCount() {
    return this.count;
  }
  /**
   * Returns the node's type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The type of the node.
   */
  getNodeType(builder) {
    if (this.nodeType === null) {
      return this.values[0].getNodeType(builder);
    }
    return this.nodeType;
  }
  /**
   * Returns the node's type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The type of the node.
   */
  getElementType(builder) {
    return this.getNodeType(builder);
  }
  /**
   * Returns the type of a member variable.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} name - The name of the member variable.
   * @return {string} The type of the member variable.
   */
  getMemberType(builder, name) {
    if (this.nodeType === null) {
      return this.values[0].getMemberType(builder, name);
    }
    return super.getMemberType(builder, name);
  }
  /**
   * This method builds the output node and returns the resulting array as a shader string.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The generated shader string.
   */
  generate(builder) {
    const type = this.getNodeType(builder);
    return builder.generateArray(type, this.count, this.values);
  }
};
var array2 = (...params) => {
  let node;
  if (params.length === 1) {
    const values2 = params[0];
    node = new ArrayNode(null, values2.length, values2);
  } else {
    const nodeType = params[0];
    const count2 = params[1];
    node = new ArrayNode(nodeType, count2);
  }
  return nodeObject(node);
};
addMethodChaining("toArray", (node, count2) => array2(Array(count2).fill(node)));
var AssignNode = class extends TempNode {
  static get type() {
    return "AssignNode";
  }
  /**
   * Constructs a new assign node.
   *
   * @param {Node} targetNode - The target node.
   * @param {Node} sourceNode - The source type.
   */
  constructor(targetNode, sourceNode) {
    super();
    this.targetNode = targetNode;
    this.sourceNode = sourceNode;
    this.isAssignNode = true;
  }
  /**
   * Whether this node is used more than once in context of other nodes. This method
   * is overwritten since it always returns `false` (assigns are unique).
   *
   * @return {boolean} A flag that indicates if there is more than one dependency to other nodes. Always `false`.
   */
  hasDependencies() {
    return false;
  }
  getNodeType(builder, output2) {
    return output2 !== "void" ? this.targetNode.getNodeType(builder) : "void";
  }
  /**
   * Whether a split is required when assigning source to target. This can happen when the component length of
   * target and source data type does not match.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {boolean} Whether a split is required when assigning source to target.
   */
  needsSplitAssign(builder) {
    const { targetNode } = this;
    if (builder.isAvailable("swizzleAssign") === false && targetNode.isSplitNode && targetNode.components.length > 1) {
      const targetLength = builder.getTypeLength(targetNode.node.getNodeType(builder));
      const assignDifferentVector = vectorComponents.join("").slice(0, targetLength) !== targetNode.components;
      return assignDifferentVector;
    }
    return false;
  }
  setup(builder) {
    const { targetNode, sourceNode } = this;
    const scope = targetNode.getScope();
    const scopeData = builder.getDataFromNode(scope);
    scopeData.assign = true;
    const properties = builder.getNodeProperties(this);
    properties.sourceNode = sourceNode;
    properties.targetNode = targetNode.context({ assign: true });
  }
  generate(builder, output2) {
    const { targetNode, sourceNode } = builder.getNodeProperties(this);
    const needsSplitAssign = this.needsSplitAssign(builder);
    const target = targetNode.build(builder);
    const targetType = targetNode.getNodeType(builder);
    const source = sourceNode.build(builder, targetType);
    const sourceType = sourceNode.getNodeType(builder);
    const nodeData = builder.getDataFromNode(this);
    let snippet;
    if (nodeData.initialized === true) {
      if (output2 !== "void") {
        snippet = target;
      }
    } else if (needsSplitAssign) {
      const sourceVar = builder.getVarFromNode(this, null, targetType);
      const sourceProperty = builder.getPropertyName(sourceVar);
      builder.addLineFlowCode(`${sourceProperty} = ${source}`, this);
      const splitNode = targetNode.node;
      const splitTargetNode = splitNode.node.context({ assign: true });
      const targetRoot = splitTargetNode.build(builder);
      for (let i2 = 0; i2 < splitNode.components.length; i2++) {
        const component = splitNode.components[i2];
        builder.addLineFlowCode(`${targetRoot}.${component} = ${sourceProperty}[ ${i2} ]`, this);
      }
      if (output2 !== "void") {
        snippet = target;
      }
    } else {
      snippet = `${target} = ${source}`;
      if (output2 === "void" || sourceType === "void") {
        builder.addLineFlowCode(snippet, this);
        if (output2 !== "void") {
          snippet = target;
        }
      }
    }
    nodeData.initialized = true;
    return builder.format(snippet, targetType, output2);
  }
};
var assign = nodeProxy(AssignNode).setParameterLength(2);
addMethodChaining("assign", assign);
var FunctionCallNode = class extends TempNode {
  static get type() {
    return "FunctionCallNode";
  }
  /**
   * Constructs a new function call node.
   *
   * @param {?FunctionNode} functionNode - The function node.
   * @param {Object<string, Node>} [parameters={}] - The parameters for the function call.
   */
  constructor(functionNode = null, parameters = {}) {
    super();
    this.functionNode = functionNode;
    this.parameters = parameters;
  }
  /**
   * Sets the parameters of the function call node.
   *
   * @param {Object<string, Node>} parameters - The parameters to set.
   * @return {FunctionCallNode} A reference to this node.
   */
  setParameters(parameters) {
    this.parameters = parameters;
    return this;
  }
  /**
   * Returns the parameters of the function call node.
   *
   * @return {Object<string, Node>} The parameters of this node.
   */
  getParameters() {
    return this.parameters;
  }
  /**
   * Returns the type of this function call node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @returns {string} The type of this node.
   */
  getNodeType(builder) {
    return this.functionNode.getNodeType(builder);
  }
  /**
   * Returns the function node of this function call node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} [name] - The name of the member.
   * @returns {string} The type of the member.
   */
  getMemberType(builder, name) {
    return this.functionNode.getMemberType(builder, name);
  }
  generate(builder) {
    const params = [];
    const functionNode = this.functionNode;
    const inputs = functionNode.getInputs(builder);
    const parameters = this.parameters;
    const generateInput = (node, inputNode) => {
      const type = inputNode.type;
      const pointer = type === "pointer";
      let output2;
      if (pointer) output2 = "&" + node.build(builder);
      else output2 = node.build(builder, type);
      return output2;
    };
    if (Array.isArray(parameters)) {
      if (parameters.length > inputs.length) {
        error("TSL: The number of provided parameters exceeds the expected number of inputs in 'Fn()'.");
        parameters.length = inputs.length;
      } else if (parameters.length < inputs.length) {
        error("TSL: The number of provided parameters is less than the expected number of inputs in 'Fn()'.");
        while (parameters.length < inputs.length) {
          parameters.push(float(0));
        }
      }
      for (let i2 = 0; i2 < parameters.length; i2++) {
        params.push(generateInput(parameters[i2], inputs[i2]));
      }
    } else {
      for (const inputNode of inputs) {
        const node = parameters[inputNode.name];
        if (node !== void 0) {
          params.push(generateInput(node, inputNode));
        } else {
          error(`TSL: Input '${inputNode.name}' not found in 'Fn()'.`);
          params.push(generateInput(float(0), inputNode));
        }
      }
    }
    const functionName = functionNode.build(builder, "property");
    return `${functionName}( ${params.join(", ")} )`;
  }
};
var call = (func, ...params) => {
  params = params.length > 1 || params[0] && params[0].isNode === true ? nodeArray(params) : nodeObjects(params[0]);
  return new FunctionCallNode(nodeObject(func), params);
};
addMethodChaining("call", call);
var _vectorOperators = {
  "==": "equal",
  "!=": "notEqual",
  "<": "lessThan",
  ">": "greaterThan",
  "<=": "lessThanEqual",
  ">=": "greaterThanEqual",
  "%": "mod"
};
var OperatorNode = class _OperatorNode extends TempNode {
  static get type() {
    return "OperatorNode";
  }
  /**
   * Constructs a new operator node.
   *
   * @param {string} op - The operator.
   * @param {Node} aNode - The first input.
   * @param {Node} bNode - The second input.
   * @param {...Node} params - Additional input parameters.
   */
  constructor(op, aNode, bNode, ...params) {
    super();
    if (params.length > 0) {
      let finalOp = new _OperatorNode(op, aNode, bNode);
      for (let i2 = 0; i2 < params.length - 1; i2++) {
        finalOp = new _OperatorNode(op, finalOp, params[i2]);
      }
      aNode = finalOp;
      bNode = params[params.length - 1];
    }
    this.op = op;
    this.aNode = aNode;
    this.bNode = bNode;
    this.isOperatorNode = true;
  }
  /**
   * Returns the operator method name.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} output - The output type.
   * @returns {string} The operator method name.
   */
  getOperatorMethod(builder, output2) {
    return builder.getMethod(_vectorOperators[this.op], output2);
  }
  /**
   * This method is overwritten since the node type is inferred from the operator
   * and the input node types.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {?string} [output=null] - The output type.
   * @return {string} The node type.
   */
  getNodeType(builder, output2 = null) {
    const op = this.op;
    const aNode = this.aNode;
    const bNode = this.bNode;
    const typeA = aNode.getNodeType(builder);
    const typeB = bNode ? bNode.getNodeType(builder) : null;
    if (typeA === "void" || typeB === "void") {
      return output2 || "void";
    } else if (op === "%") {
      return typeA;
    } else if (op === "~" || op === "&" || op === "|" || op === "^" || op === ">>" || op === "<<") {
      return builder.getIntegerType(typeA);
    } else if (op === "!" || op === "&&" || op === "||" || op === "^^") {
      return "bool";
    } else if (op === "==" || op === "!=" || op === "<" || op === ">" || op === "<=" || op === ">=") {
      const typeLength = Math.max(builder.getTypeLength(typeA), builder.getTypeLength(typeB));
      return typeLength > 1 ? `bvec${typeLength}` : "bool";
    } else {
      if (builder.isMatrix(typeA)) {
        if (typeB === "float") {
          return typeA;
        } else if (builder.isVector(typeB)) {
          return builder.getVectorFromMatrix(typeA);
        } else if (builder.isMatrix(typeB)) {
          return typeA;
        }
      } else if (builder.isMatrix(typeB)) {
        if (typeA === "float") {
          return typeB;
        } else if (builder.isVector(typeA)) {
          return builder.getVectorFromMatrix(typeB);
        }
      }
      if (builder.getTypeLength(typeB) > builder.getTypeLength(typeA)) {
        return typeB;
      }
      return typeA;
    }
  }
  generate(builder, output2) {
    const op = this.op;
    const { aNode, bNode } = this;
    const type = this.getNodeType(builder, output2);
    let typeA = null;
    let typeB = null;
    if (type !== "void") {
      typeA = aNode.getNodeType(builder);
      typeB = bNode ? bNode.getNodeType(builder) : null;
      if (op === "<" || op === ">" || op === "<=" || op === ">=" || op === "==" || op === "!=") {
        if (builder.isVector(typeA)) {
          typeB = typeA;
        } else if (builder.isVector(typeB)) {
          typeA = typeB;
        } else if (typeA !== typeB) {
          typeA = typeB = "float";
        }
      } else if (op === ">>" || op === "<<") {
        typeA = type;
        typeB = builder.changeComponentType(typeB, "uint");
      } else if (op === "%") {
        typeA = type;
        typeB = builder.isInteger(typeA) && builder.isInteger(typeB) ? typeB : typeA;
      } else if (builder.isMatrix(typeA)) {
        if (typeB === "float") {
          typeB = "float";
        } else if (builder.isVector(typeB)) {
          typeB = builder.getVectorFromMatrix(typeA);
        } else if (builder.isMatrix(typeB)) ;
        else {
          typeA = typeB = type;
        }
      } else if (builder.isMatrix(typeB)) {
        if (typeA === "float") {
          typeA = "float";
        } else if (builder.isVector(typeA)) {
          typeA = builder.getVectorFromMatrix(typeB);
        } else {
          typeA = typeB = type;
        }
      } else {
        typeA = typeB = type;
      }
    } else {
      typeA = typeB = type;
    }
    const a3 = aNode.build(builder, typeA);
    const b = bNode ? bNode.build(builder, typeB) : null;
    const fnOpSnippet = builder.getFunctionOperator(op);
    if (output2 !== "void") {
      const isGLSL = builder.renderer.coordinateSystem === WebGLCoordinateSystem;
      if (op === "==" || op === "!=" || op === "<" || op === ">" || op === "<=" || op === ">=") {
        if (isGLSL) {
          if (builder.isVector(typeA)) {
            return builder.format(`${this.getOperatorMethod(builder, output2)}( ${a3}, ${b} )`, type, output2);
          } else {
            return builder.format(`( ${a3} ${op} ${b} )`, type, output2);
          }
        } else {
          return builder.format(`( ${a3} ${op} ${b} )`, type, output2);
        }
      } else if (op === "%") {
        if (builder.isInteger(typeB)) {
          return builder.format(`( ${a3} % ${b} )`, type, output2);
        } else {
          return builder.format(`${this.getOperatorMethod(builder, type)}( ${a3}, ${b} )`, type, output2);
        }
      } else if (op === "!" || op === "~") {
        return builder.format(`(${op}${a3})`, typeA, output2);
      } else if (fnOpSnippet) {
        return builder.format(`${fnOpSnippet}( ${a3}, ${b} )`, type, output2);
      } else {
        if (builder.isMatrix(typeA) && typeB === "float") {
          return builder.format(`( ${b} ${op} ${a3} )`, type, output2);
        } else if (typeA === "float" && builder.isMatrix(typeB)) {
          return builder.format(`${a3} ${op} ${b}`, type, output2);
        } else {
          let snippet = `( ${a3} ${op} ${b} )`;
          if (!isGLSL && type === "bool" && builder.isVector(typeA) && builder.isVector(typeB)) {
            snippet = `all${snippet}`;
          }
          return builder.format(snippet, type, output2);
        }
      }
    } else if (typeA !== "void") {
      if (fnOpSnippet) {
        return builder.format(`${fnOpSnippet}( ${a3}, ${b} )`, type, output2);
      } else {
        if (builder.isMatrix(typeA) && typeB === "float") {
          return builder.format(`${b} ${op} ${a3}`, type, output2);
        } else {
          return builder.format(`${a3} ${op} ${b}`, type, output2);
        }
      }
    }
  }
  serialize(data) {
    super.serialize(data);
    data.op = this.op;
  }
  deserialize(data) {
    super.deserialize(data);
    this.op = data.op;
  }
};
var add4 = nodeProxyIntent(OperatorNode, "+").setParameterLength(2, Infinity).setName("add");
var sub = nodeProxyIntent(OperatorNode, "-").setParameterLength(2, Infinity).setName("sub");
var mul = nodeProxyIntent(OperatorNode, "*").setParameterLength(2, Infinity).setName("mul");
var div = nodeProxyIntent(OperatorNode, "/").setParameterLength(2, Infinity).setName("div");
var mod = nodeProxyIntent(OperatorNode, "%").setParameterLength(2).setName("mod");
var equal = nodeProxyIntent(OperatorNode, "==").setParameterLength(2).setName("equal");
var notEqual = nodeProxyIntent(OperatorNode, "!=").setParameterLength(2).setName("notEqual");
var lessThan = nodeProxyIntent(OperatorNode, "<").setParameterLength(2).setName("lessThan");
var greaterThan = nodeProxyIntent(OperatorNode, ">").setParameterLength(2).setName("greaterThan");
var lessThanEqual = nodeProxyIntent(OperatorNode, "<=").setParameterLength(2).setName("lessThanEqual");
var greaterThanEqual = nodeProxyIntent(OperatorNode, ">=").setParameterLength(2).setName("greaterThanEqual");
var and = nodeProxyIntent(OperatorNode, "&&").setParameterLength(2, Infinity).setName("and");
var or = nodeProxyIntent(OperatorNode, "||").setParameterLength(2, Infinity).setName("or");
var not = nodeProxyIntent(OperatorNode, "!").setParameterLength(1).setName("not");
var xor = nodeProxyIntent(OperatorNode, "^^").setParameterLength(2).setName("xor");
var bitAnd = nodeProxyIntent(OperatorNode, "&").setParameterLength(2).setName("bitAnd");
var bitNot = nodeProxyIntent(OperatorNode, "~").setParameterLength(1).setName("bitNot");
var bitOr = nodeProxyIntent(OperatorNode, "|").setParameterLength(2).setName("bitOr");
var bitXor = nodeProxyIntent(OperatorNode, "^").setParameterLength(2).setName("bitXor");
var shiftLeft = nodeProxyIntent(OperatorNode, "<<").setParameterLength(2).setName("shiftLeft");
var shiftRight = nodeProxyIntent(OperatorNode, ">>").setParameterLength(2).setName("shiftRight");
var incrementBefore = Fn(([a3]) => {
  a3.addAssign(1);
  return a3;
});
var decrementBefore = Fn(([a3]) => {
  a3.subAssign(1);
  return a3;
});
var increment = Fn(([a3]) => {
  const temp = int(a3).toConst();
  a3.addAssign(1);
  return temp;
});
var decrement = Fn(([a3]) => {
  const temp = int(a3).toConst();
  a3.subAssign(1);
  return temp;
});
addMethodChaining("add", add4);
addMethodChaining("sub", sub);
addMethodChaining("mul", mul);
addMethodChaining("div", div);
addMethodChaining("mod", mod);
addMethodChaining("equal", equal);
addMethodChaining("notEqual", notEqual);
addMethodChaining("lessThan", lessThan);
addMethodChaining("greaterThan", greaterThan);
addMethodChaining("lessThanEqual", lessThanEqual);
addMethodChaining("greaterThanEqual", greaterThanEqual);
addMethodChaining("and", and);
addMethodChaining("or", or);
addMethodChaining("not", not);
addMethodChaining("xor", xor);
addMethodChaining("bitAnd", bitAnd);
addMethodChaining("bitNot", bitNot);
addMethodChaining("bitOr", bitOr);
addMethodChaining("bitXor", bitXor);
addMethodChaining("shiftLeft", shiftLeft);
addMethodChaining("shiftRight", shiftRight);
addMethodChaining("incrementBefore", incrementBefore);
addMethodChaining("decrementBefore", decrementBefore);
addMethodChaining("increment", increment);
addMethodChaining("decrement", decrement);
var modInt = (a3, b) => {
  warn('TSL: "modInt()" is deprecated. Use "mod( int( ... ) )" instead.');
  return mod(int(a3), int(b));
};
addMethodChaining("modInt", modInt);
var MathNode = class _MathNode extends TempNode {
  static get type() {
    return "MathNode";
  }
  /**
   * Constructs a new math node.
   *
   * @param {string} method - The method name.
   * @param {Node} aNode - The first input.
   * @param {?Node} [bNode=null] - The second input.
   * @param {?Node} [cNode=null] - The third input.
   */
  constructor(method2, aNode, bNode = null, cNode = null) {
    super();
    if ((method2 === _MathNode.MAX || method2 === _MathNode.MIN) && arguments.length > 3) {
      let finalOp = new _MathNode(method2, aNode, bNode);
      for (let i2 = 2; i2 < arguments.length - 1; i2++) {
        finalOp = new _MathNode(method2, finalOp, arguments[i2]);
      }
      aNode = finalOp;
      bNode = arguments[arguments.length - 1];
      cNode = null;
    }
    this.method = method2;
    this.aNode = aNode;
    this.bNode = bNode;
    this.cNode = cNode;
    this.isMathNode = true;
  }
  /**
   * The input type is inferred from the node types of the input nodes.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType(builder) {
    const aType = this.aNode.getNodeType(builder);
    const bType = this.bNode ? this.bNode.getNodeType(builder) : null;
    const cType = this.cNode ? this.cNode.getNodeType(builder) : null;
    const aLen = builder.isMatrix(aType) ? 0 : builder.getTypeLength(aType);
    const bLen = builder.isMatrix(bType) ? 0 : builder.getTypeLength(bType);
    const cLen = builder.isMatrix(cType) ? 0 : builder.getTypeLength(cType);
    if (aLen > bLen && aLen > cLen) {
      return aType;
    } else if (bLen > cLen) {
      return bType;
    } else if (cLen > aLen) {
      return cType;
    }
    return aType;
  }
  /**
   * The selected method as well as the input type determine the node type of this node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    const method2 = this.method;
    if (method2 === _MathNode.LENGTH || method2 === _MathNode.DISTANCE || method2 === _MathNode.DOT) {
      return "float";
    } else if (method2 === _MathNode.CROSS) {
      return "vec3";
    } else if (method2 === _MathNode.ALL || method2 === _MathNode.ANY) {
      return "bool";
    } else if (method2 === _MathNode.EQUALS) {
      return builder.changeComponentType(this.aNode.getNodeType(builder), "bool");
    } else {
      return this.getInputType(builder);
    }
  }
  setup(builder) {
    const { aNode, bNode, method: method2 } = this;
    let outputNode = null;
    if (method2 === _MathNode.ONE_MINUS) {
      outputNode = sub(1, aNode);
    } else if (method2 === _MathNode.RECIPROCAL) {
      outputNode = div(1, aNode);
    } else if (method2 === _MathNode.DIFFERENCE) {
      outputNode = abs(sub(aNode, bNode));
    } else if (method2 === _MathNode.TRANSFORM_DIRECTION) {
      let tA = aNode;
      let tB = bNode;
      if (builder.isMatrix(tA.getNodeType(builder))) {
        tB = vec4(vec3(tB), 0);
      } else {
        tA = vec4(vec3(tA), 0);
      }
      const mulNode = mul(tA, tB).xyz;
      outputNode = normalize2(mulNode);
    }
    if (outputNode !== null) {
      return outputNode;
    } else {
      return super.setup(builder);
    }
  }
  generate(builder, output2) {
    const properties = builder.getNodeProperties(this);
    if (properties.outputNode) {
      return super.generate(builder, output2);
    }
    let method2 = this.method;
    const type = this.getNodeType(builder);
    const inputType = this.getInputType(builder);
    const a3 = this.aNode;
    const b = this.bNode;
    const c5 = this.cNode;
    const coordinateSystem = builder.renderer.coordinateSystem;
    if (method2 === _MathNode.NEGATE) {
      return builder.format("( - " + a3.build(builder, inputType) + " )", type, output2);
    } else {
      const params = [];
      if (method2 === _MathNode.CROSS) {
        params.push(
          a3.build(builder, type),
          b.build(builder, type)
        );
      } else if (coordinateSystem === WebGLCoordinateSystem && method2 === _MathNode.STEP) {
        params.push(
          a3.build(builder, builder.getTypeLength(a3.getNodeType(builder)) === 1 ? "float" : inputType),
          b.build(builder, inputType)
        );
      } else if (coordinateSystem === WebGLCoordinateSystem && (method2 === _MathNode.MIN || method2 === _MathNode.MAX)) {
        params.push(
          a3.build(builder, inputType),
          b.build(builder, builder.getTypeLength(b.getNodeType(builder)) === 1 ? "float" : inputType)
        );
      } else if (method2 === _MathNode.REFRACT) {
        params.push(
          a3.build(builder, inputType),
          b.build(builder, inputType),
          c5.build(builder, "float")
        );
      } else if (method2 === _MathNode.MIX) {
        params.push(
          a3.build(builder, inputType),
          b.build(builder, inputType),
          c5.build(builder, builder.getTypeLength(c5.getNodeType(builder)) === 1 ? "float" : inputType)
        );
      } else {
        if (coordinateSystem === WebGPUCoordinateSystem && method2 === _MathNode.ATAN && b !== null) {
          method2 = "atan2";
        }
        if (builder.shaderStage !== "fragment" && (method2 === _MathNode.DFDX || method2 === _MathNode.DFDY)) {
          warn(`TSL: '${method2}' is not supported in the ${builder.shaderStage} stage.`);
          method2 = "/*" + method2 + "*/";
        }
        params.push(a3.build(builder, inputType));
        if (b !== null) params.push(b.build(builder, inputType));
        if (c5 !== null) params.push(c5.build(builder, inputType));
      }
      return builder.format(`${builder.getMethod(method2, type)}( ${params.join(", ")} )`, type, output2);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.method = this.method;
  }
  deserialize(data) {
    super.deserialize(data);
    this.method = data.method;
  }
};
MathNode.ALL = "all";
MathNode.ANY = "any";
MathNode.RADIANS = "radians";
MathNode.DEGREES = "degrees";
MathNode.EXP = "exp";
MathNode.EXP2 = "exp2";
MathNode.LOG = "log";
MathNode.LOG2 = "log2";
MathNode.SQRT = "sqrt";
MathNode.INVERSE_SQRT = "inversesqrt";
MathNode.FLOOR = "floor";
MathNode.CEIL = "ceil";
MathNode.NORMALIZE = "normalize";
MathNode.FRACT = "fract";
MathNode.SIN = "sin";
MathNode.COS = "cos";
MathNode.TAN = "tan";
MathNode.ASIN = "asin";
MathNode.ACOS = "acos";
MathNode.ATAN = "atan";
MathNode.ABS = "abs";
MathNode.SIGN = "sign";
MathNode.LENGTH = "length";
MathNode.NEGATE = "negate";
MathNode.ONE_MINUS = "oneMinus";
MathNode.DFDX = "dFdx";
MathNode.DFDY = "dFdy";
MathNode.ROUND = "round";
MathNode.RECIPROCAL = "reciprocal";
MathNode.TRUNC = "trunc";
MathNode.FWIDTH = "fwidth";
MathNode.TRANSPOSE = "transpose";
MathNode.DETERMINANT = "determinant";
MathNode.INVERSE = "inverse";
MathNode.EQUALS = "equals";
MathNode.MIN = "min";
MathNode.MAX = "max";
MathNode.STEP = "step";
MathNode.REFLECT = "reflect";
MathNode.DISTANCE = "distance";
MathNode.DIFFERENCE = "difference";
MathNode.DOT = "dot";
MathNode.CROSS = "cross";
MathNode.POW = "pow";
MathNode.TRANSFORM_DIRECTION = "transformDirection";
MathNode.MIX = "mix";
MathNode.CLAMP = "clamp";
MathNode.REFRACT = "refract";
MathNode.SMOOTHSTEP = "smoothstep";
MathNode.FACEFORWARD = "faceforward";
var EPSILON = float(1e-6);
var INFINITY = float(1e6);
var PI = float(Math.PI);
var PI2 = float(Math.PI * 2);
var TWO_PI = float(Math.PI * 2);
var HALF_PI = float(Math.PI * 0.5);
var all = nodeProxyIntent(MathNode, MathNode.ALL).setParameterLength(1);
var any = nodeProxyIntent(MathNode, MathNode.ANY).setParameterLength(1);
var radians3 = nodeProxyIntent(MathNode, MathNode.RADIANS).setParameterLength(1);
var degrees4 = nodeProxyIntent(MathNode, MathNode.DEGREES).setParameterLength(1);
var exp = nodeProxyIntent(MathNode, MathNode.EXP).setParameterLength(1);
var exp2 = nodeProxyIntent(MathNode, MathNode.EXP2).setParameterLength(1);
var log3 = nodeProxyIntent(MathNode, MathNode.LOG).setParameterLength(1);
var log22 = nodeProxyIntent(MathNode, MathNode.LOG2).setParameterLength(1);
var sqrt2 = nodeProxyIntent(MathNode, MathNode.SQRT).setParameterLength(1);
var inverseSqrt = nodeProxyIntent(MathNode, MathNode.INVERSE_SQRT).setParameterLength(1);
var floor = nodeProxyIntent(MathNode, MathNode.FLOOR).setParameterLength(1);
var ceil = nodeProxyIntent(MathNode, MathNode.CEIL).setParameterLength(1);
var normalize2 = nodeProxyIntent(MathNode, MathNode.NORMALIZE).setParameterLength(1);
var fract = nodeProxyIntent(MathNode, MathNode.FRACT).setParameterLength(1);
var sin = nodeProxyIntent(MathNode, MathNode.SIN).setParameterLength(1);
var cos = nodeProxyIntent(MathNode, MathNode.COS).setParameterLength(1);
var tan = nodeProxyIntent(MathNode, MathNode.TAN).setParameterLength(1);
var asin = nodeProxyIntent(MathNode, MathNode.ASIN).setParameterLength(1);
var acos = nodeProxyIntent(MathNode, MathNode.ACOS).setParameterLength(1);
var atan = nodeProxyIntent(MathNode, MathNode.ATAN).setParameterLength(1, 2);
var abs = nodeProxyIntent(MathNode, MathNode.ABS).setParameterLength(1);
var sign2 = nodeProxyIntent(MathNode, MathNode.SIGN).setParameterLength(1);
var length = nodeProxyIntent(MathNode, MathNode.LENGTH).setParameterLength(1);
var negate = nodeProxyIntent(MathNode, MathNode.NEGATE).setParameterLength(1);
var oneMinus = nodeProxyIntent(MathNode, MathNode.ONE_MINUS).setParameterLength(1);
var dFdx = nodeProxyIntent(MathNode, MathNode.DFDX).setParameterLength(1);
var dFdy = nodeProxyIntent(MathNode, MathNode.DFDY).setParameterLength(1);
var round = nodeProxyIntent(MathNode, MathNode.ROUND).setParameterLength(1);
var reciprocal = nodeProxyIntent(MathNode, MathNode.RECIPROCAL).setParameterLength(1);
var trunc = nodeProxyIntent(MathNode, MathNode.TRUNC).setParameterLength(1);
var fwidth = nodeProxyIntent(MathNode, MathNode.FWIDTH).setParameterLength(1);
var transpose2 = nodeProxyIntent(MathNode, MathNode.TRANSPOSE).setParameterLength(1);
var determinant = nodeProxyIntent(MathNode, MathNode.DETERMINANT).setParameterLength(1);
var inverse = nodeProxyIntent(MathNode, MathNode.INVERSE).setParameterLength(1);
var equals2 = (x3, y3) => {
  warn('TSL: "equals" is deprecated. Use "equal" inside a vector instead, like: "bvec*( equal( ... ) )"');
  return equal(x3, y3);
};
var min$1 = nodeProxyIntent(MathNode, MathNode.MIN).setParameterLength(2, Infinity);
var max$1 = nodeProxyIntent(MathNode, MathNode.MAX).setParameterLength(2, Infinity);
var step = nodeProxyIntent(MathNode, MathNode.STEP).setParameterLength(2);
var reflect = nodeProxyIntent(MathNode, MathNode.REFLECT).setParameterLength(2);
var distance3 = nodeProxyIntent(MathNode, MathNode.DISTANCE).setParameterLength(2);
var difference2 = nodeProxyIntent(MathNode, MathNode.DIFFERENCE).setParameterLength(2);
var dot = nodeProxyIntent(MathNode, MathNode.DOT).setParameterLength(2);
var cross2 = nodeProxyIntent(MathNode, MathNode.CROSS).setParameterLength(2);
var pow2 = nodeProxyIntent(MathNode, MathNode.POW).setParameterLength(2);
var pow22 = (x3) => mul(x3, x3);
var pow3 = (x3) => mul(x3, x3, x3);
var pow4 = (x3) => mul(x3, x3, x3, x3);
var transformDirection = nodeProxyIntent(MathNode, MathNode.TRANSFORM_DIRECTION).setParameterLength(2);
var cbrt = (a3) => mul(sign2(a3), pow2(abs(a3), 1 / 3));
var lengthSq = (a3) => dot(a3, a3);
var mix2 = nodeProxyIntent(MathNode, MathNode.MIX).setParameterLength(3);
var clamp3 = (value, low = 0, high = 1) => nodeObject(new MathNode(MathNode.CLAMP, nodeObject(value), nodeObject(low), nodeObject(high)));
var saturate3 = (value) => clamp3(value);
var refract = nodeProxyIntent(MathNode, MathNode.REFRACT).setParameterLength(3);
var smoothstep2 = nodeProxyIntent(MathNode, MathNode.SMOOTHSTEP).setParameterLength(3);
var faceForward = nodeProxyIntent(MathNode, MathNode.FACEFORWARD).setParameterLength(3);
var rand = Fn(([uv2]) => {
  const a3 = 12.9898, b = 78.233, c5 = 43758.5453;
  const dt = dot(uv2.xy, vec2(a3, b)), sn = mod(dt, PI);
  return fract(sin(sn).mul(c5));
});
var mixElement = (t5, e1, e22) => mix2(e1, e22, t5);
var smoothstepElement = (x3, low, high) => smoothstep2(low, high, x3);
var stepElement = (x3, edge) => step(edge, x3);
var atan2 = (y3, x3) => {
  warn('TSL: "atan2" is overloaded. Use "atan" instead.');
  return atan(y3, x3);
};
var faceforward = faceForward;
var inversesqrt = inverseSqrt;
addMethodChaining("all", all);
addMethodChaining("any", any);
addMethodChaining("equals", equals2);
addMethodChaining("radians", radians3);
addMethodChaining("degrees", degrees4);
addMethodChaining("exp", exp);
addMethodChaining("exp2", exp2);
addMethodChaining("log", log3);
addMethodChaining("log2", log22);
addMethodChaining("sqrt", sqrt2);
addMethodChaining("inverseSqrt", inverseSqrt);
addMethodChaining("floor", floor);
addMethodChaining("ceil", ceil);
addMethodChaining("normalize", normalize2);
addMethodChaining("fract", fract);
addMethodChaining("sin", sin);
addMethodChaining("cos", cos);
addMethodChaining("tan", tan);
addMethodChaining("asin", asin);
addMethodChaining("acos", acos);
addMethodChaining("atan", atan);
addMethodChaining("abs", abs);
addMethodChaining("sign", sign2);
addMethodChaining("length", length);
addMethodChaining("lengthSq", lengthSq);
addMethodChaining("negate", negate);
addMethodChaining("oneMinus", oneMinus);
addMethodChaining("dFdx", dFdx);
addMethodChaining("dFdy", dFdy);
addMethodChaining("round", round);
addMethodChaining("reciprocal", reciprocal);
addMethodChaining("trunc", trunc);
addMethodChaining("fwidth", fwidth);
addMethodChaining("atan2", atan2);
addMethodChaining("min", min$1);
addMethodChaining("max", max$1);
addMethodChaining("step", stepElement);
addMethodChaining("reflect", reflect);
addMethodChaining("distance", distance3);
addMethodChaining("dot", dot);
addMethodChaining("cross", cross2);
addMethodChaining("pow", pow2);
addMethodChaining("pow2", pow22);
addMethodChaining("pow3", pow3);
addMethodChaining("pow4", pow4);
addMethodChaining("transformDirection", transformDirection);
addMethodChaining("mix", mixElement);
addMethodChaining("clamp", clamp3);
addMethodChaining("refract", refract);
addMethodChaining("smoothstep", smoothstepElement);
addMethodChaining("faceForward", faceForward);
addMethodChaining("difference", difference2);
addMethodChaining("saturate", saturate3);
addMethodChaining("cbrt", cbrt);
addMethodChaining("transpose", transpose2);
addMethodChaining("determinant", determinant);
addMethodChaining("inverse", inverse);
addMethodChaining("rand", rand);
var ConditionalNode = class extends Node4 {
  static get type() {
    return "ConditionalNode";
  }
  /**
   * Constructs a new conditional node.
   *
   * @param {Node} condNode - The node that defines the condition.
   * @param {Node} ifNode - The node that is evaluate when the condition ends up `true`.
   * @param {?Node} [elseNode=null] - The node that is evaluate when the condition ends up `false`.
   */
  constructor(condNode, ifNode, elseNode = null) {
    super();
    this.condNode = condNode;
    this.ifNode = ifNode;
    this.elseNode = elseNode;
  }
  /**
   * This method is overwritten since the node type is inferred from the if/else
   * nodes.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    const { ifNode, elseNode } = builder.getNodeProperties(this);
    if (ifNode === void 0) {
      builder.flowBuildStage(this, "setup");
      return this.getNodeType(builder);
    }
    const ifType = ifNode.getNodeType(builder);
    if (elseNode !== null) {
      const elseType = elseNode.getNodeType(builder);
      if (builder.getTypeLength(elseType) > builder.getTypeLength(ifType)) {
        return elseType;
      }
    }
    return ifType;
  }
  setup(builder) {
    const condNode = this.condNode;
    const ifNode = this.ifNode.isolate();
    const elseNode = this.elseNode ? this.elseNode.isolate() : null;
    const currentNodeBlock = builder.context.nodeBlock;
    builder.getDataFromNode(ifNode).parentNodeBlock = currentNodeBlock;
    if (elseNode !== null) builder.getDataFromNode(elseNode).parentNodeBlock = currentNodeBlock;
    const isUniformFlow = builder.context.uniformFlow;
    const properties = builder.getNodeProperties(this);
    properties.condNode = condNode;
    properties.ifNode = isUniformFlow ? ifNode : ifNode.context({ nodeBlock: ifNode });
    properties.elseNode = elseNode ? isUniformFlow ? elseNode : elseNode.context({ nodeBlock: elseNode }) : null;
  }
  generate(builder, output2) {
    const type = this.getNodeType(builder);
    const nodeData = builder.getDataFromNode(this);
    if (nodeData.nodeProperty !== void 0) {
      return nodeData.nodeProperty;
    }
    const { condNode, ifNode, elseNode } = builder.getNodeProperties(this);
    const functionNode = builder.currentFunctionNode;
    const needsOutput = output2 !== "void";
    const nodeProperty = needsOutput ? property(type).build(builder) : "";
    nodeData.nodeProperty = nodeProperty;
    const nodeSnippet = condNode.build(builder, "bool");
    const isUniformFlow = builder.context.uniformFlow;
    if (isUniformFlow && elseNode !== null) {
      const ifSnippet2 = ifNode.build(builder, type);
      const elseSnippet = elseNode.build(builder, type);
      const mathSnippet = builder.getTernary(nodeSnippet, ifSnippet2, elseSnippet);
      return builder.format(mathSnippet, type, output2);
    }
    builder.addFlowCode(`
${builder.tab}if ( ${nodeSnippet} ) {

`).addFlowTab();
    let ifSnippet = ifNode.build(builder, type);
    if (ifSnippet) {
      if (needsOutput) {
        ifSnippet = nodeProperty + " = " + ifSnippet + ";";
      } else {
        ifSnippet = "return " + ifSnippet + ";";
        if (functionNode === null) {
          warn("TSL: Return statement used in an inline 'Fn()'. Define a layout struct to allow return values.");
          ifSnippet = "// " + ifSnippet;
        }
      }
    }
    builder.removeFlowTab().addFlowCode(builder.tab + "	" + ifSnippet + "\n\n" + builder.tab + "}");
    if (elseNode !== null) {
      builder.addFlowCode(" else {\n\n").addFlowTab();
      let elseSnippet = elseNode.build(builder, type);
      if (elseSnippet) {
        if (needsOutput) {
          elseSnippet = nodeProperty + " = " + elseSnippet + ";";
        } else {
          elseSnippet = "return " + elseSnippet + ";";
          if (functionNode === null) {
            warn("TSL: Return statement used in an inline 'Fn()'. Define a layout struct to allow return values.");
            elseSnippet = "// " + elseSnippet;
          }
        }
      }
      builder.removeFlowTab().addFlowCode(builder.tab + "	" + elseSnippet + "\n\n" + builder.tab + "}\n\n");
    } else {
      builder.addFlowCode("\n\n");
    }
    return builder.format(nodeProperty, type, output2);
  }
};
var select = nodeProxy(ConditionalNode).setParameterLength(2, 3);
addMethodChaining("select", select);
var ContextNode = class extends Node4 {
  static get type() {
    return "ContextNode";
  }
  /**
   * Constructs a new context node.
   *
   * @param {Node} node - The node whose context should be modified.
   * @param {Object} [value={}] - The modified context data.
   */
  constructor(node = null, value = {}) {
    super();
    this.isContextNode = true;
    this.node = node;
    this.value = value;
  }
  /**
   * This method is overwritten to ensure it returns the reference to {@link ContextNode#node}.
   *
   * @return {Node} A reference to {@link ContextNode#node}.
   */
  getScope() {
    return this.node.getScope();
  }
  /**
   * This method is overwritten to ensure it returns the type of {@link ContextNode#node}.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  /**
   * Gathers the context data from all parent context nodes.
   *
   * @return {Object} The gathered context data.
   */
  getFlowContextData() {
    const children2 = [];
    this.traverse((node) => {
      if (node.isContextNode === true) {
        children2.push(node.value);
      }
    });
    return Object.assign({}, ...children2);
  }
  /**
   * This method is overwritten to ensure it returns the member type of {@link ContextNode#node}.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} name - The member name.
   * @returns {string} The member type.
   */
  getMemberType(builder, name) {
    return this.node.getMemberType(builder, name);
  }
  analyze(builder) {
    const previousContext = builder.addContext(this.value);
    this.node.build(builder);
    builder.setContext(previousContext);
  }
  setup(builder) {
    const previousContext = builder.addContext(this.value);
    this.node.build(builder);
    builder.setContext(previousContext);
  }
  generate(builder, output2) {
    const previousContext = builder.addContext(this.value);
    const snippet = this.node.build(builder, output2);
    builder.setContext(previousContext);
    return snippet;
  }
};
var context = (nodeOrValue = null, value = {}) => {
  let node = nodeOrValue;
  if (node === null || node.isNode !== true) {
    value = node || value;
    node = null;
  }
  return new ContextNode(node, value);
};
var uniformFlow = (node) => context(node, { uniformFlow: true });
var setName = (node, name) => context(node, { nodeName: name });
function builtinShadowContext(shadowNode, light, node = null) {
  return context(node, {
    getShadow: ({ light: shadowLight, shadowColorNode }) => {
      if (light === shadowLight) {
        return shadowColorNode.mul(shadowNode);
      }
      return shadowColorNode;
    }
  });
}
function builtinAOContext(aoNode, node = null) {
  return context(node, {
    getAO: (inputNode, { material }) => {
      if (material.transparent === true) return inputNode;
      return inputNode !== null ? inputNode.mul(aoNode) : aoNode;
    }
  });
}
function label(node, name) {
  warn('TSL: "label()" has been deprecated. Use "setName()" instead.');
  return setName(node, name);
}
addMethodChaining("context", context);
addMethodChaining("label", label);
addMethodChaining("uniformFlow", uniformFlow);
addMethodChaining("setName", setName);
addMethodChaining("builtinShadowContext", (node, shadowNode, light) => builtinShadowContext(shadowNode, light, node));
addMethodChaining("builtinAOContext", (node, aoValue) => builtinAOContext(aoValue, node));
var VarNode = class extends Node4 {
  static get type() {
    return "VarNode";
  }
  /**
   * Constructs a new variable node.
   *
   * @param {Node} node - The node for which a variable should be created.
   * @param {?string} [name=null] - The name of the variable in the shader.
   * @param {boolean} [readOnly=false] - The read-only flag.
   */
  constructor(node, name = null, readOnly = false) {
    super();
    this.node = node;
    this.name = name;
    this.global = true;
    this.isVarNode = true;
    this.readOnly = readOnly;
    this.parents = true;
    this.intent = false;
  }
  /**
   * Sets the intent flag for this node.
   *
   * This flag is used to indicate that this node is used for intent
   * and should not be built directly. Instead, it is used to indicate that
   * the node should be treated as a variable intent.
   *
   * It's useful for assigning variables without needing creating a new variable node.
   *
   * @param {boolean} value - The value to set for the intent flag.
   * @returns {VarNode} This node.
   */
  setIntent(value) {
    this.intent = value;
    return this;
  }
  /**
   * Checks if this node is used for intent.
   *
   * @param {NodeBuilder} builder - The node builder.
   * @returns {boolean} Whether this node is used for intent.
   */
  isIntent(builder) {
    const data = builder.getDataFromNode(this);
    if (data.forceDeclaration === true) return false;
    return this.intent;
  }
  /**
   * Returns the intent flag of this node.
   *
   * @return {boolean} The intent flag.
   */
  getIntent() {
    return this.intent;
  }
  getMemberType(builder, name) {
    return this.node.getMemberType(builder, name);
  }
  getElementType(builder) {
    return this.node.getElementType(builder);
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  getArrayCount(builder) {
    return this.node.getArrayCount(builder);
  }
  isAssign(builder) {
    const data = builder.getDataFromNode(this);
    return data.assign;
  }
  build(...params) {
    const builder = params[0];
    if (this._hasStack(builder) === false && builder.buildStage === "setup") {
      if (builder.context.nodeLoop || builder.context.nodeBlock) {
        let addBefore = false;
        if (this.node.isShaderCallNodeInternal && this.node.shaderNode.getLayout() === null) {
          if (builder.fnCall && builder.fnCall.shaderNode) {
            const shaderNodeData = builder.getDataFromNode(this.node.shaderNode);
            if (shaderNodeData.hasLoop) {
              const data = builder.getDataFromNode(this);
              data.forceDeclaration = true;
              addBefore = true;
            }
          }
        }
        const baseStack = builder.getBaseStack();
        if (addBefore) {
          baseStack.addToStackBefore(this);
        } else {
          baseStack.addToStack(this);
        }
      }
    }
    if (this.isIntent(builder)) {
      if (this.isAssign(builder) !== true) {
        return this.node.build(...params);
      }
    }
    return super.build(...params);
  }
  generate(builder) {
    const { node, name, readOnly } = this;
    const { renderer: renderer3 } = builder;
    const isWebGPUBackend = renderer3.backend.isWebGPUBackend === true;
    let isDeterministic = false;
    let shouldTreatAsReadOnly = false;
    if (readOnly) {
      isDeterministic = builder.isDeterministic(node);
      shouldTreatAsReadOnly = isWebGPUBackend ? readOnly : isDeterministic;
    }
    const nodeType = this.getNodeType(builder);
    if (nodeType == "void") {
      if (this.isIntent(builder) !== true) {
        error('TSL: ".toVar()" can not be used with void type.');
      }
      const snippet2 = node.build(builder);
      return snippet2;
    }
    const vectorType = builder.getVectorType(nodeType);
    const snippet = node.build(builder, vectorType);
    const nodeVar = builder.getVarFromNode(this, name, vectorType, void 0, shouldTreatAsReadOnly);
    const propertyName = builder.getPropertyName(nodeVar);
    let declarationPrefix = propertyName;
    if (shouldTreatAsReadOnly) {
      if (isWebGPUBackend) {
        declarationPrefix = isDeterministic ? `const ${propertyName}` : `let ${propertyName}`;
      } else {
        const count2 = node.getArrayCount(builder);
        declarationPrefix = `const ${builder.getVar(nodeVar.type, propertyName, count2)}`;
      }
    }
    builder.addLineFlowCode(`${declarationPrefix} = ${snippet}`, this);
    return propertyName;
  }
  _hasStack(builder) {
    const nodeData = builder.getDataFromNode(this);
    return nodeData.stack !== void 0;
  }
};
var createVar = nodeProxy(VarNode);
var Var = (node, name = null) => createVar(node, name).toStack();
var Const = (node, name = null) => createVar(node, name, true).toStack();
var VarIntent = (node) => {
  return createVar(node).setIntent(true).toStack();
};
addMethodChaining("toVar", Var);
addMethodChaining("toConst", Const);
addMethodChaining("toVarIntent", VarIntent);
var SubBuildNode = class extends Node4 {
  static get type() {
    return "SubBuild";
  }
  constructor(node, name, nodeType = null) {
    super(nodeType);
    this.node = node;
    this.name = name;
    this.isSubBuildNode = true;
  }
  getNodeType(builder) {
    if (this.nodeType !== null) return this.nodeType;
    builder.addSubBuild(this.name);
    const nodeType = this.node.getNodeType(builder);
    builder.removeSubBuild();
    return nodeType;
  }
  build(builder, ...params) {
    builder.addSubBuild(this.name);
    const data = this.node.build(builder, ...params);
    builder.removeSubBuild();
    return data;
  }
};
var subBuild = (node, name, type = null) => nodeObject(new SubBuildNode(nodeObject(node), name, type));
var VaryingNode = class extends Node4 {
  static get type() {
    return "VaryingNode";
  }
  /**
   * Constructs a new varying node.
   *
   * @param {Node} node - The node for which a varying should be created.
   * @param {?string} name - The name of the varying in the shader.
   */
  constructor(node, name = null) {
    super();
    this.node = node;
    this.name = name;
    this.isVaryingNode = true;
    this.interpolationType = null;
    this.interpolationSampling = null;
    this.global = true;
  }
  /**
   * Defines the interpolation type of the varying.
   *
   * @param {string} type - The interpolation type.
   * @param {?string} sampling - The interpolation sampling type
   * @return {VaryingNode} A reference to this node.
   */
  setInterpolation(type, sampling = null) {
    this.interpolationType = type;
    this.interpolationSampling = sampling;
    return this;
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  /**
   * This method performs the setup of a varying node with the current node builder.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {NodeVarying} The node varying from the node builder.
   */
  setupVarying(builder) {
    const properties = builder.getNodeProperties(this);
    let varying2 = properties.varying;
    if (varying2 === void 0) {
      const name = this.name;
      const type = this.getNodeType(builder);
      const interpolationType = this.interpolationType;
      const interpolationSampling = this.interpolationSampling;
      properties.varying = varying2 = builder.getVaryingFromNode(this, name, type, interpolationType, interpolationSampling);
      properties.node = subBuild(this.node, "VERTEX");
    }
    varying2.needsInterpolation || (varying2.needsInterpolation = builder.shaderStage === "fragment");
    return varying2;
  }
  setup(builder) {
    this.setupVarying(builder);
    builder.flowNodeFromShaderStage(NodeShaderStage.VERTEX, this.node);
  }
  analyze(builder) {
    this.setupVarying(builder);
    builder.flowNodeFromShaderStage(NodeShaderStage.VERTEX, this.node);
  }
  generate(builder) {
    const propertyKey = builder.getSubBuildProperty("property", builder.currentStack);
    const properties = builder.getNodeProperties(this);
    const varying2 = this.setupVarying(builder);
    if (properties[propertyKey] === void 0) {
      const type = this.getNodeType(builder);
      const propertyName = builder.getPropertyName(varying2, NodeShaderStage.VERTEX);
      builder.flowNodeFromShaderStage(NodeShaderStage.VERTEX, properties.node, type, propertyName);
      properties[propertyKey] = propertyName;
    }
    return builder.getPropertyName(varying2);
  }
};
var varying = nodeProxy(VaryingNode).setParameterLength(1, 2);
var vertexStage = (node) => varying(node);
addMethodChaining("toVarying", varying);
addMethodChaining("toVertexStage", vertexStage);
addMethodChaining("varying", (...params) => {
  warn("TSL: .varying() has been renamed to .toVarying().");
  return varying(...params);
});
addMethodChaining("vertexStage", (...params) => {
  warn("TSL: .vertexStage() has been renamed to .toVertexStage().");
  return varying(...params);
});
var sRGBTransferEOTF = Fn(([color3]) => {
  const a3 = color3.mul(0.9478672986).add(0.0521327014).pow(2.4);
  const b = color3.mul(0.0773993808);
  const factor = color3.lessThanEqual(0.04045);
  const rgbResult = mix2(a3, b, factor);
  return rgbResult;
}).setLayout({
  name: "sRGBTransferEOTF",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" }
  ]
});
var sRGBTransferOETF = Fn(([color3]) => {
  const a3 = color3.pow(0.41666).mul(1.055).sub(0.055);
  const b = color3.mul(12.92);
  const factor = color3.lessThanEqual(31308e-7);
  const rgbResult = mix2(a3, b, factor);
  return rgbResult;
}).setLayout({
  name: "sRGBTransferOETF",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" }
  ]
});
var WORKING_COLOR_SPACE = "WorkingColorSpace";
var OUTPUT_COLOR_SPACE = "OutputColorSpace";
var ColorSpaceNode = class extends TempNode {
  static get type() {
    return "ColorSpaceNode";
  }
  /**
   * Constructs a new color space node.
   *
   * @param {Node} colorNode - Represents the color to convert.
   * @param {string} source - The source color space.
   * @param {string} target - The target color space.
   */
  constructor(colorNode, source, target) {
    super("vec4");
    this.colorNode = colorNode;
    this.source = source;
    this.target = target;
  }
  /**
   * This method resolves the constants `WORKING_COLOR_SPACE` and
   * `OUTPUT_COLOR_SPACE` based on the current configuration of the
   * color management and renderer.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} colorSpace - The color space to resolve.
   * @return {string} The resolved color space.
   */
  resolveColorSpace(builder, colorSpace) {
    if (colorSpace === WORKING_COLOR_SPACE) {
      return ColorManagement.workingColorSpace;
    } else if (colorSpace === OUTPUT_COLOR_SPACE) {
      return builder.context.outputColorSpace || builder.renderer.outputColorSpace;
    }
    return colorSpace;
  }
  setup(builder) {
    const { colorNode } = this;
    const source = this.resolveColorSpace(builder, this.source);
    const target = this.resolveColorSpace(builder, this.target);
    let outputNode = colorNode;
    if (ColorManagement.enabled === false || source === target || !source || !target) {
      return outputNode;
    }
    if (ColorManagement.getTransfer(source) === SRGBTransfer) {
      outputNode = vec4(sRGBTransferEOTF(outputNode.rgb), outputNode.a);
    }
    if (ColorManagement.getPrimaries(source) !== ColorManagement.getPrimaries(target)) {
      outputNode = vec4(
        mat3(ColorManagement._getMatrix(new Matrix3(), source, target)).mul(outputNode.rgb),
        outputNode.a
      );
    }
    if (ColorManagement.getTransfer(target) === SRGBTransfer) {
      outputNode = vec4(sRGBTransferOETF(outputNode.rgb), outputNode.a);
    }
    return outputNode;
  }
};
var workingToColorSpace = (node, targetColorSpace) => nodeObject(new ColorSpaceNode(nodeObject(node), WORKING_COLOR_SPACE, targetColorSpace));
var colorSpaceToWorking = (node, sourceColorSpace) => nodeObject(new ColorSpaceNode(nodeObject(node), sourceColorSpace, WORKING_COLOR_SPACE));
var convertColorSpace = (node, sourceColorSpace, targetColorSpace) => nodeObject(new ColorSpaceNode(nodeObject(node), sourceColorSpace, targetColorSpace));
addMethodChaining("workingToColorSpace", workingToColorSpace);
addMethodChaining("colorSpaceToWorking", colorSpaceToWorking);
var ReferenceElementNode$1 = class ReferenceElementNode extends ArrayElementNode {
  static get type() {
    return "ReferenceElementNode";
  }
  /**
   * Constructs a new reference element node.
   *
   * @param {ReferenceBaseNode} referenceNode - The reference node.
   * @param {Node} indexNode - The index node that defines the element access.
   */
  constructor(referenceNode, indexNode) {
    super(referenceNode, indexNode);
    this.referenceNode = referenceNode;
    this.isReferenceElementNode = true;
  }
  /**
   * This method is overwritten since the node type is inferred from
   * the uniform type of the reference node.
   *
   * @return {string} The node type.
   */
  getNodeType() {
    return this.referenceNode.uniformType;
  }
  generate(builder) {
    const snippet = super.generate(builder);
    const arrayType = this.referenceNode.getNodeType();
    const elementType = this.getNodeType();
    return builder.format(snippet, arrayType, elementType);
  }
};
var ReferenceBaseNode = class extends Node4 {
  static get type() {
    return "ReferenceBaseNode";
  }
  /**
   * Constructs a new reference base node.
   *
   * @param {string} property - The name of the property the node refers to.
   * @param {string} uniformType - The uniform type that should be used to represent the property value.
   * @param {?Object} [object=null] - The object the property belongs to.
   * @param {?number} [count=null] - When the linked property is an array-like, this parameter defines its length.
   */
  constructor(property3, uniformType, object = null, count2 = null) {
    super();
    this.property = property3;
    this.uniformType = uniformType;
    this.object = object;
    this.count = count2;
    this.properties = property3.split(".");
    this.reference = object;
    this.node = null;
    this.group = null;
    this.updateType = NodeUpdateType.OBJECT;
  }
  /**
   * Sets the uniform group for this reference node.
   *
   * @param {UniformGroupNode} group - The uniform group to set.
   * @return {ReferenceBaseNode} A reference to this node.
   */
  setGroup(group2) {
    this.group = group2;
    return this;
  }
  /**
   * When the referred property is array-like, this method can be used
   * to access elements via an index node.
   *
   * @param {IndexNode} indexNode - indexNode.
   * @return {ReferenceElementNode} A reference to an element.
   */
  element(indexNode) {
    return new ReferenceElementNode$1(this, nodeObject(indexNode));
  }
  /**
   * Sets the node type which automatically defines the internal
   * uniform type.
   *
   * @param {string} uniformType - The type to set.
   */
  setNodeType(uniformType) {
    const node = uniform(null, uniformType);
    if (this.group !== null) {
      node.setGroup(this.group);
    }
    this.node = node;
  }
  /**
   * This method is overwritten since the node type is inferred from
   * the type of the reference node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    if (this.node === null) {
      this.updateReference(builder);
      this.updateValue();
    }
    return this.node.getNodeType(builder);
  }
  /**
   * Returns the property value from the given referred object.
   *
   * @param {Object} [object=this.reference] - The object to retrieve the property value from.
   * @return {any} The value.
   */
  getValueFromReference(object = this.reference) {
    const { properties } = this;
    let value = object[properties[0]];
    for (let i2 = 1; i2 < properties.length; i2++) {
      value = value[properties[i2]];
    }
    return value;
  }
  /**
   * Allows to update the reference based on the given state. The state is only
   * evaluated {@link ReferenceBaseNode#object} is not set.
   *
   * @param {(NodeFrame|NodeBuilder)} state - The current state.
   * @return {Object} The updated reference.
   */
  updateReference(state) {
    this.reference = this.object !== null ? this.object : state.object;
    return this.reference;
  }
  /**
   * The output of the reference node is the internal uniform node.
   *
   * @return {UniformNode} The output node.
   */
  setup() {
    this.updateValue();
    return this.node;
  }
  /**
   * Overwritten to update the internal uniform value.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update() {
    this.updateValue();
  }
  /**
   * Retrieves the value from the referred object property and uses it
   * to updated the internal uniform.
   */
  updateValue() {
    if (this.node === null) this.setNodeType(this.uniformType);
    const value = this.getValueFromReference();
    if (Array.isArray(value)) {
      this.node.array = value;
    } else {
      this.node.value = value;
    }
  }
};
var reference$1 = (name, type, object) => new ReferenceBaseNode(name, type, object);
var RendererReferenceNode = class extends ReferenceBaseNode {
  static get type() {
    return "RendererReferenceNode";
  }
  /**
   * Constructs a new renderer reference node.
   *
   * @param {string} property - The name of the property the node refers to.
   * @param {string} inputType - The uniform type that should be used to represent the property value.
   * @param {?Renderer} [renderer=null] - The renderer the property belongs to. When no renderer is set,
   * the node refers to the renderer of the current state.
   */
  constructor(property3, inputType, renderer3 = null) {
    super(property3, inputType, renderer3);
    this.renderer = renderer3;
    this.setGroup(renderGroup);
  }
  /**
   * Updates the reference based on the given state. The state is only evaluated
   * {@link RendererReferenceNode#renderer} is not set.
   *
   * @param {(NodeFrame|NodeBuilder)} state - The current state.
   * @return {Object} The updated reference.
   */
  updateReference(state) {
    this.reference = this.renderer !== null ? this.renderer : state.renderer;
    return this.reference;
  }
};
var rendererReference = (name, type, renderer3 = null) => new RendererReferenceNode(name, type, renderer3);
var ToneMappingNode = class extends TempNode {
  static get type() {
    return "ToneMappingNode";
  }
  /**
   * Constructs a new tone mapping node.
   *
   * @param {number} toneMapping - The tone mapping type.
   * @param {Node} exposureNode - The tone mapping exposure.
   * @param {Node} [colorNode=null] - The color node to process.
   */
  constructor(toneMapping2, exposureNode = toneMappingExposure, colorNode = null) {
    super("vec3");
    this._toneMapping = toneMapping2;
    this.exposureNode = exposureNode;
    this.colorNode = colorNode;
  }
  /**
   * Overwrites the default `customCacheKey()` implementation by including the tone
   * mapping type into the cache key.
   *
   * @return {number} The hash.
   */
  customCacheKey() {
    return hash$1(this._toneMapping);
  }
  /**
   * Sets the tone mapping type.
   *
   * @param {number} value - The tone mapping type.
   * @return {ToneMappingNode} A reference to this node.
   */
  setToneMapping(value) {
    this._toneMapping = value;
    return this;
  }
  /**
   * Gets the tone mapping type.
   *
   * @returns {number} The tone mapping type.
   */
  getToneMapping() {
    return this._toneMapping;
  }
  setup(builder) {
    const colorNode = this.colorNode || builder.context.color;
    const toneMapping2 = this._toneMapping;
    if (toneMapping2 === NoToneMapping) return colorNode;
    let outputNode = null;
    const toneMappingFn = builder.renderer.library.getToneMappingFunction(toneMapping2);
    if (toneMappingFn !== null) {
      outputNode = vec4(toneMappingFn(colorNode.rgb, this.exposureNode), colorNode.a);
    } else {
      error("ToneMappingNode: Unsupported Tone Mapping configuration.", toneMapping2);
      outputNode = colorNode;
    }
    return outputNode;
  }
};
var toneMapping = (mapping, exposure, color3) => nodeObject(new ToneMappingNode(mapping, nodeObject(exposure), nodeObject(color3)));
var toneMappingExposure = rendererReference("toneMappingExposure", "float");
addMethodChaining("toneMapping", (color3, mapping, exposure) => toneMapping(mapping, exposure, color3));
var _bufferLib = /* @__PURE__ */ new WeakMap();
function _getBufferAttribute(value, itemSize) {
  let buffer2 = _bufferLib.get(value);
  if (buffer2 === void 0) {
    buffer2 = new InterleavedBuffer(value, itemSize);
    _bufferLib.set(value, buffer2);
  }
  return buffer2;
}
var BufferAttributeNode = class extends InputNode {
  static get type() {
    return "BufferAttributeNode";
  }
  /**
   * Constructs a new buffer attribute node.
   *
   * @param {BufferAttribute|InterleavedBuffer|TypedArray} value - The attribute data.
   * @param {?string} [bufferType=null] - The buffer type (e.g. `'vec3'`).
   * @param {number} [bufferStride=0] - The buffer stride.
   * @param {number} [bufferOffset=0] - The buffer offset.
   */
  constructor(value, bufferType = null, bufferStride = 0, bufferOffset = 0) {
    super(value, bufferType);
    this.isBufferNode = true;
    this.bufferType = bufferType;
    this.bufferStride = bufferStride;
    this.bufferOffset = bufferOffset;
    this.usage = StaticDrawUsage;
    this.instanced = false;
    this.attribute = null;
    this.global = true;
    if (value && value.isBufferAttribute === true && value.itemSize <= 4) {
      this.attribute = value;
      this.usage = value.usage;
      this.instanced = value.isInstancedBufferAttribute;
    }
  }
  /**
   * This method is overwritten since the attribute data might be shared
   * and thus the hash should be shared as well.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The hash.
   */
  getHash(builder) {
    if (this.bufferStride === 0 && this.bufferOffset === 0) {
      let bufferData = builder.globalCache.getData(this.value);
      if (bufferData === void 0) {
        bufferData = {
          node: this
        };
        builder.globalCache.setData(this.value, bufferData);
      }
      return bufferData.node.uuid;
    }
    return this.uuid;
  }
  /**
   * This method is overwritten since the node type is inferred from
   * the buffer attribute.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    if (this.bufferType === null) {
      this.bufferType = builder.getTypeFromAttribute(this.attribute);
    }
    return this.bufferType;
  }
  /**
   * Depending on which value was passed to the node, `setup()` behaves
   * differently. If no instance of `BufferAttribute` was passed, the method
   * creates an internal attribute and configures it respectively.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setup(builder) {
    if (this.attribute !== null) return;
    const type = this.getNodeType(builder);
    const itemSize = builder.getTypeLength(type);
    const value = this.value;
    const stride = this.bufferStride || itemSize;
    const offset = this.bufferOffset;
    let buffer2;
    if (value.isInterleavedBuffer === true) {
      buffer2 = value;
    } else if (value.isBufferAttribute === true) {
      buffer2 = _getBufferAttribute(value.array, stride);
    } else {
      buffer2 = _getBufferAttribute(value, stride);
    }
    const bufferAttribute2 = new InterleavedBufferAttribute(buffer2, itemSize, offset);
    buffer2.setUsage(this.usage);
    this.attribute = bufferAttribute2;
    this.attribute.isInstancedBufferAttribute = this.instanced;
  }
  /**
   * Generates the code snippet of the buffer attribute node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The generated code snippet.
   */
  generate(builder) {
    const nodeType = this.getNodeType(builder);
    const nodeAttribute = builder.getBufferAttributeFromNode(this, nodeType);
    const propertyName = builder.getPropertyName(nodeAttribute);
    let output2 = null;
    if (builder.shaderStage === "vertex" || builder.shaderStage === "compute") {
      this.name = propertyName;
      output2 = propertyName;
    } else {
      const nodeVarying = varying(this);
      output2 = nodeVarying.build(builder, nodeType);
    }
    return output2;
  }
  /**
   * Overwrites the default implementation to return a fixed value `'bufferAttribute'`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType() {
    return "bufferAttribute";
  }
  /**
   * Sets the `usage` property to the given value.
   *
   * @param {number} value - The usage to set.
   * @return {BufferAttributeNode} A reference to this node.
   */
  setUsage(value) {
    this.usage = value;
    if (this.attribute && this.attribute.isBufferAttribute === true) {
      this.attribute.usage = value;
    }
    return this;
  }
  /**
   * Sets the `instanced` property to the given value.
   *
   * @param {boolean} value - The value to set.
   * @return {BufferAttributeNode} A reference to this node.
   */
  setInstanced(value) {
    this.instanced = value;
    return this;
  }
};
function createBufferAttribute(array4, type = null, stride = 0, offset = 0, usage = StaticDrawUsage, instanced = false) {
  if (type === "mat3" || type === null && array4.itemSize === 9) {
    return mat3(
      new BufferAttributeNode(array4, "vec3", 9, 0).setUsage(usage).setInstanced(instanced),
      new BufferAttributeNode(array4, "vec3", 9, 3).setUsage(usage).setInstanced(instanced),
      new BufferAttributeNode(array4, "vec3", 9, 6).setUsage(usage).setInstanced(instanced)
    );
  } else if (type === "mat4" || type === null && array4.itemSize === 16) {
    return mat4(
      new BufferAttributeNode(array4, "vec4", 16, 0).setUsage(usage).setInstanced(instanced),
      new BufferAttributeNode(array4, "vec4", 16, 4).setUsage(usage).setInstanced(instanced),
      new BufferAttributeNode(array4, "vec4", 16, 8).setUsage(usage).setInstanced(instanced),
      new BufferAttributeNode(array4, "vec4", 16, 12).setUsage(usage).setInstanced(instanced)
    );
  }
  return new BufferAttributeNode(array4, type, stride, offset);
}
var bufferAttribute = (array4, type = null, stride = 0, offset = 0) => createBufferAttribute(array4, type, stride, offset);
var dynamicBufferAttribute = (array4, type = null, stride = 0, offset = 0) => createBufferAttribute(array4, type, stride, offset, DynamicDrawUsage);
var instancedBufferAttribute = (array4, type = null, stride = 0, offset = 0) => createBufferAttribute(array4, type, stride, offset, StaticDrawUsage, true);
var instancedDynamicBufferAttribute = (array4, type = null, stride = 0, offset = 0) => createBufferAttribute(array4, type, stride, offset, DynamicDrawUsage, true);
addMethodChaining("toAttribute", (bufferNode) => bufferAttribute(bufferNode.value));
var ComputeNode = class extends Node4 {
  static get type() {
    return "ComputeNode";
  }
  /**
   * Constructs a new compute node.
   *
   * @param {Node} computeNode - TODO
   * @param {Array<number>} workgroupSize - TODO.
   */
  constructor(computeNode, workgroupSize) {
    super("void");
    this.isComputeNode = true;
    this.computeNode = computeNode;
    this.workgroupSize = workgroupSize;
    this.count = null;
    this.version = 1;
    this.name = "";
    this.updateBeforeType = NodeUpdateType.OBJECT;
    this.onInitFunction = null;
  }
  /**
   * TODO
   *
   * @param {number|Array<number>} count - Array with [ x, y, z ] values for dispatch or a single number for the count
   * @return {ComputeNode}
   */
  setCount(count2) {
    this.count = count2;
    return this;
  }
  /**
   * TODO
   *
   * @return {number|Array<number>}
   */
  getCount() {
    return this.count;
  }
  /**
   * Executes the `dispose` event for this node.
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  /**
   * Sets the {@link ComputeNode#name} property.
   *
   * @param {string} name - The name of the uniform.
   * @return {ComputeNode} A reference to this node.
   */
  setName(name) {
    this.name = name;
    return this;
  }
  /**
   * Sets the {@link ComputeNode#name} property.
   *
   * @deprecated
   * @param {string} name - The name of the uniform.
   * @return {ComputeNode} A reference to this node.
   */
  label(name) {
    warn('TSL: "label()" has been deprecated. Use "setName()" instead.');
    return this.setName(name);
  }
  /**
   * TODO
   *
   * @param {Function} callback - TODO.
   * @return {ComputeNode} A reference to this node.
   */
  onInit(callback) {
    this.onInitFunction = callback;
    return this;
  }
  /**
   * The method execute the compute for this node.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  updateBefore({ renderer: renderer3 }) {
    renderer3.compute(this);
  }
  setup(builder) {
    const result2 = this.computeNode.build(builder);
    if (result2) {
      const properties = builder.getNodeProperties(this);
      properties.outputComputeNode = result2.outputNode;
      result2.outputNode = null;
    }
    return result2;
  }
  generate(builder, output2) {
    const { shaderStage } = builder;
    if (shaderStage === "compute") {
      const snippet = this.computeNode.build(builder, "void");
      if (snippet !== "") {
        builder.addLineFlowCode(snippet, this);
      }
    } else {
      const properties = builder.getNodeProperties(this);
      const outputComputeNode = properties.outputComputeNode;
      if (outputComputeNode) {
        return outputComputeNode.build(builder, output2);
      }
    }
  }
};
var computeKernel = (node, workgroupSize = [64]) => {
  if (workgroupSize.length === 0 || workgroupSize.length > 3) {
    error("TSL: compute() workgroupSize must have 1, 2, or 3 elements");
  }
  for (let i2 = 0; i2 < workgroupSize.length; i2++) {
    const val = workgroupSize[i2];
    if (typeof val !== "number" || val <= 0 || !Number.isInteger(val)) {
      error(`TSL: compute() workgroupSize element at index [ ${i2} ] must be a positive integer`);
    }
  }
  while (workgroupSize.length < 3) workgroupSize.push(1);
  return nodeObject(new ComputeNode(nodeObject(node), workgroupSize));
};
var compute = (node, count2, workgroupSize) => computeKernel(node, workgroupSize).setCount(count2);
addMethodChaining("compute", compute);
addMethodChaining("computeKernel", computeKernel);
var IsolateNode = class extends Node4 {
  static get type() {
    return "IsolateNode";
  }
  /**
   * Constructs a new cache node.
   *
   * @param {Node} node - The node that should be cached.
   * @param {boolean} [parent=true] - Whether this node refers to a shared parent cache or not.
   */
  constructor(node, parent2 = true) {
    super();
    this.node = node;
    this.parent = parent2;
    this.isIsolateNode = true;
  }
  getNodeType(builder) {
    const previousCache = builder.getCache();
    const cache2 = builder.getCacheFromNode(this, this.parent);
    builder.setCache(cache2);
    const nodeType = this.node.getNodeType(builder);
    builder.setCache(previousCache);
    return nodeType;
  }
  build(builder, ...params) {
    const previousCache = builder.getCache();
    const cache2 = builder.getCacheFromNode(this, this.parent);
    builder.setCache(cache2);
    const data = this.node.build(builder, ...params);
    builder.setCache(previousCache);
    return data;
  }
  setParent(parent2) {
    this.parent = parent2;
    return this;
  }
  getParent() {
    return this.parent;
  }
};
var isolate = (node) => new IsolateNode(nodeObject(node));
function cache(node, parent2 = true) {
  warn('TSL: "cache()" has been deprecated. Use "isolate()" instead.');
  return isolate(node).setParent(parent2);
}
addMethodChaining("cache", cache);
addMethodChaining("isolate", isolate);
var BypassNode = class extends Node4 {
  static get type() {
    return "BypassNode";
  }
  /**
   * Constructs a new bypass node.
   *
   * @param {Node} outputNode - The output node.
   * @param {Node} callNode - The call node.
   */
  constructor(outputNode, callNode) {
    super();
    this.isBypassNode = true;
    this.outputNode = outputNode;
    this.callNode = callNode;
  }
  getNodeType(builder) {
    return this.outputNode.getNodeType(builder);
  }
  generate(builder) {
    const snippet = this.callNode.build(builder, "void");
    if (snippet !== "") {
      builder.addLineFlowCode(snippet, this);
    }
    return this.outputNode.build(builder);
  }
};
var bypass = nodeProxy(BypassNode).setParameterLength(2);
addMethodChaining("bypass", bypass);
var RemapNode = class extends Node4 {
  static get type() {
    return "RemapNode";
  }
  /**
   * Constructs a new remap node.
   *
   * @param {Node} node - The node that should be remapped.
   * @param {Node} inLowNode - The source or current lower bound of the range.
   * @param {Node} inHighNode - The source or current upper bound of the range.
   * @param {Node} [outLowNode=float(0)] - The target lower bound of the range.
   * @param {Node} [outHighNode=float(1)] - The target upper bound of the range.
   */
  constructor(node, inLowNode, inHighNode, outLowNode = float(0), outHighNode = float(1)) {
    super();
    this.node = node;
    this.inLowNode = inLowNode;
    this.inHighNode = inHighNode;
    this.outLowNode = outLowNode;
    this.outHighNode = outHighNode;
    this.doClamp = true;
  }
  setup() {
    const { node, inLowNode, inHighNode, outLowNode, outHighNode, doClamp } = this;
    let t5 = node.sub(inLowNode).div(inHighNode.sub(inLowNode));
    if (doClamp === true) t5 = t5.clamp();
    return t5.mul(outHighNode.sub(outLowNode)).add(outLowNode);
  }
};
var remap = nodeProxy(RemapNode, null, null, { doClamp: false }).setParameterLength(3, 5);
var remapClamp = nodeProxy(RemapNode).setParameterLength(3, 5);
addMethodChaining("remap", remap);
addMethodChaining("remapClamp", remapClamp);
var ExpressionNode = class extends Node4 {
  static get type() {
    return "ExpressionNode";
  }
  /**
   * Constructs a new expression node.
   *
   * @param {string} [snippet=''] - The native code snippet.
   * @param {string} [nodeType='void'] - The node type.
   */
  constructor(snippet = "", nodeType = "void") {
    super(nodeType);
    this.snippet = snippet;
  }
  generate(builder, output2) {
    const type = this.getNodeType(builder);
    const snippet = this.snippet;
    if (type === "void") {
      builder.addLineFlowCode(snippet, this);
    } else {
      return builder.format(snippet, type, output2);
    }
  }
};
var expression = nodeProxy(ExpressionNode).setParameterLength(1, 2);
var Discard = (conditional) => (conditional ? select(conditional, expression("discard")) : expression("discard")).toStack();
var Return = () => expression("return").toStack();
addMethodChaining("discard", Discard);
var RenderOutputNode = class extends TempNode {
  static get type() {
    return "RenderOutputNode";
  }
  /**
   * Constructs a new render output node.
   *
   * @param {Node} colorNode - The color node to process.
   * @param {?number} toneMapping - The tone mapping type.
   * @param {?string} outputColorSpace - The output color space.
   */
  constructor(colorNode, toneMapping2, outputColorSpace) {
    super("vec4");
    this.colorNode = colorNode;
    this._toneMapping = toneMapping2;
    this.outputColorSpace = outputColorSpace;
    this.isRenderOutputNode = true;
  }
  /**
   * Sets the tone mapping type.
   *
   * @param {number} value - The tone mapping type.
   * @return {ToneMappingNode} A reference to this node.
   */
  setToneMapping(value) {
    this._toneMapping = value;
    return this;
  }
  /**
   * Gets the tone mapping type.
   *
   * @returns {number} The tone mapping type.
   */
  getToneMapping() {
    return this._toneMapping;
  }
  setup({ context: context2 }) {
    let outputNode = this.colorNode || context2.color;
    const toneMapping2 = (this._toneMapping !== null ? this._toneMapping : context2.toneMapping) || NoToneMapping;
    const outputColorSpace = (this.outputColorSpace !== null ? this.outputColorSpace : context2.outputColorSpace) || NoColorSpace;
    if (toneMapping2 !== NoToneMapping) {
      outputNode = outputNode.toneMapping(toneMapping2);
    }
    if (outputColorSpace !== NoColorSpace && outputColorSpace !== ColorManagement.workingColorSpace) {
      outputNode = outputNode.workingToColorSpace(outputColorSpace);
    }
    return outputNode;
  }
};
var renderOutput = (color3, toneMapping2 = null, outputColorSpace = null) => nodeObject(new RenderOutputNode(nodeObject(color3), toneMapping2, outputColorSpace));
addMethodChaining("renderOutput", renderOutput);
var DebugNode = class extends TempNode {
  static get type() {
    return "DebugNode";
  }
  constructor(node, callback = null) {
    super();
    this.node = node;
    this.callback = callback;
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  setup(builder) {
    return this.node.build(builder);
  }
  analyze(builder) {
    return this.node.build(builder);
  }
  generate(builder) {
    const callback = this.callback;
    const snippet = this.node.build(builder);
    const title = "--- TSL debug - " + builder.shaderStage + " shader ---";
    const border = "-".repeat(title.length);
    let code2 = "";
    code2 += "// #" + title + "#\n";
    code2 += builder.flow.code.replace(/^\t/mg, "") + "\n";
    code2 += "/* ... */ " + snippet + " /* ... */\n";
    code2 += "// #" + border + "#\n";
    if (callback !== null) {
      callback(builder, code2);
    } else {
      log(code2);
    }
    return snippet;
  }
};
var debug = (node, callback = null) => nodeObject(new DebugNode(nodeObject(node), callback)).toStack();
addMethodChaining("debug", debug);
var InspectorBase = class {
  /**
   * Creates a new InspectorBase.
   */
  constructor() {
    this._renderer = null;
    this.currentFrame = null;
  }
  /**
   * Returns the node frame for the current renderer.
   *
   * @return {Object} The node frame.
   */
  get nodeFrame() {
    return this._renderer._nodes.nodeFrame;
  }
  /**
   * Sets the renderer for this inspector.
   *
   * @param {WebGLRenderer} renderer - The renderer to associate with this inspector.
   * @return {InspectorBase} This inspector instance.
   */
  setRenderer(renderer3) {
    this._renderer = renderer3;
    return this;
  }
  /**
   * Returns the renderer associated with this inspector.
   *
   * @return {WebGLRenderer} The associated renderer.
   */
  getRenderer() {
    return this._renderer;
  }
  /**
   * Initializes the inspector.
   */
  init() {
  }
  /**
   * Called when a frame begins.
   */
  begin() {
  }
  /**
   * Called when a frame ends.
   */
  finish() {
  }
  /**
   * Inspects a node.
   *
   * @param {Node} node - The node to inspect.
   */
  inspect() {
  }
  /**
   * When a compute operation is performed.
   *
   * @param {ComputeNode} computeNode - The compute node being executed.
   * @param {number|Array<number>} dispatchSizeOrCount - The dispatch size or count.
   */
  computeAsync() {
  }
  /**
   * Called when a compute operation begins.
   *
   * @param {string} uid - A unique identifier for the render context.
   * @param {ComputeNode} computeNode - The compute node being executed.
   */
  beginCompute() {
  }
  /**
   * Called when a compute operation ends.
   *
   * @param {string} uid - A unique identifier for the render context.
   * @param {ComputeNode} computeNode - The compute node being executed.
   */
  finishCompute() {
  }
  /**
   * Called when a render operation begins.
   *
   * @param {string} uid - A unique identifier for the render context.
   * @param {Scene} scene - The scene being rendered.
   * @param {Camera} camera - The camera being used for rendering.
   * @param {?WebGLRenderTarget} renderTarget - The render target, if any.
   */
  beginRender() {
  }
  /**
   * Called when an animation loop ends.
   *
   * @param {string} uid - A unique identifier for the render context.
   */
  finishRender() {
  }
  /**
   * Called when a texture copy operation is performed.
   *
   * @param {Texture} srcTexture - The source texture.
   * @param {Texture} dstTexture - The destination texture.
   */
  copyTextureToTexture() {
  }
  /**
   * Called when a framebuffer copy operation is performed.
   *
   * @param {Texture} framebufferTexture - The texture associated with the framebuffer.
   */
  copyFramebufferToTexture() {
  }
};
var InspectorNode = class extends Node4 {
  /**
   * Returns the type of the node.
   *
   * @returns {string}
   */
  static get type() {
    return "InspectorNode";
  }
  /**
   * Creates an InspectorNode.
   *
   * @param {Node} node - The node to inspect.
   * @param {string} [name=''] - Optional name for the inspector node.
   * @param {Function|null} [callback=null] - Optional callback to modify the node during setup.
   */
  constructor(node, name = "", callback = null) {
    super();
    this.node = node;
    this.name = name;
    this.callback = callback;
    this.updateType = NodeUpdateType.FRAME;
    this.isInspectorNode = true;
  }
  /**
   * Returns the name of the inspector node.
   *
   * @returns {string}
   */
  getName() {
    return this.name || this.node.name;
  }
  /**
   * Updates the inspector node, allowing inspection of the wrapped node.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update(frame2) {
    frame2.renderer.inspector.inspect(this);
  }
  /**
   * Returns the type of the wrapped node.
   *
   * @param {NodeBuilder} builder - The node builder.
   * @returns {string}
   */
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  /**
   * Sets up the inspector node.
   *
   * @param {NodeBuilder} builder - The node builder.
   * @returns {Node} The setup node.
   */
  setup(builder) {
    let node = this.node;
    if (builder.context.inspector === true && this.callback !== null) {
      node = this.callback(node);
    }
    if (builder.renderer.backend.isWebGPUBackend !== true && builder.renderer.inspector.constructor !== InspectorBase) {
      warnOnce('TSL: ".toInspector()" is only available with WebGPU.');
    }
    return node;
  }
};
function inspector(node, name = "", callback = null) {
  node = nodeObject(node);
  return node.before(new InspectorNode(node, name, callback));
}
addMethodChaining("toInspector", inspector);
function addNodeElement(name) {
  warn("TSL: AddNodeElement has been removed in favor of tree-shaking. Trying add", name);
}
var AttributeNode = class extends Node4 {
  static get type() {
    return "AttributeNode";
  }
  /**
   * Constructs a new attribute node.
   *
   * @param {string} attributeName - The name of the attribute.
   * @param {?string} nodeType - The node type.
   */
  constructor(attributeName, nodeType = null) {
    super(nodeType);
    this.global = true;
    this._attributeName = attributeName;
  }
  getHash(builder) {
    return this.getAttributeName(builder);
  }
  getNodeType(builder) {
    let nodeType = this.nodeType;
    if (nodeType === null) {
      const attributeName = this.getAttributeName(builder);
      if (builder.hasGeometryAttribute(attributeName)) {
        const attribute2 = builder.geometry.getAttribute(attributeName);
        nodeType = builder.getTypeFromAttribute(attribute2);
      } else {
        nodeType = "float";
      }
    }
    return nodeType;
  }
  /**
   * Sets the attribute name to the given value. The method can be
   * overwritten in derived classes if the final name must be computed
   * analytically.
   *
   * @param {string} attributeName - The name of the attribute.
   * @return {AttributeNode} A reference to this node.
   */
  setAttributeName(attributeName) {
    this._attributeName = attributeName;
    return this;
  }
  /**
   * Returns the attribute name of this node. The method can be
   * overwritten in derived classes if the final name must be computed
   * analytically.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The attribute name.
   */
  getAttributeName() {
    return this._attributeName;
  }
  generate(builder) {
    const attributeName = this.getAttributeName(builder);
    const nodeType = this.getNodeType(builder);
    const geometryAttribute = builder.hasGeometryAttribute(attributeName);
    if (geometryAttribute === true) {
      const attribute2 = builder.geometry.getAttribute(attributeName);
      const attributeType = builder.getTypeFromAttribute(attribute2);
      const nodeAttribute = builder.getAttribute(attributeName, attributeType);
      if (builder.shaderStage === "vertex") {
        return builder.format(nodeAttribute.name, attributeType, nodeType);
      } else {
        const nodeVarying = varying(this);
        return nodeVarying.build(builder, nodeType);
      }
    } else {
      warn(`AttributeNode: Vertex attribute "${attributeName}" not found on geometry.`);
      return builder.generateConst(nodeType);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.global = this.global;
    data._attributeName = this._attributeName;
  }
  deserialize(data) {
    super.deserialize(data);
    this.global = data.global;
    this._attributeName = data._attributeName;
  }
};
var attribute = (name, nodeType = null) => new AttributeNode(name, nodeType);
var uv$1 = (index8 = 0) => attribute("uv" + (index8 > 0 ? index8 : ""), "vec2");
var TextureSizeNode = class extends Node4 {
  static get type() {
    return "TextureSizeNode";
  }
  /**
   * Constructs a new texture size node.
   *
   * @param {TextureNode} textureNode - A texture node which size should be retrieved.
   * @param {?Node<int>} [levelNode=null] - A level node which defines the requested mip.
   */
  constructor(textureNode, levelNode = null) {
    super("uvec2");
    this.isTextureSizeNode = true;
    this.textureNode = textureNode;
    this.levelNode = levelNode;
  }
  generate(builder, output2) {
    const textureProperty = this.textureNode.build(builder, "property");
    const level = this.levelNode === null ? "0" : this.levelNode.build(builder, "int");
    return builder.format(`${builder.getMethod("textureDimensions")}( ${textureProperty}, ${level} )`, this.getNodeType(builder), output2);
  }
};
var textureSize = nodeProxy(TextureSizeNode).setParameterLength(1, 2);
var MaxMipLevelNode = class extends UniformNode {
  static get type() {
    return "MaxMipLevelNode";
  }
  /**
   * Constructs a new max mip level node.
   *
   * @param {TextureNode} textureNode - The texture node to compute the max mip level for.
   */
  constructor(textureNode) {
    super(0);
    this._textureNode = textureNode;
    this.updateType = NodeUpdateType.FRAME;
  }
  /**
   * The texture node to compute the max mip level for.
   *
   * @readonly
   * @type {TextureNode}
   */
  get textureNode() {
    return this._textureNode;
  }
  /**
   * The texture.
   *
   * @readonly
   * @type {Texture}
   */
  get texture() {
    return this._textureNode.value;
  }
  update() {
    const texture2 = this.texture;
    const images = texture2.images;
    const image = images && images.length > 0 ? images[0] && images[0].image || images[0] : texture2.image;
    if (image && image.width !== void 0) {
      const { width, height } = image;
      this.value = Math.log2(Math.max(width, height));
    }
  }
};
var maxMipLevel = nodeProxy(MaxMipLevelNode).setParameterLength(1);
var EmptyTexture$1 = new Texture();
var TextureNode = class extends UniformNode {
  static get type() {
    return "TextureNode";
  }
  /**
   * Constructs a new texture node.
   *
   * @param {Texture} [value=EmptyTexture] - The texture.
   * @param {?Node<vec2|vec3>} [uvNode=null] - The uv node.
   * @param {?Node<int>} [levelNode=null] - The level node.
   * @param {?Node<float>} [biasNode=null] - The bias node.
   */
  constructor(value = EmptyTexture$1, uvNode = null, levelNode = null, biasNode = null) {
    super(value);
    this.isTextureNode = true;
    this.uvNode = uvNode;
    this.levelNode = levelNode;
    this.biasNode = biasNode;
    this.compareNode = null;
    this.depthNode = null;
    this.gradNode = null;
    this.offsetNode = null;
    this.sampler = true;
    this.updateMatrix = false;
    this.updateType = NodeUpdateType.NONE;
    this.referenceNode = null;
    this._value = value;
    this._matrixUniform = null;
    this._flipYUniform = null;
    this.setUpdateMatrix(uvNode === null);
  }
  set value(value) {
    if (this.referenceNode) {
      this.referenceNode.value = value;
    } else {
      this._value = value;
    }
  }
  /**
   * The texture value.
   *
   * @type {Texture}
   */
  get value() {
    return this.referenceNode ? this.referenceNode.value : this._value;
  }
  /**
   * Overwritten since the uniform hash is defined by the texture's UUID.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The uniform hash.
   */
  getUniformHash() {
    return this.value.uuid;
  }
  /**
   * Overwritten since the node type is inferred from the texture type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType() {
    if (this.value.isDepthTexture === true) return "float";
    if (this.value.type === UnsignedIntType) {
      return "uvec4";
    } else if (this.value.type === IntType) {
      return "ivec4";
    }
    return "vec4";
  }
  /**
   * Overwrites the default implementation to return a fixed value `'texture'`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType() {
    return "texture";
  }
  /**
   * Returns a default uvs based on the current texture's channel.
   *
   * @return {AttributeNode<vec2>} The default uvs.
   */
  getDefaultUV() {
    return uv$1(this.value.channel);
  }
  /**
   * Overwritten to always return the texture reference of the node.
   *
   * @param {any} state - This method can be invocated in different contexts so `state` can refer to any object type.
   * @return {Texture} The texture reference.
   */
  updateReference() {
    return this.value;
  }
  /**
   * Transforms the given uv node with the texture transformation matrix.
   *
   * @param {Node} uvNode - The uv node to transform.
   * @return {Node} The transformed uv node.
   */
  getTransformedUV(uvNode) {
    if (this._matrixUniform === null) this._matrixUniform = uniform(this.value.matrix);
    return this._matrixUniform.mul(vec3(uvNode, 1)).xy;
  }
  /**
   * Defines whether the uv transformation matrix should automatically be updated or not.
   *
   * @param {boolean} value - The update toggle.
   * @return {TextureNode} A reference to this node.
   */
  setUpdateMatrix(value) {
    this.updateMatrix = value;
    return this;
  }
  /**
   * Setups the uv node. Depending on the backend as well as texture's image and type, it might be necessary
   * to modify the uv node for correct sampling.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node} uvNode - The uv node to setup.
   * @return {Node} The updated uv node.
   */
  setupUV(builder, uvNode) {
    if (builder.isFlipY()) {
      if (this._flipYUniform === null) this._flipYUniform = uniform(false);
      uvNode = uvNode.toVar();
      if (this.sampler) {
        uvNode = this._flipYUniform.select(uvNode.flipY(), uvNode);
      } else {
        uvNode = this._flipYUniform.select(uvNode.setY(int(textureSize(this, this.levelNode).y).sub(uvNode.y).sub(1)), uvNode);
      }
    }
    return uvNode;
  }
  /**
   * Setups texture node by preparing the internal nodes for code generation.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setup(builder) {
    const properties = builder.getNodeProperties(this);
    properties.referenceNode = this.referenceNode;
    const texture2 = this.value;
    if (!texture2 || texture2.isTexture !== true) {
      throw new Error("THREE.TSL: `texture( value )` function expects a valid instance of THREE.Texture().");
    }
    const uvNode = Fn(() => {
      let uvNode2 = this.uvNode;
      if ((uvNode2 === null || builder.context.forceUVContext === true) && builder.context.getUV) {
        uvNode2 = builder.context.getUV(this, builder);
      }
      if (!uvNode2) uvNode2 = this.getDefaultUV();
      if (this.updateMatrix === true) {
        uvNode2 = this.getTransformedUV(uvNode2);
      }
      uvNode2 = this.setupUV(builder, uvNode2);
      this.updateType = this._matrixUniform !== null || this._flipYUniform !== null ? NodeUpdateType.OBJECT : NodeUpdateType.NONE;
      return uvNode2;
    })();
    let levelNode = this.levelNode;
    if (levelNode === null && builder.context.getTextureLevel) {
      levelNode = builder.context.getTextureLevel(this);
    }
    properties.uvNode = uvNode;
    properties.levelNode = levelNode;
    properties.biasNode = this.biasNode;
    properties.compareNode = this.compareNode;
    properties.gradNode = this.gradNode;
    properties.depthNode = this.depthNode;
    properties.offsetNode = this.offsetNode;
  }
  /**
   * Generates the uv code snippet.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node} uvNode - The uv node to generate code for.
   * @return {string} The generated code snippet.
   */
  generateUV(builder, uvNode) {
    return uvNode.build(builder, this.sampler === true ? "vec2" : "ivec2");
  }
  /**
   * Generates the offset code snippet.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node} offsetNode - The offset node to generate code for.
   * @return {string} The generated code snippet.
   */
  generateOffset(builder, offsetNode) {
    return offsetNode.build(builder, "ivec2");
  }
  /**
   * Generates the snippet for the texture sampling.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} textureProperty - The texture property.
   * @param {string} uvSnippet - The uv snippet.
   * @param {?string} levelSnippet - The level snippet.
   * @param {?string} biasSnippet - The bias snippet.
   * @param {?string} depthSnippet - The depth snippet.
   * @param {?string} compareSnippet - The compare snippet.
   * @param {?Array<string>} gradSnippet - The grad snippet.
   * @param {?string} offsetSnippet - The offset snippet.
   * @return {string} The generated code snippet.
   */
  generateSnippet(builder, textureProperty, uvSnippet, levelSnippet, biasSnippet, depthSnippet, compareSnippet, gradSnippet, offsetSnippet) {
    const texture2 = this.value;
    let snippet;
    if (biasSnippet) {
      snippet = builder.generateTextureBias(texture2, textureProperty, uvSnippet, biasSnippet, depthSnippet, offsetSnippet);
    } else if (gradSnippet) {
      snippet = builder.generateTextureGrad(texture2, textureProperty, uvSnippet, gradSnippet, depthSnippet, offsetSnippet);
    } else if (compareSnippet) {
      snippet = builder.generateTextureCompare(texture2, textureProperty, uvSnippet, compareSnippet, depthSnippet, offsetSnippet);
    } else if (this.sampler === false) {
      snippet = builder.generateTextureLoad(texture2, textureProperty, uvSnippet, levelSnippet, depthSnippet, offsetSnippet);
    } else if (levelSnippet) {
      snippet = builder.generateTextureLevel(texture2, textureProperty, uvSnippet, levelSnippet, depthSnippet, offsetSnippet);
    } else {
      snippet = builder.generateTexture(texture2, textureProperty, uvSnippet, depthSnippet, offsetSnippet);
    }
    return snippet;
  }
  /**
   * Generates the code snippet of the texture node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} output - The current output.
   * @return {string} The generated code snippet.
   */
  generate(builder, output2) {
    const texture2 = this.value;
    const properties = builder.getNodeProperties(this);
    const textureProperty = super.generate(builder, "property");
    if (/^sampler/.test(output2)) {
      return textureProperty + "_sampler";
    } else if (builder.isReference(output2)) {
      return textureProperty;
    } else {
      const nodeData = builder.getDataFromNode(this);
      let propertyName = nodeData.propertyName;
      if (propertyName === void 0) {
        const { uvNode, levelNode, biasNode, compareNode, depthNode, gradNode, offsetNode } = properties;
        const uvSnippet = this.generateUV(builder, uvNode);
        const levelSnippet = levelNode ? levelNode.build(builder, "float") : null;
        const biasSnippet = biasNode ? biasNode.build(builder, "float") : null;
        const depthSnippet = depthNode ? depthNode.build(builder, "int") : null;
        const compareSnippet = compareNode ? compareNode.build(builder, "float") : null;
        const gradSnippet = gradNode ? [gradNode[0].build(builder, "vec2"), gradNode[1].build(builder, "vec2")] : null;
        const offsetSnippet = offsetNode ? this.generateOffset(builder, offsetNode) : null;
        const nodeVar = builder.getVarFromNode(this);
        propertyName = builder.getPropertyName(nodeVar);
        const snippet2 = this.generateSnippet(builder, textureProperty, uvSnippet, levelSnippet, biasSnippet, depthSnippet, compareSnippet, gradSnippet, offsetSnippet);
        builder.addLineFlowCode(`${propertyName} = ${snippet2}`, this);
        nodeData.snippet = snippet2;
        nodeData.propertyName = propertyName;
      }
      let snippet = propertyName;
      const nodeType = this.getNodeType(builder);
      if (builder.needsToWorkingColorSpace(texture2)) {
        snippet = colorSpaceToWorking(expression(snippet, nodeType), texture2.colorSpace).setup(builder).build(builder, nodeType);
      }
      return builder.format(snippet, nodeType, output2);
    }
  }
  /**
   * Sets the sampler value.
   *
   * @param {boolean} value - The sampler value to set.
   * @return {TextureNode} A reference to this texture node.
   */
  setSampler(value) {
    this.sampler = value;
    return this;
  }
  /**
   * Returns the sampler value.
   *
   * @return {boolean} The sampler value.
   */
  getSampler() {
    return this.sampler;
  }
  // @TODO: Move to TSL
  /**
   * @function
   * @deprecated since r172. Use {@link TextureNode#sample} instead.
   *
   * @param {Node} uvNode - The uv node.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  uv(uvNode) {
    warn("TextureNode: .uv() has been renamed. Use .sample() instead.");
    return this.sample(uvNode);
  }
  /**
   * Samples the texture with the given uv node.
   *
   * @param {Node} uvNode - The uv node.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  sample(uvNode) {
    const textureNode = this.clone();
    textureNode.uvNode = nodeObject(uvNode);
    textureNode.referenceNode = this.getBase();
    return nodeObject(textureNode);
  }
  /**
   * TSL function for creating a texture node that fetches/loads texels without interpolation.
   *
   * @param {Node<uvec2>} uvNode - The uv node.
   * @returns {TextureNode} A texture node representing the texture load.
   */
  load(uvNode) {
    return this.sample(uvNode).setSampler(false);
  }
  /**
   * Samples a blurred version of the texture by defining an internal bias.
   *
   * @param {Node<float>} amountNode - How blurred the texture should be.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  blur(amountNode) {
    const textureNode = this.clone();
    textureNode.biasNode = nodeObject(amountNode).mul(maxMipLevel(textureNode));
    textureNode.referenceNode = this.getBase();
    const map6 = textureNode.value;
    if (textureNode.generateMipmaps === false && (map6 && map6.generateMipmaps === false || map6.minFilter === NearestFilter || map6.magFilter === NearestFilter)) {
      warn("TSL: texture().blur() requires mipmaps and sampling. Use .generateMipmaps=true and .minFilter/.magFilter=THREE.LinearFilter in the Texture.");
      textureNode.biasNode = null;
    }
    return nodeObject(textureNode);
  }
  /**
   * Samples a specific mip of the texture.
   *
   * @param {Node<int>} levelNode - The mip level to sample.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  level(levelNode) {
    const textureNode = this.clone();
    textureNode.levelNode = nodeObject(levelNode);
    textureNode.referenceNode = this.getBase();
    return nodeObject(textureNode);
  }
  /**
   * Returns the texture size of the requested level.
   *
   * @param {Node<int>} levelNode - The level to compute the size for.
   * @return {TextureSizeNode} The texture size.
   */
  size(levelNode) {
    return textureSize(this, levelNode);
  }
  /**
   * Samples the texture with the given bias.
   *
   * @param {Node<float>} biasNode - The bias node.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  bias(biasNode) {
    const textureNode = this.clone();
    textureNode.biasNode = nodeObject(biasNode);
    textureNode.referenceNode = this.getBase();
    return nodeObject(textureNode);
  }
  /**
   * Returns the base texture of this node.
   * @return {TextureNode} The base texture node.
   */
  getBase() {
    return this.referenceNode ? this.referenceNode.getBase() : this;
  }
  /**
   * Samples the texture by executing a compare operation.
   *
   * @param {Node<float>} compareNode - The node that defines the compare value.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  compare(compareNode) {
    const textureNode = this.clone();
    textureNode.compareNode = nodeObject(compareNode);
    textureNode.referenceNode = this.getBase();
    return nodeObject(textureNode);
  }
  /**
   * Samples the texture using an explicit gradient.
   *
   * @param {Node<vec2>} gradNodeX - The gradX node.
   * @param {Node<vec2>} gradNodeY - The gradY node.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  grad(gradNodeX, gradNodeY) {
    const textureNode = this.clone();
    textureNode.gradNode = [nodeObject(gradNodeX), nodeObject(gradNodeY)];
    textureNode.referenceNode = this.getBase();
    return nodeObject(textureNode);
  }
  /**
   * Samples the texture by defining a depth node.
   *
   * @param {Node<int>} depthNode - The depth node.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  depth(depthNode) {
    const textureNode = this.clone();
    textureNode.depthNode = nodeObject(depthNode);
    textureNode.referenceNode = this.getBase();
    return nodeObject(textureNode);
  }
  /**
   * Samples the texture by defining an offset node.
   *
   * @param {Node<ivec2>} offsetNode - The offset node.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  offset(offsetNode) {
    const textureNode = this.clone();
    textureNode.offsetNode = nodeObject(offsetNode);
    textureNode.referenceNode = this.getBase();
    return nodeObject(textureNode);
  }
  // --
  serialize(data) {
    super.serialize(data);
    data.value = this.value.toJSON(data.meta).uuid;
    data.sampler = this.sampler;
    data.updateMatrix = this.updateMatrix;
    data.updateType = this.updateType;
  }
  deserialize(data) {
    super.deserialize(data);
    this.value = data.meta.textures[data.value];
    this.sampler = data.sampler;
    this.updateMatrix = data.updateMatrix;
    this.updateType = data.updateType;
  }
  /**
   * The update is used to implement the update of the uv transformation matrix.
   */
  update() {
    const texture2 = this.value;
    const matrixUniform = this._matrixUniform;
    if (matrixUniform !== null) matrixUniform.value = texture2.matrix;
    if (texture2.matrixAutoUpdate === true) {
      texture2.updateMatrix();
    }
    const flipYUniform = this._flipYUniform;
    if (flipYUniform !== null) {
      flipYUniform.value = texture2.image instanceof ImageBitmap && texture2.flipY === true || texture2.isRenderTargetTexture === true || texture2.isFramebufferTexture === true || texture2.isDepthTexture === true;
    }
  }
  /**
   * Clones the texture node.
   *
   * @return {TextureNode} The cloned texture node.
   */
  clone() {
    const newNode = new this.constructor(this.value, this.uvNode, this.levelNode, this.biasNode);
    newNode.sampler = this.sampler;
    newNode.depthNode = this.depthNode;
    newNode.compareNode = this.compareNode;
    newNode.gradNode = this.gradNode;
    newNode.offsetNode = this.offsetNode;
    return newNode;
  }
};
var textureBase = nodeProxy(TextureNode).setParameterLength(1, 4).setName("texture");
var texture = (value = EmptyTexture$1, uvNode = null, levelNode = null, biasNode = null) => {
  let textureNode;
  if (value && value.isTextureNode === true) {
    textureNode = nodeObject(value.clone());
    textureNode.referenceNode = value.getBase();
    if (uvNode !== null) textureNode.uvNode = nodeObject(uvNode);
    if (levelNode !== null) textureNode.levelNode = nodeObject(levelNode);
    if (biasNode !== null) textureNode.biasNode = nodeObject(biasNode);
  } else {
    textureNode = textureBase(value, uvNode, levelNode, biasNode);
  }
  return textureNode;
};
var uniformTexture = (value = EmptyTexture$1) => texture(value);
var textureLoad = (...params) => texture(...params).setSampler(false);
var textureLevel = (value, uv2, level) => texture(value, uv2).level(level);
var sampler = (value) => (value.isNode === true ? value : texture(value)).convert("sampler");
var samplerComparison = (value) => (value.isNode === true ? value : texture(value)).convert("samplerComparison");
var BufferNode = class extends UniformNode {
  static get type() {
    return "BufferNode";
  }
  /**
   * Constructs a new buffer node.
   *
   * @param {Array<number>} value - Array-like buffer data.
   * @param {string} bufferType - The data type of the buffer.
   * @param {number} [bufferCount=0] - The count of buffer elements.
   */
  constructor(value, bufferType, bufferCount = 0) {
    super(value, bufferType);
    this.isBufferNode = true;
    this.bufferType = bufferType;
    this.bufferCount = bufferCount;
    this.updateRanges = [];
  }
  /**
   * Adds a range of data in the data array to be updated on the GPU.
   *
   * @param {number} start - Position at which to start update.
   * @param {number} count - The number of components to update.
   */
  addUpdateRange(start2, count2) {
    this.updateRanges.push({ start: start2, count: count2 });
  }
  /**
   * Clears the update ranges.
   */
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  /**
   * The data type of the buffer elements.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The element type.
   */
  getElementType(builder) {
    return this.getNodeType(builder);
  }
  /**
   * Overwrites the default implementation to return a fixed value `'buffer'`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType() {
    return "buffer";
  }
};
var buffer = (value, type, count2) => new BufferNode(value, type, count2);
var UniformArrayElementNode = class extends ArrayElementNode {
  static get type() {
    return "UniformArrayElementNode";
  }
  /**
   * Constructs a new buffer node.
   *
   * @param {UniformArrayNode} uniformArrayNode - The uniform array node to access.
   * @param {IndexNode} indexNode - The index data that define the position of the accessed element in the array.
   */
  constructor(uniformArrayNode, indexNode) {
    super(uniformArrayNode, indexNode);
    this.isArrayBufferElementNode = true;
  }
  generate(builder) {
    const snippet = super.generate(builder);
    const type = this.getNodeType();
    const paddedType = this.node.getPaddedType();
    return builder.format(snippet, paddedType, type);
  }
};
var UniformArrayNode = class extends BufferNode {
  static get type() {
    return "UniformArrayNode";
  }
  /**
   * Constructs a new uniform array node.
   *
   * @param {Array<any>} value - Array holding the buffer data.
   * @param {?string} [elementType=null] - The data type of a buffer element.
   */
  constructor(value, elementType = null) {
    super(null);
    this.array = value;
    this.elementType = elementType === null ? getValueType(value[0]) : elementType;
    this.paddedType = this.getPaddedType();
    this.updateType = NodeUpdateType.RENDER;
    this.isArrayBufferNode = true;
  }
  /**
   * This method is overwritten since the node type is inferred from the
   * {@link UniformArrayNode#paddedType}.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType() {
    return this.paddedType;
  }
  /**
   * The data type of the array elements.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The element type.
   */
  getElementType() {
    return this.elementType;
  }
  /**
   * Returns the padded type based on the element type.
   *
   * @return {string} The padded type.
   */
  getPaddedType() {
    const elementType = this.elementType;
    let paddedType = "vec4";
    if (elementType === "mat2") {
      paddedType = "mat2";
    } else if (/mat/.test(elementType) === true) {
      paddedType = "mat4";
    } else if (elementType.charAt(0) === "i") {
      paddedType = "ivec4";
    } else if (elementType.charAt(0) === "u") {
      paddedType = "uvec4";
    }
    return paddedType;
  }
  /**
   * The update makes sure to correctly transfer the data from the (complex) objects
   * in the array to the internal, correctly padded value buffer.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update() {
    const { array: array4, value } = this;
    const elementType = this.elementType;
    if (elementType === "float" || elementType === "int" || elementType === "uint") {
      for (let i2 = 0; i2 < array4.length; i2++) {
        const index8 = i2 * 4;
        value[index8] = array4[i2];
      }
    } else if (elementType === "color") {
      for (let i2 = 0; i2 < array4.length; i2++) {
        const index8 = i2 * 4;
        const vector = array4[i2];
        value[index8] = vector.r;
        value[index8 + 1] = vector.g;
        value[index8 + 2] = vector.b || 0;
      }
    } else if (elementType === "mat2") {
      for (let i2 = 0; i2 < array4.length; i2++) {
        const index8 = i2 * 4;
        const matrix = array4[i2];
        value[index8] = matrix.elements[0];
        value[index8 + 1] = matrix.elements[1];
        value[index8 + 2] = matrix.elements[2];
        value[index8 + 3] = matrix.elements[3];
      }
    } else if (elementType === "mat3") {
      for (let i2 = 0; i2 < array4.length; i2++) {
        const index8 = i2 * 16;
        const matrix = array4[i2];
        value[index8] = matrix.elements[0];
        value[index8 + 1] = matrix.elements[1];
        value[index8 + 2] = matrix.elements[2];
        value[index8 + 4] = matrix.elements[3];
        value[index8 + 5] = matrix.elements[4];
        value[index8 + 6] = matrix.elements[5];
        value[index8 + 8] = matrix.elements[6];
        value[index8 + 9] = matrix.elements[7];
        value[index8 + 10] = matrix.elements[8];
        value[index8 + 15] = 1;
      }
    } else if (elementType === "mat4") {
      for (let i2 = 0; i2 < array4.length; i2++) {
        const index8 = i2 * 16;
        const matrix = array4[i2];
        for (let i3 = 0; i3 < matrix.elements.length; i3++) {
          value[index8 + i3] = matrix.elements[i3];
        }
      }
    } else {
      for (let i2 = 0; i2 < array4.length; i2++) {
        const index8 = i2 * 4;
        const vector = array4[i2];
        value[index8] = vector.x;
        value[index8 + 1] = vector.y;
        value[index8 + 2] = vector.z || 0;
        value[index8 + 3] = vector.w || 0;
      }
    }
  }
  /**
   * Implement the value buffer creation based on the array data.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @return {null}
   */
  setup(builder) {
    const length2 = this.array.length;
    const elementType = this.elementType;
    let arrayType = Float32Array;
    const paddedType = this.paddedType;
    const paddedElementLength = builder.getTypeLength(paddedType);
    if (elementType.charAt(0) === "i") arrayType = Int32Array;
    if (elementType.charAt(0) === "u") arrayType = Uint32Array;
    this.value = new arrayType(length2 * paddedElementLength);
    this.bufferCount = length2;
    this.bufferType = paddedType;
    return super.setup(builder);
  }
  /**
   * Overwrites the default `element()` method to provide element access
   * based on {@link UniformArrayNode}.
   *
   * @param {IndexNode} indexNode - The index node.
   * @return {UniformArrayElementNode}
   */
  element(indexNode) {
    return new UniformArrayElementNode(this, nodeObject(indexNode));
  }
};
var uniformArray = (values2, nodeType) => new UniformArrayNode(values2, nodeType);
var BuiltinNode = class extends Node4 {
  /**
   * Constructs a new builtin node.
   *
   * @param {string} name - The name of the built-in shader variable.
   */
  constructor(name) {
    super("float");
    this.name = name;
    this.isBuiltinNode = true;
  }
  /**
   * Generates the code snippet of the builtin node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The generated code snippet.
   */
  generate() {
    return this.name;
  }
};
var builtin = nodeProxy(BuiltinNode).setParameterLength(1);
var _screenSizeVec;
var _viewportVec;
var ScreenNode = class _ScreenNode extends Node4 {
  static get type() {
    return "ScreenNode";
  }
  /**
   * Constructs a new screen node.
   *
   * @param {('coordinate'|'viewport'|'size'|'uv'|'dpr')} scope - The node's scope.
   */
  constructor(scope) {
    super();
    this.scope = scope;
    this._output = null;
    this.isViewportNode = true;
  }
  /**
   * This method is overwritten since the node type depends on the selected scope.
   *
   * @return {('float'|'vec2'|'vec4')} The node type.
   */
  getNodeType() {
    if (this.scope === _ScreenNode.DPR) return "float";
    if (this.scope === _ScreenNode.VIEWPORT) return "vec4";
    else return "vec2";
  }
  /**
   * This method is overwritten since the node's update type depends on the selected scope.
   *
   * @return {NodeUpdateType} The update type.
   */
  getUpdateType() {
    let updateType = NodeUpdateType.NONE;
    if (this.scope === _ScreenNode.SIZE || this.scope === _ScreenNode.VIEWPORT || this.scope === _ScreenNode.DPR) {
      updateType = NodeUpdateType.RENDER;
    }
    this.updateType = updateType;
    return updateType;
  }
  /**
   * `ScreenNode` implements {@link Node#update} to retrieve viewport and size information
   * from the current renderer.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update({ renderer: renderer3 }) {
    const renderTarget = renderer3.getRenderTarget();
    if (this.scope === _ScreenNode.VIEWPORT) {
      if (renderTarget !== null) {
        _viewportVec.copy(renderTarget.viewport);
      } else {
        renderer3.getViewport(_viewportVec);
        _viewportVec.multiplyScalar(renderer3.getPixelRatio());
      }
    } else if (this.scope === _ScreenNode.DPR) {
      this._output.value = renderer3.getPixelRatio();
    } else {
      if (renderTarget !== null) {
        _screenSizeVec.width = renderTarget.width;
        _screenSizeVec.height = renderTarget.height;
      } else {
        renderer3.getDrawingBufferSize(_screenSizeVec);
      }
    }
  }
  setup() {
    const scope = this.scope;
    let output2 = null;
    if (scope === _ScreenNode.SIZE) {
      output2 = uniform(_screenSizeVec || (_screenSizeVec = new Vector2()));
    } else if (scope === _ScreenNode.VIEWPORT) {
      output2 = uniform(_viewportVec || (_viewportVec = new Vector4()));
    } else if (scope === _ScreenNode.DPR) {
      output2 = uniform(1);
    } else {
      output2 = vec2(screenCoordinate.div(screenSize));
    }
    this._output = output2;
    return output2;
  }
  generate(builder) {
    if (this.scope === _ScreenNode.COORDINATE) {
      let coord = builder.getFragCoord();
      if (builder.isFlipY()) {
        const size2 = builder.getNodeProperties(screenSize).outputNode.build(builder);
        coord = `${builder.getType("vec2")}( ${coord}.x, ${size2}.y - ${coord}.y )`;
      }
      return coord;
    }
    return super.generate(builder);
  }
};
ScreenNode.COORDINATE = "coordinate";
ScreenNode.VIEWPORT = "viewport";
ScreenNode.SIZE = "size";
ScreenNode.UV = "uv";
ScreenNode.DPR = "dpr";
var screenDPR = nodeImmutable(ScreenNode, ScreenNode.DPR);
var screenUV = nodeImmutable(ScreenNode, ScreenNode.UV);
var screenSize = nodeImmutable(ScreenNode, ScreenNode.SIZE);
var screenCoordinate = nodeImmutable(ScreenNode, ScreenNode.COORDINATE);
var viewport = nodeImmutable(ScreenNode, ScreenNode.VIEWPORT);
var viewportSize = viewport.zw;
var viewportCoordinate = screenCoordinate.sub(viewport.xy);
var viewportUV = viewportCoordinate.div(viewportSize);
var viewportResolution = Fn(() => {
  warn('TSL: "viewportResolution" is deprecated. Use "screenSize" instead.');
  return screenSize;
}, "vec2").once()();
var cameraIndex = uniform(0, "uint").setName("u_cameraIndex").setGroup(sharedUniformGroup("cameraIndex")).toVarying("v_cameraIndex");
var cameraNear = uniform("float").setName("cameraNear").setGroup(renderGroup).onRenderUpdate(({ camera: camera3 }) => camera3.near);
var cameraFar = uniform("float").setName("cameraFar").setGroup(renderGroup).onRenderUpdate(({ camera: camera3 }) => camera3.far);
var cameraProjectionMatrix = Fn(({ camera: camera3 }) => {
  let cameraProjectionMatrix2;
  if (camera3.isArrayCamera && camera3.cameras.length > 0) {
    const matrices = [];
    for (const subCamera of camera3.cameras) {
      matrices.push(subCamera.projectionMatrix);
    }
    const cameraProjectionMatrices = uniformArray(matrices).setGroup(renderGroup).setName("cameraProjectionMatrices");
    cameraProjectionMatrix2 = cameraProjectionMatrices.element(camera3.isMultiViewCamera ? builtin("gl_ViewID_OVR") : cameraIndex).toConst("cameraProjectionMatrix");
  } else {
    cameraProjectionMatrix2 = uniform("mat4").setName("cameraProjectionMatrix").setGroup(renderGroup).onRenderUpdate(({ camera: camera4 }) => camera4.projectionMatrix);
  }
  return cameraProjectionMatrix2;
}).once()();
var cameraProjectionMatrixInverse = Fn(({ camera: camera3 }) => {
  let cameraProjectionMatrixInverse2;
  if (camera3.isArrayCamera && camera3.cameras.length > 0) {
    const matrices = [];
    for (const subCamera of camera3.cameras) {
      matrices.push(subCamera.projectionMatrixInverse);
    }
    const cameraProjectionMatricesInverse = uniformArray(matrices).setGroup(renderGroup).setName("cameraProjectionMatricesInverse");
    cameraProjectionMatrixInverse2 = cameraProjectionMatricesInverse.element(camera3.isMultiViewCamera ? builtin("gl_ViewID_OVR") : cameraIndex).toConst("cameraProjectionMatrixInverse");
  } else {
    cameraProjectionMatrixInverse2 = uniform("mat4").setName("cameraProjectionMatrixInverse").setGroup(renderGroup).onRenderUpdate(({ camera: camera4 }) => camera4.projectionMatrixInverse);
  }
  return cameraProjectionMatrixInverse2;
}).once()();
var cameraViewMatrix = Fn(({ camera: camera3 }) => {
  let cameraViewMatrix2;
  if (camera3.isArrayCamera && camera3.cameras.length > 0) {
    const matrices = [];
    for (const subCamera of camera3.cameras) {
      matrices.push(subCamera.matrixWorldInverse);
    }
    const cameraViewMatrices = uniformArray(matrices).setGroup(renderGroup).setName("cameraViewMatrices");
    cameraViewMatrix2 = cameraViewMatrices.element(camera3.isMultiViewCamera ? builtin("gl_ViewID_OVR") : cameraIndex).toConst("cameraViewMatrix");
  } else {
    cameraViewMatrix2 = uniform("mat4").setName("cameraViewMatrix").setGroup(renderGroup).onRenderUpdate(({ camera: camera4 }) => camera4.matrixWorldInverse);
  }
  return cameraViewMatrix2;
}).once()();
var cameraWorldMatrix = Fn(({ camera: camera3 }) => {
  let cameraWorldMatrix2;
  if (camera3.isArrayCamera && camera3.cameras.length > 0) {
    const matrices = [];
    for (const subCamera of camera3.cameras) {
      matrices.push(subCamera.matrixWorld);
    }
    const cameraWorldMatrices = uniformArray(matrices).setGroup(renderGroup).setName("cameraWorldMatrices");
    cameraWorldMatrix2 = cameraWorldMatrices.element(camera3.isMultiViewCamera ? builtin("gl_ViewID_OVR") : cameraIndex).toConst("cameraWorldMatrix");
  } else {
    cameraWorldMatrix2 = uniform("mat4").setName("cameraWorldMatrix").setGroup(renderGroup).onRenderUpdate(({ camera: camera4 }) => camera4.matrixWorld);
  }
  return cameraWorldMatrix2;
}).once()();
var cameraNormalMatrix = Fn(({ camera: camera3 }) => {
  let cameraNormalMatrix2;
  if (camera3.isArrayCamera && camera3.cameras.length > 0) {
    const matrices = [];
    for (const subCamera of camera3.cameras) {
      matrices.push(subCamera.normalMatrix);
    }
    const cameraNormalMatrices = uniformArray(matrices).setGroup(renderGroup).setName("cameraNormalMatrices");
    cameraNormalMatrix2 = cameraNormalMatrices.element(camera3.isMultiViewCamera ? builtin("gl_ViewID_OVR") : cameraIndex).toConst("cameraNormalMatrix");
  } else {
    cameraNormalMatrix2 = uniform("mat3").setName("cameraNormalMatrix").setGroup(renderGroup).onRenderUpdate(({ camera: camera4 }) => camera4.normalMatrix);
  }
  return cameraNormalMatrix2;
}).once()();
var cameraPosition = Fn(({ camera: camera3 }) => {
  let cameraPosition3;
  if (camera3.isArrayCamera && camera3.cameras.length > 0) {
    const positions = [];
    for (let i2 = 0, l2 = camera3.cameras.length; i2 < l2; i2++) {
      positions.push(new Vector3());
    }
    const cameraPositions = uniformArray(positions).setGroup(renderGroup).setName("cameraPositions").onRenderUpdate(({ camera: camera4 }, self2) => {
      const subCameras = camera4.cameras;
      const array4 = self2.array;
      for (let i2 = 0, l2 = subCameras.length; i2 < l2; i2++) {
        array4[i2].setFromMatrixPosition(subCameras[i2].matrixWorld);
      }
    });
    cameraPosition3 = cameraPositions.element(camera3.isMultiViewCamera ? builtin("gl_ViewID_OVR") : cameraIndex).toConst("cameraPosition");
  } else {
    cameraPosition3 = uniform(new Vector3()).setName("cameraPosition").setGroup(renderGroup).onRenderUpdate(({ camera: camera4 }, self2) => self2.value.setFromMatrixPosition(camera4.matrixWorld));
  }
  return cameraPosition3;
}).once()();
var cameraViewport = Fn(({ camera: camera3 }) => {
  let cameraViewport2;
  if (camera3.isArrayCamera && camera3.cameras.length > 0) {
    const viewports = [];
    for (const subCamera of camera3.cameras) {
      viewports.push(subCamera.viewport);
    }
    const cameraViewports = uniformArray(viewports, "vec4").setGroup(renderGroup).setName("cameraViewports");
    cameraViewport2 = cameraViewports.element(cameraIndex).toConst("cameraViewport");
  } else {
    cameraViewport2 = vec4(0, 0, screenSize.x, screenSize.y).toConst("cameraViewport");
  }
  return cameraViewport2;
}).once()();
var _sphere2 = new Sphere();
var Object3DNode = class _Object3DNode extends Node4 {
  static get type() {
    return "Object3DNode";
  }
  /**
   * Constructs a new object 3D node.
   *
   * @param {('position'|'viewPosition'|'direction'|'scale'|'worldMatrix')} scope - The node represents a different type of transformation depending on the scope.
   * @param {?Object3D} [object3d=null] - The 3D object.
   */
  constructor(scope, object3d = null) {
    super();
    this.scope = scope;
    this.object3d = object3d;
    this.updateType = NodeUpdateType.OBJECT;
    this.uniformNode = new UniformNode(null);
  }
  /**
   * Overwritten since the node type is inferred from the scope.
   *
   * @return {('mat4'|'vec3'|'float')} The node type.
   */
  getNodeType() {
    const scope = this.scope;
    if (scope === _Object3DNode.WORLD_MATRIX) {
      return "mat4";
    } else if (scope === _Object3DNode.POSITION || scope === _Object3DNode.VIEW_POSITION || scope === _Object3DNode.DIRECTION || scope === _Object3DNode.SCALE) {
      return "vec3";
    } else if (scope === _Object3DNode.RADIUS) {
      return "float";
    }
  }
  /**
   * Updates the uniform value depending on the scope.
   *
   * @param {NodeFrame} frame - The current node frame.
   */
  update(frame2) {
    const object = this.object3d;
    const uniformNode = this.uniformNode;
    const scope = this.scope;
    if (scope === _Object3DNode.WORLD_MATRIX) {
      uniformNode.value = object.matrixWorld;
    } else if (scope === _Object3DNode.POSITION) {
      uniformNode.value = uniformNode.value || new Vector3();
      uniformNode.value.setFromMatrixPosition(object.matrixWorld);
    } else if (scope === _Object3DNode.SCALE) {
      uniformNode.value = uniformNode.value || new Vector3();
      uniformNode.value.setFromMatrixScale(object.matrixWorld);
    } else if (scope === _Object3DNode.DIRECTION) {
      uniformNode.value = uniformNode.value || new Vector3();
      object.getWorldDirection(uniformNode.value);
    } else if (scope === _Object3DNode.VIEW_POSITION) {
      const camera3 = frame2.camera;
      uniformNode.value = uniformNode.value || new Vector3();
      uniformNode.value.setFromMatrixPosition(object.matrixWorld);
      uniformNode.value.applyMatrix4(camera3.matrixWorldInverse);
    } else if (scope === _Object3DNode.RADIUS) {
      const geometry = frame2.object.geometry;
      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
      _sphere2.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
      uniformNode.value = _sphere2.radius;
    }
  }
  /**
   * Generates the code snippet of the uniform node. The node type of the uniform
   * node also depends on the selected scope.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The generated code snippet.
   */
  generate(builder) {
    const scope = this.scope;
    if (scope === _Object3DNode.WORLD_MATRIX) {
      this.uniformNode.nodeType = "mat4";
    } else if (scope === _Object3DNode.POSITION || scope === _Object3DNode.VIEW_POSITION || scope === _Object3DNode.DIRECTION || scope === _Object3DNode.SCALE) {
      this.uniformNode.nodeType = "vec3";
    } else if (scope === _Object3DNode.RADIUS) {
      this.uniformNode.nodeType = "float";
    }
    return this.uniformNode.build(builder);
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
Object3DNode.WORLD_MATRIX = "worldMatrix";
Object3DNode.POSITION = "position";
Object3DNode.SCALE = "scale";
Object3DNode.VIEW_POSITION = "viewPosition";
Object3DNode.DIRECTION = "direction";
Object3DNode.RADIUS = "radius";
var objectDirection = nodeProxy(Object3DNode, Object3DNode.DIRECTION).setParameterLength(1);
var objectWorldMatrix = nodeProxy(Object3DNode, Object3DNode.WORLD_MATRIX).setParameterLength(1);
var objectPosition = nodeProxy(Object3DNode, Object3DNode.POSITION).setParameterLength(1);
var objectScale = nodeProxy(Object3DNode, Object3DNode.SCALE).setParameterLength(1);
var objectViewPosition = nodeProxy(Object3DNode, Object3DNode.VIEW_POSITION).setParameterLength(1);
var objectRadius = nodeProxy(Object3DNode, Object3DNode.RADIUS).setParameterLength(1);
var ModelNode = class extends Object3DNode {
  static get type() {
    return "ModelNode";
  }
  /**
   * Constructs a new object model node.
   *
   * @param {('position'|'viewPosition'|'direction'|'scale'|'worldMatrix')} scope - The node represents a different type of transformation depending on the scope.
   */
  constructor(scope) {
    super(scope);
  }
  /**
   * Extracts the model reference from the frame state and then
   * updates the uniform value depending on the scope.
   *
   * @param {NodeFrame} frame - The current node frame.
   */
  update(frame2) {
    this.object3d = frame2.object;
    super.update(frame2);
  }
};
var modelDirection = nodeImmutable(ModelNode, ModelNode.DIRECTION);
var modelWorldMatrix = nodeImmutable(ModelNode, ModelNode.WORLD_MATRIX);
var modelPosition = nodeImmutable(ModelNode, ModelNode.POSITION);
var modelScale = nodeImmutable(ModelNode, ModelNode.SCALE);
var modelViewPosition = nodeImmutable(ModelNode, ModelNode.VIEW_POSITION);
var modelRadius = nodeImmutable(ModelNode, ModelNode.RADIUS);
var modelNormalMatrix = uniform(new Matrix3()).onObjectUpdate(({ object }, self2) => self2.value.getNormalMatrix(object.matrixWorld));
var modelWorldMatrixInverse = uniform(new Matrix4()).onObjectUpdate(({ object }, self2) => self2.value.copy(object.matrixWorld).invert());
var modelViewMatrix = Fn((builder) => {
  return builder.context.modelViewMatrix || mediumpModelViewMatrix;
}).once()().toVar("modelViewMatrix");
var mediumpModelViewMatrix = cameraViewMatrix.mul(modelWorldMatrix);
var highpModelViewMatrix = Fn((builder) => {
  builder.context.isHighPrecisionModelViewMatrix = true;
  return uniform("mat4").onObjectUpdate(({ object, camera: camera3 }) => {
    return object.modelViewMatrix.multiplyMatrices(camera3.matrixWorldInverse, object.matrixWorld);
  });
}).once()().toVar("highpModelViewMatrix");
var highpModelNormalViewMatrix = Fn((builder) => {
  const isHighPrecisionModelViewMatrix = builder.context.isHighPrecisionModelViewMatrix;
  return uniform("mat3").onObjectUpdate(({ object, camera: camera3 }) => {
    if (isHighPrecisionModelViewMatrix !== true) {
      object.modelViewMatrix.multiplyMatrices(camera3.matrixWorldInverse, object.matrixWorld);
    }
    return object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
  });
}).once()().toVar("highpModelNormalViewMatrix");
var positionGeometry = attribute("position", "vec3");
var positionLocal = positionGeometry.toVarying("positionLocal");
var positionPrevious = positionGeometry.toVarying("positionPrevious");
var positionWorld = Fn((builder) => {
  return modelWorldMatrix.mul(positionLocal).xyz.toVarying(builder.getSubBuildProperty("v_positionWorld"));
}, "vec3").once(["POSITION"])();
var positionWorldDirection = Fn(() => {
  const vertexPWD = positionLocal.transformDirection(modelWorldMatrix).toVarying("v_positionWorldDirection");
  return vertexPWD.normalize().toVar("positionWorldDirection");
}, "vec3").once(["POSITION"])();
var positionView = Fn((builder) => {
  return builder.context.setupPositionView().toVarying("v_positionView");
}, "vec3").once(["POSITION"])();
var positionViewDirection = Fn((builder) => {
  let output2;
  if (builder.camera.isOrthographicCamera) {
    output2 = vec3(0, 0, 1);
  } else {
    output2 = positionView.negate().toVarying("v_positionViewDirection").normalize();
  }
  return output2.toVar("positionViewDirection");
}, "vec3").once(["POSITION"])();
var FrontFacingNode = class extends Node4 {
  static get type() {
    return "FrontFacingNode";
  }
  /**
   * Constructs a new front facing node.
   */
  constructor() {
    super("bool");
    this.isFrontFacingNode = true;
  }
  generate(builder) {
    if (builder.shaderStage !== "fragment") return "true";
    const { material } = builder;
    if (material.side === BackSide) {
      return "false";
    }
    return builder.getFrontFacing();
  }
};
var frontFacing = nodeImmutable(FrontFacingNode);
var faceDirection = float(frontFacing).mul(2).sub(1);
var directionToFaceDirection = Fn(([direction], { material }) => {
  const side = material.side;
  if (side === BackSide) {
    direction = direction.mul(-1);
  } else if (side === DoubleSide) {
    direction = direction.mul(faceDirection);
  }
  return direction;
});
var normalGeometry = attribute("normal", "vec3");
var normalLocal = Fn((builder) => {
  if (builder.geometry.hasAttribute("normal") === false) {
    warn('TSL: Vertex attribute "normal" not found on geometry.');
    return vec3(0, 1, 0);
  }
  return normalGeometry;
}, "vec3").once()().toVar("normalLocal");
var normalFlat = positionView.dFdx().cross(positionView.dFdy()).normalize().toVar("normalFlat");
var normalViewGeometry = Fn((builder) => {
  let node;
  if (builder.material.flatShading === true) {
    node = normalFlat;
  } else {
    node = transformNormalToView(normalLocal).toVarying("v_normalViewGeometry").normalize();
  }
  return node;
}, "vec3").once()().toVar("normalViewGeometry");
var normalWorldGeometry = Fn((builder) => {
  let normal2 = normalViewGeometry.transformDirection(cameraViewMatrix);
  if (builder.material.flatShading !== true) {
    normal2 = normal2.toVarying("v_normalWorldGeometry");
  }
  return normal2.normalize().toVar("normalWorldGeometry");
}, "vec3").once()();
var normalView = Fn(({ subBuildFn, material, context: context2 }) => {
  let node;
  if (subBuildFn === "NORMAL" || subBuildFn === "VERTEX") {
    node = normalViewGeometry;
    if (material.flatShading !== true) {
      node = directionToFaceDirection(node);
    }
  } else {
    node = context2.setupNormal().context({ getUV: null });
  }
  return node;
}, "vec3").once(["NORMAL", "VERTEX"])().toVar("normalView");
var normalWorld = normalView.transformDirection(cameraViewMatrix).toVar("normalWorld");
var clearcoatNormalView = Fn(({ subBuildFn, context: context2 }) => {
  let node;
  if (subBuildFn === "NORMAL" || subBuildFn === "VERTEX") {
    node = normalView;
  } else {
    node = context2.setupClearcoatNormal().context({ getUV: null });
  }
  return node;
}, "vec3").once(["NORMAL", "VERTEX"])().toVar("clearcoatNormalView");
var transformNormal = Fn(([normal2, matrix = modelWorldMatrix]) => {
  const m3 = mat3(matrix);
  const transformedNormal = normal2.div(vec3(m3[0].dot(m3[0]), m3[1].dot(m3[1]), m3[2].dot(m3[2])));
  return m3.mul(transformedNormal).xyz;
});
var transformNormalToView = Fn(([normal2], builder) => {
  const modelNormalViewMatrix = builder.context.modelNormalViewMatrix;
  if (modelNormalViewMatrix) {
    return modelNormalViewMatrix.transformDirection(normal2);
  }
  const transformedNormal = modelNormalMatrix.mul(normal2);
  return cameraViewMatrix.transformDirection(transformedNormal);
});
var transformedNormalView = Fn(() => {
  warn('TSL: "transformedNormalView" is deprecated. Use "normalView" instead.');
  return normalView;
}).once(["NORMAL", "VERTEX"])();
var transformedNormalWorld = Fn(() => {
  warn('TSL: "transformedNormalWorld" is deprecated. Use "normalWorld" instead.');
  return normalWorld;
}).once(["NORMAL", "VERTEX"])();
var transformedClearcoatNormalView = Fn(() => {
  warn('TSL: "transformedClearcoatNormalView" is deprecated. Use "clearcoatNormalView" instead.');
  return clearcoatNormalView;
}).once(["NORMAL", "VERTEX"])();
var _e1$12 = new Euler();
var _m1$12 = new Matrix4();
var materialRefractionRatio = uniform(0).onReference(({ material }) => material).onObjectUpdate(({ material }) => material.refractionRatio);
var materialEnvIntensity = uniform(1).onReference(({ material }) => material).onObjectUpdate(function({ material, scene: scene3 }) {
  return material.envMap ? material.envMapIntensity : scene3.environmentIntensity;
});
var materialEnvRotation = uniform(new Matrix4()).onReference(function(frame2) {
  return frame2.material;
}).onObjectUpdate(function({ material, scene: scene3 }) {
  const rotation = scene3.environment !== null && material.envMap === null ? scene3.environmentRotation : material.envMapRotation;
  if (rotation) {
    _e1$12.copy(rotation);
    _m1$12.makeRotationFromEuler(_e1$12);
  } else {
    _m1$12.identity();
  }
  return _m1$12;
});
var reflectView = positionViewDirection.negate().reflect(normalView);
var refractView = positionViewDirection.negate().refract(normalView, materialRefractionRatio);
var reflectVector = reflectView.transformDirection(cameraViewMatrix).toVar("reflectVector");
var refractVector = refractView.transformDirection(cameraViewMatrix).toVar("reflectVector");
var EmptyTexture = new CubeTexture();
var CubeTextureNode = class extends TextureNode {
  static get type() {
    return "CubeTextureNode";
  }
  /**
   * Constructs a new cube texture node.
   *
   * @param {CubeTexture} value - The cube texture.
   * @param {?Node<vec3>} [uvNode=null] - The uv node.
   * @param {?Node<int>} [levelNode=null] - The level node.
   * @param {?Node<float>} [biasNode=null] - The bias node.
   */
  constructor(value, uvNode = null, levelNode = null, biasNode = null) {
    super(value, uvNode, levelNode, biasNode);
    this.isCubeTextureNode = true;
  }
  /**
   * Overwrites the default implementation to return the appropriate cube texture type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType() {
    if (this.value.isDepthTexture === true) {
      return "cubeDepthTexture";
    }
    return "cubeTexture";
  }
  /**
   * Returns a default uvs based on the mapping type of the cube texture.
   *
   * @return {Node<vec3>} The default uv attribute.
   */
  getDefaultUV() {
    const texture2 = this.value;
    if (texture2.mapping === CubeReflectionMapping) {
      return reflectVector;
    } else if (texture2.mapping === CubeRefractionMapping) {
      return refractVector;
    } else {
      error('CubeTextureNode: Mapping "%s" not supported.', texture2.mapping);
      return vec3(0, 0, 0);
    }
  }
  /**
   * Overwritten with an empty implementation since the `updateMatrix` flag is ignored
   * for cube textures. The uv transformation matrix is not applied to cube textures.
   *
   * @param {boolean} value - The update toggle.
   */
  setUpdateMatrix() {
  }
  // Ignore .updateMatrix for CubeTextureNode
  /**
   * Setups the uv node. Depending on the backend as well as the texture type, it might be necessary
   * to modify the uv node for correct sampling.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node} uvNode - The uv node to setup.
   * @return {Node} The updated uv node.
   */
  setupUV(builder, uvNode) {
    const texture2 = this.value;
    if (texture2.isDepthTexture === true) {
      if (builder.renderer.coordinateSystem === WebGPUCoordinateSystem) {
        return vec3(uvNode.x, uvNode.y.negate(), uvNode.z);
      }
      return uvNode;
    }
    if (builder.renderer.coordinateSystem === WebGPUCoordinateSystem || !texture2.isRenderTargetTexture) {
      uvNode = vec3(uvNode.x.negate(), uvNode.yz);
    }
    return materialEnvRotation.mul(uvNode);
  }
  /**
   * Generates the uv code snippet.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node} cubeUV - The uv node to generate code for.
   * @return {string} The generated code snippet.
   */
  generateUV(builder, cubeUV) {
    return cubeUV.build(builder, this.sampler === true ? "vec3" : "ivec3");
  }
};
var cubeTextureBase = nodeProxy(CubeTextureNode).setParameterLength(1, 4).setName("cubeTexture");
var cubeTexture = (value = EmptyTexture, uvNode = null, levelNode = null, biasNode = null) => {
  let textureNode;
  if (value && value.isCubeTextureNode === true) {
    textureNode = nodeObject(value.clone());
    textureNode.referenceNode = value;
    if (uvNode !== null) textureNode.uvNode = nodeObject(uvNode);
    if (levelNode !== null) textureNode.levelNode = nodeObject(levelNode);
    if (biasNode !== null) textureNode.biasNode = nodeObject(biasNode);
  } else {
    textureNode = cubeTextureBase(value, uvNode, levelNode, biasNode);
  }
  return textureNode;
};
var uniformCubeTexture = (value = EmptyTexture) => cubeTextureBase(value);
var ReferenceElementNode2 = class extends ArrayElementNode {
  static get type() {
    return "ReferenceElementNode";
  }
  /**
   * Constructs a new reference element node.
   *
   * @param {?ReferenceNode} referenceNode - The reference node.
   * @param {Node} indexNode - The index node that defines the element access.
   */
  constructor(referenceNode, indexNode) {
    super(referenceNode, indexNode);
    this.referenceNode = referenceNode;
    this.isReferenceElementNode = true;
  }
  /**
   * This method is overwritten since the node type is inferred from
   * the uniform type of the reference node.
   *
   * @return {string} The node type.
   */
  getNodeType() {
    return this.referenceNode.uniformType;
  }
  generate(builder) {
    const snippet = super.generate(builder);
    const arrayType = this.referenceNode.getNodeType();
    const elementType = this.getNodeType();
    return builder.format(snippet, arrayType, elementType);
  }
};
var ReferenceNode = class extends Node4 {
  static get type() {
    return "ReferenceNode";
  }
  /**
   * Constructs a new reference node.
   *
   * @param {string} property - The name of the property the node refers to.
   * @param {string} uniformType - The uniform type that should be used to represent the property value.
   * @param {?Object} [object=null] - The object the property belongs to.
   * @param {?number} [count=null] - When the linked property is an array-like, this parameter defines its length.
   */
  constructor(property3, uniformType, object = null, count2 = null) {
    super();
    this.property = property3;
    this.uniformType = uniformType;
    this.object = object;
    this.count = count2;
    this.properties = property3.split(".");
    this.reference = object;
    this.node = null;
    this.group = null;
    this.name = null;
    this.updateType = NodeUpdateType.OBJECT;
  }
  /**
   * When the referred property is array-like, this method can be used
   * to access elements via an index node.
   *
   * @param {IndexNode} indexNode - indexNode.
   * @return {ReferenceElementNode} A reference to an element.
   */
  element(indexNode) {
    return new ReferenceElementNode2(this, nodeObject(indexNode));
  }
  /**
   * Sets the uniform group for this reference node.
   *
   * @param {UniformGroupNode} group - The uniform group to set.
   * @return {ReferenceNode} A reference to this node.
   */
  setGroup(group2) {
    this.group = group2;
    return this;
  }
  /**
   * Sets the name for the internal uniform.
   *
   * @param {string} name - The label to set.
   * @return {ReferenceNode} A reference to this node.
   */
  setName(name) {
    this.name = name;
    return this;
  }
  /**
   * Sets the label for the internal uniform.
   *
   * @deprecated
   * @param {string} name - The label to set.
   * @return {ReferenceNode} A reference to this node.
   */
  label(name) {
    warn('TSL: "label()" has been deprecated. Use "setName()" instead.');
    return this.setName(name);
  }
  /**
   * Sets the node type which automatically defines the internal
   * uniform type.
   *
   * @param {string} uniformType - The type to set.
   */
  setNodeType(uniformType) {
    let node = null;
    if (this.count !== null) {
      node = buffer(null, uniformType, this.count);
    } else if (Array.isArray(this.getValueFromReference())) {
      node = uniformArray(null, uniformType);
    } else if (uniformType === "texture") {
      node = texture(null);
    } else if (uniformType === "cubeTexture") {
      node = cubeTexture(null);
    } else {
      node = uniform(null, uniformType);
    }
    if (this.group !== null) {
      node.setGroup(this.group);
    }
    if (this.name !== null) node.setName(this.name);
    this.node = node;
  }
  /**
   * This method is overwritten since the node type is inferred from
   * the type of the reference node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    if (this.node === null) {
      this.updateReference(builder);
      this.updateValue();
    }
    return this.node.getNodeType(builder);
  }
  /**
   * Returns the property value from the given referred object.
   *
   * @param {Object} [object=this.reference] - The object to retrieve the property value from.
   * @return {any} The value.
   */
  getValueFromReference(object = this.reference) {
    const { properties } = this;
    let value = object[properties[0]];
    for (let i2 = 1; i2 < properties.length; i2++) {
      value = value[properties[i2]];
    }
    return value;
  }
  /**
   * Allows to update the reference based on the given state. The state is only
   * evaluated {@link ReferenceNode#object} is not set.
   *
   * @param {(NodeFrame|NodeBuilder)} state - The current state.
   * @return {Object} The updated reference.
   */
  updateReference(state) {
    this.reference = this.object !== null ? this.object : state.object;
    return this.reference;
  }
  /**
   * The output of the reference node is the internal uniform node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {UniformNode} The output node.
   */
  setup() {
    this.updateValue();
    return this.node;
  }
  /**
   * Overwritten to update the internal uniform value.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update() {
    this.updateValue();
  }
  /**
   * Retrieves the value from the referred object property and uses it
   * to updated the internal uniform.
   */
  updateValue() {
    if (this.node === null) this.setNodeType(this.uniformType);
    const value = this.getValueFromReference();
    if (Array.isArray(value)) {
      this.node.array = value;
    } else {
      this.node.value = value;
    }
  }
};
var reference = (name, type, object) => new ReferenceNode(name, type, object);
var referenceBuffer = (name, type, count2, object) => new ReferenceNode(name, type, object, count2);
var MaterialReferenceNode = class extends ReferenceNode {
  static get type() {
    return "MaterialReferenceNode";
  }
  /**
   * Constructs a new material reference node.
   *
   * @param {string} property - The name of the property the node refers to.
   * @param {string} inputType - The uniform type that should be used to represent the property value.
   * @param {?Material} [material=null] - The material the property belongs to. When no material is set,
   * the node refers to the material of the current rendered object.
   */
  constructor(property3, inputType, material = null) {
    super(property3, inputType, material);
    this.material = material;
    this.isMaterialReferenceNode = true;
  }
  /**
   * Updates the reference based on the given state. The state is only evaluated
   * {@link MaterialReferenceNode#material} is not set.
   *
   * @param {(NodeFrame|NodeBuilder)} state - The current state.
   * @return {Object} The updated reference.
   */
  updateReference(state) {
    this.reference = this.material !== null ? this.material : state.material;
    return this.reference;
  }
};
var materialReference = (name, type, material = null) => new MaterialReferenceNode(name, type, material);
var uv = uv$1();
var q0 = positionView.dFdx();
var q1 = positionView.dFdy();
var st0 = uv.dFdx();
var st1 = uv.dFdy();
var N = normalView;
var q1perp = q1.cross(N);
var q0perp = N.cross(q0);
var T = q1perp.mul(st0.x).add(q0perp.mul(st1.x));
var B2 = q1perp.mul(st0.y).add(q0perp.mul(st1.y));
var det = T.dot(T).max(B2.dot(B2));
var scale$1 = det.equal(0).select(0, det.inverseSqrt());
var tangentViewFrame = T.mul(scale$1).toVar("tangentViewFrame");
var bitangentViewFrame = B2.mul(scale$1).toVar("bitangentViewFrame");
var tangentGeometry = attribute("tangent", "vec4");
var tangentLocal = tangentGeometry.xyz.toVar("tangentLocal");
var tangentView = Fn(({ subBuildFn, geometry, material }) => {
  let node;
  if (subBuildFn === "VERTEX" || geometry.hasAttribute("tangent")) {
    node = modelViewMatrix.mul(vec4(tangentLocal, 0)).xyz.toVarying("v_tangentView").normalize();
  } else {
    node = tangentViewFrame;
  }
  if (material.flatShading !== true) {
    node = directionToFaceDirection(node);
  }
  return node;
}, "vec3").once(["NORMAL", "VERTEX"])().toVar("tangentView");
var tangentWorld = tangentView.transformDirection(cameraViewMatrix).toVarying("v_tangentWorld").normalize().toVar("tangentWorld");
var getBitangent = Fn(([crossNormalTangent, varyingName], { subBuildFn, material }) => {
  let bitangent = crossNormalTangent.mul(tangentGeometry.w).xyz;
  if (subBuildFn === "NORMAL" && material.flatShading !== true) {
    bitangent = bitangent.toVarying(varyingName);
  }
  return bitangent;
}).once(["NORMAL"]);
var bitangentGeometry = getBitangent(normalGeometry.cross(tangentGeometry), "v_bitangentGeometry").normalize().toVar("bitangentGeometry");
var bitangentLocal = getBitangent(normalLocal.cross(tangentLocal), "v_bitangentLocal").normalize().toVar("bitangentLocal");
var bitangentView = Fn(({ subBuildFn, geometry, material }) => {
  let node;
  if (subBuildFn === "VERTEX" || geometry.hasAttribute("tangent")) {
    node = getBitangent(normalView.cross(tangentView), "v_bitangentView").normalize();
  } else {
    node = bitangentViewFrame;
  }
  if (material.flatShading !== true) {
    node = directionToFaceDirection(node);
  }
  return node;
}, "vec3").once(["NORMAL", "VERTEX"])().toVar("bitangentView");
var bitangentWorld = getBitangent(normalWorld.cross(tangentWorld), "v_bitangentWorld").normalize().toVar("bitangentWorld");
var TBNViewMatrix = mat3(tangentView, bitangentView, normalView).toVar("TBNViewMatrix");
var parallaxDirection = positionViewDirection.mul(TBNViewMatrix);
var parallaxUV = (uv2, scale2) => uv2.sub(parallaxDirection.mul(scale2));
var bentNormalView = Fn(() => {
  let bentNormal = anisotropyB.cross(positionViewDirection);
  bentNormal = bentNormal.cross(anisotropyB).normalize();
  bentNormal = mix2(bentNormal, normalView, anisotropy.mul(roughness.oneMinus()).oneMinus().pow2().pow2()).normalize();
  return bentNormal;
}).once()();
var directionToColor = (node) => nodeObject(node).mul(0.5).add(0.5);
var colorToDirection = (node) => nodeObject(node).mul(2).sub(1);
var unpackNormal = (xy) => vec3(xy, sqrt2(saturate3(float(1).sub(dot(xy, xy)))));
var NormalMapNode = class extends TempNode {
  static get type() {
    return "NormalMapNode";
  }
  /**
   * Constructs a new normal map node.
   *
   * @param {Node<vec3>} node - Represents the normal map data.
   * @param {?Node<vec2>} [scaleNode=null] - Controls the intensity of the effect.
   */
  constructor(node, scaleNode = null) {
    super("vec3");
    this.node = node;
    this.scaleNode = scaleNode;
    this.normalMapType = TangentSpaceNormalMap;
    this.unpackNormalMode = NoNormalPacking;
  }
  setup({ material }) {
    const { normalMapType, scaleNode, unpackNormalMode } = this;
    let normalMap2 = this.node.mul(2).sub(1);
    if (normalMapType === TangentSpaceNormalMap) {
      if (unpackNormalMode === NormalRGPacking) {
        normalMap2 = unpackNormal(normalMap2.xy);
      } else if (unpackNormalMode === NormalGAPacking) {
        normalMap2 = unpackNormal(normalMap2.yw);
      } else if (unpackNormalMode !== NoNormalPacking) {
        console.error(`THREE.NodeMaterial: Unexpected unpack normal mode: ${unpackNormalMode}`);
      }
    } else {
      if (unpackNormalMode !== NoNormalPacking) {
        console.error(`THREE.NodeMaterial: Normal map type '${normalMapType}' is not compatible with unpack normal mode '${unpackNormalMode}'`);
      }
    }
    if (scaleNode !== null) {
      let scale2 = scaleNode;
      if (material.flatShading === true) {
        scale2 = directionToFaceDirection(scale2);
      }
      normalMap2 = vec3(normalMap2.xy.mul(scale2), normalMap2.z);
    }
    let output2 = null;
    if (normalMapType === ObjectSpaceNormalMap) {
      output2 = transformNormalToView(normalMap2);
    } else if (normalMapType === TangentSpaceNormalMap) {
      output2 = TBNViewMatrix.mul(normalMap2).normalize();
    } else {
      error(`NodeMaterial: Unsupported normal map type: ${normalMapType}`);
      output2 = normalView;
    }
    return output2;
  }
};
var normalMap = nodeProxy(NormalMapNode).setParameterLength(1, 2);
var dHdxy_fwd = Fn(({ textureNode, bumpScale }) => {
  const sampleTexture = (callback) => textureNode.isolate().context({ getUV: (texNode) => callback(texNode.uvNode || uv$1()), forceUVContext: true });
  const Hll = float(sampleTexture((uvNode) => uvNode));
  return vec2(
    float(sampleTexture((uvNode) => uvNode.add(uvNode.dFdx()))).sub(Hll),
    float(sampleTexture((uvNode) => uvNode.add(uvNode.dFdy()))).sub(Hll)
  ).mul(bumpScale);
});
var perturbNormalArb = Fn((inputs) => {
  const { surf_pos, surf_norm, dHdxy } = inputs;
  const vSigmaX = surf_pos.dFdx().normalize();
  const vSigmaY = surf_pos.dFdy().normalize();
  const vN = surf_norm;
  const R1 = vSigmaY.cross(vN);
  const R2 = vN.cross(vSigmaX);
  const fDet = vSigmaX.dot(R1).mul(faceDirection);
  const vGrad = fDet.sign().mul(dHdxy.x.mul(R1).add(dHdxy.y.mul(R2)));
  return fDet.abs().mul(surf_norm).sub(vGrad).normalize();
});
var BumpMapNode = class extends TempNode {
  static get type() {
    return "BumpMapNode";
  }
  /**
   * Constructs a new bump map node.
   *
   * @param {Node<float>} textureNode - Represents the bump map data.
   * @param {?Node<float>} [scaleNode=null] - Controls the intensity of the bump effect.
   */
  constructor(textureNode, scaleNode = null) {
    super("vec3");
    this.textureNode = textureNode;
    this.scaleNode = scaleNode;
  }
  setup() {
    const bumpScale = this.scaleNode !== null ? this.scaleNode : 1;
    const dHdxy = dHdxy_fwd({ textureNode: this.textureNode, bumpScale });
    return perturbNormalArb({
      surf_pos: positionView,
      surf_norm: normalView,
      dHdxy
    });
  }
};
var bumpMap = nodeProxy(BumpMapNode).setParameterLength(1, 2);
var _propertyCache = /* @__PURE__ */ new Map();
var MaterialNode = class _MaterialNode extends Node4 {
  static get type() {
    return "MaterialNode";
  }
  /**
   * Constructs a new material node.
   *
   * @param {string} scope - The scope defines what kind of material property is referred by the node.
   */
  constructor(scope) {
    super();
    this.scope = scope;
  }
  /**
   * Returns a cached reference node for the given property and type.
   *
   * @param {string} property - The name of the material property.
   * @param {string} type - The uniform type of the property.
   * @return {MaterialReferenceNode} A material reference node representing the property access.
   */
  getCache(property3, type) {
    let node = _propertyCache.get(property3);
    if (node === void 0) {
      node = materialReference(property3, type);
      _propertyCache.set(property3, node);
    }
    return node;
  }
  /**
   * Returns a float-typed material reference node for the given property name.
   *
   * @param {string} property - The name of the material property.
   * @return {MaterialReferenceNode<float>} A material reference node representing the property access.
   */
  getFloat(property3) {
    return this.getCache(property3, "float");
  }
  /**
   * Returns a color-typed material reference node for the given property name.
   *
   * @param {string} property - The name of the material property.
   * @return {MaterialReferenceNode<color>} A material reference node representing the property access.
   */
  getColor(property3) {
    return this.getCache(property3, "color");
  }
  /**
   * Returns a texture-typed material reference node for the given property name.
   *
   * @param {string} property - The name of the material property.
   * @return {MaterialReferenceNode} A material reference node representing the property access.
   */
  getTexture(property3) {
    return this.getCache(property3 === "map" ? "map" : property3 + "Map", "texture");
  }
  /**
   * The node setup is done depending on the selected scope. Multiple material properties
   * might be grouped into a single node composition if they logically belong together.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node} The node representing the selected scope.
   */
  setup(builder) {
    const material = builder.context.material;
    const scope = this.scope;
    let node = null;
    if (scope === _MaterialNode.COLOR) {
      const colorNode = material.color !== void 0 ? this.getColor(scope) : vec3();
      if (material.map && material.map.isTexture === true) {
        node = colorNode.mul(this.getTexture("map"));
      } else {
        node = colorNode;
      }
    } else if (scope === _MaterialNode.OPACITY) {
      const opacityNode = this.getFloat(scope);
      if (material.alphaMap && material.alphaMap.isTexture === true) {
        node = opacityNode.mul(this.getTexture("alpha"));
      } else {
        node = opacityNode;
      }
    } else if (scope === _MaterialNode.SPECULAR_STRENGTH) {
      if (material.specularMap && material.specularMap.isTexture === true) {
        node = this.getTexture("specular").r;
      } else {
        node = float(1);
      }
    } else if (scope === _MaterialNode.SPECULAR_INTENSITY) {
      const specularIntensityNode = this.getFloat(scope);
      if (material.specularIntensityMap && material.specularIntensityMap.isTexture === true) {
        node = specularIntensityNode.mul(this.getTexture(scope).a);
      } else {
        node = specularIntensityNode;
      }
    } else if (scope === _MaterialNode.SPECULAR_COLOR) {
      const specularColorNode = this.getColor(scope);
      if (material.specularColorMap && material.specularColorMap.isTexture === true) {
        node = specularColorNode.mul(this.getTexture(scope).rgb);
      } else {
        node = specularColorNode;
      }
    } else if (scope === _MaterialNode.ROUGHNESS) {
      const roughnessNode = this.getFloat(scope);
      if (material.roughnessMap && material.roughnessMap.isTexture === true) {
        node = roughnessNode.mul(this.getTexture(scope).g);
      } else {
        node = roughnessNode;
      }
    } else if (scope === _MaterialNode.METALNESS) {
      const metalnessNode = this.getFloat(scope);
      if (material.metalnessMap && material.metalnessMap.isTexture === true) {
        node = metalnessNode.mul(this.getTexture(scope).b);
      } else {
        node = metalnessNode;
      }
    } else if (scope === _MaterialNode.EMISSIVE) {
      const emissiveIntensityNode = this.getFloat("emissiveIntensity");
      const emissiveNode = this.getColor(scope).mul(emissiveIntensityNode);
      if (material.emissiveMap && material.emissiveMap.isTexture === true) {
        node = emissiveNode.mul(this.getTexture(scope));
      } else {
        node = emissiveNode;
      }
    } else if (scope === _MaterialNode.NORMAL) {
      if (material.normalMap) {
        node = normalMap(this.getTexture("normal"), this.getCache("normalScale", "vec2"));
        node.normalMapType = material.normalMapType;
        if (material.normalMap.format == RGFormat || material.normalMap.format == RED_GREEN_RGTC2_Format || material.normalMap.format == RG11_EAC_Format) {
          node.unpackNormalMode = NormalRGPacking;
        }
      } else if (material.bumpMap) {
        node = bumpMap(this.getTexture("bump").r, this.getFloat("bumpScale"));
      } else {
        node = normalView;
      }
    } else if (scope === _MaterialNode.CLEARCOAT) {
      const clearcoatNode = this.getFloat(scope);
      if (material.clearcoatMap && material.clearcoatMap.isTexture === true) {
        node = clearcoatNode.mul(this.getTexture(scope).r);
      } else {
        node = clearcoatNode;
      }
    } else if (scope === _MaterialNode.CLEARCOAT_ROUGHNESS) {
      const clearcoatRoughnessNode = this.getFloat(scope);
      if (material.clearcoatRoughnessMap && material.clearcoatRoughnessMap.isTexture === true) {
        node = clearcoatRoughnessNode.mul(this.getTexture(scope).r);
      } else {
        node = clearcoatRoughnessNode;
      }
    } else if (scope === _MaterialNode.CLEARCOAT_NORMAL) {
      if (material.clearcoatNormalMap) {
        node = normalMap(this.getTexture(scope), this.getCache(scope + "Scale", "vec2"));
      } else {
        node = normalView;
      }
    } else if (scope === _MaterialNode.SHEEN) {
      const sheenNode = this.getColor("sheenColor").mul(this.getFloat("sheen"));
      if (material.sheenColorMap && material.sheenColorMap.isTexture === true) {
        node = sheenNode.mul(this.getTexture("sheenColor").rgb);
      } else {
        node = sheenNode;
      }
    } else if (scope === _MaterialNode.SHEEN_ROUGHNESS) {
      const sheenRoughnessNode = this.getFloat(scope);
      if (material.sheenRoughnessMap && material.sheenRoughnessMap.isTexture === true) {
        node = sheenRoughnessNode.mul(this.getTexture(scope).a);
      } else {
        node = sheenRoughnessNode;
      }
      node = node.clamp(1e-4, 1);
    } else if (scope === _MaterialNode.ANISOTROPY) {
      if (material.anisotropyMap && material.anisotropyMap.isTexture === true) {
        const anisotropyPolar = this.getTexture(scope);
        const anisotropyMat = mat2(materialAnisotropyVector.x, materialAnisotropyVector.y, materialAnisotropyVector.y.negate(), materialAnisotropyVector.x);
        node = anisotropyMat.mul(anisotropyPolar.rg.mul(2).sub(vec2(1)).normalize().mul(anisotropyPolar.b));
      } else {
        node = materialAnisotropyVector;
      }
    } else if (scope === _MaterialNode.IRIDESCENCE_THICKNESS) {
      const iridescenceThicknessMaximum = reference("1", "float", material.iridescenceThicknessRange);
      if (material.iridescenceThicknessMap) {
        const iridescenceThicknessMinimum = reference("0", "float", material.iridescenceThicknessRange);
        node = iridescenceThicknessMaximum.sub(iridescenceThicknessMinimum).mul(this.getTexture(scope).g).add(iridescenceThicknessMinimum);
      } else {
        node = iridescenceThicknessMaximum;
      }
    } else if (scope === _MaterialNode.TRANSMISSION) {
      const transmissionNode = this.getFloat(scope);
      if (material.transmissionMap) {
        node = transmissionNode.mul(this.getTexture(scope).r);
      } else {
        node = transmissionNode;
      }
    } else if (scope === _MaterialNode.THICKNESS) {
      const thicknessNode = this.getFloat(scope);
      if (material.thicknessMap) {
        node = thicknessNode.mul(this.getTexture(scope).g);
      } else {
        node = thicknessNode;
      }
    } else if (scope === _MaterialNode.IOR) {
      node = this.getFloat(scope);
    } else if (scope === _MaterialNode.LIGHT_MAP) {
      node = this.getTexture(scope).rgb.mul(this.getFloat("lightMapIntensity"));
    } else if (scope === _MaterialNode.AO) {
      node = this.getTexture(scope).r.sub(1).mul(this.getFloat("aoMapIntensity")).add(1);
    } else if (scope === _MaterialNode.LINE_DASH_OFFSET) {
      node = material.dashOffset ? this.getFloat(scope) : float(0);
    } else {
      const outputType = this.getNodeType(builder);
      node = this.getCache(scope, outputType);
    }
    return node;
  }
};
MaterialNode.ALPHA_TEST = "alphaTest";
MaterialNode.COLOR = "color";
MaterialNode.OPACITY = "opacity";
MaterialNode.SHININESS = "shininess";
MaterialNode.SPECULAR = "specular";
MaterialNode.SPECULAR_STRENGTH = "specularStrength";
MaterialNode.SPECULAR_INTENSITY = "specularIntensity";
MaterialNode.SPECULAR_COLOR = "specularColor";
MaterialNode.REFLECTIVITY = "reflectivity";
MaterialNode.ROUGHNESS = "roughness";
MaterialNode.METALNESS = "metalness";
MaterialNode.NORMAL = "normal";
MaterialNode.CLEARCOAT = "clearcoat";
MaterialNode.CLEARCOAT_ROUGHNESS = "clearcoatRoughness";
MaterialNode.CLEARCOAT_NORMAL = "clearcoatNormal";
MaterialNode.EMISSIVE = "emissive";
MaterialNode.ROTATION = "rotation";
MaterialNode.SHEEN = "sheen";
MaterialNode.SHEEN_ROUGHNESS = "sheenRoughness";
MaterialNode.ANISOTROPY = "anisotropy";
MaterialNode.IRIDESCENCE = "iridescence";
MaterialNode.IRIDESCENCE_IOR = "iridescenceIOR";
MaterialNode.IRIDESCENCE_THICKNESS = "iridescenceThickness";
MaterialNode.IOR = "ior";
MaterialNode.TRANSMISSION = "transmission";
MaterialNode.THICKNESS = "thickness";
MaterialNode.ATTENUATION_DISTANCE = "attenuationDistance";
MaterialNode.ATTENUATION_COLOR = "attenuationColor";
MaterialNode.LINE_SCALE = "scale";
MaterialNode.LINE_DASH_SIZE = "dashSize";
MaterialNode.LINE_GAP_SIZE = "gapSize";
MaterialNode.LINE_WIDTH = "linewidth";
MaterialNode.LINE_DASH_OFFSET = "dashOffset";
MaterialNode.POINT_SIZE = "size";
MaterialNode.DISPERSION = "dispersion";
MaterialNode.LIGHT_MAP = "light";
MaterialNode.AO = "ao";
var materialAlphaTest = nodeImmutable(MaterialNode, MaterialNode.ALPHA_TEST);
var materialColor = nodeImmutable(MaterialNode, MaterialNode.COLOR);
var materialShininess = nodeImmutable(MaterialNode, MaterialNode.SHININESS);
var materialEmissive = nodeImmutable(MaterialNode, MaterialNode.EMISSIVE);
var materialOpacity = nodeImmutable(MaterialNode, MaterialNode.OPACITY);
var materialSpecular = nodeImmutable(MaterialNode, MaterialNode.SPECULAR);
var materialSpecularIntensity = nodeImmutable(MaterialNode, MaterialNode.SPECULAR_INTENSITY);
var materialSpecularColor = nodeImmutable(MaterialNode, MaterialNode.SPECULAR_COLOR);
var materialSpecularStrength = nodeImmutable(MaterialNode, MaterialNode.SPECULAR_STRENGTH);
var materialReflectivity = nodeImmutable(MaterialNode, MaterialNode.REFLECTIVITY);
var materialRoughness = nodeImmutable(MaterialNode, MaterialNode.ROUGHNESS);
var materialMetalness = nodeImmutable(MaterialNode, MaterialNode.METALNESS);
var materialNormal = nodeImmutable(MaterialNode, MaterialNode.NORMAL);
var materialClearcoat = nodeImmutable(MaterialNode, MaterialNode.CLEARCOAT);
var materialClearcoatRoughness = nodeImmutable(MaterialNode, MaterialNode.CLEARCOAT_ROUGHNESS);
var materialClearcoatNormal = nodeImmutable(MaterialNode, MaterialNode.CLEARCOAT_NORMAL);
var materialRotation = nodeImmutable(MaterialNode, MaterialNode.ROTATION);
var materialSheen = nodeImmutable(MaterialNode, MaterialNode.SHEEN);
var materialSheenRoughness = nodeImmutable(MaterialNode, MaterialNode.SHEEN_ROUGHNESS);
var materialAnisotropy = nodeImmutable(MaterialNode, MaterialNode.ANISOTROPY);
var materialIridescence = nodeImmutable(MaterialNode, MaterialNode.IRIDESCENCE);
var materialIridescenceIOR = nodeImmutable(MaterialNode, MaterialNode.IRIDESCENCE_IOR);
var materialIridescenceThickness = nodeImmutable(MaterialNode, MaterialNode.IRIDESCENCE_THICKNESS);
var materialTransmission = nodeImmutable(MaterialNode, MaterialNode.TRANSMISSION);
var materialThickness = nodeImmutable(MaterialNode, MaterialNode.THICKNESS);
var materialIOR = nodeImmutable(MaterialNode, MaterialNode.IOR);
var materialAttenuationDistance = nodeImmutable(MaterialNode, MaterialNode.ATTENUATION_DISTANCE);
var materialAttenuationColor = nodeImmutable(MaterialNode, MaterialNode.ATTENUATION_COLOR);
var materialLineScale = nodeImmutable(MaterialNode, MaterialNode.LINE_SCALE);
var materialLineDashSize = nodeImmutable(MaterialNode, MaterialNode.LINE_DASH_SIZE);
var materialLineGapSize = nodeImmutable(MaterialNode, MaterialNode.LINE_GAP_SIZE);
var materialLineWidth = nodeImmutable(MaterialNode, MaterialNode.LINE_WIDTH);
var materialLineDashOffset = nodeImmutable(MaterialNode, MaterialNode.LINE_DASH_OFFSET);
var materialPointSize = nodeImmutable(MaterialNode, MaterialNode.POINT_SIZE);
var materialDispersion = nodeImmutable(MaterialNode, MaterialNode.DISPERSION);
var materialLightMap = nodeImmutable(MaterialNode, MaterialNode.LIGHT_MAP);
var materialAO = nodeImmutable(MaterialNode, MaterialNode.AO);
var materialAnisotropyVector = uniform(new Vector2()).onReference(function(frame2) {
  return frame2.material;
}).onRenderUpdate(function({ material }) {
  this.value.set(material.anisotropy * Math.cos(material.anisotropyRotation), material.anisotropy * Math.sin(material.anisotropyRotation));
});
var modelViewProjection = Fn((builder) => {
  return builder.context.setupModelViewProjection();
}, "vec4").once()().toVarying("v_modelViewProjection");
var StorageArrayElementNode = class extends ArrayElementNode {
  static get type() {
    return "StorageArrayElementNode";
  }
  /**
   * Constructs storage buffer element node.
   *
   * @param {StorageBufferNode} storageBufferNode - The storage buffer node.
   * @param {Node} indexNode - The index node that defines the element access.
   */
  constructor(storageBufferNode, indexNode) {
    super(storageBufferNode, indexNode);
    this.isStorageArrayElementNode = true;
  }
  /**
   * The storage buffer node.
   *
   * @param {Node} value
   * @type {StorageBufferNode}
   */
  set storageBufferNode(value) {
    this.node = value;
  }
  get storageBufferNode() {
    return this.node;
  }
  getMemberType(builder, name) {
    const structTypeNode = this.storageBufferNode.structTypeNode;
    if (structTypeNode) {
      return structTypeNode.getMemberType(builder, name);
    }
    return "void";
  }
  setup(builder) {
    if (builder.isAvailable("storageBuffer") === false) {
      if (this.node.isPBO === true) {
        builder.setupPBO(this.node);
      }
    }
    return super.setup(builder);
  }
  generate(builder, output2) {
    let snippet;
    const isAssignContext = builder.context.assign;
    if (builder.isAvailable("storageBuffer") === false) {
      if (this.node.isPBO === true && isAssignContext !== true && (this.node.value.isInstancedBufferAttribute || builder.shaderStage !== "compute")) {
        snippet = builder.generatePBO(this);
      } else {
        snippet = this.node.build(builder);
      }
    } else {
      snippet = super.generate(builder);
    }
    if (isAssignContext !== true) {
      const type = this.getNodeType(builder);
      snippet = builder.format(snippet, type, output2);
    }
    return snippet;
  }
};
var storageElement = nodeProxy(StorageArrayElementNode).setParameterLength(2);
var StorageBufferNode = class extends BufferNode {
  static get type() {
    return "StorageBufferNode";
  }
  /**
   * Constructs a new storage buffer node.
   *
   * @param {StorageBufferAttribute|StorageInstancedBufferAttribute|BufferAttribute} value - The buffer data.
   * @param {?(string|Struct)} [bufferType=null] - The buffer type (e.g. `'vec3'`).
   * @param {number} [bufferCount=0] - The buffer count.
   */
  constructor(value, bufferType = null, bufferCount = 0) {
    let nodeType, structTypeNode = null;
    if (bufferType && bufferType.isStruct) {
      nodeType = "struct";
      structTypeNode = bufferType.layout;
      if (value.isStorageBufferAttribute || value.isStorageInstancedBufferAttribute) {
        bufferCount = value.count;
      }
    } else if (bufferType === null && (value.isStorageBufferAttribute || value.isStorageInstancedBufferAttribute)) {
      nodeType = getTypeFromLength(value.itemSize);
      bufferCount = value.count;
    } else {
      nodeType = bufferType;
    }
    super(value, nodeType, bufferCount);
    this.isStorageBufferNode = true;
    this.structTypeNode = structTypeNode;
    this.access = NodeAccess.READ_WRITE;
    this.isAtomic = false;
    this.isPBO = false;
    this._attribute = null;
    this._varying = null;
    this.global = true;
    if (value.isStorageBufferAttribute !== true && value.isStorageInstancedBufferAttribute !== true) {
      if (value.isInstancedBufferAttribute) value.isStorageInstancedBufferAttribute = true;
      else value.isStorageBufferAttribute = true;
    }
  }
  /**
   * This method is overwritten since the buffer data might be shared
   * and thus the hash should be shared as well.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The hash.
   */
  getHash(builder) {
    if (this.bufferCount === 0) {
      let bufferData = builder.globalCache.getData(this.value);
      if (bufferData === void 0) {
        bufferData = {
          node: this
        };
        builder.globalCache.setData(this.value, bufferData);
      }
      return bufferData.node.uuid;
    }
    return this.uuid;
  }
  /**
   * Overwrites the default implementation to return a fixed value `'indirectStorageBuffer'` or `'storageBuffer'`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType() {
    return this.value.isIndirectStorageBufferAttribute ? "indirectStorageBuffer" : "storageBuffer";
  }
  /**
   * Enables element access with the given index node.
   *
   * @param {IndexNode} indexNode - The index node.
   * @return {StorageArrayElementNode} A node representing the element access.
   */
  element(indexNode) {
    return storageElement(this, indexNode);
  }
  /**
   * Defines whether this node is a PBO or not. Only relevant for WebGL.
   *
   * @param {boolean} value - The value so set.
   * @return {StorageBufferNode} A reference to this node.
   */
  setPBO(value) {
    this.isPBO = value;
    return this;
  }
  /**
   * Returns the `isPBO` value.
   *
   * @return {boolean} Whether the node represents a PBO or not.
   */
  getPBO() {
    return this.isPBO;
  }
  /**
   * Defines the node access.
   *
   * @param {string} value - The node access.
   * @return {StorageBufferNode} A reference to this node.
   */
  setAccess(value) {
    this.access = value;
    return this;
  }
  /**
   * Convenience method for configuring a read-only node access.
   *
   * @return {StorageBufferNode} A reference to this node.
   */
  toReadOnly() {
    return this.setAccess(NodeAccess.READ_ONLY);
  }
  /**
   * Defines whether the node is atomic or not.
   *
   * @param {boolean} value - The atomic flag.
   * @return {StorageBufferNode} A reference to this node.
   */
  setAtomic(value) {
    this.isAtomic = value;
    return this;
  }
  /**
   * Convenience method for making this node atomic.
   *
   * @return {StorageBufferNode} A reference to this node.
   */
  toAtomic() {
    return this.setAtomic(true);
  }
  /**
   * Returns attribute data for this storage buffer node.
   *
   * @return {{attribute: BufferAttributeNode, varying: VaryingNode}} The attribute data.
   */
  getAttributeData() {
    if (this._attribute === null) {
      this._attribute = bufferAttribute(this.value);
      this._varying = varying(this._attribute);
    }
    return {
      attribute: this._attribute,
      varying: this._varying
    };
  }
  /**
   * This method is overwritten since the node type from the availability of storage buffers
   * and the attribute data.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    if (this.structTypeNode !== null) {
      return this.structTypeNode.getNodeType(builder);
    }
    if (builder.isAvailable("storageBuffer") || builder.isAvailable("indirectStorageBuffer")) {
      return super.getNodeType(builder);
    }
    const { attribute: attribute2 } = this.getAttributeData();
    return attribute2.getNodeType(builder);
  }
  /**
   * Returns the type of a member of the struct.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} name - The name of the member.
   * @return {string} The type of the member.
   */
  getMemberType(builder, name) {
    if (this.structTypeNode !== null) {
      return this.structTypeNode.getMemberType(builder, name);
    }
    return "void";
  }
  /**
   * Generates the code snippet of the storage buffer node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The generated code snippet.
   */
  generate(builder) {
    if (this.structTypeNode !== null) this.structTypeNode.build(builder);
    if (builder.isAvailable("storageBuffer") || builder.isAvailable("indirectStorageBuffer")) {
      return super.generate(builder);
    }
    const { attribute: attribute2, varying: varying2 } = this.getAttributeData();
    const output2 = varying2.build(builder);
    builder.registerTransform(output2, attribute2);
    return output2;
  }
};
var storage = (value, type = null, count2 = 0) => new StorageBufferNode(value, type, count2);
var storageObject = (value, type, count2) => {
  warn('TSL: "storageObject()" is deprecated. Use "storage().setPBO( true )" instead.');
  return storage(value, type, count2).setPBO(true);
};
var IndexNode = class _IndexNode extends Node4 {
  static get type() {
    return "IndexNode";
  }
  /**
   * Constructs a new index node.
   *
   * @param {('vertex'|'instance'|'subgroup'|'invocationLocal'|'invocationGlobal'|'invocationSubgroup'|'draw')} scope - The scope of the index node.
   */
  constructor(scope) {
    super("uint");
    this.scope = scope;
    this.isIndexNode = true;
  }
  generate(builder) {
    const nodeType = this.getNodeType(builder);
    const scope = this.scope;
    let propertyName;
    if (scope === _IndexNode.VERTEX) {
      propertyName = builder.getVertexIndex();
    } else if (scope === _IndexNode.INSTANCE) {
      propertyName = builder.getInstanceIndex();
    } else if (scope === _IndexNode.DRAW) {
      propertyName = builder.getDrawIndex();
    } else if (scope === _IndexNode.INVOCATION_LOCAL) {
      propertyName = builder.getInvocationLocalIndex();
    } else if (scope === _IndexNode.INVOCATION_SUBGROUP) {
      propertyName = builder.getInvocationSubgroupIndex();
    } else if (scope === _IndexNode.SUBGROUP) {
      propertyName = builder.getSubgroupIndex();
    } else {
      throw new Error("THREE.IndexNode: Unknown scope: " + scope);
    }
    let output2;
    if (builder.shaderStage === "vertex" || builder.shaderStage === "compute") {
      output2 = propertyName;
    } else {
      const nodeVarying = varying(this);
      output2 = nodeVarying.build(builder, nodeType);
    }
    return output2;
  }
};
IndexNode.VERTEX = "vertex";
IndexNode.INSTANCE = "instance";
IndexNode.SUBGROUP = "subgroup";
IndexNode.INVOCATION_LOCAL = "invocationLocal";
IndexNode.INVOCATION_SUBGROUP = "invocationSubgroup";
IndexNode.DRAW = "draw";
var vertexIndex = nodeImmutable(IndexNode, IndexNode.VERTEX);
var instanceIndex = nodeImmutable(IndexNode, IndexNode.INSTANCE);
var subgroupIndex = nodeImmutable(IndexNode, IndexNode.SUBGROUP);
var invocationSubgroupIndex = nodeImmutable(IndexNode, IndexNode.INVOCATION_SUBGROUP);
var invocationLocalIndex = nodeImmutable(IndexNode, IndexNode.INVOCATION_LOCAL);
var drawIndex = nodeImmutable(IndexNode, IndexNode.DRAW);
var InstanceNode = class extends Node4 {
  static get type() {
    return "InstanceNode";
  }
  /**
   * Constructs a new instance node.
   *
   * @param {number} count - The number of instances.
   * @param {InstancedBufferAttribute|StorageInstancedBufferAttribute} instanceMatrix - Instanced buffer attribute representing the instance transformations.
   * @param {?InstancedBufferAttribute|StorageInstancedBufferAttribute} instanceColor - Instanced buffer attribute representing the instance colors.
   */
  constructor(count2, instanceMatrix, instanceColor = null) {
    super("void");
    this.count = count2;
    this.instanceMatrix = instanceMatrix;
    this.instanceColor = instanceColor;
    this.instanceMatrixNode = null;
    this.instanceColorNode = null;
    this.updateType = NodeUpdateType.FRAME;
    this.buffer = null;
    this.bufferColor = null;
  }
  /**
   * Tracks whether the matrix data is provided via a storage buffer.
   *
   * @type {boolean}
   */
  get isStorageMatrix() {
    const { instanceMatrix } = this;
    return instanceMatrix && instanceMatrix.isStorageInstancedBufferAttribute === true;
  }
  /**
   * Tracks whether the color data is provided via a storage buffer.
   *
   * @type {boolean}
   */
  get isStorageColor() {
    const { instanceColor } = this;
    return instanceColor && instanceColor.isStorageInstancedBufferAttribute === true;
  }
  /**
   * Setups the internal buffers and nodes and assigns the transformed vertex data
   * to predefined node variables for accumulation. That follows the same patterns
   * like with morph and skinning nodes.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setup(builder) {
    const { instanceMatrix, instanceColor, isStorageMatrix, isStorageColor } = this;
    const { count: count2 } = instanceMatrix;
    let { instanceMatrixNode, instanceColorNode } = this;
    if (instanceMatrixNode === null) {
      if (isStorageMatrix) {
        instanceMatrixNode = storage(instanceMatrix, "mat4", Math.max(count2, 1)).element(instanceIndex);
      } else {
        if (count2 <= 1e3) {
          instanceMatrixNode = buffer(instanceMatrix.array, "mat4", Math.max(count2, 1)).element(instanceIndex);
        } else {
          const interleaved = new InstancedInterleavedBuffer(instanceMatrix.array, 16, 1);
          this.buffer = interleaved;
          const bufferFn = instanceMatrix.usage === DynamicDrawUsage ? instancedDynamicBufferAttribute : instancedBufferAttribute;
          const instanceBuffers = [
            bufferFn(interleaved, "vec4", 16, 0),
            bufferFn(interleaved, "vec4", 16, 4),
            bufferFn(interleaved, "vec4", 16, 8),
            bufferFn(interleaved, "vec4", 16, 12)
          ];
          instanceMatrixNode = mat4(...instanceBuffers);
        }
      }
      this.instanceMatrixNode = instanceMatrixNode;
    }
    if (instanceColor && instanceColorNode === null) {
      if (isStorageColor) {
        instanceColorNode = storage(instanceColor, "vec3", Math.max(instanceColor.count, 1)).element(instanceIndex);
      } else {
        const bufferAttribute2 = new InstancedBufferAttribute(instanceColor.array, 3);
        const bufferFn = instanceColor.usage === DynamicDrawUsage ? instancedDynamicBufferAttribute : instancedBufferAttribute;
        this.bufferColor = bufferAttribute2;
        instanceColorNode = vec3(bufferFn(bufferAttribute2, "vec3", 3, 0));
      }
      this.instanceColorNode = instanceColorNode;
    }
    const instancePosition = instanceMatrixNode.mul(positionLocal).xyz;
    positionLocal.assign(instancePosition);
    if (builder.hasGeometryAttribute("normal")) {
      const instanceNormal = transformNormal(normalLocal, instanceMatrixNode);
      normalLocal.assign(instanceNormal);
    }
    if (this.instanceColorNode !== null) {
      varyingProperty("vec3", "vInstanceColor").assign(this.instanceColorNode);
    }
  }
  /**
   * Checks if the internal buffers require an update.
   *
   * @param {NodeFrame} frame - The current node frame.
   */
  update() {
    if (this.buffer !== null && this.isStorageMatrix !== true) {
      this.buffer.clearUpdateRanges();
      this.buffer.updateRanges.push(...this.instanceMatrix.updateRanges);
      if (this.instanceMatrix.usage !== DynamicDrawUsage && this.instanceMatrix.version !== this.buffer.version) {
        this.buffer.version = this.instanceMatrix.version;
      }
    }
    if (this.instanceColor && this.bufferColor !== null && this.isStorageColor !== true) {
      this.bufferColor.clearUpdateRanges();
      this.bufferColor.updateRanges.push(...this.instanceColor.updateRanges);
      if (this.instanceColor.usage !== DynamicDrawUsage && this.instanceColor.version !== this.bufferColor.version) {
        this.bufferColor.version = this.instanceColor.version;
      }
    }
  }
};
var instance = nodeProxy(InstanceNode).setParameterLength(2, 3);
var InstancedMeshNode = class extends InstanceNode {
  static get type() {
    return "InstancedMeshNode";
  }
  /**
   * Constructs a new instanced mesh node.
   *
   * @param {InstancedMesh} instancedMesh - The instanced mesh.
   */
  constructor(instancedMesh2) {
    const { count: count2, instanceMatrix, instanceColor } = instancedMesh2;
    super(count2, instanceMatrix, instanceColor);
    this.instancedMesh = instancedMesh2;
  }
};
var instancedMesh = nodeProxy(InstancedMeshNode).setParameterLength(1);
var BatchNode = class extends Node4 {
  static get type() {
    return "BatchNode";
  }
  /**
   * Constructs a new batch node.
   *
   * @param {BatchedMesh} batchMesh - A reference to batched mesh.
   */
  constructor(batchMesh) {
    super("void");
    this.batchMesh = batchMesh;
    this.batchingIdNode = null;
  }
  /**
   * Setups the internal buffers and nodes and assigns the transformed vertex data
   * to predefined node variables for accumulation. That follows the same patterns
   * like with morph and skinning nodes.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setup(builder) {
    if (this.batchingIdNode === null) {
      if (builder.getDrawIndex() === null) {
        this.batchingIdNode = instanceIndex;
      } else {
        this.batchingIdNode = drawIndex;
      }
    }
    const getIndirectIndex = Fn(([id2]) => {
      const size3 = int(textureSize(textureLoad(this.batchMesh._indirectTexture), 0).x).toConst();
      const x4 = int(id2).mod(size3).toConst();
      const y4 = int(id2).div(size3).toConst();
      return textureLoad(this.batchMesh._indirectTexture, ivec2(x4, y4)).x;
    }).setLayout({
      name: "getIndirectIndex",
      type: "uint",
      inputs: [
        { name: "id", type: "int" }
      ]
    });
    const indirectId = getIndirectIndex(int(this.batchingIdNode));
    const matricesTexture = this.batchMesh._matricesTexture;
    const size2 = int(textureSize(textureLoad(matricesTexture), 0).x).toConst();
    const j2 = float(indirectId).mul(4).toInt().toConst();
    const x3 = j2.mod(size2).toConst();
    const y3 = j2.div(size2).toConst();
    const batchingMatrix = mat4(
      textureLoad(matricesTexture, ivec2(x3, y3)),
      textureLoad(matricesTexture, ivec2(x3.add(1), y3)),
      textureLoad(matricesTexture, ivec2(x3.add(2), y3)),
      textureLoad(matricesTexture, ivec2(x3.add(3), y3))
    );
    const colorsTexture = this.batchMesh._colorsTexture;
    if (colorsTexture !== null) {
      const getBatchingColor = Fn(([id2]) => {
        const size3 = int(textureSize(textureLoad(colorsTexture), 0).x).toConst();
        const j3 = id2;
        const x4 = j3.mod(size3).toConst();
        const y4 = j3.div(size3).toConst();
        return textureLoad(colorsTexture, ivec2(x4, y4)).rgb;
      }).setLayout({
        name: "getBatchingColor",
        type: "vec3",
        inputs: [
          { name: "id", type: "int" }
        ]
      });
      const color3 = getBatchingColor(indirectId);
      varyingProperty("vec3", "vBatchColor").assign(color3);
    }
    const bm = mat3(batchingMatrix);
    positionLocal.assign(batchingMatrix.mul(positionLocal));
    const transformedNormal = normalLocal.div(vec3(bm[0].dot(bm[0]), bm[1].dot(bm[1]), bm[2].dot(bm[2])));
    const batchingNormal = bm.mul(transformedNormal).xyz;
    normalLocal.assign(batchingNormal);
    if (builder.hasGeometryAttribute("tangent")) {
      tangentLocal.mulAssign(bm);
    }
  }
};
var batch = nodeProxy(BatchNode).setParameterLength(1);
var _frameId = /* @__PURE__ */ new WeakMap();
var SkinningNode = class extends Node4 {
  static get type() {
    return "SkinningNode";
  }
  /**
   * Constructs a new skinning node.
   *
   * @param {SkinnedMesh} skinnedMesh - The skinned mesh.
   */
  constructor(skinnedMesh) {
    super("void");
    this.skinnedMesh = skinnedMesh;
    this.updateType = NodeUpdateType.OBJECT;
    this.skinIndexNode = attribute("skinIndex", "uvec4");
    this.skinWeightNode = attribute("skinWeight", "vec4");
    this.bindMatrixNode = reference("bindMatrix", "mat4");
    this.bindMatrixInverseNode = reference("bindMatrixInverse", "mat4");
    this.boneMatricesNode = referenceBuffer("skeleton.boneMatrices", "mat4", skinnedMesh.skeleton.bones.length);
    this.positionNode = positionLocal;
    this.toPositionNode = positionLocal;
    this.previousBoneMatricesNode = null;
  }
  /**
   * Transforms the given vertex position via skinning.
   *
   * @param {Node} [boneMatrices=this.boneMatricesNode] - The bone matrices
   * @param {Node<vec3>} [position=this.positionNode] - The vertex position in local space.
   * @return {Node<vec3>} The transformed vertex position.
   */
  getSkinnedPosition(boneMatrices = this.boneMatricesNode, position = this.positionNode) {
    const { skinIndexNode, skinWeightNode, bindMatrixNode, bindMatrixInverseNode } = this;
    const boneMatX = boneMatrices.element(skinIndexNode.x);
    const boneMatY = boneMatrices.element(skinIndexNode.y);
    const boneMatZ = boneMatrices.element(skinIndexNode.z);
    const boneMatW = boneMatrices.element(skinIndexNode.w);
    const skinVertex = bindMatrixNode.mul(position);
    const skinned = add4(
      boneMatX.mul(skinWeightNode.x).mul(skinVertex),
      boneMatY.mul(skinWeightNode.y).mul(skinVertex),
      boneMatZ.mul(skinWeightNode.z).mul(skinVertex),
      boneMatW.mul(skinWeightNode.w).mul(skinVertex)
    );
    return bindMatrixInverseNode.mul(skinned).xyz;
  }
  /**
   * Transforms the given vertex normal via skinning.
   *
   * @param {Node} [boneMatrices=this.boneMatricesNode] - The bone matrices
   * @param {Node<vec3>} [normal=normalLocal] - The vertex normal in local space.
   * @return {Node<vec3>} The transformed vertex normal.
   */
  getSkinnedNormal(boneMatrices = this.boneMatricesNode, normal2 = normalLocal) {
    const { skinIndexNode, skinWeightNode, bindMatrixNode, bindMatrixInverseNode } = this;
    const boneMatX = boneMatrices.element(skinIndexNode.x);
    const boneMatY = boneMatrices.element(skinIndexNode.y);
    const boneMatZ = boneMatrices.element(skinIndexNode.z);
    const boneMatW = boneMatrices.element(skinIndexNode.w);
    let skinMatrix = add4(
      skinWeightNode.x.mul(boneMatX),
      skinWeightNode.y.mul(boneMatY),
      skinWeightNode.z.mul(boneMatZ),
      skinWeightNode.w.mul(boneMatW)
    );
    skinMatrix = bindMatrixInverseNode.mul(skinMatrix).mul(bindMatrixNode);
    return skinMatrix.transformDirection(normal2).xyz;
  }
  /**
   * Computes the transformed/skinned vertex position of the previous frame.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec3>} The skinned position from the previous frame.
   */
  getPreviousSkinnedPosition(builder) {
    const skinnedMesh = builder.object;
    if (this.previousBoneMatricesNode === null) {
      skinnedMesh.skeleton.previousBoneMatrices = new Float32Array(skinnedMesh.skeleton.boneMatrices);
      this.previousBoneMatricesNode = referenceBuffer("skeleton.previousBoneMatrices", "mat4", skinnedMesh.skeleton.bones.length);
    }
    return this.getSkinnedPosition(this.previousBoneMatricesNode, positionPrevious);
  }
  /**
   * Returns `true` if bone matrices from the previous frame are required. Relevant
   * when computing motion vectors with {@link VelocityNode}.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {boolean} Whether bone matrices from the previous frame are required or not.
   */
  needsPreviousBoneMatrices(builder) {
    const mrt2 = builder.renderer.getMRT();
    return mrt2 && mrt2.has("velocity") || getDataFromObject(builder.object).useVelocity === true;
  }
  /**
   * Setups the skinning node by assigning the transformed vertex data to predefined node variables.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec3>} The transformed vertex position.
   */
  setup(builder) {
    if (this.needsPreviousBoneMatrices(builder)) {
      positionPrevious.assign(this.getPreviousSkinnedPosition(builder));
    }
    const skinPosition = this.getSkinnedPosition();
    if (this.toPositionNode) this.toPositionNode.assign(skinPosition);
    if (builder.hasGeometryAttribute("normal")) {
      const skinNormal = this.getSkinnedNormal();
      normalLocal.assign(skinNormal);
      if (builder.hasGeometryAttribute("tangent")) {
        tangentLocal.assign(skinNormal);
      }
    }
    return skinPosition;
  }
  /**
   * Generates the code snippet of the skinning node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} output - The current output.
   * @return {string} The generated code snippet.
   */
  generate(builder, output2) {
    if (output2 !== "void") {
      return super.generate(builder, output2);
    }
  }
  /**
   * Updates the state of the skinned mesh by updating the skeleton once per frame.
   *
   * @param {NodeFrame} frame - The current node frame.
   */
  update(frame2) {
    const skeleton = frame2.object && frame2.object.skeleton ? frame2.object.skeleton : this.skinnedMesh.skeleton;
    if (_frameId.get(skeleton) === frame2.frameId) return;
    _frameId.set(skeleton, frame2.frameId);
    if (this.previousBoneMatricesNode !== null) {
      if (skeleton.previousBoneMatrices === null) {
        skeleton.previousBoneMatrices = new Float32Array(skeleton.boneMatrices);
      }
      skeleton.previousBoneMatrices.set(skeleton.boneMatrices);
    }
    skeleton.update();
  }
};
var skinning = (skinnedMesh) => new SkinningNode(skinnedMesh);
var computeSkinning = (skinnedMesh, toPosition = null) => {
  const node = new SkinningNode(skinnedMesh);
  node.positionNode = storage(new InstancedBufferAttribute(skinnedMesh.geometry.getAttribute("position").array, 3), "vec3").setPBO(true).toReadOnly().element(instanceIndex).toVar();
  node.skinIndexNode = storage(new InstancedBufferAttribute(new Uint32Array(skinnedMesh.geometry.getAttribute("skinIndex").array), 4), "uvec4").setPBO(true).toReadOnly().element(instanceIndex).toVar();
  node.skinWeightNode = storage(new InstancedBufferAttribute(skinnedMesh.geometry.getAttribute("skinWeight").array, 4), "vec4").setPBO(true).toReadOnly().element(instanceIndex).toVar();
  node.bindMatrixNode = uniform(skinnedMesh.bindMatrix, "mat4");
  node.bindMatrixInverseNode = uniform(skinnedMesh.bindMatrixInverse, "mat4");
  node.boneMatricesNode = buffer(skinnedMesh.skeleton.boneMatrices, "mat4", skinnedMesh.skeleton.bones.length);
  node.toPositionNode = toPosition;
  return nodeObject(node);
};
var LoopNode = class extends Node4 {
  static get type() {
    return "LoopNode";
  }
  /**
   * Constructs a new loop node.
   *
   * @param {Array<any>} params - Depending on the loop type, array holds different parameterization values for the loop.
   */
  constructor(params = []) {
    super("void");
    this.params = params;
  }
  /**
   * Returns a loop variable name based on an index. The pattern is
   * `0` = `i`, `1`= `j`, `2`= `k` and so on.
   *
   * @param {number} index - The index.
   * @return {string} The loop variable name.
   */
  getVarName(index8) {
    return String.fromCharCode("i".charCodeAt(0) + index8);
  }
  /**
   * Returns properties about this node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Object} The node properties.
   */
  getProperties(builder) {
    const properties = builder.getNodeProperties(this);
    if (properties.stackNode !== void 0) return properties;
    const inputs = {};
    for (let i2 = 0, l2 = this.params.length - 1; i2 < l2; i2++) {
      const param = this.params[i2];
      const name = param.isNode !== true && param.name || this.getVarName(i2);
      const type = param.isNode !== true && param.type || "int";
      inputs[name] = expression(name, type);
    }
    const stack2 = builder.addStack();
    const fnCall = this.params[this.params.length - 1](inputs);
    properties.returnsNode = fnCall.context({ nodeLoop: fnCall });
    properties.stackNode = stack2;
    const baseParam = this.params[0];
    if (baseParam.isNode !== true && typeof baseParam.update === "function") {
      const fnUpdateCall = Fn(this.params[0].update)(inputs);
      properties.updateNode = fnUpdateCall.context({ nodeLoop: fnUpdateCall });
    }
    builder.removeStack();
    return properties;
  }
  setup(builder) {
    this.getProperties(builder);
    if (builder.fnCall) {
      const shaderNodeData = builder.getDataFromNode(builder.fnCall.shaderNode);
      shaderNodeData.hasLoop = true;
    }
  }
  generate(builder) {
    const properties = this.getProperties(builder);
    const params = this.params;
    const stackNode = properties.stackNode;
    for (let i2 = 0, l2 = params.length - 1; i2 < l2; i2++) {
      const param = params[i2];
      let isWhile = false, start2 = null, end = null, name = null, type = null, condition = null, update9 = null;
      if (param.isNode) {
        if (param.getNodeType(builder) === "bool") {
          isWhile = true;
          type = "bool";
          end = param.build(builder, type);
        } else {
          type = "int";
          name = this.getVarName(i2);
          start2 = "0";
          end = param.build(builder, type);
          condition = "<";
        }
      } else {
        type = param.type || "int";
        name = param.name || this.getVarName(i2);
        start2 = param.start;
        end = param.end;
        condition = param.condition;
        update9 = param.update;
        if (typeof start2 === "number") start2 = builder.generateConst(type, start2);
        else if (start2 && start2.isNode) start2 = start2.build(builder, type);
        if (typeof end === "number") end = builder.generateConst(type, end);
        else if (end && end.isNode) end = end.build(builder, type);
        if (start2 !== void 0 && end === void 0) {
          start2 = start2 + " - 1";
          end = "0";
          condition = ">=";
        } else if (end !== void 0 && start2 === void 0) {
          start2 = "0";
          condition = "<";
        }
        if (condition === void 0) {
          if (Number(start2) > Number(end)) {
            condition = ">=";
          } else {
            condition = "<";
          }
        }
      }
      let loopSnippet;
      if (isWhile) {
        loopSnippet = `while ( ${end} )`;
      } else {
        const internalParam = { start: start2, end };
        const startSnippet = internalParam.start;
        const endSnippet = internalParam.end;
        let updateSnippet;
        const deltaOperator = () => condition.includes("<") ? "+=" : "-=";
        if (update9 !== void 0 && update9 !== null) {
          switch (typeof update9) {
            case "function":
              const flow2 = builder.flowStagesNode(properties.updateNode, "void");
              const snippet = flow2.code.replace(/\t|;/g, "");
              updateSnippet = snippet;
              break;
            case "number":
              updateSnippet = name + " " + deltaOperator() + " " + builder.generateConst(type, update9);
              break;
            case "string":
              updateSnippet = name + " " + update9;
              break;
            default:
              if (update9.isNode) {
                updateSnippet = name + " " + deltaOperator() + " " + update9.build(builder);
              } else {
                error("TSL: 'Loop( { update: ... } )' is not a function, string or number.");
                updateSnippet = "break /* invalid update */";
              }
          }
        } else {
          if (type === "int" || type === "uint") {
            update9 = condition.includes("<") ? "++" : "--";
          } else {
            update9 = deltaOperator() + " 1.";
          }
          updateSnippet = name + " " + update9;
        }
        const declarationSnippet = builder.getVar(type, name) + " = " + startSnippet;
        const conditionalSnippet = name + " " + condition + " " + endSnippet;
        loopSnippet = `for ( ${declarationSnippet}; ${conditionalSnippet}; ${updateSnippet} )`;
      }
      builder.addFlowCode((i2 === 0 ? "\n" : "") + builder.tab + loopSnippet + " {\n\n").addFlowTab();
    }
    const stackSnippet = stackNode.build(builder, "void");
    properties.returnsNode.build(builder, "void");
    builder.removeFlowTab().addFlowCode("\n" + builder.tab + stackSnippet);
    for (let i2 = 0, l2 = this.params.length - 1; i2 < l2; i2++) {
      builder.addFlowCode((i2 === 0 ? "" : builder.tab) + "}\n\n").removeFlowTab();
    }
    builder.addFlowTab();
  }
};
var Loop = (...params) => new LoopNode(nodeArray(params, "int")).toStack();
var Continue = () => expression("continue").toStack();
var Break = () => expression("break").toStack();
var _morphTextures = /* @__PURE__ */ new WeakMap();
var _morphVec4 = new Vector4();
var getMorph = Fn(({ bufferMap, influence, stride, width, depth: depth2, offset }) => {
  const texelIndex = int(vertexIndex).mul(stride).add(offset);
  const y3 = texelIndex.div(width);
  const x3 = texelIndex.sub(y3.mul(width));
  const bufferAttrib = textureLoad(bufferMap, ivec2(x3, y3)).depth(depth2).xyz;
  return bufferAttrib.mul(influence);
});
function getEntry(geometry) {
  const hasMorphPosition = geometry.morphAttributes.position !== void 0;
  const hasMorphNormals = geometry.morphAttributes.normal !== void 0;
  const hasMorphColors = geometry.morphAttributes.color !== void 0;
  const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
  const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
  let entry = _morphTextures.get(geometry);
  if (entry === void 0 || entry.count !== morphTargetsCount) {
    let disposeTexture = function() {
      bufferTexture.dispose();
      _morphTextures.delete(geometry);
      geometry.removeEventListener("dispose", disposeTexture);
    };
    if (entry !== void 0) entry.texture.dispose();
    const morphTargets = geometry.morphAttributes.position || [];
    const morphNormals = geometry.morphAttributes.normal || [];
    const morphColors = geometry.morphAttributes.color || [];
    let vertexDataCount = 0;
    if (hasMorphPosition === true) vertexDataCount = 1;
    if (hasMorphNormals === true) vertexDataCount = 2;
    if (hasMorphColors === true) vertexDataCount = 3;
    let width = geometry.attributes.position.count * vertexDataCount;
    let height = 1;
    const maxTextureSize = 4096;
    if (width > maxTextureSize) {
      height = Math.ceil(width / maxTextureSize);
      width = maxTextureSize;
    }
    const buffer2 = new Float32Array(width * height * 4 * morphTargetsCount);
    const bufferTexture = new DataArrayTexture(buffer2, width, height, morphTargetsCount);
    bufferTexture.type = FloatType;
    bufferTexture.needsUpdate = true;
    const vertexDataStride = vertexDataCount * 4;
    for (let i2 = 0; i2 < morphTargetsCount; i2++) {
      const morphTarget = morphTargets[i2];
      const morphNormal = morphNormals[i2];
      const morphColor = morphColors[i2];
      const offset = width * height * 4 * i2;
      for (let j2 = 0; j2 < morphTarget.count; j2++) {
        const stride = j2 * vertexDataStride;
        if (hasMorphPosition === true) {
          _morphVec4.fromBufferAttribute(morphTarget, j2);
          buffer2[offset + stride + 0] = _morphVec4.x;
          buffer2[offset + stride + 1] = _morphVec4.y;
          buffer2[offset + stride + 2] = _morphVec4.z;
          buffer2[offset + stride + 3] = 0;
        }
        if (hasMorphNormals === true) {
          _morphVec4.fromBufferAttribute(morphNormal, j2);
          buffer2[offset + stride + 4] = _morphVec4.x;
          buffer2[offset + stride + 5] = _morphVec4.y;
          buffer2[offset + stride + 6] = _morphVec4.z;
          buffer2[offset + stride + 7] = 0;
        }
        if (hasMorphColors === true) {
          _morphVec4.fromBufferAttribute(morphColor, j2);
          buffer2[offset + stride + 8] = _morphVec4.x;
          buffer2[offset + stride + 9] = _morphVec4.y;
          buffer2[offset + stride + 10] = _morphVec4.z;
          buffer2[offset + stride + 11] = morphColor.itemSize === 4 ? _morphVec4.w : 1;
        }
      }
    }
    entry = {
      count: morphTargetsCount,
      texture: bufferTexture,
      stride: vertexDataCount,
      size: new Vector2(width, height)
    };
    _morphTextures.set(geometry, entry);
    geometry.addEventListener("dispose", disposeTexture);
  }
  return entry;
}
var MorphNode = class extends Node4 {
  static get type() {
    return "MorphNode";
  }
  /**
   * Constructs a new morph node.
   *
   * @param {Mesh} mesh - The mesh holding the morph targets.
   */
  constructor(mesh) {
    super("void");
    this.mesh = mesh;
    this.morphBaseInfluence = uniform(1);
    this.updateType = NodeUpdateType.OBJECT;
  }
  /**
   * Setups the morph node by assigning the transformed vertex data to predefined node variables.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setup(builder) {
    const { geometry } = builder;
    const hasMorphPosition = geometry.morphAttributes.position !== void 0;
    const hasMorphNormals = geometry.hasAttribute("normal") && geometry.morphAttributes.normal !== void 0;
    const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
    const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
    const { texture: bufferMap, stride, size: size2 } = getEntry(geometry);
    if (hasMorphPosition === true) positionLocal.mulAssign(this.morphBaseInfluence);
    if (hasMorphNormals === true) normalLocal.mulAssign(this.morphBaseInfluence);
    const width = int(size2.width);
    Loop(morphTargetsCount, ({ i: i2 }) => {
      const influence = float(0).toVar();
      if (this.mesh.count > 1 && (this.mesh.morphTexture !== null && this.mesh.morphTexture !== void 0)) {
        influence.assign(textureLoad(this.mesh.morphTexture, ivec2(int(i2).add(1), int(instanceIndex))).r);
      } else {
        influence.assign(reference("morphTargetInfluences", "float").element(i2).toVar());
      }
      If(influence.notEqual(0), () => {
        if (hasMorphPosition === true) {
          positionLocal.addAssign(getMorph({
            bufferMap,
            influence,
            stride,
            width,
            depth: i2,
            offset: int(0)
          }));
        }
        if (hasMorphNormals === true) {
          normalLocal.addAssign(getMorph({
            bufferMap,
            influence,
            stride,
            width,
            depth: i2,
            offset: int(1)
          }));
        }
      });
    });
  }
  /**
   * Updates the state of the morphed mesh by updating the base influence.
   *
   * @param {NodeFrame} frame - The current node frame.
   */
  update() {
    const morphBaseInfluence = this.morphBaseInfluence;
    if (this.mesh.geometry.morphTargetsRelative) {
      morphBaseInfluence.value = 1;
    } else {
      morphBaseInfluence.value = 1 - this.mesh.morphTargetInfluences.reduce((a3, b) => a3 + b, 0);
    }
  }
};
var morphReference = nodeProxy(MorphNode).setParameterLength(1);
var LightingNode = class extends Node4 {
  static get type() {
    return "LightingNode";
  }
  /**
   * Constructs a new lighting node.
   */
  constructor() {
    super("vec3");
    this.isLightingNode = true;
  }
};
var AONode = class extends LightingNode {
  static get type() {
    return "AONode";
  }
  /**
   * Constructs a new AO node.
   *
   * @param {?Node<float>} [aoNode=null] - The ambient occlusion node.
   */
  constructor(aoNode = null) {
    super();
    this.aoNode = aoNode;
  }
  setup(builder) {
    builder.context.ambientOcclusion.mulAssign(this.aoNode);
  }
};
var LightingContextNode = class extends ContextNode {
  static get type() {
    return "LightingContextNode";
  }
  /**
   * Constructs a new lighting context node.
   *
   * @param {LightsNode} lightsNode - The lights node.
   * @param {?LightingModel} [lightingModel=null] - The current lighting model.
   * @param {?Node<vec3>} [backdropNode=null] - A backdrop node.
   * @param {?Node<float>} [backdropAlphaNode=null] - A backdrop alpha node.
   */
  constructor(lightsNode, lightingModel = null, backdropNode = null, backdropAlphaNode = null) {
    super(lightsNode);
    this.lightingModel = lightingModel;
    this.backdropNode = backdropNode;
    this.backdropAlphaNode = backdropAlphaNode;
    this._value = null;
  }
  /**
   * Returns a lighting context object.
   *
   * @return {{
   * radiance: Node<vec3>,
   * irradiance: Node<vec3>,
   * iblIrradiance: Node<vec3>,
   * ambientOcclusion: Node<float>,
   * reflectedLight: {directDiffuse: Node<vec3>, directSpecular: Node<vec3>, indirectDiffuse: Node<vec3>, indirectSpecular: Node<vec3>},
   * backdrop: Node<vec3>,
   * backdropAlpha: Node<float>
   * }} The lighting context object.
   */
  getContext() {
    const { backdropNode, backdropAlphaNode } = this;
    const directDiffuse = vec3().toVar("directDiffuse"), directSpecular = vec3().toVar("directSpecular"), indirectDiffuse = vec3().toVar("indirectDiffuse"), indirectSpecular = vec3().toVar("indirectSpecular");
    const reflectedLight = {
      directDiffuse,
      directSpecular,
      indirectDiffuse,
      indirectSpecular
    };
    const context2 = {
      radiance: vec3().toVar("radiance"),
      irradiance: vec3().toVar("irradiance"),
      iblIrradiance: vec3().toVar("iblIrradiance"),
      ambientOcclusion: float(1).toVar("ambientOcclusion"),
      reflectedLight,
      backdrop: backdropNode,
      backdropAlpha: backdropAlphaNode
    };
    return context2;
  }
  setup(builder) {
    this.value = this._value || (this._value = this.getContext());
    this.value.lightingModel = this.lightingModel || builder.context.lightingModel;
    return super.setup(builder);
  }
};
var lightingContext = nodeProxy(LightingContextNode);
var IrradianceNode = class extends LightingNode {
  static get type() {
    return "IrradianceNode";
  }
  /**
   * Constructs a new irradiance node.
   *
   * @param {Node<vec3>} node - A node contributing irradiance.
   */
  constructor(node) {
    super();
    this.node = node;
  }
  setup(builder) {
    builder.context.irradiance.addAssign(this.node);
  }
};
var _size$5 = new Vector2();
var ViewportTextureNode = class extends TextureNode {
  static get type() {
    return "ViewportTextureNode";
  }
  /**
   * Constructs a new viewport texture node.
   *
   * @param {Node} [uvNode=screenUV] - The uv node.
   * @param {?Node} [levelNode=null] - The level node.
   * @param {?Texture} [framebufferTexture=null] - A framebuffer texture holding the viewport data. If not provided, a framebuffer texture is created automatically.
   */
  constructor(uvNode = screenUV, levelNode = null, framebufferTexture = null) {
    let defaultFramebuffer = null;
    if (framebufferTexture === null) {
      defaultFramebuffer = new FramebufferTexture();
      defaultFramebuffer.minFilter = LinearMipmapLinearFilter;
      framebufferTexture = defaultFramebuffer;
    } else {
      defaultFramebuffer = framebufferTexture;
    }
    super(framebufferTexture, uvNode, levelNode);
    this.generateMipmaps = false;
    this.defaultFramebuffer = defaultFramebuffer;
    this.isOutputTextureNode = true;
    this.updateBeforeType = NodeUpdateType.FRAME;
    this._cacheTextures = /* @__PURE__ */ new WeakMap();
  }
  /**
   * This methods returns a texture for the given render target reference.
   *
   * To avoid rendering errors, `ViewportTextureNode` must use unique framebuffer textures
   * for different render contexts.
   *
   * @param {?RenderTarget} [reference=null] - The render target reference.
   * @return {Texture} The framebuffer texture.
   */
  getTextureForReference(reference2 = null) {
    let defaultFramebuffer;
    let cacheTextures;
    if (this.referenceNode) {
      defaultFramebuffer = this.referenceNode.defaultFramebuffer;
      cacheTextures = this.referenceNode._cacheTextures;
    } else {
      defaultFramebuffer = this.defaultFramebuffer;
      cacheTextures = this._cacheTextures;
    }
    if (reference2 === null) {
      return defaultFramebuffer;
    }
    if (cacheTextures.has(reference2) === false) {
      const framebufferTexture = defaultFramebuffer.clone();
      cacheTextures.set(reference2, framebufferTexture);
    }
    return cacheTextures.get(reference2);
  }
  updateReference(frame2) {
    const renderTarget = frame2.renderer.getRenderTarget();
    this.value = this.getTextureForReference(renderTarget);
    return this.value;
  }
  updateBefore(frame2) {
    const renderer3 = frame2.renderer;
    const renderTarget = renderer3.getRenderTarget();
    if (renderTarget === null) {
      renderer3.getDrawingBufferSize(_size$5);
    } else {
      _size$5.set(renderTarget.width, renderTarget.height);
    }
    const framebufferTexture = this.getTextureForReference(renderTarget);
    if (framebufferTexture.image.width !== _size$5.width || framebufferTexture.image.height !== _size$5.height) {
      framebufferTexture.image.width = _size$5.width;
      framebufferTexture.image.height = _size$5.height;
      framebufferTexture.needsUpdate = true;
    }
    const currentGenerateMipmaps = framebufferTexture.generateMipmaps;
    framebufferTexture.generateMipmaps = this.generateMipmaps;
    renderer3.copyFramebufferToTexture(framebufferTexture);
    framebufferTexture.generateMipmaps = currentGenerateMipmaps;
  }
  clone() {
    const viewportTextureNode = new this.constructor(this.uvNode, this.levelNode, this.value);
    viewportTextureNode.generateMipmaps = this.generateMipmaps;
    return viewportTextureNode;
  }
};
var viewportTexture = nodeProxy(ViewportTextureNode).setParameterLength(0, 3);
var viewportMipTexture = nodeProxy(ViewportTextureNode, null, null, { generateMipmaps: true }).setParameterLength(0, 3);
var _sharedDepthbuffer = null;
var ViewportDepthTextureNode = class extends ViewportTextureNode {
  static get type() {
    return "ViewportDepthTextureNode";
  }
  /**
   * Constructs a new viewport depth texture node.
   *
   * @param {Node} [uvNode=screenUV] - The uv node.
   * @param {?Node} [levelNode=null] - The level node.
   */
  constructor(uvNode = screenUV, levelNode = null) {
    if (_sharedDepthbuffer === null) {
      _sharedDepthbuffer = new DepthTexture();
    }
    super(uvNode, levelNode, _sharedDepthbuffer);
  }
  /**
   * Overwritten so the method always returns the unique shared
   * depth texture.
   *
   * @return {DepthTexture} The shared depth texture.
   */
  getTextureForReference() {
    return _sharedDepthbuffer;
  }
};
var viewportDepthTexture = nodeProxy(ViewportDepthTextureNode).setParameterLength(0, 2);
var ViewportDepthNode = class _ViewportDepthNode extends Node4 {
  static get type() {
    return "ViewportDepthNode";
  }
  /**
   * Constructs a new viewport depth node.
   *
   * @param {('depth'|'depthBase'|'linearDepth')} scope - The node's scope.
   * @param {?Node} [valueNode=null] - The value node.
   */
  constructor(scope, valueNode = null) {
    super("float");
    this.scope = scope;
    this.valueNode = valueNode;
    this.isViewportDepthNode = true;
  }
  generate(builder) {
    const { scope } = this;
    if (scope === _ViewportDepthNode.DEPTH_BASE) {
      return builder.getFragDepth();
    }
    return super.generate(builder);
  }
  setup({ camera: camera3 }) {
    const { scope } = this;
    const value = this.valueNode;
    let node = null;
    if (scope === _ViewportDepthNode.DEPTH_BASE) {
      if (value !== null) {
        node = depthBase().assign(value);
      }
    } else if (scope === _ViewportDepthNode.DEPTH) {
      if (camera3.isPerspectiveCamera) {
        node = viewZToPerspectiveDepth(positionView.z, cameraNear, cameraFar);
      } else {
        node = viewZToOrthographicDepth(positionView.z, cameraNear, cameraFar);
      }
    } else if (scope === _ViewportDepthNode.LINEAR_DEPTH) {
      if (value !== null) {
        if (camera3.isPerspectiveCamera) {
          const viewZ = perspectiveDepthToViewZ(value, cameraNear, cameraFar);
          node = viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);
        } else {
          node = value;
        }
      } else {
        node = viewZToOrthographicDepth(positionView.z, cameraNear, cameraFar);
      }
    }
    return node;
  }
};
ViewportDepthNode.DEPTH_BASE = "depthBase";
ViewportDepthNode.DEPTH = "depth";
ViewportDepthNode.LINEAR_DEPTH = "linearDepth";
var viewZToOrthographicDepth = (viewZ, near, far) => viewZ.add(near).div(near.sub(far));
var orthographicDepthToViewZ = (depth2, near, far) => near.sub(far).mul(depth2).sub(near);
var viewZToPerspectiveDepth = (viewZ, near, far) => near.add(viewZ).mul(far).div(far.sub(near).mul(viewZ));
var perspectiveDepthToViewZ = (depth2, near, far) => near.mul(far).div(far.sub(near).mul(depth2).sub(far));
var viewZToLogarithmicDepth = (viewZ, near, far) => {
  near = near.max(1e-6).toVar();
  const numerator = log22(viewZ.negate().div(near));
  const denominator = log22(far.div(near));
  return numerator.div(denominator);
};
var logarithmicDepthToViewZ = (depth2, near, far) => {
  const exponent2 = depth2.mul(log3(far.div(near)));
  return float(Math.E).pow(exponent2).mul(near).negate();
};
var depthBase = nodeProxy(ViewportDepthNode, ViewportDepthNode.DEPTH_BASE);
var depth = nodeImmutable(ViewportDepthNode, ViewportDepthNode.DEPTH);
var linearDepth = nodeProxy(ViewportDepthNode, ViewportDepthNode.LINEAR_DEPTH).setParameterLength(0, 1);
var viewportLinearDepth = linearDepth(viewportDepthTexture());
depth.assign = (value) => depthBase(value);
var ClippingNode = class _ClippingNode extends Node4 {
  static get type() {
    return "ClippingNode";
  }
  /**
   * Constructs a new clipping node.
   *
   * @param {('default'|'hardware'|'alphaToCoverage')} [scope='default'] - The node's scope. Similar to other nodes,
   * the selected scope influences the behavior of the node and what type of code is generated.
   */
  constructor(scope = _ClippingNode.DEFAULT) {
    super();
    this.scope = scope;
  }
  /**
   * Setups the node depending on the selected scope.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node} The result node.
   */
  setup(builder) {
    super.setup(builder);
    const clippingContext = builder.clippingContext;
    const { intersectionPlanes, unionPlanes } = clippingContext;
    this.hardwareClipping = builder.material.hardwareClipping;
    if (this.scope === _ClippingNode.ALPHA_TO_COVERAGE) {
      return this.setupAlphaToCoverage(intersectionPlanes, unionPlanes);
    } else if (this.scope === _ClippingNode.HARDWARE) {
      return this.setupHardwareClipping(unionPlanes, builder);
    } else {
      return this.setupDefault(intersectionPlanes, unionPlanes);
    }
  }
  /**
   * Setups alpha to coverage.
   *
   * @param {Array<Vector4>} intersectionPlanes - The intersection planes.
   * @param {Array<Vector4>} unionPlanes - The union planes.
   * @return {Node} The result node.
   */
  setupAlphaToCoverage(intersectionPlanes, unionPlanes) {
    return Fn(() => {
      const distanceToPlane = float().toVar("distanceToPlane");
      const distanceGradient = float().toVar("distanceToGradient");
      const clipOpacity = float(1).toVar("clipOpacity");
      const numUnionPlanes = unionPlanes.length;
      if (this.hardwareClipping === false && numUnionPlanes > 0) {
        const clippingPlanes = uniformArray(unionPlanes).setGroup(renderGroup);
        Loop(numUnionPlanes, ({ i: i2 }) => {
          const plane = clippingPlanes.element(i2);
          distanceToPlane.assign(positionView.dot(plane.xyz).negate().add(plane.w));
          distanceGradient.assign(distanceToPlane.fwidth().div(2));
          clipOpacity.mulAssign(smoothstep2(distanceGradient.negate(), distanceGradient, distanceToPlane));
        });
      }
      const numIntersectionPlanes = intersectionPlanes.length;
      if (numIntersectionPlanes > 0) {
        const clippingPlanes = uniformArray(intersectionPlanes).setGroup(renderGroup);
        const intersectionClipOpacity = float(1).toVar("intersectionClipOpacity");
        Loop(numIntersectionPlanes, ({ i: i2 }) => {
          const plane = clippingPlanes.element(i2);
          distanceToPlane.assign(positionView.dot(plane.xyz).negate().add(plane.w));
          distanceGradient.assign(distanceToPlane.fwidth().div(2));
          intersectionClipOpacity.mulAssign(smoothstep2(distanceGradient.negate(), distanceGradient, distanceToPlane).oneMinus());
        });
        clipOpacity.mulAssign(intersectionClipOpacity.oneMinus());
      }
      diffuseColor.a.mulAssign(clipOpacity);
      diffuseColor.a.equal(0).discard();
    })();
  }
  /**
   * Setups the default clipping.
   *
   * @param {Array<Vector4>} intersectionPlanes - The intersection planes.
   * @param {Array<Vector4>} unionPlanes - The union planes.
   * @return {Node} The result node.
   */
  setupDefault(intersectionPlanes, unionPlanes) {
    return Fn(() => {
      const numUnionPlanes = unionPlanes.length;
      if (this.hardwareClipping === false && numUnionPlanes > 0) {
        const clippingPlanes = uniformArray(unionPlanes).setGroup(renderGroup);
        Loop(numUnionPlanes, ({ i: i2 }) => {
          const plane = clippingPlanes.element(i2);
          positionView.dot(plane.xyz).greaterThan(plane.w).discard();
        });
      }
      const numIntersectionPlanes = intersectionPlanes.length;
      if (numIntersectionPlanes > 0) {
        const clippingPlanes = uniformArray(intersectionPlanes).setGroup(renderGroup);
        const clipped = bool(true).toVar("clipped");
        Loop(numIntersectionPlanes, ({ i: i2 }) => {
          const plane = clippingPlanes.element(i2);
          clipped.assign(positionView.dot(plane.xyz).greaterThan(plane.w).and(clipped));
        });
        clipped.discard();
      }
    })();
  }
  /**
   * Setups hardware clipping.
   *
   * @param {Array<Vector4>} unionPlanes - The union planes.
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node} The result node.
   */
  setupHardwareClipping(unionPlanes, builder) {
    const numUnionPlanes = unionPlanes.length;
    builder.enableHardwareClipping(numUnionPlanes);
    return Fn(() => {
      const clippingPlanes = uniformArray(unionPlanes).setGroup(renderGroup);
      const hw_clip_distances = builtin(builder.getClipDistance());
      Loop(numUnionPlanes, ({ i: i2 }) => {
        const plane = clippingPlanes.element(i2);
        const distance4 = positionView.dot(plane.xyz).sub(plane.w).negate();
        hw_clip_distances.element(i2).assign(distance4);
      });
    })();
  }
};
ClippingNode.ALPHA_TO_COVERAGE = "alphaToCoverage";
ClippingNode.DEFAULT = "default";
ClippingNode.HARDWARE = "hardware";
var clipping = () => new ClippingNode();
var clippingAlpha = () => new ClippingNode(ClippingNode.ALPHA_TO_COVERAGE);
var hardwareClipping = () => new ClippingNode(ClippingNode.HARDWARE);
var ALPHA_HASH_SCALE = 0.05;
var hash2D = Fn(([value]) => {
  return fract(mul(1e4, sin(mul(17, value.x).add(mul(0.1, value.y)))).mul(add4(0.1, abs(sin(mul(13, value.y).add(value.x))))));
});
var hash3D = Fn(([value]) => {
  return hash2D(vec2(hash2D(value.xy), value.z));
});
var getAlphaHashThreshold = Fn(([position]) => {
  const maxDeriv = max$1(
    length(dFdx(position.xyz)),
    length(dFdy(position.xyz))
  );
  const pixScale = float(1).div(float(ALPHA_HASH_SCALE).mul(maxDeriv)).toVar("pixScale");
  const pixScales = vec2(
    exp2(floor(log22(pixScale))),
    exp2(ceil(log22(pixScale)))
  );
  const alpha = vec2(
    hash3D(floor(pixScales.x.mul(position.xyz))),
    hash3D(floor(pixScales.y.mul(position.xyz)))
  );
  const lerpFactor = fract(log22(pixScale));
  const x3 = add4(mul(lerpFactor.oneMinus(), alpha.x), mul(lerpFactor, alpha.y));
  const a3 = min$1(lerpFactor, lerpFactor.oneMinus());
  const cases = vec3(
    x3.mul(x3).div(mul(2, a3).mul(sub(1, a3))),
    x3.sub(mul(0.5, a3)).div(sub(1, a3)),
    sub(1, sub(1, x3).mul(sub(1, x3)).div(mul(2, a3).mul(sub(1, a3))))
  );
  const threshold2 = x3.lessThan(a3.oneMinus()).select(x3.lessThan(a3).select(cases.x, cases.y), cases.z);
  return clamp3(threshold2, 1e-6, 1);
}).setLayout({
  name: "getAlphaHashThreshold",
  type: "float",
  inputs: [
    { name: "position", type: "vec3" }
  ]
});
var VertexColorNode = class extends AttributeNode {
  static get type() {
    return "VertexColorNode";
  }
  /**
   * Constructs a new vertex color node.
   *
   * @param {number} index - The attribute index.
   */
  constructor(index8) {
    super(null, "vec4");
    this.isVertexColorNode = true;
    this.index = index8;
  }
  /**
   * Overwrites the default implementation by honoring the attribute index.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The attribute name.
   */
  getAttributeName() {
    const index8 = this.index;
    return "color" + (index8 > 0 ? index8 : "");
  }
  generate(builder) {
    const attributeName = this.getAttributeName(builder);
    const geometryAttribute = builder.hasGeometryAttribute(attributeName);
    let result2;
    if (geometryAttribute === true) {
      result2 = super.generate(builder);
    } else {
      result2 = builder.generateConst(this.nodeType, new Vector4(1, 1, 1, 1));
    }
    return result2;
  }
  serialize(data) {
    super.serialize(data);
    data.index = this.index;
  }
  deserialize(data) {
    super.deserialize(data);
    this.index = data.index;
  }
};
var vertexColor = (index8 = 0) => new VertexColorNode(index8);
var blendBurn = Fn(([base, blend]) => {
  return min$1(1, base.oneMinus().div(blend)).oneMinus();
}).setLayout({
  name: "blendBurn",
  type: "vec3",
  inputs: [
    { name: "base", type: "vec3" },
    { name: "blend", type: "vec3" }
  ]
});
var blendDodge = Fn(([base, blend]) => {
  return min$1(base.div(blend.oneMinus()), 1);
}).setLayout({
  name: "blendDodge",
  type: "vec3",
  inputs: [
    { name: "base", type: "vec3" },
    { name: "blend", type: "vec3" }
  ]
});
var blendScreen = Fn(([base, blend]) => {
  return base.oneMinus().mul(blend.oneMinus()).oneMinus();
}).setLayout({
  name: "blendScreen",
  type: "vec3",
  inputs: [
    { name: "base", type: "vec3" },
    { name: "blend", type: "vec3" }
  ]
});
var blendOverlay = Fn(([base, blend]) => {
  return mix2(base.mul(2).mul(blend), base.oneMinus().mul(2).mul(blend.oneMinus()).oneMinus(), step(0.5, base));
}).setLayout({
  name: "blendOverlay",
  type: "vec3",
  inputs: [
    { name: "base", type: "vec3" },
    { name: "blend", type: "vec3" }
  ]
});
var blendColor = Fn(([base, blend]) => {
  const outAlpha = blend.a.add(base.a.mul(blend.a.oneMinus()));
  return vec4(blend.rgb.mul(blend.a).add(base.rgb.mul(base.a).mul(blend.a.oneMinus())).div(outAlpha), outAlpha);
}).setLayout({
  name: "blendColor",
  type: "vec4",
  inputs: [
    { name: "base", type: "vec4" },
    { name: "blend", type: "vec4" }
  ]
});
var premultiplyAlpha = Fn(([color3]) => {
  return vec4(color3.rgb.mul(color3.a), color3.a);
}, { color: "vec4", return: "vec4" });
var unpremultiplyAlpha = Fn(([color3]) => {
  If(color3.a.equal(0), () => vec4(0));
  return vec4(color3.rgb.div(color3.a), color3.a);
}, { color: "vec4", return: "vec4" });
var burn = (...params) => {
  warn('TSL: "burn" has been renamed. Use "blendBurn" instead.');
  return blendBurn(params);
};
var dodge = (...params) => {
  warn('TSL: "dodge" has been renamed. Use "blendDodge" instead.');
  return blendDodge(params);
};
var screen = (...params) => {
  warn('TSL: "screen" has been renamed. Use "blendScreen" instead.');
  return blendScreen(params);
};
var overlay = (...params) => {
  warn('TSL: "overlay" has been renamed. Use "blendOverlay" instead.');
  return blendOverlay(params);
};
var NodeMaterial = class extends Material {
  static get type() {
    return "NodeMaterial";
  }
  /**
   * Represents the type of the node material.
   *
   * @type {string}
   */
  get type() {
    return this.constructor.type;
  }
  set type(_value) {
  }
  /**
   * Constructs a new node material.
   */
  constructor() {
    super();
    this.isNodeMaterial = true;
    this.fog = true;
    this.lights = false;
    this.hardwareClipping = false;
    this.lightsNode = null;
    this.envNode = null;
    this.aoNode = null;
    this.colorNode = null;
    this.normalNode = null;
    this.opacityNode = null;
    this.backdropNode = null;
    this.backdropAlphaNode = null;
    this.alphaTestNode = null;
    this.maskNode = null;
    this.positionNode = null;
    this.geometryNode = null;
    this.depthNode = null;
    this.receivedShadowPositionNode = null;
    this.castShadowPositionNode = null;
    this.receivedShadowNode = null;
    this.castShadowNode = null;
    this.outputNode = null;
    this.mrtNode = null;
    this.fragmentNode = null;
    this.vertexNode = null;
    this.contextNode = null;
    Object.defineProperty(this, "shadowPositionNode", {
      // @deprecated, r176
      get: () => {
        return this.receivedShadowPositionNode;
      },
      set: (value) => {
        warn('NodeMaterial: ".shadowPositionNode" was renamed to ".receivedShadowPositionNode".');
        this.receivedShadowPositionNode = value;
      }
    });
  }
  /**
   * Returns an array of child nodes for this material.
   *
   * @private
   * @returns {Array<{property: string, childNode: Node}>}
   */
  _getNodeChildren() {
    const children2 = [];
    for (const property3 of Object.getOwnPropertyNames(this)) {
      if (property3.startsWith("_") === true) continue;
      const object = this[property3];
      if (object && object.isNode === true) {
        children2.push({ property: property3, childNode: object });
      }
    }
    return children2;
  }
  /**
   * Allows to define a custom cache key that influence the material key computation
   * for render objects.
   *
   * @return {string} The custom cache key.
   */
  customProgramCacheKey() {
    const values2 = [];
    for (const { property: property3, childNode } of this._getNodeChildren()) {
      values2.push(hashString(property3.slice(0, -4)), childNode.getCacheKey());
    }
    return this.type + hashArray(values2);
  }
  /**
   * Builds this material with the given node builder.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  build(builder) {
    this.setup(builder);
  }
  /**
   * Setups a node material observer with the given builder.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {NodeMaterialObserver} The node material observer.
   */
  setupObserver(builder) {
    return new NodeMaterialObserver(builder);
  }
  /**
   * Setups the vertex and fragment stage of this node material.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setup(builder) {
    builder.context.setupNormal = () => subBuild(this.setupNormal(builder), "NORMAL", "vec3");
    builder.context.setupPositionView = () => this.setupPositionView(builder);
    builder.context.setupModelViewProjection = () => this.setupModelViewProjection(builder);
    const renderer3 = builder.renderer;
    const renderTarget = renderer3.getRenderTarget();
    if (renderer3.contextNode.isContextNode === true) {
      builder.context = { ...builder.context, ...renderer3.contextNode.getFlowContextData() };
    } else {
      error('NodeMaterial: "renderer.contextNode" must be an instance of `context()`.');
    }
    if (this.contextNode !== null) {
      if (this.contextNode.isContextNode === true) {
        builder.context = { ...builder.context, ...this.contextNode.getFlowContextData() };
      } else {
        error('NodeMaterial: "material.contextNode" must be an instance of `context()`.');
      }
    }
    builder.addStack();
    const mvp = subBuild(this.setupVertex(builder), "VERTEX");
    const vertexNode = this.vertexNode || mvp;
    builder.stack.outputNode = vertexNode;
    this.setupHardwareClipping(builder);
    if (this.geometryNode !== null) {
      builder.stack.outputNode = builder.stack.outputNode.bypass(this.geometryNode);
    }
    builder.addFlow("vertex", builder.removeStack());
    builder.addStack();
    let resultNode;
    const clippingNode = this.setupClipping(builder);
    if (this.depthWrite === true || this.depthTest === true) {
      if (renderTarget !== null) {
        if (renderTarget.depthBuffer === true) this.setupDepth(builder);
      } else {
        if (renderer3.depth === true) this.setupDepth(builder);
      }
    }
    if (this.fragmentNode === null) {
      this.setupDiffuseColor(builder);
      this.setupVariants(builder);
      const outgoingLightNode = this.setupLighting(builder);
      if (clippingNode !== null) builder.stack.addToStack(clippingNode);
      const basicOutput = vec4(outgoingLightNode, diffuseColor.a).max(0);
      resultNode = this.setupOutput(builder, basicOutput);
      output.assign(resultNode);
      const isCustomOutput = this.outputNode !== null;
      if (isCustomOutput) resultNode = this.outputNode;
      if (builder.context.getOutput) {
        resultNode = builder.context.getOutput(resultNode, builder);
      }
      if (renderTarget !== null) {
        const mrt2 = renderer3.getMRT();
        const materialMRT = this.mrtNode;
        if (mrt2 !== null) {
          if (isCustomOutput) output.assign(resultNode);
          resultNode = mrt2;
          if (materialMRT !== null) {
            resultNode = mrt2.merge(materialMRT);
          }
        } else if (materialMRT !== null) {
          resultNode = materialMRT;
        }
      }
    } else {
      let fragmentNode = this.fragmentNode;
      if (fragmentNode.isOutputStructNode !== true) {
        fragmentNode = vec4(fragmentNode);
      }
      resultNode = this.setupOutput(builder, fragmentNode);
    }
    builder.stack.outputNode = resultNode;
    builder.addFlow("fragment", builder.removeStack());
    builder.observer = this.setupObserver(builder);
  }
  /**
   * Setups the clipping node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {ClippingNode} The clipping node.
   */
  setupClipping(builder) {
    if (builder.clippingContext === null) return null;
    const { unionPlanes, intersectionPlanes } = builder.clippingContext;
    let result2 = null;
    if (unionPlanes.length > 0 || intersectionPlanes.length > 0) {
      const samples = builder.renderer.currentSamples;
      if (this.alphaToCoverage && samples > 1) {
        result2 = clippingAlpha();
      } else {
        builder.stack.addToStack(clipping());
      }
    }
    return result2;
  }
  /**
   * Setups the hardware clipping if available on the current device.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setupHardwareClipping(builder) {
    this.hardwareClipping = false;
    if (builder.clippingContext === null) return;
    const candidateCount = builder.clippingContext.unionPlanes.length;
    if (candidateCount > 0 && candidateCount <= 8 && builder.isAvailable("clipDistance")) {
      builder.stack.addToStack(hardwareClipping());
      this.hardwareClipping = true;
    }
    return;
  }
  /**
   * Setups the depth of this material.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setupDepth(builder) {
    const { renderer: renderer3, camera: camera3 } = builder;
    let depthNode = this.depthNode;
    if (depthNode === null) {
      const mrt2 = renderer3.getMRT();
      if (mrt2 && mrt2.has("depth")) {
        depthNode = mrt2.get("depth");
      } else if (renderer3.logarithmicDepthBuffer === true) {
        if (camera3.isPerspectiveCamera) {
          depthNode = viewZToLogarithmicDepth(positionView.z, cameraNear, cameraFar);
        } else {
          depthNode = viewZToOrthographicDepth(positionView.z, cameraNear, cameraFar);
        }
      }
    }
    if (depthNode !== null) {
      depth.assign(depthNode).toStack();
    }
  }
  /**
   * Setups the position node in view space. This method exists
   * so derived node materials can modify the implementation e.g. sprite materials.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec3>} The position in view space.
   */
  setupPositionView() {
    return modelViewMatrix.mul(positionLocal).xyz;
  }
  /**
   * Setups the position in clip space.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec4>} The position in view space.
   */
  setupModelViewProjection() {
    return cameraProjectionMatrix.mul(positionView);
  }
  /**
   * Setups the logic for the vertex stage.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec4>} The position in clip space.
   */
  setupVertex(builder) {
    builder.addStack();
    this.setupPosition(builder);
    builder.context.vertex = builder.removeStack();
    return modelViewProjection;
  }
  /**
   * Setups the computation of the position in local space.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec3>} The position in local space.
   */
  setupPosition(builder) {
    const { object, geometry } = builder;
    if (geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color) {
      morphReference(object).toStack();
    }
    if (object.isSkinnedMesh === true) {
      skinning(object).toStack();
    }
    if (this.displacementMap) {
      const displacementMap = materialReference("displacementMap", "texture");
      const displacementScale = materialReference("displacementScale", "float");
      const displacementBias = materialReference("displacementBias", "float");
      positionLocal.addAssign(normalLocal.normalize().mul(displacementMap.x.mul(displacementScale).add(displacementBias)));
    }
    if (object.isBatchedMesh) {
      batch(object).toStack();
    }
    if (object.isInstancedMesh && object.instanceMatrix && object.instanceMatrix.isInstancedBufferAttribute === true) {
      instancedMesh(object).toStack();
    }
    if (this.positionNode !== null) {
      positionLocal.assign(subBuild(this.positionNode, "POSITION", "vec3"));
    }
    return positionLocal;
  }
  /**
   * Setups the computation of the material's diffuse color.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {BufferGeometry} geometry - The geometry.
   */
  setupDiffuseColor(builder) {
    const { object, geometry } = builder;
    if (this.maskNode !== null) {
      bool(this.maskNode).not().discard();
    }
    let colorNode = this.colorNode ? vec4(this.colorNode) : materialColor;
    if (this.vertexColors === true && geometry.hasAttribute("color")) {
      colorNode = colorNode.mul(vertexColor());
    }
    if (object.instanceColor) {
      const instanceColor = varyingProperty("vec3", "vInstanceColor");
      colorNode = instanceColor.mul(colorNode);
    }
    if (object.isBatchedMesh && object._colorsTexture) {
      const batchColor = varyingProperty("vec3", "vBatchColor");
      colorNode = batchColor.mul(colorNode);
    }
    diffuseColor.assign(colorNode);
    const opacityNode = this.opacityNode ? float(this.opacityNode) : materialOpacity;
    diffuseColor.a.assign(diffuseColor.a.mul(opacityNode));
    let alphaTestNode = null;
    if (this.alphaTestNode !== null || this.alphaTest > 0) {
      alphaTestNode = this.alphaTestNode !== null ? float(this.alphaTestNode) : materialAlphaTest;
      if (this.alphaToCoverage === true) {
        diffuseColor.a = smoothstep2(alphaTestNode, alphaTestNode.add(fwidth(diffuseColor.a)), diffuseColor.a);
        diffuseColor.a.lessThanEqual(0).discard();
      } else {
        diffuseColor.a.lessThanEqual(alphaTestNode).discard();
      }
    }
    if (this.alphaHash === true) {
      diffuseColor.a.lessThan(getAlphaHashThreshold(positionLocal)).discard();
    }
    if (builder.isOpaque()) {
      diffuseColor.a.assign(1);
    }
  }
  /**
   * Abstract interface method that can be implemented by derived materials
   * to setup material-specific node variables.
   *
   * @abstract
   * @param {NodeBuilder} builder - The current node builder.
   */
  setupVariants() {
  }
  /**
   * Setups the outgoing light node variable
   *
   * @return {Node<vec3>} The outgoing light node.
   */
  setupOutgoingLight() {
    return this.lights === true ? vec3(0) : diffuseColor.rgb;
  }
  /**
   * Setups the normal node from the material.
   *
   * @return {Node<vec3>} The normal node.
   */
  setupNormal() {
    return this.normalNode ? vec3(this.normalNode) : materialNormal;
  }
  /**
   * Setups the environment node from the material.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec4>} The environment node.
   */
  setupEnvironment() {
    let node = null;
    if (this.envNode) {
      node = this.envNode;
    } else if (this.envMap) {
      node = this.envMap.isCubeTexture ? materialReference("envMap", "cubeTexture") : materialReference("envMap", "texture");
    }
    return node;
  }
  /**
   * Setups the light map node from the material.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec3>} The light map node.
   */
  setupLightMap(builder) {
    let node = null;
    if (builder.material.lightMap) {
      node = new IrradianceNode(materialLightMap);
    }
    return node;
  }
  /**
   * Setups the lights node based on the scene, environment and material.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {LightsNode} The lights node.
   */
  setupLights(builder) {
    const materialLightsNode = [];
    const envNode = this.setupEnvironment(builder);
    if (envNode && envNode.isLightingNode) {
      materialLightsNode.push(envNode);
    }
    const lightMapNode = this.setupLightMap(builder);
    if (lightMapNode && lightMapNode.isLightingNode) {
      materialLightsNode.push(lightMapNode);
    }
    let aoNode = this.aoNode;
    if (aoNode === null && builder.material.aoMap) {
      aoNode = materialAO;
    }
    if (builder.context.getAO) {
      aoNode = builder.context.getAO(aoNode, builder);
    }
    if (aoNode) {
      materialLightsNode.push(new AONode(aoNode));
    }
    let lightsN = this.lightsNode || builder.lightsNode;
    if (materialLightsNode.length > 0) {
      lightsN = builder.renderer.lighting.createNode([...lightsN.getLights(), ...materialLightsNode]);
    }
    return lightsN;
  }
  /**
   * This method should be implemented by most derived materials
   * since it defines the material's lighting model.
   *
   * @abstract
   * @param {NodeBuilder} builder - The current node builder.
   * @return {LightingModel} The lighting model.
   */
  setupLightingModel() {
  }
  /**
   * Setups the outgoing light node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec3>} The outgoing light node.
   */
  setupLighting(builder) {
    const { material } = builder;
    const { backdropNode, backdropAlphaNode, emissiveNode } = this;
    const lights2 = this.lights === true || this.lightsNode !== null;
    const lightsNode = lights2 ? this.setupLights(builder) : null;
    let outgoingLightNode = this.setupOutgoingLight(builder);
    if (lightsNode && lightsNode.getScope().hasLights) {
      const lightingModel = this.setupLightingModel(builder) || null;
      outgoingLightNode = lightingContext(lightsNode, lightingModel, backdropNode, backdropAlphaNode);
    } else if (backdropNode !== null) {
      outgoingLightNode = vec3(backdropAlphaNode !== null ? mix2(outgoingLightNode, backdropNode, backdropAlphaNode) : backdropNode);
    }
    if (emissiveNode && emissiveNode.isNode === true || material.emissive && material.emissive.isColor === true) {
      emissive.assign(vec3(emissiveNode ? emissiveNode : materialEmissive));
      outgoingLightNode = outgoingLightNode.add(emissive);
    }
    return outgoingLightNode;
  }
  /**
   * Setup the fog.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node<vec4>} outputNode - The existing output node.
   * @return {Node<vec4>} The output node.
   */
  setupFog(builder, outputNode) {
    const fogNode = builder.fogNode;
    if (fogNode) {
      output.assign(outputNode);
      outputNode = vec4(fogNode.toVar());
    }
    return outputNode;
  }
  /**
   * Setups premultiplied alpha.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node<vec4>} outputNode - The existing output node.
   * @return {Node<vec4>} The output node.
   */
  setupPremultipliedAlpha(builder, outputNode) {
    return premultiplyAlpha(outputNode);
  }
  /**
   * Setups the output node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node<vec4>} outputNode - The existing output node.
   * @return {Node<vec4>} The output node.
   */
  setupOutput(builder, outputNode) {
    if (this.fog === true) {
      outputNode = this.setupFog(builder, outputNode);
    }
    if (this.premultipliedAlpha === true) {
      outputNode = this.setupPremultipliedAlpha(builder, outputNode);
    }
    return outputNode;
  }
  /**
   * Most classic material types have a node pendant e.g. for `MeshBasicMaterial`
   * there is `MeshBasicNodeMaterial`. This utility method is intended for
   * defining all material properties of the classic type in the node type.
   *
   * @param {Material} material - The material to copy properties with their values to this node material.
   */
  setDefaultValues(material) {
    for (const property3 in material) {
      const value = material[property3];
      if (this[property3] === void 0) {
        this[property3] = value;
        if (value && value.clone) this[property3] = value.clone();
      }
    }
    const descriptors = Object.getOwnPropertyDescriptors(material.constructor.prototype);
    for (const key in descriptors) {
      if (Object.getOwnPropertyDescriptor(this.constructor.prototype, key) === void 0 && descriptors[key].get !== void 0) {
        Object.defineProperty(this.constructor.prototype, key, descriptors[key]);
      }
    }
  }
  /**
   * Serializes this material to JSON.
   *
   * @param {?(Object|string)} meta - The meta information for serialization.
   * @return {Object} The serialized node.
   */
  toJSON(meta) {
    const isRoot = meta === void 0 || typeof meta === "string";
    if (isRoot) {
      meta = {
        textures: {},
        images: {},
        nodes: {}
      };
    }
    const data = Material.prototype.toJSON.call(this, meta);
    data.inputNodes = {};
    for (const { property: property3, childNode } of this._getNodeChildren()) {
      data.inputNodes[property3] = childNode.toJSON(meta).uuid;
    }
    function extractFromCache(cache2) {
      const values2 = [];
      for (const key in cache2) {
        const data2 = cache2[key];
        delete data2.metadata;
        values2.push(data2);
      }
      return values2;
    }
    if (isRoot) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const nodes = extractFromCache(meta.nodes);
      if (textures.length > 0) data.textures = textures;
      if (images.length > 0) data.images = images;
      if (nodes.length > 0) data.nodes = nodes;
    }
    return data;
  }
  /**
   * Copies the properties of the given node material to this instance.
   *
   * @param {NodeMaterial} source - The material to copy.
   * @return {NodeMaterial} A reference to this node material.
   */
  copy(source) {
    this.lightsNode = source.lightsNode;
    this.envNode = source.envNode;
    this.aoNode = source.aoNode;
    this.colorNode = source.colorNode;
    this.normalNode = source.normalNode;
    this.opacityNode = source.opacityNode;
    this.backdropNode = source.backdropNode;
    this.backdropAlphaNode = source.backdropAlphaNode;
    this.alphaTestNode = source.alphaTestNode;
    this.maskNode = source.maskNode;
    this.positionNode = source.positionNode;
    this.geometryNode = source.geometryNode;
    this.depthNode = source.depthNode;
    this.receivedShadowPositionNode = source.receivedShadowPositionNode;
    this.castShadowPositionNode = source.castShadowPositionNode;
    this.receivedShadowNode = source.receivedShadowNode;
    this.castShadowNode = source.castShadowNode;
    this.outputNode = source.outputNode;
    this.mrtNode = source.mrtNode;
    this.fragmentNode = source.fragmentNode;
    this.vertexNode = source.vertexNode;
    this.contextNode = source.contextNode;
    return super.copy(source);
  }
};
var _defaultValues$d = new LineBasicMaterial();
var LineBasicNodeMaterial = class extends NodeMaterial {
  static get type() {
    return "LineBasicNodeMaterial";
  }
  /**
   * Constructs a new line basic node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(parameters) {
    super();
    this.isLineBasicNodeMaterial = true;
    this.setDefaultValues(_defaultValues$d);
    this.setValues(parameters);
  }
};
var _defaultValues$c = new LineDashedMaterial();
var LineDashedNodeMaterial = class extends NodeMaterial {
  static get type() {
    return "LineDashedNodeMaterial";
  }
  /**
   * Constructs a new line dashed node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(parameters) {
    super();
    this.isLineDashedNodeMaterial = true;
    this.setDefaultValues(_defaultValues$c);
    this.dashOffset = 0;
    this.offsetNode = null;
    this.dashScaleNode = null;
    this.dashSizeNode = null;
    this.gapSizeNode = null;
    this.setValues(parameters);
  }
  /**
   * Setups the dash specific node variables.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setupVariants() {
    const offsetNode = this.offsetNode ? float(this.offsetNode) : materialLineDashOffset;
    const dashScaleNode = this.dashScaleNode ? float(this.dashScaleNode) : materialLineScale;
    const dashSizeNode = this.dashSizeNode ? float(this.dashSizeNode) : materialLineDashSize;
    const gapSizeNode = this.gapSizeNode ? float(this.gapSizeNode) : materialLineGapSize;
    dashSize.assign(dashSizeNode);
    gapSize.assign(gapSizeNode);
    const vLineDistance = varying(attribute("lineDistance").mul(dashScaleNode));
    const vLineDistanceOffset = offsetNode ? vLineDistance.add(offsetNode) : vLineDistance;
    vLineDistanceOffset.mod(dashSize.add(gapSize)).greaterThan(dashSize).discard();
  }
};
var _sharedFramebuffer = null;
var ViewportSharedTextureNode = class extends ViewportTextureNode {
  static get type() {
    return "ViewportSharedTextureNode";
  }
  /**
   * Constructs a new viewport shared texture node.
   *
   * @param {Node} [uvNode=screenUV] - The uv node.
   * @param {?Node} [levelNode=null] - The level node.
   */
  constructor(uvNode = screenUV, levelNode = null) {
    if (_sharedFramebuffer === null) {
      _sharedFramebuffer = new FramebufferTexture();
    }
    super(uvNode, levelNode, _sharedFramebuffer);
  }
  /**
   * Overwritten so the method always returns the unique shared
   * framebuffer texture.
   *
   * @return {FramebufferTexture} The shared framebuffer texture.
   */
  getTextureForReference() {
    return _sharedFramebuffer;
  }
  updateReference() {
    return this;
  }
};
var viewportSharedTexture = nodeProxy(ViewportSharedTextureNode).setParameterLength(0, 2);
var _defaultValues$b = new LineDashedMaterial();
var _defaultValues$a = new MeshNormalMaterial();
var MeshNormalNodeMaterial = class extends NodeMaterial {
  static get type() {
    return "MeshNormalNodeMaterial";
  }
  /**
   * Constructs a new mesh normal node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(parameters) {
    super();
    this.isMeshNormalNodeMaterial = true;
    this.setDefaultValues(_defaultValues$a);
    this.setValues(parameters);
  }
  /**
   * Overwrites the default implementation by computing the diffuse color
   * based on the normal data.
   */
  setupDiffuseColor() {
    const opacityNode = this.opacityNode ? float(this.opacityNode) : materialOpacity;
    diffuseColor.assign(colorSpaceToWorking(vec4(directionToColor(normalView), opacityNode), SRGBColorSpace));
  }
};
var equirectUV = Fn(([dir = positionWorldDirection]) => {
  const u2 = dir.z.atan(dir.x).mul(1 / (Math.PI * 2)).add(0.5);
  const v2 = dir.y.clamp(-1, 1).asin().mul(1 / Math.PI).add(0.5);
  return vec2(u2, v2);
});
var CubeRenderTarget = class extends WebGLCubeRenderTarget {
  /**
   * Constructs a new cube render target.
   *
   * @param {number} [size=1] - The size of the render target.
   * @param {RenderTarget~Options} [options] - The configuration object.
   */
  constructor(size2 = 1, options = {}) {
    super(size2, options);
    this.isCubeRenderTarget = true;
  }
  /**
   * Converts the given equirectangular texture to a cube map.
   *
   * @param {Renderer} renderer - The renderer.
   * @param {Texture} texture - The equirectangular texture.
   * @return {CubeRenderTarget} A reference to this cube render target.
   */
  fromEquirectangularTexture(renderer3, texture$1) {
    const currentMinFilter = texture$1.minFilter;
    const currentGenerateMipmaps = texture$1.generateMipmaps;
    texture$1.generateMipmaps = true;
    this.texture.type = texture$1.type;
    this.texture.colorSpace = texture$1.colorSpace;
    this.texture.generateMipmaps = texture$1.generateMipmaps;
    this.texture.minFilter = texture$1.minFilter;
    this.texture.magFilter = texture$1.magFilter;
    const geometry = new BoxGeometry(5, 5, 5);
    const uvNode = equirectUV(positionWorldDirection);
    const material = new NodeMaterial();
    material.colorNode = texture(texture$1, uvNode, 0);
    material.side = BackSide;
    material.blending = NoBlending;
    const mesh = new Mesh(geometry, material);
    const scene3 = new Scene();
    scene3.add(mesh);
    if (texture$1.minFilter === LinearMipmapLinearFilter) texture$1.minFilter = LinearFilter;
    const camera3 = new CubeCamera(1, 10, this);
    const currentMRT = renderer3.getMRT();
    renderer3.setMRT(null);
    camera3.update(renderer3, scene3);
    renderer3.setMRT(currentMRT);
    texture$1.minFilter = currentMinFilter;
    texture$1.currentGenerateMipmaps = currentGenerateMipmaps;
    mesh.geometry.dispose();
    mesh.material.dispose();
    return this;
  }
};
var _cache$1 = /* @__PURE__ */ new WeakMap();
var CubeMapNode = class extends TempNode {
  static get type() {
    return "CubeMapNode";
  }
  /**
   * Constructs a new cube map node.
   *
   * @param {Node} envNode - The node representing the environment map.
   */
  constructor(envNode) {
    super("vec3");
    this.envNode = envNode;
    this._cubeTexture = null;
    this._cubeTextureNode = cubeTexture(null);
    const defaultTexture = new CubeTexture();
    defaultTexture.isRenderTargetTexture = true;
    this._defaultTexture = defaultTexture;
    this.updateBeforeType = NodeUpdateType.RENDER;
  }
  updateBefore(frame2) {
    const { renderer: renderer3, material } = frame2;
    const envNode = this.envNode;
    if (envNode.isTextureNode || envNode.isMaterialReferenceNode) {
      const texture2 = envNode.isTextureNode ? envNode.value : material[envNode.property];
      if (texture2 && texture2.isTexture) {
        const mapping = texture2.mapping;
        if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
          if (_cache$1.has(texture2)) {
            const cubeMap = _cache$1.get(texture2);
            mapTextureMapping(cubeMap, texture2.mapping);
            this._cubeTexture = cubeMap;
          } else {
            const image = texture2.image;
            if (isEquirectangularMapReady$1(image)) {
              const renderTarget = new CubeRenderTarget(image.height);
              renderTarget.fromEquirectangularTexture(renderer3, texture2);
              mapTextureMapping(renderTarget.texture, texture2.mapping);
              this._cubeTexture = renderTarget.texture;
              _cache$1.set(texture2, renderTarget.texture);
              texture2.addEventListener("dispose", onTextureDispose);
            } else {
              this._cubeTexture = this._defaultTexture;
            }
          }
          this._cubeTextureNode.value = this._cubeTexture;
        } else {
          this._cubeTextureNode = this.envNode;
        }
      }
    }
  }
  setup(builder) {
    this.updateBefore(builder);
    return this._cubeTextureNode;
  }
};
function isEquirectangularMapReady$1(image) {
  if (image === null || image === void 0) return false;
  return image.height > 0;
}
function onTextureDispose(event) {
  const texture2 = event.target;
  texture2.removeEventListener("dispose", onTextureDispose);
  const renderTarget = _cache$1.get(texture2);
  if (renderTarget !== void 0) {
    _cache$1.delete(texture2);
    renderTarget.dispose();
  }
}
function mapTextureMapping(texture2, mapping) {
  if (mapping === EquirectangularReflectionMapping) {
    texture2.mapping = CubeReflectionMapping;
  } else if (mapping === EquirectangularRefractionMapping) {
    texture2.mapping = CubeRefractionMapping;
  }
}
var cubeMapNode = nodeProxy(CubeMapNode).setParameterLength(1);
var BasicEnvironmentNode = class extends LightingNode {
  static get type() {
    return "BasicEnvironmentNode";
  }
  /**
   * Constructs a new basic environment node.
   *
   * @param {Node} [envNode=null] - A node representing the environment.
   */
  constructor(envNode = null) {
    super();
    this.envNode = envNode;
  }
  setup(builder) {
    builder.context.environment = cubeMapNode(this.envNode);
  }
};
var BasicLightMapNode = class extends LightingNode {
  static get type() {
    return "BasicLightMapNode";
  }
  /**
   * Constructs a new basic light map node.
   *
   * @param {?Node<vec3>} [lightMapNode=null] - The light map node.
   */
  constructor(lightMapNode = null) {
    super();
    this.lightMapNode = lightMapNode;
  }
  setup(builder) {
    const RECIPROCAL_PI2 = float(1 / Math.PI);
    builder.context.irradianceLightMap = this.lightMapNode.mul(RECIPROCAL_PI2);
  }
};
var LightingModel = class {
  /**
   * This method is intended for setting up lighting model and context data
   * which are later used in the evaluation process.
   *
   * @abstract
   * @param {NodeBuilder} builder - The current node builder.
   */
  start(builder) {
    builder.lightsNode.setupLights(builder, builder.lightsNode.getLightNodes(builder));
    this.indirect(builder);
  }
  /**
   * This method is intended for executing final tasks like final updates
   * to the outgoing light.
   *
   * @abstract
   * @param {NodeBuilder} builder - The current node builder.
   */
  finish() {
  }
  /**
   * This method is intended for implementing the direct light term and
   * executed during the build process of directional, point and spot light nodes.
   *
   * @abstract
   * @param {Object} lightData - The light data.
   * @param {NodeBuilder} builder - The current node builder.
   */
  direct() {
  }
  /**
   * This method is intended for implementing the direct light term for
   * rect area light nodes.
   *
   * @abstract
   * @param {Object} lightData - The light data.
   * @param {NodeBuilder} builder - The current node builder.
   */
  directRectArea() {
  }
  /**
   * This method is intended for implementing the indirect light term.
   *
   * @abstract
   * @param {NodeBuilder} builder - The current node builder.
   */
  indirect() {
  }
  /**
   * This method is intended for implementing the ambient occlusion term.
   * Unlike other methods, this method must be called manually by the lighting
   * model in its indirect term.
   *
   * @abstract
   * @param {NodeBuilder} builder - The current node builder.
   */
  ambientOcclusion() {
  }
};
var BasicLightingModel = class extends LightingModel {
  /**
   * Constructs a new basic lighting model.
   */
  constructor() {
    super();
  }
  /**
   * Implements the baked indirect lighting with its modulation.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  indirect({ context: context2 }) {
    const ambientOcclusion = context2.ambientOcclusion;
    const reflectedLight = context2.reflectedLight;
    const irradianceLightMap = context2.irradianceLightMap;
    reflectedLight.indirectDiffuse.assign(vec4(0));
    if (irradianceLightMap) {
      reflectedLight.indirectDiffuse.addAssign(irradianceLightMap);
    } else {
      reflectedLight.indirectDiffuse.addAssign(vec4(1, 1, 1, 0));
    }
    reflectedLight.indirectDiffuse.mulAssign(ambientOcclusion);
    reflectedLight.indirectDiffuse.mulAssign(diffuseColor.rgb);
  }
  /**
   * Implements the environment mapping.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  finish(builder) {
    const { material, context: context2 } = builder;
    const outgoingLight = context2.outgoingLight;
    const envNode = builder.context.environment;
    if (envNode) {
      switch (material.combine) {
        case MultiplyOperation:
          outgoingLight.rgb.assign(mix2(outgoingLight.rgb, outgoingLight.rgb.mul(envNode.rgb), materialSpecularStrength.mul(materialReflectivity)));
          break;
        case MixOperation:
          outgoingLight.rgb.assign(mix2(outgoingLight.rgb, envNode.rgb, materialSpecularStrength.mul(materialReflectivity)));
          break;
        case AddOperation:
          outgoingLight.rgb.addAssign(envNode.rgb.mul(materialSpecularStrength.mul(materialReflectivity)));
          break;
        default:
          warn("BasicLightingModel: Unsupported .combine value:", material.combine);
          break;
      }
    }
  }
};
var _defaultValues$9 = new MeshBasicMaterial();
var MeshBasicNodeMaterial = class extends NodeMaterial {
  static get type() {
    return "MeshBasicNodeMaterial";
  }
  /**
   * Constructs a new mesh basic node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(parameters) {
    super();
    this.isMeshBasicNodeMaterial = true;
    this.lights = true;
    this.setDefaultValues(_defaultValues$9);
    this.setValues(parameters);
  }
  /**
   * Basic materials are not affected by normal and bump maps so we
   * return by default {@link normalViewGeometry}.
   *
   * @return {Node<vec3>} The normal node.
   */
  setupNormal() {
    return directionToFaceDirection(normalViewGeometry);
  }
  /**
   * Overwritten since this type of material uses {@link BasicEnvironmentNode}
   * to implement the default environment mapping.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {?BasicEnvironmentNode<vec3>} The environment node.
   */
  setupEnvironment(builder) {
    const envNode = super.setupEnvironment(builder);
    return envNode ? new BasicEnvironmentNode(envNode) : null;
  }
  /**
   * This method must be overwritten since light maps are evaluated
   * with a special scaling factor for basic materials.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {?BasicLightMapNode<vec3>} The light map node.
   */
  setupLightMap(builder) {
    let node = null;
    if (builder.material.lightMap) {
      node = new BasicLightMapNode(materialLightMap);
    }
    return node;
  }
  /**
   * The material overwrites this method because `lights` is set to `true` but
   * we still want to return the diffuse color as the outgoing light.
   *
   * @return {Node<vec3>} The outgoing light node.
   */
  setupOutgoingLight() {
    return diffuseColor.rgb;
  }
  /**
   * Setups the lighting model.
   *
   * @return {BasicLightingModel} The lighting model.
   */
  setupLightingModel() {
    return new BasicLightingModel();
  }
};
var F_Schlick = Fn(({ f0, f90, dotVH }) => {
  const fresnel = dotVH.mul(-5.55473).sub(6.98316).mul(dotVH).exp2();
  return f0.mul(fresnel.oneMinus()).add(f90.mul(fresnel));
});
var BRDF_Lambert = Fn((inputs) => {
  return inputs.diffuseColor.mul(1 / Math.PI);
});
var G_BlinnPhong_Implicit = () => float(0.25);
var D_BlinnPhong = Fn(({ dotNH }) => {
  return shininess.mul(float(0.5)).add(1).mul(float(1 / Math.PI)).mul(dotNH.pow(shininess));
});
var BRDF_BlinnPhong = Fn(({ lightDirection }) => {
  const halfDir = lightDirection.add(positionViewDirection).normalize();
  const dotNH = normalView.dot(halfDir).clamp();
  const dotVH = positionViewDirection.dot(halfDir).clamp();
  const F2 = F_Schlick({ f0: specularColor, f90: 1, dotVH });
  const G2 = G_BlinnPhong_Implicit();
  const D3 = D_BlinnPhong({ dotNH });
  return F2.mul(G2).mul(D3);
});
var PhongLightingModel = class extends BasicLightingModel {
  /**
   * Constructs a new phong lighting model.
   *
   * @param {boolean} [specular=true] - Whether specular is supported or not.
   */
  constructor(specular = true) {
    super();
    this.specular = specular;
  }
  /**
   * Implements the direct lighting. The specular portion is optional an can be controlled
   * with the {@link PhongLightingModel#specular} flag.
   *
   * @param {Object} lightData - The light data.
   */
  direct({ lightDirection, lightColor, reflectedLight }) {
    const dotNL = normalView.dot(lightDirection).clamp();
    const irradiance = dotNL.mul(lightColor);
    reflectedLight.directDiffuse.addAssign(irradiance.mul(BRDF_Lambert({ diffuseColor: diffuseColor.rgb })));
    if (this.specular === true) {
      reflectedLight.directSpecular.addAssign(irradiance.mul(BRDF_BlinnPhong({ lightDirection })).mul(materialSpecularStrength));
    }
  }
  /**
   * Implements the indirect lighting.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  indirect(builder) {
    const { ambientOcclusion, irradiance, reflectedLight } = builder.context;
    reflectedLight.indirectDiffuse.addAssign(irradiance.mul(BRDF_Lambert({ diffuseColor })));
    reflectedLight.indirectDiffuse.mulAssign(ambientOcclusion);
  }
};
var _defaultValues$8 = new MeshLambertMaterial();
var MeshLambertNodeMaterial = class extends NodeMaterial {
  static get type() {
    return "MeshLambertNodeMaterial";
  }
  /**
   * Constructs a new mesh lambert node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(parameters) {
    super();
    this.isMeshLambertNodeMaterial = true;
    this.lights = true;
    this.setDefaultValues(_defaultValues$8);
    this.setValues(parameters);
  }
  /**
   * Overwritten since this type of material uses {@link BasicEnvironmentNode}
   * to implement the default environment mapping.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {?BasicEnvironmentNode<vec3>} The environment node.
   */
  setupEnvironment(builder) {
    const envNode = super.setupEnvironment(builder);
    return envNode ? new BasicEnvironmentNode(envNode) : null;
  }
  /**
   * Setups the lighting model.
   *
   * @return {PhongLightingModel} The lighting model.
   */
  setupLightingModel() {
    return new PhongLightingModel(false);
  }
};
var _defaultValues$7 = new MeshPhongMaterial();
var MeshPhongNodeMaterial = class extends NodeMaterial {
  static get type() {
    return "MeshPhongNodeMaterial";
  }
  /**
   * Constructs a new mesh lambert node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(parameters) {
    super();
    this.isMeshPhongNodeMaterial = true;
    this.lights = true;
    this.shininessNode = null;
    this.specularNode = null;
    this.setDefaultValues(_defaultValues$7);
    this.setValues(parameters);
  }
  /**
   * Overwritten since this type of material uses {@link BasicEnvironmentNode}
   * to implement the default environment mapping.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {?BasicEnvironmentNode<vec3>} The environment node.
   */
  setupEnvironment(builder) {
    const envNode = super.setupEnvironment(builder);
    return envNode ? new BasicEnvironmentNode(envNode) : null;
  }
  /**
   * Setups the lighting model.
   *
   * @return {PhongLightingModel} The lighting model.
   */
  setupLightingModel() {
    return new PhongLightingModel();
  }
  /**
   * Setups the phong specific node variables.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setupVariants() {
    const shininessNode = (this.shininessNode ? float(this.shininessNode) : materialShininess).max(1e-4);
    shininess.assign(shininessNode);
    const specularNode = this.specularNode || materialSpecular;
    specularColor.assign(specularNode);
  }
  copy(source) {
    this.shininessNode = source.shininessNode;
    this.specularNode = source.specularNode;
    return super.copy(source);
  }
};
var getGeometryRoughness = Fn((builder) => {
  if (builder.geometry.hasAttribute("normal") === false) {
    return float(0);
  }
  const dxy = normalViewGeometry.dFdx().abs().max(normalViewGeometry.dFdy().abs());
  const geometryRoughness = dxy.x.max(dxy.y).max(dxy.z);
  return geometryRoughness;
});
var getRoughness = Fn((inputs) => {
  const { roughness: roughness2 } = inputs;
  const geometryRoughness = getGeometryRoughness();
  let roughnessFactor = roughness2.max(0.0525);
  roughnessFactor = roughnessFactor.add(geometryRoughness);
  roughnessFactor = roughnessFactor.min(1);
  return roughnessFactor;
});
var V_GGX_SmithCorrelated = Fn(({ alpha, dotNL, dotNV }) => {
  const a22 = alpha.pow2();
  const gv = dotNL.mul(a22.add(a22.oneMinus().mul(dotNV.pow2())).sqrt());
  const gl = dotNV.mul(a22.add(a22.oneMinus().mul(dotNL.pow2())).sqrt());
  return div(0.5, gv.add(gl).max(EPSILON));
}).setLayout({
  name: "V_GGX_SmithCorrelated",
  type: "float",
  inputs: [
    { name: "alpha", type: "float" },
    { name: "dotNL", type: "float" },
    { name: "dotNV", type: "float" }
  ]
});
var V_GGX_SmithCorrelated_Anisotropic = Fn(({ alphaT: alphaT2, alphaB, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL }) => {
  const gv = dotNL.mul(vec3(alphaT2.mul(dotTV), alphaB.mul(dotBV), dotNV).length());
  const gl = dotNV.mul(vec3(alphaT2.mul(dotTL), alphaB.mul(dotBL), dotNL).length());
  const v2 = div(0.5, gv.add(gl));
  return v2;
}).setLayout({
  name: "V_GGX_SmithCorrelated_Anisotropic",
  type: "float",
  inputs: [
    { name: "alphaT", type: "float", qualifier: "in" },
    { name: "alphaB", type: "float", qualifier: "in" },
    { name: "dotTV", type: "float", qualifier: "in" },
    { name: "dotBV", type: "float", qualifier: "in" },
    { name: "dotTL", type: "float", qualifier: "in" },
    { name: "dotBL", type: "float", qualifier: "in" },
    { name: "dotNV", type: "float", qualifier: "in" },
    { name: "dotNL", type: "float", qualifier: "in" }
  ]
});
var D_GGX = Fn(({ alpha, dotNH }) => {
  const a22 = alpha.pow2();
  const denom = dotNH.pow2().mul(a22.oneMinus()).oneMinus();
  return a22.div(denom.pow2()).mul(1 / Math.PI);
}).setLayout({
  name: "D_GGX",
  type: "float",
  inputs: [
    { name: "alpha", type: "float" },
    { name: "dotNH", type: "float" }
  ]
});
var RECIPROCAL_PI = float(1 / Math.PI);
var D_GGX_Anisotropic = Fn(({ alphaT: alphaT2, alphaB, dotNH, dotTH, dotBH }) => {
  const a22 = alphaT2.mul(alphaB);
  const v2 = vec3(alphaB.mul(dotTH), alphaT2.mul(dotBH), a22.mul(dotNH));
  const v22 = v2.dot(v2);
  const w22 = a22.div(v22);
  return RECIPROCAL_PI.mul(a22.mul(w22.pow2()));
}).setLayout({
  name: "D_GGX_Anisotropic",
  type: "float",
  inputs: [
    { name: "alphaT", type: "float", qualifier: "in" },
    { name: "alphaB", type: "float", qualifier: "in" },
    { name: "dotNH", type: "float", qualifier: "in" },
    { name: "dotTH", type: "float", qualifier: "in" },
    { name: "dotBH", type: "float", qualifier: "in" }
  ]
});
var BRDF_GGX = Fn(({ lightDirection, f0, f90, roughness: roughness2, f: f3, normalView: normalView$1 = normalView, USE_IRIDESCENCE, USE_ANISOTROPY }) => {
  const alpha = roughness2.pow2();
  const halfDir = lightDirection.add(positionViewDirection).normalize();
  const dotNL = normalView$1.dot(lightDirection).clamp();
  const dotNV = normalView$1.dot(positionViewDirection).clamp();
  const dotNH = normalView$1.dot(halfDir).clamp();
  const dotVH = positionViewDirection.dot(halfDir).clamp();
  let F2 = F_Schlick({ f0, f90, dotVH });
  let V2, D3;
  if (defined(USE_IRIDESCENCE)) {
    F2 = iridescence.mix(F2, f3);
  }
  if (defined(USE_ANISOTROPY)) {
    const dotTL = anisotropyT.dot(lightDirection);
    const dotTV = anisotropyT.dot(positionViewDirection);
    const dotTH = anisotropyT.dot(halfDir);
    const dotBL = anisotropyB.dot(lightDirection);
    const dotBV = anisotropyB.dot(positionViewDirection);
    const dotBH = anisotropyB.dot(halfDir);
    V2 = V_GGX_SmithCorrelated_Anisotropic({ alphaT, alphaB: alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL });
    D3 = D_GGX_Anisotropic({ alphaT, alphaB: alpha, dotNH, dotTH, dotBH });
  } else {
    V2 = V_GGX_SmithCorrelated({ alpha, dotNL, dotNV });
    D3 = D_GGX({ alpha, dotNH });
  }
  return F2.mul(V2).mul(D3);
});
var DATA = new Uint16Array([
  12469,
  15057,
  12620,
  14925,
  13266,
  14620,
  13807,
  14376,
  14323,
  13990,
  14545,
  13625,
  14713,
  13328,
  14840,
  12882,
  14931,
  12528,
  14996,
  12233,
  15039,
  11829,
  15066,
  11525,
  15080,
  11295,
  15085,
  10976,
  15082,
  10705,
  15073,
  10495,
  13880,
  14564,
  13898,
  14542,
  13977,
  14430,
  14158,
  14124,
  14393,
  13732,
  14556,
  13410,
  14702,
  12996,
  14814,
  12596,
  14891,
  12291,
  14937,
  11834,
  14957,
  11489,
  14958,
  11194,
  14943,
  10803,
  14921,
  10506,
  14893,
  10278,
  14858,
  9960,
  14484,
  14039,
  14487,
  14025,
  14499,
  13941,
  14524,
  13740,
  14574,
  13468,
  14654,
  13106,
  14743,
  12678,
  14818,
  12344,
  14867,
  11893,
  14889,
  11509,
  14893,
  11180,
  14881,
  10751,
  14852,
  10428,
  14812,
  10128,
  14765,
  9754,
  14712,
  9466,
  14764,
  13480,
  14764,
  13475,
  14766,
  13440,
  14766,
  13347,
  14769,
  13070,
  14786,
  12713,
  14816,
  12387,
  14844,
  11957,
  14860,
  11549,
  14868,
  11215,
  14855,
  10751,
  14825,
  10403,
  14782,
  10044,
  14729,
  9651,
  14666,
  9352,
  14599,
  9029,
  14967,
  12835,
  14966,
  12831,
  14963,
  12804,
  14954,
  12723,
  14936,
  12564,
  14917,
  12347,
  14900,
  11958,
  14886,
  11569,
  14878,
  11247,
  14859,
  10765,
  14828,
  10401,
  14784,
  10011,
  14727,
  9600,
  14660,
  9289,
  14586,
  8893,
  14508,
  8533,
  15111,
  12234,
  15110,
  12234,
  15104,
  12216,
  15092,
  12156,
  15067,
  12010,
  15028,
  11776,
  14981,
  11500,
  14942,
  11205,
  14902,
  10752,
  14861,
  10393,
  14812,
  9991,
  14752,
  9570,
  14682,
  9252,
  14603,
  8808,
  14519,
  8445,
  14431,
  8145,
  15209,
  11449,
  15208,
  11451,
  15202,
  11451,
  15190,
  11438,
  15163,
  11384,
  15117,
  11274,
  15055,
  10979,
  14994,
  10648,
  14932,
  10343,
  14871,
  9936,
  14803,
  9532,
  14729,
  9218,
  14645,
  8742,
  14556,
  8381,
  14461,
  8020,
  14365,
  7603,
  15273,
  10603,
  15272,
  10607,
  15267,
  10619,
  15256,
  10631,
  15231,
  10614,
  15182,
  10535,
  15118,
  10389,
  15042,
  10167,
  14963,
  9787,
  14883,
  9447,
  14800,
  9115,
  14710,
  8665,
  14615,
  8318,
  14514,
  7911,
  14411,
  7507,
  14279,
  7198,
  15314,
  9675,
  15313,
  9683,
  15309,
  9712,
  15298,
  9759,
  15277,
  9797,
  15229,
  9773,
  15166,
  9668,
  15084,
  9487,
  14995,
  9274,
  14898,
  8910,
  14800,
  8539,
  14697,
  8234,
  14590,
  7790,
  14479,
  7409,
  14367,
  7067,
  14178,
  6621,
  15337,
  8619,
  15337,
  8631,
  15333,
  8677,
  15325,
  8769,
  15305,
  8871,
  15264,
  8940,
  15202,
  8909,
  15119,
  8775,
  15022,
  8565,
  14916,
  8328,
  14804,
  8009,
  14688,
  7614,
  14569,
  7287,
  14448,
  6888,
  14321,
  6483,
  14088,
  6171,
  15350,
  7402,
  15350,
  7419,
  15347,
  7480,
  15340,
  7613,
  15322,
  7804,
  15287,
  7973,
  15229,
  8057,
  15148,
  8012,
  15046,
  7846,
  14933,
  7611,
  14810,
  7357,
  14682,
  7069,
  14552,
  6656,
  14421,
  6316,
  14251,
  5948,
  14007,
  5528,
  15356,
  5942,
  15356,
  5977,
  15353,
  6119,
  15348,
  6294,
  15332,
  6551,
  15302,
  6824,
  15249,
  7044,
  15171,
  7122,
  15070,
  7050,
  14949,
  6861,
  14818,
  6611,
  14679,
  6349,
  14538,
  6067,
  14398,
  5651,
  14189,
  5311,
  13935,
  4958,
  15359,
  4123,
  15359,
  4153,
  15356,
  4296,
  15353,
  4646,
  15338,
  5160,
  15311,
  5508,
  15263,
  5829,
  15188,
  6042,
  15088,
  6094,
  14966,
  6001,
  14826,
  5796,
  14678,
  5543,
  14527,
  5287,
  14377,
  4985,
  14133,
  4586,
  13869,
  4257,
  15360,
  1563,
  15360,
  1642,
  15358,
  2076,
  15354,
  2636,
  15341,
  3350,
  15317,
  4019,
  15273,
  4429,
  15203,
  4732,
  15105,
  4911,
  14981,
  4932,
  14836,
  4818,
  14679,
  4621,
  14517,
  4386,
  14359,
  4156,
  14083,
  3795,
  13808,
  3437,
  15360,
  122,
  15360,
  137,
  15358,
  285,
  15355,
  636,
  15344,
  1274,
  15322,
  2177,
  15281,
  2765,
  15215,
  3223,
  15120,
  3451,
  14995,
  3569,
  14846,
  3567,
  14681,
  3466,
  14511,
  3305,
  14344,
  3121,
  14037,
  2800,
  13753,
  2467,
  15360,
  0,
  15360,
  1,
  15359,
  21,
  15355,
  89,
  15346,
  253,
  15325,
  479,
  15287,
  796,
  15225,
  1148,
  15133,
  1492,
  15008,
  1749,
  14856,
  1882,
  14685,
  1886,
  14506,
  1783,
  14324,
  1608,
  13996,
  1398,
  13702,
  1183
]);
var lut = null;
var DFGLUT = Fn(({ roughness: roughness2, dotNV }) => {
  if (lut === null) {
    lut = new DataTexture(DATA, 16, 16, RGFormat, HalfFloatType);
    lut.name = "DFG_LUT";
    lut.minFilter = LinearFilter;
    lut.magFilter = LinearFilter;
    lut.wrapS = ClampToEdgeWrapping;
    lut.wrapT = ClampToEdgeWrapping;
    lut.generateMipmaps = false;
    lut.needsUpdate = true;
  }
  const uv2 = vec2(roughness2, dotNV);
  return texture(lut, uv2).rg;
});
var BRDF_GGX_Multiscatter = Fn(({ lightDirection, f0, f90, roughness: _roughness, f: f3, USE_IRIDESCENCE, USE_ANISOTROPY }) => {
  const singleScatter = BRDF_GGX({ lightDirection, f0, f90, roughness: _roughness, f: f3, USE_IRIDESCENCE, USE_ANISOTROPY });
  const dotNL = normalView.dot(lightDirection).clamp();
  const dotNV = normalView.dot(positionViewDirection).clamp();
  const dfgV = DFGLUT({ roughness: _roughness, dotNV });
  const dfgL = DFGLUT({ roughness: _roughness, dotNV: dotNL });
  const FssEss_V = f0.mul(dfgV.x).add(f90.mul(dfgV.y));
  const FssEss_L = f0.mul(dfgL.x).add(f90.mul(dfgL.y));
  const Ess_V = dfgV.x.add(dfgV.y);
  const Ess_L = dfgL.x.add(dfgL.y);
  const Ems_V = float(1).sub(Ess_V);
  const Ems_L = float(1).sub(Ess_L);
  const Favg = f0.add(f0.oneMinus().mul(0.047619));
  const Fms = FssEss_V.mul(FssEss_L).mul(Favg).div(float(1).sub(Ems_V.mul(Ems_L).mul(Favg).mul(Favg)).add(EPSILON));
  const compensationFactor = Ems_V.mul(Ems_L);
  const multiScatter = Fms.mul(compensationFactor);
  return singleScatter.add(multiScatter);
});
var EnvironmentBRDF = Fn((inputs) => {
  const { dotNV, specularColor: specularColor2, specularF90: specularF902, roughness: roughness2 } = inputs;
  const fab = DFGLUT({ dotNV, roughness: roughness2 });
  return specularColor2.mul(fab.x).add(specularF902.mul(fab.y));
});
var Schlick_to_F0 = Fn(({ f: f3, f90, dotVH }) => {
  const x3 = dotVH.oneMinus().saturate();
  const x22 = x3.mul(x3);
  const x5 = x3.mul(x22, x22).clamp(0, 0.9999);
  return f3.sub(vec3(f90).mul(x5)).div(x5.oneMinus());
}).setLayout({
  name: "Schlick_to_F0",
  type: "vec3",
  inputs: [
    { name: "f", type: "vec3" },
    { name: "f90", type: "float" },
    { name: "dotVH", type: "float" }
  ]
});
var D_Charlie = Fn(({ roughness: roughness2, dotNH }) => {
  const alpha = roughness2.pow2();
  const invAlpha = float(1).div(alpha);
  const cos2h = dotNH.pow2();
  const sin2h = cos2h.oneMinus().max(78125e-7);
  return float(2).add(invAlpha).mul(sin2h.pow(invAlpha.mul(0.5))).div(2 * Math.PI);
}).setLayout({
  name: "D_Charlie",
  type: "float",
  inputs: [
    { name: "roughness", type: "float" },
    { name: "dotNH", type: "float" }
  ]
});
var V_Neubelt = Fn(({ dotNV, dotNL }) => {
  return float(1).div(float(4).mul(dotNL.add(dotNV).sub(dotNL.mul(dotNV))));
}).setLayout({
  name: "V_Neubelt",
  type: "float",
  inputs: [
    { name: "dotNV", type: "float" },
    { name: "dotNL", type: "float" }
  ]
});
var BRDF_Sheen = Fn(({ lightDirection }) => {
  const halfDir = lightDirection.add(positionViewDirection).normalize();
  const dotNL = normalView.dot(lightDirection).clamp();
  const dotNV = normalView.dot(positionViewDirection).clamp();
  const dotNH = normalView.dot(halfDir).clamp();
  const D3 = D_Charlie({ roughness: sheenRoughness, dotNH });
  const V2 = V_Neubelt({ dotNV, dotNL });
  return sheen.mul(D3).mul(V2);
});
var LTC_Uv = Fn(({ N: N3, V: V2, roughness: roughness2 }) => {
  const LUT_SIZE = 64;
  const LUT_SCALE = (LUT_SIZE - 1) / LUT_SIZE;
  const LUT_BIAS = 0.5 / LUT_SIZE;
  const dotNV = N3.dot(V2).saturate();
  const uv2 = vec2(roughness2, dotNV.oneMinus().sqrt());
  uv2.assign(uv2.mul(LUT_SCALE).add(LUT_BIAS));
  return uv2;
}).setLayout({
  name: "LTC_Uv",
  type: "vec2",
  inputs: [
    { name: "N", type: "vec3" },
    { name: "V", type: "vec3" },
    { name: "roughness", type: "float" }
  ]
});
var LTC_ClippedSphereFormFactor = Fn(({ f: f3 }) => {
  const l2 = f3.length();
  return max$1(l2.mul(l2).add(f3.z).div(l2.add(1)), 0);
}).setLayout({
  name: "LTC_ClippedSphereFormFactor",
  type: "float",
  inputs: [
    { name: "f", type: "vec3" }
  ]
});
var LTC_EdgeVectorFormFactor = Fn(({ v1, v2 }) => {
  const x3 = v1.dot(v2);
  const y3 = x3.abs().toVar();
  const a3 = y3.mul(0.0145206).add(0.4965155).mul(y3).add(0.8543985).toVar();
  const b = y3.add(4.1616724).mul(y3).add(3.417594).toVar();
  const v3 = a3.div(b);
  const theta_sintheta = x3.greaterThan(0).select(v3, max$1(x3.mul(x3).oneMinus(), 1e-7).inverseSqrt().mul(0.5).sub(v3));
  return v1.cross(v2).mul(theta_sintheta);
}).setLayout({
  name: "LTC_EdgeVectorFormFactor",
  type: "vec3",
  inputs: [
    { name: "v1", type: "vec3" },
    { name: "v2", type: "vec3" }
  ]
});
var LTC_Evaluate = Fn(({ N: N3, V: V2, P: P2, mInv, p0, p1, p2: p22, p3 }) => {
  const v1 = p1.sub(p0).toVar();
  const v2 = p3.sub(p0).toVar();
  const lightNormal = v1.cross(v2);
  const result2 = vec3().toVar();
  If(lightNormal.dot(P2.sub(p0)).greaterThanEqual(0), () => {
    const T1 = V2.sub(N3.mul(V2.dot(N3))).normalize();
    const T22 = N3.cross(T1).negate();
    const mat = mInv.mul(mat3(T1, T22, N3).transpose()).toVar();
    const coords0 = mat.mul(p0.sub(P2)).normalize().toVar();
    const coords1 = mat.mul(p1.sub(P2)).normalize().toVar();
    const coords2 = mat.mul(p22.sub(P2)).normalize().toVar();
    const coords3 = mat.mul(p3.sub(P2)).normalize().toVar();
    const vectorFormFactor = vec3(0).toVar();
    vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({ v1: coords0, v2: coords1 }));
    vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({ v1: coords1, v2: coords2 }));
    vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({ v1: coords2, v2: coords3 }));
    vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({ v1: coords3, v2: coords0 }));
    result2.assign(vec3(LTC_ClippedSphereFormFactor({ f: vectorFormFactor })));
  });
  return result2;
}).setLayout({
  name: "LTC_Evaluate",
  type: "vec3",
  inputs: [
    { name: "N", type: "vec3" },
    { name: "V", type: "vec3" },
    { name: "P", type: "vec3" },
    { name: "mInv", type: "mat3" },
    { name: "p0", type: "vec3" },
    { name: "p1", type: "vec3" },
    { name: "p2", type: "vec3" },
    { name: "p3", type: "vec3" }
  ]
});
var LTC_Evaluate_Volume = Fn(({ P: P2, p0, p1, p2: p22, p3 }) => {
  const v1 = p1.sub(p0).toVar();
  const v2 = p3.sub(p0).toVar();
  const lightNormal = v1.cross(v2);
  const result2 = vec3().toVar();
  If(lightNormal.dot(P2.sub(p0)).greaterThanEqual(0), () => {
    const coords0 = p0.sub(P2).normalize().toVar();
    const coords1 = p1.sub(P2).normalize().toVar();
    const coords2 = p22.sub(P2).normalize().toVar();
    const coords3 = p3.sub(P2).normalize().toVar();
    const vectorFormFactor = vec3(0).toVar();
    vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({ v1: coords0, v2: coords1 }));
    vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({ v1: coords1, v2: coords2 }));
    vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({ v1: coords2, v2: coords3 }));
    vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({ v1: coords3, v2: coords0 }));
    result2.assign(vec3(LTC_ClippedSphereFormFactor({ f: vectorFormFactor.abs() })));
  });
  return result2;
}).setLayout({
  name: "LTC_Evaluate",
  type: "vec3",
  inputs: [
    { name: "P", type: "vec3" },
    { name: "p0", type: "vec3" },
    { name: "p1", type: "vec3" },
    { name: "p2", type: "vec3" },
    { name: "p3", type: "vec3" }
  ]
});
var bC = 1 / 6;
var w0 = (a3) => mul(bC, mul(a3, mul(a3, a3.negate().add(3)).sub(3)).add(1));
var w1 = (a3) => mul(bC, mul(a3, mul(a3, mul(3, a3).sub(6))).add(4));
var w2 = (a3) => mul(bC, mul(a3, mul(a3, mul(-3, a3).add(3)).add(3)).add(1));
var w3 = (a3) => mul(bC, pow2(a3, 3));
var g0 = (a3) => w0(a3).add(w1(a3));
var g1 = (a3) => w2(a3).add(w3(a3));
var h0 = (a3) => add4(-1, w1(a3).div(w0(a3).add(w1(a3))));
var h1 = (a3) => add4(1, w3(a3).div(w2(a3).add(w3(a3))));
var bicubic = (textureNode, texelSize, lod) => {
  const uv2 = textureNode.uvNode;
  const uvScaled = mul(uv2, texelSize.zw).add(0.5);
  const iuv = floor(uvScaled);
  const fuv = fract(uvScaled);
  const g0x = g0(fuv.x);
  const g1x = g1(fuv.x);
  const h0x = h0(fuv.x);
  const h1x = h1(fuv.x);
  const h0y = h0(fuv.y);
  const h1y = h1(fuv.y);
  const p0 = vec2(iuv.x.add(h0x), iuv.y.add(h0y)).sub(0.5).mul(texelSize.xy);
  const p1 = vec2(iuv.x.add(h1x), iuv.y.add(h0y)).sub(0.5).mul(texelSize.xy);
  const p22 = vec2(iuv.x.add(h0x), iuv.y.add(h1y)).sub(0.5).mul(texelSize.xy);
  const p3 = vec2(iuv.x.add(h1x), iuv.y.add(h1y)).sub(0.5).mul(texelSize.xy);
  const a3 = g0(fuv.y).mul(add4(g0x.mul(textureNode.sample(p0).level(lod)), g1x.mul(textureNode.sample(p1).level(lod))));
  const b = g1(fuv.y).mul(add4(g0x.mul(textureNode.sample(p22).level(lod)), g1x.mul(textureNode.sample(p3).level(lod))));
  return a3.add(b);
};
var textureBicubicLevel = Fn(([textureNode, lodNode]) => {
  const fLodSize = vec2(textureNode.size(int(lodNode)));
  const cLodSize = vec2(textureNode.size(int(lodNode.add(1))));
  const fLodSizeInv = div(1, fLodSize);
  const cLodSizeInv = div(1, cLodSize);
  const fSample = bicubic(textureNode, vec4(fLodSizeInv, fLodSize), floor(lodNode));
  const cSample = bicubic(textureNode, vec4(cLodSizeInv, cLodSize), ceil(lodNode));
  return fract(lodNode).mix(fSample, cSample);
});
var textureBicubic = Fn(([textureNode, strength]) => {
  const lod = strength.mul(maxMipLevel(textureNode));
  return textureBicubicLevel(textureNode, lod);
});
var getVolumeTransmissionRay = Fn(([n2, v2, thickness2, ior2, modelMatrix]) => {
  const refractionVector = vec3(refract(v2.negate(), normalize2(n2), div(1, ior2)));
  const modelScale2 = vec3(
    length(modelMatrix[0].xyz),
    length(modelMatrix[1].xyz),
    length(modelMatrix[2].xyz)
  );
  return normalize2(refractionVector).mul(thickness2.mul(modelScale2));
}).setLayout({
  name: "getVolumeTransmissionRay",
  type: "vec3",
  inputs: [
    { name: "n", type: "vec3" },
    { name: "v", type: "vec3" },
    { name: "thickness", type: "float" },
    { name: "ior", type: "float" },
    { name: "modelMatrix", type: "mat4" }
  ]
});
var applyIorToRoughness = Fn(([roughness2, ior2]) => {
  return roughness2.mul(clamp3(ior2.mul(2).sub(2), 0, 1));
}).setLayout({
  name: "applyIorToRoughness",
  type: "float",
  inputs: [
    { name: "roughness", type: "float" },
    { name: "ior", type: "float" }
  ]
});
var viewportBackSideTexture = viewportMipTexture();
var viewportFrontSideTexture = viewportMipTexture();
var getTransmissionSample = Fn(([fragCoord, roughness2, ior2], { material }) => {
  const vTexture = material.side === BackSide ? viewportBackSideTexture : viewportFrontSideTexture;
  const transmissionSample = vTexture.sample(fragCoord);
  const lod = log22(screenSize.x).mul(applyIorToRoughness(roughness2, ior2));
  return textureBicubicLevel(transmissionSample, lod);
});
var volumeAttenuation = Fn(([transmissionDistance, attenuationColor2, attenuationDistance2]) => {
  If(attenuationDistance2.notEqual(0), () => {
    const attenuationCoefficient = log3(attenuationColor2).negate().div(attenuationDistance2);
    const transmittance = exp(attenuationCoefficient.negate().mul(transmissionDistance));
    return transmittance;
  });
  return vec3(1);
}).setLayout({
  name: "volumeAttenuation",
  type: "vec3",
  inputs: [
    { name: "transmissionDistance", type: "float" },
    { name: "attenuationColor", type: "vec3" },
    { name: "attenuationDistance", type: "float" }
  ]
});
var getIBLVolumeRefraction = Fn(([n2, v2, roughness2, diffuseColor2, specularColor2, specularF902, position, modelMatrix, viewMatrix, projMatrix, ior2, thickness2, attenuationColor2, attenuationDistance2, dispersion2]) => {
  let transmittedLight, transmittance;
  if (dispersion2) {
    transmittedLight = vec4().toVar();
    transmittance = vec3().toVar();
    const halfSpread = ior2.sub(1).mul(dispersion2.mul(0.025));
    const iors = vec3(ior2.sub(halfSpread), ior2, ior2.add(halfSpread));
    Loop({ start: 0, end: 3 }, ({ i: i2 }) => {
      const ior3 = iors.element(i2);
      const transmissionRay = getVolumeTransmissionRay(n2, v2, thickness2, ior3, modelMatrix);
      const refractedRayExit = position.add(transmissionRay);
      const ndcPos = projMatrix.mul(viewMatrix.mul(vec4(refractedRayExit, 1)));
      const refractionCoords = vec2(ndcPos.xy.div(ndcPos.w)).toVar();
      refractionCoords.addAssign(1);
      refractionCoords.divAssign(2);
      refractionCoords.assign(vec2(refractionCoords.x, refractionCoords.y.oneMinus()));
      const transmissionSample = getTransmissionSample(refractionCoords, roughness2, ior3);
      transmittedLight.element(i2).assign(transmissionSample.element(i2));
      transmittedLight.a.addAssign(transmissionSample.a);
      transmittance.element(i2).assign(diffuseColor2.element(i2).mul(volumeAttenuation(length(transmissionRay), attenuationColor2, attenuationDistance2).element(i2)));
    });
    transmittedLight.a.divAssign(3);
  } else {
    const transmissionRay = getVolumeTransmissionRay(n2, v2, thickness2, ior2, modelMatrix);
    const refractedRayExit = position.add(transmissionRay);
    const ndcPos = projMatrix.mul(viewMatrix.mul(vec4(refractedRayExit, 1)));
    const refractionCoords = vec2(ndcPos.xy.div(ndcPos.w)).toVar();
    refractionCoords.addAssign(1);
    refractionCoords.divAssign(2);
    refractionCoords.assign(vec2(refractionCoords.x, refractionCoords.y.oneMinus()));
    transmittedLight = getTransmissionSample(refractionCoords, roughness2, ior2);
    transmittance = diffuseColor2.mul(volumeAttenuation(length(transmissionRay), attenuationColor2, attenuationDistance2));
  }
  const attenuatedColor = transmittance.rgb.mul(transmittedLight.rgb);
  const dotNV = n2.dot(v2).clamp();
  const F2 = vec3(EnvironmentBRDF({
    // n, v, specularColor, specularF90, roughness
    dotNV,
    specularColor: specularColor2,
    specularF90: specularF902,
    roughness: roughness2
  }));
  const transmittanceFactor = transmittance.r.add(transmittance.g, transmittance.b).div(3);
  return vec4(F2.oneMinus().mul(attenuatedColor), transmittedLight.a.oneMinus().mul(transmittanceFactor).oneMinus());
});
var XYZ_TO_REC709 = mat3(
  3.2404542,
  -0.969266,
  0.0556434,
  -1.5371385,
  1.8760108,
  -0.2040259,
  -0.4985314,
  0.041556,
  1.0572252
);
var Fresnel0ToIor = (fresnel0) => {
  const sqrtF0 = fresnel0.sqrt();
  return vec3(1).add(sqrtF0).div(vec3(1).sub(sqrtF0));
};
var IorToFresnel0 = (transmittedIor, incidentIor) => {
  return transmittedIor.sub(incidentIor).div(transmittedIor.add(incidentIor)).pow2();
};
var evalSensitivity = (OPD, shift) => {
  const phase = OPD.mul(2 * Math.PI * 1e-9);
  const val = vec3(54856e-17, 44201e-17, 52481e-17);
  const pos = vec3(1681e3, 1795300, 2208400);
  const VAR = vec3(43278e5, 93046e5, 66121e5);
  const x3 = float(9747e-17 * Math.sqrt(2 * Math.PI * 45282e5)).mul(phase.mul(2239900).add(shift.x).cos()).mul(phase.pow2().mul(-45282e5).exp());
  let xyz = val.mul(VAR.mul(2 * Math.PI).sqrt()).mul(pos.mul(phase).add(shift).cos()).mul(phase.pow2().negate().mul(VAR).exp());
  xyz = vec3(xyz.x.add(x3), xyz.y, xyz.z).div(10685e-11);
  const rgb3 = XYZ_TO_REC709.mul(xyz);
  return rgb3;
};
var evalIridescence = Fn(({ outsideIOR, eta2, cosTheta1, thinFilmThickness, baseF0 }) => {
  const iridescenceIOR2 = mix2(outsideIOR, eta2, smoothstep2(0, 0.03, thinFilmThickness));
  const sinTheta2Sq = outsideIOR.div(iridescenceIOR2).pow2().mul(cosTheta1.pow2().oneMinus());
  const cosTheta2Sq = sinTheta2Sq.oneMinus();
  If(cosTheta2Sq.lessThan(0), () => {
    return vec3(1);
  });
  const cosTheta2 = cosTheta2Sq.sqrt();
  const R0 = IorToFresnel0(iridescenceIOR2, outsideIOR);
  const R12 = F_Schlick({ f0: R0, f90: 1, dotVH: cosTheta1 });
  const T121 = R12.oneMinus();
  const phi12 = iridescenceIOR2.lessThan(outsideIOR).select(Math.PI, 0);
  const phi21 = float(Math.PI).sub(phi12);
  const baseIOR = Fresnel0ToIor(baseF0.clamp(0, 0.9999));
  const R1 = IorToFresnel0(baseIOR, iridescenceIOR2.toVec3());
  const R23 = F_Schlick({ f0: R1, f90: 1, dotVH: cosTheta2 });
  const phi23 = vec3(
    baseIOR.x.lessThan(iridescenceIOR2).select(Math.PI, 0),
    baseIOR.y.lessThan(iridescenceIOR2).select(Math.PI, 0),
    baseIOR.z.lessThan(iridescenceIOR2).select(Math.PI, 0)
  );
  const OPD = iridescenceIOR2.mul(thinFilmThickness, cosTheta2, 2);
  const phi = vec3(phi21).add(phi23);
  const R123 = R12.mul(R23).clamp(1e-5, 0.9999);
  const r123 = R123.sqrt();
  const Rs = T121.pow2().mul(R23).div(vec3(1).sub(R123));
  const C0 = R12.add(Rs);
  const I2 = C0.toVar();
  const Cm = Rs.sub(T121).toVar();
  Loop({ start: 1, end: 2, condition: "<=", name: "m" }, ({ m: m3 }) => {
    Cm.mulAssign(r123);
    const Sm = evalSensitivity(float(m3).mul(OPD), float(m3).mul(phi)).mul(2);
    I2.addAssign(Cm.mul(Sm));
  });
  return I2.max(vec3(0));
}).setLayout({
  name: "evalIridescence",
  type: "vec3",
  inputs: [
    { name: "outsideIOR", type: "float" },
    { name: "eta2", type: "float" },
    { name: "cosTheta1", type: "float" },
    { name: "thinFilmThickness", type: "float" },
    { name: "baseF0", type: "vec3" }
  ]
});
var IBLSheenBRDF = Fn(({ normal: normal2, viewDir, roughness: roughness2 }) => {
  const dotNV = normal2.dot(viewDir).saturate();
  const r2 = roughness2.mul(roughness2);
  const rInv = roughness2.add(0.1).reciprocal();
  const a3 = float(-1.9362).add(roughness2.mul(1.0678)).add(r2.mul(0.4573)).sub(rInv.mul(0.8469));
  const b = float(-0.6014).add(roughness2.mul(0.5538)).sub(r2.mul(0.467)).sub(rInv.mul(0.1255));
  const DG = a3.mul(dotNV).add(b).exp();
  return DG.saturate();
});
var clearcoatF0 = vec3(0.04);
var clearcoatF90 = float(1);
var PhysicalLightingModel = class extends LightingModel {
  /**
   * Constructs a new physical lighting model.
   *
   * @param {boolean} [clearcoat=false] - Whether clearcoat is supported or not.
   * @param {boolean} [sheen=false] - Whether sheen is supported or not.
   * @param {boolean} [iridescence=false] - Whether iridescence is supported or not.
   * @param {boolean} [anisotropy=false] - Whether anisotropy is supported or not.
   * @param {boolean} [transmission=false] - Whether transmission is supported or not.
   * @param {boolean} [dispersion=false] - Whether dispersion is supported or not.
   */
  constructor(clearcoat2 = false, sheen2 = false, iridescence2 = false, anisotropy2 = false, transmission2 = false, dispersion2 = false) {
    super();
    this.clearcoat = clearcoat2;
    this.sheen = sheen2;
    this.iridescence = iridescence2;
    this.anisotropy = anisotropy2;
    this.transmission = transmission2;
    this.dispersion = dispersion2;
    this.clearcoatRadiance = null;
    this.clearcoatSpecularDirect = null;
    this.clearcoatSpecularIndirect = null;
    this.sheenSpecularDirect = null;
    this.sheenSpecularIndirect = null;
    this.iridescenceFresnel = null;
    this.iridescenceF0 = null;
    this.iridescenceF0Dielectric = null;
    this.iridescenceF0Metallic = null;
  }
  /**
   * Depending on what features are requested, the method prepares certain node variables
   * which are later used for lighting computations.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  start(builder) {
    if (this.clearcoat === true) {
      this.clearcoatRadiance = vec3().toVar("clearcoatRadiance");
      this.clearcoatSpecularDirect = vec3().toVar("clearcoatSpecularDirect");
      this.clearcoatSpecularIndirect = vec3().toVar("clearcoatSpecularIndirect");
    }
    if (this.sheen === true) {
      this.sheenSpecularDirect = vec3().toVar("sheenSpecularDirect");
      this.sheenSpecularIndirect = vec3().toVar("sheenSpecularIndirect");
    }
    if (this.iridescence === true) {
      const dotNVi = normalView.dot(positionViewDirection).clamp();
      const iridescenceFresnelDielectric = evalIridescence({
        outsideIOR: float(1),
        eta2: iridescenceIOR,
        cosTheta1: dotNVi,
        thinFilmThickness: iridescenceThickness,
        baseF0: specularColor
      });
      const iridescenceFresnelMetallic = evalIridescence({
        outsideIOR: float(1),
        eta2: iridescenceIOR,
        cosTheta1: dotNVi,
        thinFilmThickness: iridescenceThickness,
        baseF0: diffuseColor.rgb
      });
      this.iridescenceFresnel = mix2(iridescenceFresnelDielectric, iridescenceFresnelMetallic, metalness);
      this.iridescenceF0Dielectric = Schlick_to_F0({ f: iridescenceFresnelDielectric, f90: 1, dotVH: dotNVi });
      this.iridescenceF0Metallic = Schlick_to_F0({ f: iridescenceFresnelMetallic, f90: 1, dotVH: dotNVi });
      this.iridescenceF0 = mix2(this.iridescenceF0Dielectric, this.iridescenceF0Metallic, metalness);
    }
    if (this.transmission === true) {
      const position = positionWorld;
      const v2 = cameraPosition.sub(positionWorld).normalize();
      const n2 = normalWorld;
      const context2 = builder.context;
      context2.backdrop = getIBLVolumeRefraction(
        n2,
        v2,
        roughness,
        diffuseContribution,
        specularColorBlended,
        specularF90,
        // specularF90
        position,
        // positionWorld
        modelWorldMatrix,
        // modelMatrix
        cameraViewMatrix,
        // viewMatrix
        cameraProjectionMatrix,
        // projMatrix
        ior,
        thickness,
        attenuationColor,
        attenuationDistance,
        this.dispersion ? dispersion : null
      );
      context2.backdropAlpha = transmission;
      diffuseColor.a.mulAssign(mix2(1, context2.backdrop.a, transmission));
    }
    super.start(builder);
  }
  // Fdez-AgÃ¼era's "Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting"
  // Approximates multi-scattering in order to preserve energy.
  // http://www.jcgt.org/published/0008/01/03/
  computeMultiscattering(singleScatter, multiScatter, specularF902, f0, iridescenceF0 = null) {
    const dotNV = normalView.dot(positionViewDirection).clamp();
    const fab = DFGLUT({ roughness, dotNV });
    const Fr = iridescenceF0 ? iridescence.mix(f0, iridescenceF0) : f0;
    const FssEss = Fr.mul(fab.x).add(specularF902.mul(fab.y));
    const Ess = fab.x.add(fab.y);
    const Ems = Ess.oneMinus();
    const Favg = Fr.add(Fr.oneMinus().mul(0.047619));
    const Fms = FssEss.mul(Favg).div(Ems.mul(Favg).oneMinus());
    singleScatter.addAssign(FssEss);
    multiScatter.addAssign(Fms.mul(Ems));
  }
  /**
   * Implements the direct light.
   *
   * @param {Object} lightData - The light data.
   * @param {NodeBuilder} builder - The current node builder.
   */
  direct({ lightDirection, lightColor, reflectedLight }) {
    const dotNL = normalView.dot(lightDirection).clamp();
    const irradiance = dotNL.mul(lightColor).toVar();
    if (this.sheen === true) {
      this.sheenSpecularDirect.addAssign(irradiance.mul(BRDF_Sheen({ lightDirection })));
      const sheenAlbedoV = IBLSheenBRDF({ normal: normalView, viewDir: positionViewDirection, roughness: sheenRoughness });
      const sheenAlbedoL = IBLSheenBRDF({ normal: normalView, viewDir: lightDirection, roughness: sheenRoughness });
      const sheenEnergyComp = sheen.r.max(sheen.g).max(sheen.b).mul(sheenAlbedoV.max(sheenAlbedoL)).oneMinus();
      irradiance.mulAssign(sheenEnergyComp);
    }
    if (this.clearcoat === true) {
      const dotNLcc = clearcoatNormalView.dot(lightDirection).clamp();
      const ccIrradiance = dotNLcc.mul(lightColor);
      this.clearcoatSpecularDirect.addAssign(ccIrradiance.mul(BRDF_GGX({ lightDirection, f0: clearcoatF0, f90: clearcoatF90, roughness: clearcoatRoughness, normalView: clearcoatNormalView })));
    }
    reflectedLight.directDiffuse.addAssign(irradiance.mul(BRDF_Lambert({ diffuseColor: diffuseContribution })));
    reflectedLight.directSpecular.addAssign(irradiance.mul(BRDF_GGX_Multiscatter({ lightDirection, f0: specularColorBlended, f90: 1, roughness, f: this.iridescenceFresnel, USE_IRIDESCENCE: this.iridescence, USE_ANISOTROPY: this.anisotropy })));
  }
  /**
   * This method is intended for implementing the direct light term for
   * rect area light nodes.
   *
   * @param {Object} input - The input data.
   * @param {NodeBuilder} builder - The current node builder.
   */
  directRectArea({ lightColor, lightPosition: lightPosition2, halfWidth, halfHeight, reflectedLight, ltc_1, ltc_2 }) {
    const p0 = lightPosition2.add(halfWidth).sub(halfHeight);
    const p1 = lightPosition2.sub(halfWidth).sub(halfHeight);
    const p22 = lightPosition2.sub(halfWidth).add(halfHeight);
    const p3 = lightPosition2.add(halfWidth).add(halfHeight);
    const N3 = normalView;
    const V2 = positionViewDirection;
    const P2 = positionView.toVar();
    const uv2 = LTC_Uv({ N: N3, V: V2, roughness });
    const t13 = ltc_1.sample(uv2).toVar();
    const t22 = ltc_2.sample(uv2).toVar();
    const mInv = mat3(
      vec3(t13.x, 0, t13.y),
      vec3(0, 1, 0),
      vec3(t13.z, 0, t13.w)
    ).toVar();
    const fresnel = specularColorBlended.mul(t22.x).add(specularColorBlended.oneMinus().mul(t22.y)).toVar();
    reflectedLight.directSpecular.addAssign(lightColor.mul(fresnel).mul(LTC_Evaluate({ N: N3, V: V2, P: P2, mInv, p0, p1, p2: p22, p3 })));
    reflectedLight.directDiffuse.addAssign(lightColor.mul(diffuseContribution).mul(LTC_Evaluate({ N: N3, V: V2, P: P2, mInv: mat3(1, 0, 0, 0, 1, 0, 0, 0, 1), p0, p1, p2: p22, p3 })));
  }
  /**
   * Implements the indirect lighting.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  indirect(builder) {
    this.indirectDiffuse(builder);
    this.indirectSpecular(builder);
    this.ambientOcclusion(builder);
  }
  /**
   * Implements the indirect diffuse term.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  indirectDiffuse(builder) {
    const { irradiance, reflectedLight } = builder.context;
    const diffuse = irradiance.mul(BRDF_Lambert({ diffuseColor: diffuseContribution })).toVar();
    if (this.sheen === true) {
      const sheenAlbedo = IBLSheenBRDF({ normal: normalView, viewDir: positionViewDirection, roughness: sheenRoughness });
      const sheenEnergyComp = sheen.r.max(sheen.g).max(sheen.b).mul(sheenAlbedo).oneMinus();
      diffuse.mulAssign(sheenEnergyComp);
    }
    reflectedLight.indirectDiffuse.addAssign(diffuse);
  }
  /**
   * Implements the indirect specular term.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  indirectSpecular(builder) {
    const { radiance, iblIrradiance, reflectedLight } = builder.context;
    if (this.sheen === true) {
      this.sheenSpecularIndirect.addAssign(iblIrradiance.mul(
        sheen,
        IBLSheenBRDF({
          normal: normalView,
          viewDir: positionViewDirection,
          roughness: sheenRoughness
        })
      ));
    }
    if (this.clearcoat === true) {
      const dotNVcc = clearcoatNormalView.dot(positionViewDirection).clamp();
      const clearcoatEnv = EnvironmentBRDF({
        dotNV: dotNVcc,
        specularColor: clearcoatF0,
        specularF90: clearcoatF90,
        roughness: clearcoatRoughness
      });
      this.clearcoatSpecularIndirect.addAssign(this.clearcoatRadiance.mul(clearcoatEnv));
    }
    const singleScatteringDielectric = vec3().toVar("singleScatteringDielectric");
    const multiScatteringDielectric = vec3().toVar("multiScatteringDielectric");
    const singleScatteringMetallic = vec3().toVar("singleScatteringMetallic");
    const multiScatteringMetallic = vec3().toVar("multiScatteringMetallic");
    this.computeMultiscattering(singleScatteringDielectric, multiScatteringDielectric, specularF90, specularColor, this.iridescenceF0Dielectric);
    this.computeMultiscattering(singleScatteringMetallic, multiScatteringMetallic, specularF90, diffuseColor.rgb, this.iridescenceF0Metallic);
    const singleScattering = mix2(singleScatteringDielectric, singleScatteringMetallic, metalness);
    const multiScattering = mix2(multiScatteringDielectric, multiScatteringMetallic, metalness);
    const totalScatteringDielectric = singleScatteringDielectric.add(multiScatteringDielectric);
    const diffuse = diffuseContribution.mul(totalScatteringDielectric.oneMinus());
    const cosineWeightedIrradiance = iblIrradiance.mul(1 / Math.PI);
    const indirectSpecular = radiance.mul(singleScattering).add(multiScattering.mul(cosineWeightedIrradiance)).toVar();
    const indirectDiffuse = diffuse.mul(cosineWeightedIrradiance).toVar();
    if (this.sheen === true) {
      const sheenAlbedo = IBLSheenBRDF({ normal: normalView, viewDir: positionViewDirection, roughness: sheenRoughness });
      const sheenEnergyComp = sheen.r.max(sheen.g).max(sheen.b).mul(sheenAlbedo).oneMinus();
      indirectSpecular.mulAssign(sheenEnergyComp);
      indirectDiffuse.mulAssign(sheenEnergyComp);
    }
    reflectedLight.indirectSpecular.addAssign(indirectSpecular);
    reflectedLight.indirectDiffuse.addAssign(indirectDiffuse);
  }
  /**
   * Implements the ambient occlusion term.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  ambientOcclusion(builder) {
    const { ambientOcclusion, reflectedLight } = builder.context;
    const dotNV = normalView.dot(positionViewDirection).clamp();
    const aoNV = dotNV.add(ambientOcclusion);
    const aoExp = roughness.mul(-16).oneMinus().negate().exp2();
    const aoNode = ambientOcclusion.sub(aoNV.pow(aoExp).oneMinus()).clamp();
    if (this.clearcoat === true) {
      this.clearcoatSpecularIndirect.mulAssign(ambientOcclusion);
    }
    if (this.sheen === true) {
      this.sheenSpecularIndirect.mulAssign(ambientOcclusion);
    }
    reflectedLight.indirectDiffuse.mulAssign(ambientOcclusion);
    reflectedLight.indirectSpecular.mulAssign(aoNode);
  }
  /**
   * Used for final lighting accumulations depending on the requested features.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  finish({ context: context2 }) {
    const { outgoingLight } = context2;
    if (this.clearcoat === true) {
      const dotNVcc = clearcoatNormalView.dot(positionViewDirection).clamp();
      const Fcc = F_Schlick({
        dotVH: dotNVcc,
        f0: clearcoatF0,
        f90: clearcoatF90
      });
      const clearcoatLight = outgoingLight.mul(clearcoat.mul(Fcc).oneMinus()).add(this.clearcoatSpecularDirect.add(this.clearcoatSpecularIndirect).mul(clearcoat));
      outgoingLight.assign(clearcoatLight);
    }
    if (this.sheen === true) {
      const sheenLight = outgoingLight.add(this.sheenSpecularDirect, this.sheenSpecularIndirect.mul(1 / Math.PI));
      outgoingLight.assign(sheenLight);
    }
  }
};
var cubeUV_r0 = float(1);
var cubeUV_m0 = float(-2);
var cubeUV_r1 = float(0.8);
var cubeUV_m1 = float(-1);
var cubeUV_r4 = float(0.4);
var cubeUV_m4 = float(2);
var cubeUV_r5 = float(0.305);
var cubeUV_m5 = float(3);
var cubeUV_r6 = float(0.21);
var cubeUV_m6 = float(4);
var cubeUV_minMipLevel = float(4);
var cubeUV_minTileSize = float(16);
var getFace = Fn(([direction]) => {
  const absDirection = vec3(abs(direction)).toVar();
  const face = float(-1).toVar();
  If(absDirection.x.greaterThan(absDirection.z), () => {
    If(absDirection.x.greaterThan(absDirection.y), () => {
      face.assign(select(direction.x.greaterThan(0), 0, 3));
    }).Else(() => {
      face.assign(select(direction.y.greaterThan(0), 1, 4));
    });
  }).Else(() => {
    If(absDirection.z.greaterThan(absDirection.y), () => {
      face.assign(select(direction.z.greaterThan(0), 2, 5));
    }).Else(() => {
      face.assign(select(direction.y.greaterThan(0), 1, 4));
    });
  });
  return face;
}).setLayout({
  name: "getFace",
  type: "float",
  inputs: [
    { name: "direction", type: "vec3" }
  ]
});
var getUV = Fn(([direction, face]) => {
  const uv2 = vec2().toVar();
  If(face.equal(0), () => {
    uv2.assign(vec2(direction.z, direction.y).div(abs(direction.x)));
  }).ElseIf(face.equal(1), () => {
    uv2.assign(vec2(direction.x.negate(), direction.z.negate()).div(abs(direction.y)));
  }).ElseIf(face.equal(2), () => {
    uv2.assign(vec2(direction.x.negate(), direction.y).div(abs(direction.z)));
  }).ElseIf(face.equal(3), () => {
    uv2.assign(vec2(direction.z.negate(), direction.y).div(abs(direction.x)));
  }).ElseIf(face.equal(4), () => {
    uv2.assign(vec2(direction.x.negate(), direction.z).div(abs(direction.y)));
  }).Else(() => {
    uv2.assign(vec2(direction.x, direction.y).div(abs(direction.z)));
  });
  return mul(0.5, uv2.add(1));
}).setLayout({
  name: "getUV",
  type: "vec2",
  inputs: [
    { name: "direction", type: "vec3" },
    { name: "face", type: "float" }
  ]
});
var roughnessToMip = Fn(([roughness2]) => {
  const mip = float(0).toVar();
  If(roughness2.greaterThanEqual(cubeUV_r1), () => {
    mip.assign(cubeUV_r0.sub(roughness2).mul(cubeUV_m1.sub(cubeUV_m0)).div(cubeUV_r0.sub(cubeUV_r1)).add(cubeUV_m0));
  }).ElseIf(roughness2.greaterThanEqual(cubeUV_r4), () => {
    mip.assign(cubeUV_r1.sub(roughness2).mul(cubeUV_m4.sub(cubeUV_m1)).div(cubeUV_r1.sub(cubeUV_r4)).add(cubeUV_m1));
  }).ElseIf(roughness2.greaterThanEqual(cubeUV_r5), () => {
    mip.assign(cubeUV_r4.sub(roughness2).mul(cubeUV_m5.sub(cubeUV_m4)).div(cubeUV_r4.sub(cubeUV_r5)).add(cubeUV_m4));
  }).ElseIf(roughness2.greaterThanEqual(cubeUV_r6), () => {
    mip.assign(cubeUV_r5.sub(roughness2).mul(cubeUV_m6.sub(cubeUV_m5)).div(cubeUV_r5.sub(cubeUV_r6)).add(cubeUV_m5));
  }).Else(() => {
    mip.assign(float(-2).mul(log22(mul(1.16, roughness2))));
  });
  return mip;
}).setLayout({
  name: "roughnessToMip",
  type: "float",
  inputs: [
    { name: "roughness", type: "float" }
  ]
});
var getDirection = Fn(([uv_immutable, face]) => {
  const uv2 = uv_immutable.toVar();
  uv2.assign(mul(2, uv2).sub(1));
  const direction = vec3(uv2, 1).toVar();
  If(face.equal(0), () => {
    direction.assign(direction.zyx);
  }).ElseIf(face.equal(1), () => {
    direction.assign(direction.xzy);
    direction.xz.mulAssign(-1);
  }).ElseIf(face.equal(2), () => {
    direction.x.mulAssign(-1);
  }).ElseIf(face.equal(3), () => {
    direction.assign(direction.zyx);
    direction.xz.mulAssign(-1);
  }).ElseIf(face.equal(4), () => {
    direction.assign(direction.xzy);
    direction.xy.mulAssign(-1);
  }).ElseIf(face.equal(5), () => {
    direction.z.mulAssign(-1);
  });
  return direction;
}).setLayout({
  name: "getDirection",
  type: "vec3",
  inputs: [
    { name: "uv", type: "vec2" },
    { name: "face", type: "float" }
  ]
});
var textureCubeUV = Fn(([envMap, sampleDir_immutable, roughness_immutable, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP]) => {
  const roughness2 = float(roughness_immutable);
  const sampleDir = vec3(sampleDir_immutable);
  const mip = clamp3(roughnessToMip(roughness2), cubeUV_m0, CUBEUV_MAX_MIP);
  const mipF = fract(mip);
  const mipInt = floor(mip);
  const color0 = vec3(bilinearCubeUV(envMap, sampleDir, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP)).toVar();
  If(mipF.notEqual(0), () => {
    const color1 = vec3(bilinearCubeUV(envMap, sampleDir, mipInt.add(1), CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP)).toVar();
    color0.assign(mix2(color0, color1, mipF));
  });
  return color0;
});
var bilinearCubeUV = Fn(([envMap, direction_immutable, mipInt_immutable, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP]) => {
  const mipInt = float(mipInt_immutable).toVar();
  const direction = vec3(direction_immutable);
  const face = float(getFace(direction)).toVar();
  const filterInt = float(max$1(cubeUV_minMipLevel.sub(mipInt), 0)).toVar();
  mipInt.assign(max$1(mipInt, cubeUV_minMipLevel));
  const faceSize = float(exp2(mipInt)).toVar();
  const uv2 = vec2(getUV(direction, face).mul(faceSize.sub(2)).add(1)).toVar();
  If(face.greaterThan(2), () => {
    uv2.y.addAssign(faceSize);
    face.subAssign(3);
  });
  uv2.x.addAssign(face.mul(faceSize));
  uv2.x.addAssign(filterInt.mul(mul(3, cubeUV_minTileSize)));
  uv2.y.addAssign(mul(4, exp2(CUBEUV_MAX_MIP).sub(faceSize)));
  uv2.x.mulAssign(CUBEUV_TEXEL_WIDTH);
  uv2.y.mulAssign(CUBEUV_TEXEL_HEIGHT);
  return envMap.sample(uv2).grad(vec2(), vec2());
});
var getSample = Fn(({ envMap, mipInt, outputDirection, theta, axis, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP }) => {
  const cosTheta = cos(theta);
  const sampleDirection = outputDirection.mul(cosTheta).add(axis.cross(outputDirection).mul(sin(theta))).add(axis.mul(axis.dot(outputDirection).mul(cosTheta.oneMinus())));
  return bilinearCubeUV(envMap, sampleDirection, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP);
});
var blur3 = Fn(({ n: n2, latitudinal, poleAxis, outputDirection, weights, samples, dTheta, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP }) => {
  const axis = vec3(select(latitudinal, poleAxis, cross2(poleAxis, outputDirection))).toVar();
  If(axis.equal(vec3(0)), () => {
    axis.assign(vec3(outputDirection.z, 0, outputDirection.x.negate()));
  });
  axis.assign(normalize2(axis));
  const gl_FragColor = vec3().toVar();
  gl_FragColor.addAssign(weights.element(0).mul(getSample({ theta: 0, axis, outputDirection, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP })));
  Loop({ start: int(1), end: n2 }, ({ i: i2 }) => {
    If(i2.greaterThanEqual(samples), () => {
      Break();
    });
    const theta = float(dTheta.mul(float(i2))).toVar();
    gl_FragColor.addAssign(weights.element(i2).mul(getSample({ theta: theta.mul(-1), axis, outputDirection, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP })));
    gl_FragColor.addAssign(weights.element(i2).mul(getSample({ theta, axis, outputDirection, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP })));
  });
  return vec4(gl_FragColor, 1);
});
var radicalInverse_VdC = Fn(([bits_immutable]) => {
  const bits2 = uint(bits_immutable).toVar();
  bits2.assign(bits2.shiftLeft(uint(16)).bitOr(bits2.shiftRight(uint(16))));
  bits2.assign(bits2.bitAnd(uint(1431655765)).shiftLeft(uint(1)).bitOr(bits2.bitAnd(uint(2863311530)).shiftRight(uint(1))));
  bits2.assign(bits2.bitAnd(uint(858993459)).shiftLeft(uint(2)).bitOr(bits2.bitAnd(uint(3435973836)).shiftRight(uint(2))));
  bits2.assign(bits2.bitAnd(uint(252645135)).shiftLeft(uint(4)).bitOr(bits2.bitAnd(uint(4042322160)).shiftRight(uint(4))));
  bits2.assign(bits2.bitAnd(uint(16711935)).shiftLeft(uint(8)).bitOr(bits2.bitAnd(uint(4278255360)).shiftRight(uint(8))));
  return float(bits2).mul(23283064365386963e-26);
});
var hammersley = Fn(([i2, N3]) => {
  return vec2(float(i2).div(float(N3)), radicalInverse_VdC(i2));
});
var importanceSampleGGX_VNDF = Fn(([Xi, V_immutable, roughness_immutable]) => {
  const V2 = vec3(V_immutable).toVar();
  const roughness2 = float(roughness_immutable);
  const alpha = roughness2.mul(roughness2).toVar();
  const Vh = normalize2(vec3(alpha.mul(V2.x), alpha.mul(V2.y), V2.z)).toVar();
  const lensq = Vh.x.mul(Vh.x).add(Vh.y.mul(Vh.y));
  const T1 = select(lensq.greaterThan(0), vec3(Vh.y.negate(), Vh.x, 0).div(sqrt2(lensq)), vec3(1, 0, 0)).toVar();
  const T22 = cross2(Vh, T1).toVar();
  const r2 = sqrt2(Xi.x);
  const phi = mul(2, 3.14159265359).mul(Xi.y);
  const t13 = r2.mul(cos(phi)).toVar();
  const t22 = r2.mul(sin(phi)).toVar();
  const s2 = mul(0.5, Vh.z.add(1));
  t22.assign(s2.oneMinus().mul(sqrt2(t13.mul(t13).oneMinus())).add(s2.mul(t22)));
  const Nh = T1.mul(t13).add(T22.mul(t22)).add(Vh.mul(sqrt2(max$1(0, t13.mul(t13).add(t22.mul(t22)).oneMinus()))));
  return normalize2(vec3(alpha.mul(Nh.x), alpha.mul(Nh.y), max$1(0, Nh.z)));
});
var ggxConvolution = Fn(({ roughness: roughness2, mipInt, envMap, N_immutable, GGX_SAMPLES: GGX_SAMPLES2, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP }) => {
  const N3 = vec3(N_immutable).toVar();
  const prefilteredColor = vec3(0).toVar();
  const totalWeight = float(0).toVar();
  If(roughness2.lessThan(1e-3), () => {
    prefilteredColor.assign(bilinearCubeUV(envMap, N3, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP));
  }).Else(() => {
    const up = select(abs(N3.z).lessThan(0.999), vec3(0, 0, 1), vec3(1, 0, 0));
    const tangent = normalize2(cross2(up, N3)).toVar();
    const bitangent = cross2(N3, tangent).toVar();
    Loop({ start: uint(0), end: GGX_SAMPLES2 }, ({ i: i2 }) => {
      const Xi = hammersley(i2, GGX_SAMPLES2);
      const H_tangent = importanceSampleGGX_VNDF(Xi, vec3(0, 0, 1), roughness2);
      const H = normalize2(tangent.mul(H_tangent.x).add(bitangent.mul(H_tangent.y)).add(N3.mul(H_tangent.z)));
      const L2 = normalize2(H.mul(dot(N3, H).mul(2)).sub(N3));
      const NdotL = max$1(dot(N3, L2), 0);
      If(NdotL.greaterThan(0), () => {
        const sampleColor = bilinearCubeUV(envMap, L2, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP);
        prefilteredColor.addAssign(sampleColor.mul(NdotL));
        totalWeight.addAssign(NdotL);
      });
    });
    If(totalWeight.greaterThan(0), () => {
      prefilteredColor.assign(prefilteredColor.div(totalWeight));
    });
  });
  return vec4(prefilteredColor, 1);
});
var LOD_MIN = 4;
var EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
var MAX_SAMPLES = 20;
var GGX_SAMPLES = 512;
var _flatCamera2 = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
var _cubeCamera = new PerspectiveCamera(90, 1);
var _clearColor$2 = new Color();
var _oldTarget = null;
var _oldActiveCubeFace = 0;
var _oldActiveMipmapLevel = 0;
var _origin = new Vector3();
var _uniformsMap = /* @__PURE__ */ new WeakMap();
var _faceLib = [
  3,
  1,
  5,
  0,
  4,
  2
];
var _direction = getDirection(uv$1(), attribute("faceIndex")).normalize();
var _outputDirection = vec3(_direction.x, _direction.y, _direction.z);
var PMREMGenerator = class {
  /**
   * Constructs a new PMREM generator.
   *
   * @param {Renderer} renderer - The renderer.
   */
  constructor(renderer3) {
    this._renderer = renderer3;
    this._pingPongRenderTarget = null;
    this._lodMax = 0;
    this._cubeSize = 0;
    this._sizeLods = [];
    this._sigmas = [];
    this._lodMeshes = [];
    this._blurMaterial = null;
    this._ggxMaterial = null;
    this._cubemapMaterial = null;
    this._equirectMaterial = null;
    this._backgroundBox = null;
  }
  get _hasInitialized() {
    return this._renderer.hasInitialized();
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety.
   *
   * @param {Scene} scene - The scene to be captured.
   * @param {number} [sigma=0] - The blur radius in radians.
   * @param {number} [near=0.1] - The near plane distance.
   * @param {number} [far=100] - The far plane distance.
   * @param {Object} [options={}] - The configuration options.
   * @param {number} [options.size=256] - The texture size of the PMREM.
   * @param {Vector3} [options.renderTarget=origin] - The position of the internal cube camera that renders the scene.
   * @param {?RenderTarget} [options.renderTarget=null] - The render target to use.
   * @return {RenderTarget} The resulting PMREM.
   * @see {@link PMREMGenerator#fromScene}
   */
  fromScene(scene3, sigma = 0, near = 0.1, far = 100, options = {}) {
    const {
      size: size2 = 256,
      position = _origin,
      renderTarget = null
    } = options;
    this._setSize(size2);
    if (this._hasInitialized === false) {
      warn('PMREMGenerator: ".fromScene()" called before the backend is initialized. Try using "await renderer.init()" instead.');
      const cubeUVRenderTarget2 = renderTarget || this._allocateTarget();
      options.renderTarget = cubeUVRenderTarget2;
      this.fromSceneAsync(scene3, sigma, near, far, options);
      return cubeUVRenderTarget2;
    }
    _oldTarget = this._renderer.getRenderTarget();
    _oldActiveCubeFace = this._renderer.getActiveCubeFace();
    _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
    const cubeUVRenderTarget = renderTarget || this._allocateTarget();
    cubeUVRenderTarget.depthBuffer = true;
    this._init(cubeUVRenderTarget);
    this._sceneToCubeUV(scene3, near, far, cubeUVRenderTarget, position);
    if (sigma > 0) {
      this._blur(cubeUVRenderTarget, 0, 0, sigma);
    }
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   *
   * @deprecated
   * @param {Scene} scene - The scene to be captured.
   * @param {number} [sigma=0] - The blur radius in radians.
   * @param {number} [near=0.1] - The near plane distance.
   * @param {number} [far=100] - The far plane distance.
   * @param {Object} [options={}] - The configuration options.
   * @param {number} [options.size=256] - The texture size of the PMREM.
   * @param {Vector3} [options.position=origin] - The position of the internal cube camera that renders the scene.
   * @param {?RenderTarget} [options.renderTarget=null] - The render target to use.
   * @return {Promise<RenderTarget>} A Promise that resolve with the PMREM when the generation has been finished.
   * @see {@link PMREMGenerator#fromScene}
   */
  async fromSceneAsync(scene3, sigma = 0, near = 0.1, far = 100, options = {}) {
    warnOnce('PMREMGenerator: ".fromSceneAsync()" is deprecated. Use "await renderer.init()" instead.');
    await this._renderer.init();
    return this.fromScene(scene3, sigma, near, far, options);
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   *
   * @param {Texture} equirectangular - The equirectangular texture to be converted.
   * @param {?RenderTarget} [renderTarget=null] - The render target to use.
   * @return {RenderTarget} The resulting PMREM.
   * @see {@link PMREMGenerator#fromEquirectangularAsync}
   */
  fromEquirectangular(equirectangular, renderTarget = null) {
    if (this._hasInitialized === false) {
      warn('PMREMGenerator: .fromEquirectangular() called before the backend is initialized. Try using "await renderer.init()" instead.');
      this._setSizeFromTexture(equirectangular);
      const cubeUVRenderTarget = renderTarget || this._allocateTarget();
      this.fromEquirectangularAsync(equirectangular, cubeUVRenderTarget);
      return cubeUVRenderTarget;
    }
    return this._fromTexture(equirectangular, renderTarget);
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   *
   * @deprecated
   * @param {Texture} equirectangular - The equirectangular texture to be converted.
   * @param {?RenderTarget} [renderTarget=null] - The render target to use.
   * @return {Promise<RenderTarget>} The resulting PMREM.
   * @see {@link PMREMGenerator#fromEquirectangular}
   */
  async fromEquirectangularAsync(equirectangular, renderTarget = null) {
    warnOnce('PMREMGenerator: ".fromEquirectangularAsync()" is deprecated. Use "await renderer.init()" instead.');
    await this._renderer.init();
    return this._fromTexture(equirectangular, renderTarget);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   *
   * @param {Texture} cubemap - The cubemap texture to be converted.
   * @param {?RenderTarget} [renderTarget=null] - The render target to use.
   * @return {RenderTarget} The resulting PMREM.
   * @see {@link PMREMGenerator#fromCubemapAsync}
   */
  fromCubemap(cubemap, renderTarget = null) {
    if (this._hasInitialized === false) {
      warn("PMREMGenerator: .fromCubemap() called before the backend is initialized. Try using .fromCubemapAsync() instead.");
      this._setSizeFromTexture(cubemap);
      const cubeUVRenderTarget = renderTarget || this._allocateTarget();
      this.fromCubemapAsync(cubemap, renderTarget);
      return cubeUVRenderTarget;
    }
    return this._fromTexture(cubemap, renderTarget);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * with the 256 x 256 cubemap output.
   *
   * @deprecated
   * @param {Texture} cubemap - The cubemap texture to be converted.
   * @param {?RenderTarget} [renderTarget=null] - The render target to use.
   * @return {Promise<RenderTarget>} The resulting PMREM.
   * @see {@link PMREMGenerator#fromCubemap}
   */
  async fromCubemapAsync(cubemap, renderTarget = null) {
    warnOnce('PMREMGenerator: ".fromCubemapAsync()" is deprecated. Use "await renderer.init()" instead.');
    await this._renderer.init();
    return this._fromTexture(cubemap, renderTarget);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   *
   * @returns {Promise}
   */
  async compileCubemapShader() {
    if (this._cubemapMaterial === null) {
      this._cubemapMaterial = _getCubemapMaterial();
      await this._compileMaterial(this._cubemapMaterial);
    }
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   *
   * @returns {Promise}
   */
  async compileEquirectangularShader() {
    if (this._equirectMaterial === null) {
      this._equirectMaterial = _getEquirectMaterial();
      await this._compileMaterial(this._equirectMaterial);
    }
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose();
    if (this._cubemapMaterial !== null) this._cubemapMaterial.dispose();
    if (this._equirectMaterial !== null) this._equirectMaterial.dispose();
    if (this._backgroundBox !== null) {
      this._backgroundBox.geometry.dispose();
      this._backgroundBox.material.dispose();
    }
  }
  // private interface
  _setSizeFromTexture(texture2) {
    if (texture2.mapping === CubeReflectionMapping || texture2.mapping === CubeRefractionMapping) {
      this._setSize(texture2.image.length === 0 ? 16 : texture2.image[0].width || texture2.image[0].image.width);
    } else {
      this._setSize(texture2.image.width / 4);
    }
  }
  _setSize(cubeSize) {
    this._lodMax = Math.floor(Math.log2(cubeSize));
    this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    if (this._blurMaterial !== null) this._blurMaterial.dispose();
    if (this._ggxMaterial !== null) this._ggxMaterial.dispose();
    if (this._pingPongRenderTarget !== null) this._pingPongRenderTarget.dispose();
    for (let i2 = 0; i2 < this._lodMeshes.length; i2++) {
      this._lodMeshes[i2].geometry.dispose();
    }
  }
  _cleanup(outputTarget) {
    this._renderer.setRenderTarget(_oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel);
    outputTarget.scissorTest = false;
    _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
  }
  _fromTexture(texture2, renderTarget) {
    this._setSizeFromTexture(texture2);
    _oldTarget = this._renderer.getRenderTarget();
    _oldActiveCubeFace = this._renderer.getActiveCubeFace();
    _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
    const cubeUVRenderTarget = renderTarget || this._allocateTarget();
    this._init(cubeUVRenderTarget);
    this._textureToCubeUV(texture2, cubeUVRenderTarget);
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  _allocateTarget() {
    const width = 3 * Math.max(this._cubeSize, 16 * 7);
    const height = 4 * this._cubeSize;
    const cubeUVRenderTarget = _createRenderTarget(width, height);
    return cubeUVRenderTarget;
  }
  _init(renderTarget) {
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== renderTarget.width || this._pingPongRenderTarget.height !== renderTarget.height) {
      if (this._pingPongRenderTarget !== null) {
        this._dispose();
      }
      this._pingPongRenderTarget = _createRenderTarget(renderTarget.width, renderTarget.height);
      const { _lodMax } = this;
      ({ lodMeshes: this._lodMeshes, sizeLods: this._sizeLods, sigmas: this._sigmas } = _createPlanes(_lodMax));
      this._blurMaterial = _getBlurShader(_lodMax, renderTarget.width, renderTarget.height);
      this._ggxMaterial = _getGGXShader(_lodMax, renderTarget.width, renderTarget.height);
    }
  }
  async _compileMaterial(material) {
    const mesh = new Mesh(new BufferGeometry(), material);
    await this._renderer.compile(mesh, _flatCamera2);
  }
  _sceneToCubeUV(scene3, near, far, cubeUVRenderTarget, position) {
    const cubeCamera = _cubeCamera;
    cubeCamera.near = near;
    cubeCamera.far = far;
    const upSign = [1, 1, 1, 1, -1, 1];
    const forwardSign = [1, -1, 1, -1, 1, -1];
    const renderer3 = this._renderer;
    const originalAutoClear = renderer3.autoClear;
    renderer3.getClearColor(_clearColor$2);
    renderer3.autoClear = false;
    if (this._backgroundBox === null) {
      this._backgroundBox = new Mesh(
        new BoxGeometry(),
        new MeshBasicMaterial({
          name: "PMREM.Background",
          side: BackSide,
          depthWrite: false,
          depthTest: false
        })
      );
    }
    const backgroundBox = this._backgroundBox;
    const backgroundMaterial = backgroundBox.material;
    let useSolidColor = false;
    const background = scene3.background;
    if (background) {
      if (background.isColor) {
        backgroundMaterial.color.copy(background);
        scene3.background = null;
        useSolidColor = true;
      }
    } else {
      backgroundMaterial.color.copy(_clearColor$2);
      useSolidColor = true;
    }
    renderer3.setRenderTarget(cubeUVRenderTarget);
    renderer3.clear();
    if (useSolidColor) {
      renderer3.render(backgroundBox, cubeCamera);
    }
    for (let i2 = 0; i2 < 6; i2++) {
      const col = i2 % 3;
      if (col === 0) {
        cubeCamera.up.set(0, upSign[i2], 0);
        cubeCamera.position.set(position.x, position.y, position.z);
        cubeCamera.lookAt(position.x + forwardSign[i2], position.y, position.z);
      } else if (col === 1) {
        cubeCamera.up.set(0, 0, upSign[i2]);
        cubeCamera.position.set(position.x, position.y, position.z);
        cubeCamera.lookAt(position.x, position.y + forwardSign[i2], position.z);
      } else {
        cubeCamera.up.set(0, upSign[i2], 0);
        cubeCamera.position.set(position.x, position.y, position.z);
        cubeCamera.lookAt(position.x, position.y, position.z + forwardSign[i2]);
      }
      const size2 = this._cubeSize;
      _setViewport(cubeUVRenderTarget, col * size2, i2 > 2 ? size2 : 0, size2, size2);
      renderer3.render(scene3, cubeCamera);
    }
    renderer3.autoClear = originalAutoClear;
    scene3.background = background;
  }
  _textureToCubeUV(texture2, cubeUVRenderTarget) {
    const renderer3 = this._renderer;
    const isCubeTexture = texture2.mapping === CubeReflectionMapping || texture2.mapping === CubeRefractionMapping;
    if (isCubeTexture) {
      if (this._cubemapMaterial === null) {
        this._cubemapMaterial = _getCubemapMaterial(texture2);
      }
    } else {
      if (this._equirectMaterial === null) {
        this._equirectMaterial = _getEquirectMaterial(texture2);
      }
    }
    const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
    material.fragmentNode.value = texture2;
    const mesh = this._lodMeshes[0];
    mesh.material = material;
    const size2 = this._cubeSize;
    _setViewport(cubeUVRenderTarget, 0, 0, 3 * size2, 2 * size2);
    renderer3.setRenderTarget(cubeUVRenderTarget);
    renderer3.render(mesh, _flatCamera2);
  }
  _applyPMREM(cubeUVRenderTarget) {
    const renderer3 = this._renderer;
    const autoClear = renderer3.autoClear;
    renderer3.autoClear = false;
    const n2 = this._lodMeshes.length;
    for (let i2 = 1; i2 < n2; i2++) {
      this._applyGGXFilter(cubeUVRenderTarget, i2 - 1, i2);
    }
    renderer3.autoClear = autoClear;
  }
  /**
   * Applies GGX VNDF importance sampling filter to generate a prefiltered environment map.
   * Uses Monte Carlo integration with VNDF importance sampling to accurately represent the
   * GGX BRDF for physically-based rendering. Reads from the previous LOD level and
   * applies incremental roughness filtering to avoid over-blurring.
   *
   * @private
   * @param {RenderTarget} cubeUVRenderTarget
   * @param {number} lodIn - Source LOD level to read from
   * @param {number} lodOut - Target LOD level to write to
   */
  _applyGGXFilter(cubeUVRenderTarget, lodIn, lodOut) {
    const renderer3 = this._renderer;
    const pingPongRenderTarget = this._pingPongRenderTarget;
    const ggxMaterial = this._ggxMaterial;
    const ggxMesh = this._lodMeshes[lodOut];
    ggxMesh.material = ggxMaterial;
    const ggxUniforms = _uniformsMap.get(ggxMaterial);
    const targetRoughness = lodOut / (this._lodMeshes.length - 1);
    const sourceRoughness = lodIn / (this._lodMeshes.length - 1);
    const incrementalRoughness = Math.sqrt(targetRoughness * targetRoughness - sourceRoughness * sourceRoughness);
    const blurStrength = 0 + targetRoughness * 1.25;
    const adjustedRoughness = incrementalRoughness * blurStrength;
    const { _lodMax } = this;
    const outputSize = this._sizeLods[lodOut];
    const x3 = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);
    const y3 = 4 * (this._cubeSize - outputSize);
    cubeUVRenderTarget.texture.frame = (cubeUVRenderTarget.texture.frame || 0) + 1;
    ggxUniforms.envMap.value = cubeUVRenderTarget.texture;
    ggxUniforms.roughness.value = adjustedRoughness;
    ggxUniforms.mipInt.value = _lodMax - lodIn;
    _setViewport(pingPongRenderTarget, x3, y3, 3 * outputSize, 2 * outputSize);
    renderer3.setRenderTarget(pingPongRenderTarget);
    renderer3.render(ggxMesh, _flatCamera2);
    pingPongRenderTarget.texture.frame = (pingPongRenderTarget.texture.frame || 0) + 1;
    ggxUniforms.envMap.value = pingPongRenderTarget.texture;
    ggxUniforms.roughness.value = 0;
    ggxUniforms.mipInt.value = _lodMax - lodOut;
    _setViewport(cubeUVRenderTarget, x3, y3, 3 * outputSize, 2 * outputSize);
    renderer3.setRenderTarget(cubeUVRenderTarget);
    renderer3.render(ggxMesh, _flatCamera2);
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   *
   * Used for initial scene blur in fromScene() method when sigma > 0.
   *
   * @private
   * @param {RenderTarget} cubeUVRenderTarget - The cubemap render target.
   * @param {number} lodIn - The input level-of-detail.
   * @param {number} lodOut - The output level-of-detail.
   * @param {number} sigma - The blur radius in radians.
   * @param {Vector3} [poleAxis] - The pole axis.
   */
  _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
    const pingPongRenderTarget = this._pingPongRenderTarget;
    this._halfBlur(
      cubeUVRenderTarget,
      pingPongRenderTarget,
      lodIn,
      lodOut,
      sigma,
      "latitudinal",
      poleAxis
    );
    this._halfBlur(
      pingPongRenderTarget,
      cubeUVRenderTarget,
      lodOut,
      lodOut,
      sigma,
      "longitudinal",
      poleAxis
    );
  }
  _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
    const renderer3 = this._renderer;
    const blurMaterial = this._blurMaterial;
    if (direction !== "latitudinal" && direction !== "longitudinal") {
      error("blur direction must be either latitudinal or longitudinal!");
    }
    const STANDARD_DEVIATIONS = 3;
    const blurMesh = this._lodMeshes[lodOut];
    blurMesh.material = blurMaterial;
    const blurUniforms = _uniformsMap.get(blurMaterial);
    const pixels = this._sizeLods[lodIn] - 1;
    const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
    const sigmaPixels = sigmaRadians / radiansPerPixel;
    const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
    if (samples > MAX_SAMPLES) {
      warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
    }
    const weights = [];
    let sum3 = 0;
    for (let i2 = 0; i2 < MAX_SAMPLES; ++i2) {
      const x4 = i2 / sigmaPixels;
      const weight = Math.exp(-x4 * x4 / 2);
      weights.push(weight);
      if (i2 === 0) {
        sum3 += weight;
      } else if (i2 < samples) {
        sum3 += 2 * weight;
      }
    }
    for (let i2 = 0; i2 < weights.length; i2++) {
      weights[i2] = weights[i2] / sum3;
    }
    targetIn.texture.frame = (targetIn.texture.frame || 0) + 1;
    blurUniforms.envMap.value = targetIn.texture;
    blurUniforms.samples.value = samples;
    blurUniforms.weights.array = weights;
    blurUniforms.latitudinal.value = direction === "latitudinal" ? 1 : 0;
    if (poleAxis) {
      blurUniforms.poleAxis.value = poleAxis;
    }
    const { _lodMax } = this;
    blurUniforms.dTheta.value = radiansPerPixel;
    blurUniforms.mipInt.value = _lodMax - lodIn;
    const outputSize = this._sizeLods[lodOut];
    const x3 = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);
    const y3 = 4 * (this._cubeSize - outputSize);
    _setViewport(targetOut, x3, y3, 3 * outputSize, 2 * outputSize);
    renderer3.setRenderTarget(targetOut);
    renderer3.render(blurMesh, _flatCamera2);
  }
};
function _createPlanes(lodMax) {
  const sizeLods = [];
  const sigmas = [];
  const lodMeshes = [];
  let lod = lodMax;
  const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
  for (let i2 = 0; i2 < totalLods; i2++) {
    const sizeLod = Math.pow(2, lod);
    sizeLods.push(sizeLod);
    let sigma = 1 / sizeLod;
    if (i2 > lodMax - LOD_MIN) {
      sigma = EXTRA_LOD_SIGMA[i2 - lodMax + LOD_MIN - 1];
    } else if (i2 === 0) {
      sigma = 0;
    }
    sigmas.push(sigma);
    const texelSize = 1 / (sizeLod - 2);
    const min5 = -texelSize;
    const max6 = 1 + texelSize;
    const uv1 = [min5, min5, max6, min5, max6, max6, min5, min5, max6, max6, min5, max6];
    const cubeFaces = 6;
    const vertices = 6;
    const positionSize = 3;
    const uvSize = 2;
    const faceIndexSize = 1;
    const position = new Float32Array(positionSize * vertices * cubeFaces);
    const uv2 = new Float32Array(uvSize * vertices * cubeFaces);
    const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
    for (let face = 0; face < cubeFaces; face++) {
      const x3 = face % 3 * 2 / 3 - 1;
      const y3 = face > 2 ? 0 : -1;
      const coordinates = [
        x3,
        y3,
        0,
        x3 + 2 / 3,
        y3,
        0,
        x3 + 2 / 3,
        y3 + 1,
        0,
        x3,
        y3,
        0,
        x3 + 2 / 3,
        y3 + 1,
        0,
        x3,
        y3 + 1,
        0
      ];
      const faceIdx = _faceLib[face];
      position.set(coordinates, positionSize * vertices * faceIdx);
      uv2.set(uv1, uvSize * vertices * faceIdx);
      const fill2 = [faceIdx, faceIdx, faceIdx, faceIdx, faceIdx, faceIdx];
      faceIndex.set(fill2, faceIndexSize * vertices * faceIdx);
    }
    const planes = new BufferGeometry();
    planes.setAttribute("position", new BufferAttribute(position, positionSize));
    planes.setAttribute("uv", new BufferAttribute(uv2, uvSize));
    planes.setAttribute("faceIndex", new BufferAttribute(faceIndex, faceIndexSize));
    lodMeshes.push(new Mesh(planes, null));
    if (lod > LOD_MIN) {
      lod--;
    }
  }
  return { lodMeshes, sizeLods, sigmas };
}
function _createRenderTarget(width, height) {
  const params = {
    magFilter: LinearFilter,
    minFilter: LinearFilter,
    generateMipmaps: false,
    type: HalfFloatType,
    format: RGBAFormat,
    colorSpace: LinearSRGBColorSpace
    //depthBuffer: false
  };
  const cubeUVRenderTarget = new RenderTarget(width, height, params);
  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
  cubeUVRenderTarget.texture.name = "PMREM.cubeUv";
  cubeUVRenderTarget.texture.isPMREMTexture = true;
  cubeUVRenderTarget.scissorTest = true;
  return cubeUVRenderTarget;
}
function _setViewport(target, x3, y3, width, height) {
  target.viewport.set(x3, y3, width, height);
  target.scissor.set(x3, y3, width, height);
}
function _getMaterial(type) {
  const material = new NodeMaterial();
  material.depthTest = false;
  material.depthWrite = false;
  material.blending = NoBlending;
  material.name = `PMREM_${type}`;
  return material;
}
function _getBlurShader(lodMax, width, height) {
  const weights = uniformArray(new Array(MAX_SAMPLES).fill(0));
  const poleAxis = uniform(new Vector3(0, 1, 0));
  const dTheta = uniform(0);
  const n2 = float(MAX_SAMPLES);
  const latitudinal = uniform(0);
  const samples = uniform(1);
  const envMap = texture();
  const mipInt = uniform(0);
  const CUBEUV_TEXEL_WIDTH = float(1 / width);
  const CUBEUV_TEXEL_HEIGHT = float(1 / height);
  const CUBEUV_MAX_MIP = float(lodMax);
  const materialUniforms = {
    n: n2,
    latitudinal,
    weights,
    poleAxis,
    outputDirection: _outputDirection,
    dTheta,
    samples,
    envMap,
    mipInt,
    CUBEUV_TEXEL_WIDTH,
    CUBEUV_TEXEL_HEIGHT,
    CUBEUV_MAX_MIP
  };
  const material = _getMaterial("blur");
  material.fragmentNode = blur3({ ...materialUniforms, latitudinal: latitudinal.equal(1) });
  _uniformsMap.set(material, materialUniforms);
  return material;
}
function _getGGXShader(lodMax, width, height) {
  const envMap = texture();
  const roughness2 = uniform(0);
  const mipInt = uniform(0);
  const CUBEUV_TEXEL_WIDTH = float(1 / width);
  const CUBEUV_TEXEL_HEIGHT = float(1 / height);
  const CUBEUV_MAX_MIP = float(lodMax);
  const materialUniforms = {
    envMap,
    roughness: roughness2,
    mipInt,
    CUBEUV_TEXEL_WIDTH,
    CUBEUV_TEXEL_HEIGHT,
    CUBEUV_MAX_MIP
  };
  const material = _getMaterial("ggx");
  material.fragmentNode = ggxConvolution({
    ...materialUniforms,
    N_immutable: _outputDirection,
    GGX_SAMPLES: uint(GGX_SAMPLES)
  });
  _uniformsMap.set(material, materialUniforms);
  return material;
}
function _getCubemapMaterial(envTexture) {
  const material = _getMaterial("cubemap");
  material.fragmentNode = cubeTexture(envTexture, _outputDirection);
  return material;
}
function _getEquirectMaterial(envTexture) {
  const material = _getMaterial("equirect");
  material.fragmentNode = texture(envTexture, equirectUV(_outputDirection), 0);
  return material;
}
var _cache2 = /* @__PURE__ */ new WeakMap();
function _generateCubeUVSize(imageHeight) {
  const maxMip = Math.log2(imageHeight) - 2;
  const texelHeight = 1 / imageHeight;
  const texelWidth = 1 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));
  return { texelWidth, texelHeight, maxMip };
}
function _getPMREMFromTexture(texture2, renderer3, generator) {
  const cache2 = _getCache(renderer3);
  let cacheTexture = cache2.get(texture2);
  const pmremVersion = cacheTexture !== void 0 ? cacheTexture.pmremVersion : -1;
  if (pmremVersion !== texture2.pmremVersion) {
    const image = texture2.image;
    if (texture2.isCubeTexture) {
      if (isCubeMapReady(image)) {
        cacheTexture = generator.fromCubemap(texture2, cacheTexture);
      } else {
        return null;
      }
    } else {
      if (isEquirectangularMapReady(image)) {
        cacheTexture = generator.fromEquirectangular(texture2, cacheTexture);
      } else {
        return null;
      }
    }
    cacheTexture.pmremVersion = texture2.pmremVersion;
    cache2.set(texture2, cacheTexture);
  }
  return cacheTexture.texture;
}
function _getCache(renderer3) {
  let rendererCache2 = _cache2.get(renderer3);
  if (rendererCache2 === void 0) {
    rendererCache2 = /* @__PURE__ */ new WeakMap();
    _cache2.set(renderer3, rendererCache2);
  }
  return rendererCache2;
}
var PMREMNode = class extends TempNode {
  static get type() {
    return "PMREMNode";
  }
  /**
   * Constructs a new function overloading node.
   *
   * @param {Texture} value - The input texture.
   * @param {Node<vec2>} [uvNode=null] - The uv node.
   * @param {Node<float>} [levelNode=null] - The level node.
   */
  constructor(value, uvNode = null, levelNode = null) {
    super("vec3");
    this._value = value;
    this._pmrem = null;
    this.uvNode = uvNode;
    this.levelNode = levelNode;
    this._generator = null;
    const defaultTexture = new Texture();
    defaultTexture.isRenderTargetTexture = true;
    this._texture = texture(defaultTexture);
    this._width = uniform(0);
    this._height = uniform(0);
    this._maxMip = uniform(0);
    this.updateBeforeType = NodeUpdateType.RENDER;
  }
  set value(value) {
    this._value = value;
    this._pmrem = null;
  }
  /**
   * The node's texture value.
   *
   * @type {Texture}
   */
  get value() {
    return this._value;
  }
  /**
   * Uses the given PMREM texture to update internal values.
   *
   * @param {Texture} texture - The PMREM texture.
   */
  updateFromTexture(texture2) {
    const cubeUVSize = _generateCubeUVSize(texture2.image.height);
    this._texture.value = texture2;
    this._width.value = cubeUVSize.texelWidth;
    this._height.value = cubeUVSize.texelHeight;
    this._maxMip.value = cubeUVSize.maxMip;
  }
  updateBefore(frame2) {
    let pmrem = this._pmrem;
    const pmremVersion = pmrem ? pmrem.pmremVersion : -1;
    const texture2 = this._value;
    if (pmremVersion !== texture2.pmremVersion) {
      if (texture2.isPMREMTexture === true) {
        pmrem = texture2;
      } else {
        pmrem = _getPMREMFromTexture(texture2, frame2.renderer, this._generator);
      }
      if (pmrem !== null) {
        this._pmrem = pmrem;
        this.updateFromTexture(pmrem);
      }
    }
  }
  setup(builder) {
    if (this._generator === null) {
      this._generator = new PMREMGenerator(builder.renderer);
    }
    this.updateBefore(builder);
    let uvNode = this.uvNode;
    if (uvNode === null && builder.context.getUV) {
      uvNode = builder.context.getUV(this, builder);
    }
    uvNode = materialEnvRotation.mul(vec3(uvNode.x, uvNode.y.negate(), uvNode.z));
    let levelNode = this.levelNode;
    if (levelNode === null && builder.context.getTextureLevel) {
      levelNode = builder.context.getTextureLevel(this);
    }
    return textureCubeUV(this._texture, uvNode, levelNode, this._width, this._height, this._maxMip);
  }
  dispose() {
    super.dispose();
    if (this._generator !== null) this._generator.dispose();
  }
};
function isCubeMapReady(image) {
  if (image === null || image === void 0) return false;
  let count2 = 0;
  const length2 = 6;
  for (let i2 = 0; i2 < length2; i2++) {
    if (image[i2] !== void 0) count2++;
  }
  return count2 === length2;
}
function isEquirectangularMapReady(image) {
  if (image === null || image === void 0) return false;
  return image.height > 0;
}
var pmremTexture = nodeProxy(PMREMNode).setParameterLength(1, 3);
var _envNodeCache = /* @__PURE__ */ new WeakMap();
var EnvironmentNode = class extends LightingNode {
  static get type() {
    return "EnvironmentNode";
  }
  /**
   * Constructs a new environment node.
   *
   * @param {Node} [envNode=null] - A node representing the environment.
   */
  constructor(envNode = null) {
    super();
    this.envNode = envNode;
  }
  setup(builder) {
    const { material } = builder;
    let envNode = this.envNode;
    if (envNode.isTextureNode || envNode.isMaterialReferenceNode) {
      const value = envNode.isTextureNode ? envNode.value : material[envNode.property];
      let cacheEnvNode = _envNodeCache.get(value);
      if (cacheEnvNode === void 0) {
        cacheEnvNode = pmremTexture(value);
        _envNodeCache.set(value, cacheEnvNode);
      }
      envNode = cacheEnvNode;
    }
    const useAnisotropy = material.useAnisotropy === true || material.anisotropy > 0;
    const radianceNormalView = useAnisotropy ? bentNormalView : normalView;
    const radiance = envNode.context(createRadianceContext(roughness, radianceNormalView)).mul(materialEnvIntensity);
    const irradiance = envNode.context(createIrradianceContext(normalWorld)).mul(Math.PI).mul(materialEnvIntensity);
    const isolateRadiance = isolate(radiance);
    const isolateIrradiance = isolate(irradiance);
    builder.context.radiance.addAssign(isolateRadiance);
    builder.context.iblIrradiance.addAssign(isolateIrradiance);
    const clearcoatRadiance = builder.context.lightingModel.clearcoatRadiance;
    if (clearcoatRadiance) {
      const clearcoatRadianceContext = envNode.context(createRadianceContext(clearcoatRoughness, clearcoatNormalView)).mul(materialEnvIntensity);
      const isolateClearcoatRadiance = isolate(clearcoatRadianceContext);
      clearcoatRadiance.addAssign(isolateClearcoatRadiance);
    }
  }
};
var createRadianceContext = (roughnessNode, normalViewNode) => {
  let reflectVec = null;
  return {
    getUV: () => {
      if (reflectVec === null) {
        reflectVec = positionViewDirection.negate().reflect(normalViewNode);
        reflectVec = pow4(roughnessNode).mix(reflectVec, normalViewNode).normalize();
        reflectVec = reflectVec.transformDirection(cameraViewMatrix);
      }
      return reflectVec;
    },
    getTextureLevel: () => {
      return roughnessNode;
    }
  };
};
var createIrradianceContext = (normalWorldNode) => {
  return {
    getUV: () => {
      return normalWorldNode;
    },
    getTextureLevel: () => {
      return float(1);
    }
  };
};
var _defaultValues$6 = new MeshStandardMaterial();
var MeshStandardNodeMaterial = class extends NodeMaterial {
  static get type() {
    return "MeshStandardNodeMaterial";
  }
  /**
   * Constructs a new mesh standard node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(parameters) {
    super();
    this.isMeshStandardNodeMaterial = true;
    this.lights = true;
    this.emissiveNode = null;
    this.metalnessNode = null;
    this.roughnessNode = null;
    this.setDefaultValues(_defaultValues$6);
    this.setValues(parameters);
  }
  /**
   * Overwritten since this type of material uses {@link EnvironmentNode}
   * to implement the PBR (PMREM based) environment mapping. Besides, the
   * method honors `Scene.environment`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {?EnvironmentNode<vec3>} The environment node.
   */
  setupEnvironment(builder) {
    let envNode = super.setupEnvironment(builder);
    if (envNode === null && builder.environmentNode) {
      envNode = builder.environmentNode;
    }
    return envNode ? new EnvironmentNode(envNode) : null;
  }
  /**
   * Setups the lighting model.
   *
   * @return {PhysicalLightingModel} The lighting model.
   */
  setupLightingModel() {
    return new PhysicalLightingModel();
  }
  /**
   * Setups the specular related node variables.
   */
  setupSpecular() {
    const specularColorNode = mix2(vec3(0.04), diffuseColor.rgb, metalness);
    specularColor.assign(vec3(0.04));
    specularColorBlended.assign(specularColorNode);
    specularF90.assign(1);
  }
  /**
   * Setups the standard specific node variables.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setupVariants() {
    const metalnessNode = this.metalnessNode ? float(this.metalnessNode) : materialMetalness;
    metalness.assign(metalnessNode);
    let roughnessNode = this.roughnessNode ? float(this.roughnessNode) : materialRoughness;
    roughnessNode = getRoughness({ roughness: roughnessNode });
    roughness.assign(roughnessNode);
    this.setupSpecular();
    diffuseContribution.assign(diffuseColor.rgb.mul(metalnessNode.oneMinus()));
  }
  copy(source) {
    this.emissiveNode = source.emissiveNode;
    this.metalnessNode = source.metalnessNode;
    this.roughnessNode = source.roughnessNode;
    return super.copy(source);
  }
};
var _defaultValues$5 = new MeshPhysicalMaterial();
var MeshPhysicalNodeMaterial = class extends MeshStandardNodeMaterial {
  static get type() {
    return "MeshPhysicalNodeMaterial";
  }
  /**
   * Constructs a new mesh physical node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(parameters) {
    super();
    this.isMeshPhysicalNodeMaterial = true;
    this.clearcoatNode = null;
    this.clearcoatRoughnessNode = null;
    this.clearcoatNormalNode = null;
    this.sheenNode = null;
    this.sheenRoughnessNode = null;
    this.iridescenceNode = null;
    this.iridescenceIORNode = null;
    this.iridescenceThicknessNode = null;
    this.specularIntensityNode = null;
    this.specularColorNode = null;
    this.iorNode = null;
    this.transmissionNode = null;
    this.thicknessNode = null;
    this.attenuationDistanceNode = null;
    this.attenuationColorNode = null;
    this.dispersionNode = null;
    this.anisotropyNode = null;
    this.setDefaultValues(_defaultValues$5);
    this.setValues(parameters);
  }
  /**
   * Whether the lighting model should use clearcoat or not.
   *
   * @type {boolean}
   * @default true
   */
  get useClearcoat() {
    return this.clearcoat > 0 || this.clearcoatNode !== null;
  }
  /**
   * Whether the lighting model should use iridescence or not.
   *
   * @type {boolean}
   * @default true
   */
  get useIridescence() {
    return this.iridescence > 0 || this.iridescenceNode !== null;
  }
  /**
   * Whether the lighting model should use sheen or not.
   *
   * @type {boolean}
   * @default true
   */
  get useSheen() {
    return this.sheen > 0 || this.sheenNode !== null;
  }
  /**
   * Whether the lighting model should use anisotropy or not.
   *
   * @type {boolean}
   * @default true
   */
  get useAnisotropy() {
    return this.anisotropy > 0 || this.anisotropyNode !== null;
  }
  /**
   * Whether the lighting model should use transmission or not.
   *
   * @type {boolean}
   * @default true
   */
  get useTransmission() {
    return this.transmission > 0 || this.transmissionNode !== null;
  }
  /**
   * Whether the lighting model should use dispersion or not.
   *
   * @type {boolean}
   * @default true
   */
  get useDispersion() {
    return this.dispersion > 0 || this.dispersionNode !== null;
  }
  /**
   * Setups the specular related node variables.
   */
  setupSpecular() {
    const iorNode = this.iorNode ? float(this.iorNode) : materialIOR;
    ior.assign(iorNode);
    specularColor.assign(min$1(pow22(ior.sub(1).div(ior.add(1))).mul(materialSpecularColor), vec3(1)).mul(materialSpecularIntensity));
    specularColorBlended.assign(mix2(specularColor, diffuseColor.rgb, metalness));
    specularF90.assign(mix2(materialSpecularIntensity, 1, metalness));
  }
  /**
   * Setups the lighting model.
   *
   * @return {PhysicalLightingModel} The lighting model.
   */
  setupLightingModel() {
    return new PhysicalLightingModel(this.useClearcoat, this.useSheen, this.useIridescence, this.useAnisotropy, this.useTransmission, this.useDispersion);
  }
  /**
   * Setups the physical specific node variables.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setupVariants(builder) {
    super.setupVariants(builder);
    if (this.useClearcoat) {
      const clearcoatNode = this.clearcoatNode ? float(this.clearcoatNode) : materialClearcoat;
      const clearcoatRoughnessNode = this.clearcoatRoughnessNode ? float(this.clearcoatRoughnessNode) : materialClearcoatRoughness;
      clearcoat.assign(clearcoatNode);
      clearcoatRoughness.assign(getRoughness({ roughness: clearcoatRoughnessNode }));
    }
    if (this.useSheen) {
      const sheenNode = this.sheenNode ? vec3(this.sheenNode) : materialSheen;
      const sheenRoughnessNode = this.sheenRoughnessNode ? float(this.sheenRoughnessNode) : materialSheenRoughness;
      sheen.assign(sheenNode);
      sheenRoughness.assign(sheenRoughnessNode);
    }
    if (this.useIridescence) {
      const iridescenceNode = this.iridescenceNode ? float(this.iridescenceNode) : materialIridescence;
      const iridescenceIORNode = this.iridescenceIORNode ? float(this.iridescenceIORNode) : materialIridescenceIOR;
      const iridescenceThicknessNode = this.iridescenceThicknessNode ? float(this.iridescenceThicknessNode) : materialIridescenceThickness;
      iridescence.assign(iridescenceNode);
      iridescenceIOR.assign(iridescenceIORNode);
      iridescenceThickness.assign(iridescenceThicknessNode);
    }
    if (this.useAnisotropy) {
      const anisotropyV = (this.anisotropyNode ? vec2(this.anisotropyNode) : materialAnisotropy).toVar();
      anisotropy.assign(anisotropyV.length());
      If(anisotropy.equal(0), () => {
        anisotropyV.assign(vec2(1, 0));
      }).Else(() => {
        anisotropyV.divAssign(vec2(anisotropy));
        anisotropy.assign(anisotropy.saturate());
      });
      alphaT.assign(anisotropy.pow2().mix(roughness.pow2(), 1));
      anisotropyT.assign(TBNViewMatrix[0].mul(anisotropyV.x).add(TBNViewMatrix[1].mul(anisotropyV.y)));
      anisotropyB.assign(TBNViewMatrix[1].mul(anisotropyV.x).sub(TBNViewMatrix[0].mul(anisotropyV.y)));
    }
    if (this.useTransmission) {
      const transmissionNode = this.transmissionNode ? float(this.transmissionNode) : materialTransmission;
      const thicknessNode = this.thicknessNode ? float(this.thicknessNode) : materialThickness;
      const attenuationDistanceNode = this.attenuationDistanceNode ? float(this.attenuationDistanceNode) : materialAttenuationDistance;
      const attenuationColorNode = this.attenuationColorNode ? vec3(this.attenuationColorNode) : materialAttenuationColor;
      transmission.assign(transmissionNode);
      thickness.assign(thicknessNode);
      attenuationDistance.assign(attenuationDistanceNode);
      attenuationColor.assign(attenuationColorNode);
      if (this.useDispersion) {
        const dispersionNode = this.dispersionNode ? float(this.dispersionNode) : materialDispersion;
        dispersion.assign(dispersionNode);
      }
    }
  }
  /**
   * Setups the clearcoat normal node.
   *
   * @return {Node<vec3>} The clearcoat normal.
   */
  setupClearcoatNormal() {
    return this.clearcoatNormalNode ? vec3(this.clearcoatNormalNode) : materialClearcoatNormal;
  }
  setup(builder) {
    builder.context.setupClearcoatNormal = () => subBuild(this.setupClearcoatNormal(builder), "NORMAL", "vec3");
    super.setup(builder);
  }
  copy(source) {
    this.clearcoatNode = source.clearcoatNode;
    this.clearcoatRoughnessNode = source.clearcoatRoughnessNode;
    this.clearcoatNormalNode = source.clearcoatNormalNode;
    this.sheenNode = source.sheenNode;
    this.sheenRoughnessNode = source.sheenRoughnessNode;
    this.iridescenceNode = source.iridescenceNode;
    this.iridescenceIORNode = source.iridescenceIORNode;
    this.iridescenceThicknessNode = source.iridescenceThicknessNode;
    this.specularIntensityNode = source.specularIntensityNode;
    this.specularColorNode = source.specularColorNode;
    this.transmissionNode = source.transmissionNode;
    this.thicknessNode = source.thicknessNode;
    this.attenuationDistanceNode = source.attenuationDistanceNode;
    this.attenuationColorNode = source.attenuationColorNode;
    this.dispersionNode = source.dispersionNode;
    this.anisotropyNode = source.anisotropyNode;
    return super.copy(source);
  }
};
var getGradientIrradiance = Fn(({ normal: normal2, lightDirection, builder }) => {
  const dotNL = normal2.dot(lightDirection);
  const coord = vec2(dotNL.mul(0.5).add(0.5), 0);
  if (builder.material.gradientMap) {
    const gradientMap = materialReference("gradientMap", "texture").context({ getUV: () => coord });
    return vec3(gradientMap.r);
  } else {
    const fw = coord.fwidth().mul(0.5);
    return mix2(vec3(0.7), vec3(1), smoothstep2(float(0.7).sub(fw.x), float(0.7).add(fw.x), coord.x));
  }
});
var ToonLightingModel = class extends LightingModel {
  /**
   * Implements the direct lighting. Instead of using a conventional smooth irradiance, the irradiance is
   * reduced to a small number of discrete shades to create a comic-like, flat look.
   *
   * @param {Object} lightData - The light data.
   * @param {NodeBuilder} builder - The current node builder.
   */
  direct({ lightDirection, lightColor, reflectedLight }, builder) {
    const irradiance = getGradientIrradiance({ normal: normalGeometry, lightDirection, builder }).mul(lightColor);
    reflectedLight.directDiffuse.addAssign(irradiance.mul(BRDF_Lambert({ diffuseColor: diffuseColor.rgb })));
  }
  /**
   * Implements the indirect lighting.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  indirect(builder) {
    const { ambientOcclusion, irradiance, reflectedLight } = builder.context;
    reflectedLight.indirectDiffuse.addAssign(irradiance.mul(BRDF_Lambert({ diffuseColor })));
    reflectedLight.indirectDiffuse.mulAssign(ambientOcclusion);
  }
};
var _defaultValues$4 = new MeshToonMaterial();
var MeshToonNodeMaterial = class extends NodeMaterial {
  static get type() {
    return "MeshToonNodeMaterial";
  }
  /**
   * Constructs a new mesh toon node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(parameters) {
    super();
    this.isMeshToonNodeMaterial = true;
    this.lights = true;
    this.setDefaultValues(_defaultValues$4);
    this.setValues(parameters);
  }
  /**
   * Setups the lighting model.
   *
   * @return {ToonLightingModel} The lighting model.
   */
  setupLightingModel() {
    return new ToonLightingModel();
  }
};
var matcapUV = Fn(() => {
  const x3 = vec3(positionViewDirection.z, 0, positionViewDirection.x.negate()).normalize();
  const y3 = positionViewDirection.cross(x3);
  return vec2(x3.dot(normalView), y3.dot(normalView)).mul(0.495).add(0.5);
}).once(["NORMAL", "VERTEX"])().toVar("matcapUV");
var _defaultValues$3 = new MeshMatcapMaterial();
var MeshMatcapNodeMaterial = class extends NodeMaterial {
  static get type() {
    return "MeshMatcapNodeMaterial";
  }
  /**
   * Constructs a new mesh normal node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(parameters) {
    super();
    this.isMeshMatcapNodeMaterial = true;
    this.setDefaultValues(_defaultValues$3);
    this.setValues(parameters);
  }
  /**
   * Setups the matcap specific node variables.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setupVariants(builder) {
    const uv2 = matcapUV;
    let matcapColor;
    if (builder.material.matcap) {
      matcapColor = materialReference("matcap", "texture").context({ getUV: () => uv2 });
    } else {
      matcapColor = vec3(mix2(0.2, 0.8, uv2.y));
    }
    diffuseColor.rgb.mulAssign(matcapColor.rgb);
  }
};
var RotateNode = class extends TempNode {
  static get type() {
    return "RotateNode";
  }
  /**
   * Constructs a new rotate node.
   *
   * @param {Node} positionNode - The position node.
   * @param {Node} rotationNode - Represents the rotation that is applied to the position node. Depending
   * on whether the position data are 2D or 3D, the rotation is expressed a single float value or an Euler value.
   */
  constructor(positionNode, rotationNode) {
    super();
    this.positionNode = positionNode;
    this.rotationNode = rotationNode;
  }
  /**
   * The type of the {@link RotateNode#positionNode} defines the node's type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node's type.
   */
  getNodeType(builder) {
    return this.positionNode.getNodeType(builder);
  }
  setup(builder) {
    const { rotationNode, positionNode } = this;
    const nodeType = this.getNodeType(builder);
    if (nodeType === "vec2") {
      const cosAngle = rotationNode.cos();
      const sinAngle = rotationNode.sin();
      const rotationMatrix = mat2(
        cosAngle,
        sinAngle,
        sinAngle.negate(),
        cosAngle
      );
      return rotationMatrix.mul(positionNode);
    } else {
      const rotation = rotationNode;
      const rotationXMatrix = mat4(vec4(1, 0, 0, 0), vec4(0, cos(rotation.x), sin(rotation.x).negate(), 0), vec4(0, sin(rotation.x), cos(rotation.x), 0), vec4(0, 0, 0, 1));
      const rotationYMatrix = mat4(vec4(cos(rotation.y), 0, sin(rotation.y), 0), vec4(0, 1, 0, 0), vec4(sin(rotation.y).negate(), 0, cos(rotation.y), 0), vec4(0, 0, 0, 1));
      const rotationZMatrix = mat4(vec4(cos(rotation.z), sin(rotation.z).negate(), 0, 0), vec4(sin(rotation.z), cos(rotation.z), 0, 0), vec4(0, 0, 1, 0), vec4(0, 0, 0, 1));
      return rotationXMatrix.mul(rotationYMatrix).mul(rotationZMatrix).mul(vec4(positionNode, 1)).xyz;
    }
  }
};
var rotate = nodeProxy(RotateNode).setParameterLength(2);
var _defaultValues$2 = new SpriteMaterial();
var SpriteNodeMaterial = class extends NodeMaterial {
  static get type() {
    return "SpriteNodeMaterial";
  }
  /**
   * Constructs a new sprite node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(parameters) {
    super();
    this.isSpriteNodeMaterial = true;
    this._useSizeAttenuation = true;
    this.positionNode = null;
    this.rotationNode = null;
    this.scaleNode = null;
    this.transparent = true;
    this.setDefaultValues(_defaultValues$2);
    this.setValues(parameters);
  }
  /**
   * Setups the position node in view space. This method implements
   * the sprite specific vertex shader.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec3>} The position in view space.
   */
  setupPositionView(builder) {
    const { object, camera: camera3 } = builder;
    const { positionNode, rotationNode, scaleNode, sizeAttenuation } = this;
    const mvPosition = modelViewMatrix.mul(vec3(positionNode || 0));
    let scale2 = vec2(modelWorldMatrix[0].xyz.length(), modelWorldMatrix[1].xyz.length());
    if (scaleNode !== null) {
      scale2 = scale2.mul(vec2(scaleNode));
    }
    if (camera3.isPerspectiveCamera && sizeAttenuation === false) {
      scale2 = scale2.mul(mvPosition.z.negate());
    }
    let alignedPosition = positionGeometry.xy;
    if (object.center && object.center.isVector2 === true) {
      const center = reference$1("center", "vec2", object);
      alignedPosition = alignedPosition.sub(center.sub(0.5));
    }
    alignedPosition = alignedPosition.mul(scale2);
    const rotation = float(rotationNode || materialRotation);
    const rotatedPosition = rotate(alignedPosition, rotation);
    return vec4(mvPosition.xy.add(rotatedPosition), mvPosition.zw);
  }
  copy(source) {
    this.positionNode = source.positionNode;
    this.rotationNode = source.rotationNode;
    this.scaleNode = source.scaleNode;
    return super.copy(source);
  }
  /**
   * Whether to use size attenuation or not.
   *
   * @type {boolean}
   * @default true
   */
  get sizeAttenuation() {
    return this._useSizeAttenuation;
  }
  set sizeAttenuation(value) {
    if (this._useSizeAttenuation !== value) {
      this._useSizeAttenuation = value;
      this.needsUpdate = true;
    }
  }
};
var _defaultValues$1 = new PointsMaterial();
var _size$4 = new Vector2();
var PointsNodeMaterial = class extends SpriteNodeMaterial {
  static get type() {
    return "PointsNodeMaterial";
  }
  /**
   * Constructs a new points node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(parameters) {
    super();
    this.sizeNode = null;
    this.isPointsNodeMaterial = true;
    this.setDefaultValues(_defaultValues$1);
    this.setValues(parameters);
  }
  setupPositionView() {
    const { positionNode } = this;
    return modelViewMatrix.mul(vec3(positionNode || positionLocal)).xyz;
  }
  setupVertexSprite(builder) {
    const { material, camera: camera3 } = builder;
    const { rotationNode, scaleNode, sizeNode, sizeAttenuation } = this;
    let mvp = super.setupVertex(builder);
    if (material.isNodeMaterial !== true) {
      return mvp;
    }
    let pointSize = sizeNode !== null ? vec2(sizeNode) : materialPointSize;
    pointSize = pointSize.mul(screenDPR);
    if (camera3.isPerspectiveCamera && sizeAttenuation === true) {
      pointSize = pointSize.mul(scale.div(positionView.z.negate()));
    }
    if (scaleNode && scaleNode.isNode) {
      pointSize = pointSize.mul(vec2(scaleNode));
    }
    let offset = positionGeometry.xy;
    if (rotationNode && rotationNode.isNode) {
      const rotation = float(rotationNode);
      offset = rotate(offset, rotation);
    }
    offset = offset.mul(pointSize);
    offset = offset.div(viewportSize.div(2));
    offset = offset.mul(mvp.w);
    mvp = mvp.add(vec4(offset, 0, 0));
    return mvp;
  }
  setupVertex(builder) {
    if (builder.object.isPoints) {
      return super.setupVertex(builder);
    } else {
      return this.setupVertexSprite(builder);
    }
  }
  /**
   * Whether alpha to coverage should be used or not.
   *
   * @type {boolean}
   * @default true
   */
  get alphaToCoverage() {
    return this._useAlphaToCoverage;
  }
  set alphaToCoverage(value) {
    if (this._useAlphaToCoverage !== value) {
      this._useAlphaToCoverage = value;
      this.needsUpdate = true;
    }
  }
};
var scale = uniform(1).onFrameUpdate(function({ renderer: renderer3 }) {
  const size2 = renderer3.getSize(_size$4);
  this.value = 0.5 * size2.y;
});
var ShadowMaskModel = class extends LightingModel {
  /**
   * Constructs a new shadow mask model.
   */
  constructor() {
    super();
    this.shadowNode = float(1).toVar("shadowMask");
  }
  /**
   * Only used to save the shadow mask.
   *
   * @param {Object} input - The input data.
   */
  direct({ lightNode }) {
    if (lightNode.shadowNode !== null) {
      this.shadowNode.mulAssign(lightNode.shadowNode);
    }
  }
  /**
   * Uses the shadow mask to produce the final color.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  finish({ context: context2 }) {
    diffuseColor.a.mulAssign(this.shadowNode.oneMinus());
    context2.outgoingLight.rgb.assign(diffuseColor.rgb);
  }
};
var _defaultValues = new ShadowMaterial();
var ShadowNodeMaterial = class extends NodeMaterial {
  static get type() {
    return "ShadowNodeMaterial";
  }
  /**
   * Constructs a new shadow node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(parameters) {
    super();
    this.isShadowNodeMaterial = true;
    this.lights = true;
    this.transparent = true;
    this.setDefaultValues(_defaultValues);
    this.setValues(parameters);
  }
  /**
   * Setups the lighting model.
   *
   * @return {ShadowMaskModel} The lighting model.
   */
  setupLightingModel() {
    return new ShadowMaskModel();
  }
};
var scatteringDensity = property("vec3");
var linearDepthRay = property("vec3");
var outgoingRayLight = property("vec3");
var Animation = class {
  /**
   * Constructs a new animation loop management component.
   *
   * @param {Renderer} renderer - A reference to the main renderer.
   * @param {Nodes} nodes - Renderer component for managing nodes related logic.
   * @param {Info} info - Renderer component for managing metrics and monitoring data.
   */
  constructor(renderer3, nodes, info) {
    this.renderer = renderer3;
    this.nodes = nodes;
    this.info = info;
    this._context = typeof self !== "undefined" ? self : null;
    this._animationLoop = null;
    this._requestId = null;
  }
  /**
   * Starts the internal animation loop.
   */
  start() {
    const update9 = (time3, xrFrame) => {
      this._requestId = this._context.requestAnimationFrame(update9);
      if (this.info.autoReset === true) this.info.reset();
      this.nodes.nodeFrame.update();
      this.info.frame = this.nodes.nodeFrame.frameId;
      this.renderer._inspector.begin();
      if (this._animationLoop !== null) this._animationLoop(time3, xrFrame);
      this.renderer._inspector.finish();
    };
    update9();
  }
  /**
   * Stops the internal animation loop.
   */
  stop() {
    this._context.cancelAnimationFrame(this._requestId);
    this._requestId = null;
  }
  /**
   * Returns the user-level animation loop.
   *
   * @return {?Function} The animation loop.
   */
  getAnimationLoop() {
    return this._animationLoop;
  }
  /**
   * Defines the user-level animation loop.
   *
   * @param {?Function} callback - The animation loop.
   */
  setAnimationLoop(callback) {
    this._animationLoop = callback;
  }
  /**
   * Returns the animation context.
   *
   * @return {Window|XRSession} The animation context.
   */
  getContext() {
    return this._context;
  }
  /**
   * Defines the context in which `requestAnimationFrame()` is executed.
   *
   * @param {Window|XRSession} context - The context to set.
   */
  setContext(context2) {
    this._context = context2;
  }
  /**
   * Frees all internal resources and stops the animation loop.
   */
  dispose() {
    this.stop();
  }
};
var ChainMap = class {
  /**
   * Constructs a new Chain Map.
   */
  constructor() {
    this.weakMaps = {};
  }
  /**
   * Returns the Weak Map for the given keys.
   *
   * @param {Array<Object>} keys - List of keys.
   * @return {WeakMap} The weak map.
   */
  _getWeakMap(keys2) {
    const length2 = keys2.length;
    let weakMap = this.weakMaps[length2];
    if (weakMap === void 0) {
      weakMap = /* @__PURE__ */ new WeakMap();
      this.weakMaps[length2] = weakMap;
    }
    return weakMap;
  }
  /**
   * Returns the value for the given array of keys.
   *
   * @param {Array<Object>} keys - List of keys.
   * @return {any} The value. Returns `undefined` if no value was found.
   */
  get(keys2) {
    let map6 = this._getWeakMap(keys2);
    for (let i2 = 0; i2 < keys2.length - 1; i2++) {
      map6 = map6.get(keys2[i2]);
      if (map6 === void 0) return void 0;
    }
    return map6.get(keys2[keys2.length - 1]);
  }
  /**
   * Sets the value for the given keys.
   *
   * @param {Array<Object>} keys - List of keys.
   * @param {any} value - The value to set.
   * @return {ChainMap} A reference to this Chain Map.
   */
  set(keys2, value) {
    let map6 = this._getWeakMap(keys2);
    for (let i2 = 0; i2 < keys2.length - 1; i2++) {
      const key = keys2[i2];
      if (map6.has(key) === false) map6.set(key, /* @__PURE__ */ new WeakMap());
      map6 = map6.get(key);
    }
    map6.set(keys2[keys2.length - 1], value);
    return this;
  }
  /**
   * Deletes a value for the given keys.
   *
   * @param {Array<Object>} keys - The keys.
   * @return {boolean} Returns `true` if the value has been removed successfully and `false` if the value has not be found.
   */
  delete(keys2) {
    let map6 = this._getWeakMap(keys2);
    for (let i2 = 0; i2 < keys2.length - 1; i2++) {
      map6 = map6.get(keys2[i2]);
      if (map6 === void 0) return false;
    }
    return map6.delete(keys2[keys2.length - 1]);
  }
};
var _id$a = 0;
function getKeys(obj) {
  const keys2 = Object.keys(obj);
  let proto2 = Object.getPrototypeOf(obj);
  while (proto2) {
    const descriptors = Object.getOwnPropertyDescriptors(proto2);
    for (const key in descriptors) {
      if (descriptors[key] !== void 0) {
        const descriptor = descriptors[key];
        if (descriptor && typeof descriptor.get === "function") {
          keys2.push(key);
        }
      }
    }
    proto2 = Object.getPrototypeOf(proto2);
  }
  return keys2;
}
var RenderObject = class {
  /**
   * Constructs a new render object.
   *
   * @param {Nodes} nodes - Renderer component for managing nodes related logic.
   * @param {Geometries} geometries - Renderer component for managing geometries.
   * @param {Renderer} renderer - The renderer.
   * @param {Object3D} object - The 3D object.
   * @param {Material} material - The 3D object's material.
   * @param {Scene} scene - The scene the 3D object belongs to.
   * @param {Camera} camera - The camera the object should be rendered with.
   * @param {LightsNode} lightsNode - The lights node.
   * @param {RenderContext} renderContext - The render context.
   * @param {ClippingContext} clippingContext - The clipping context.
   */
  constructor(nodes, geometries, renderer3, object, material, scene3, camera3, lightsNode, renderContext, clippingContext) {
    this.id = _id$a++;
    this._nodes = nodes;
    this._geometries = geometries;
    this.renderer = renderer3;
    this.object = object;
    this.material = material;
    this.scene = scene3;
    this.camera = camera3;
    this.lightsNode = lightsNode;
    this.context = renderContext;
    this.geometry = object.geometry;
    this.version = material.version;
    this.drawRange = null;
    this.attributes = null;
    this.attributesId = null;
    this.pipeline = null;
    this.group = null;
    this.vertexBuffers = null;
    this.drawParams = null;
    this.bundle = null;
    this.clippingContext = clippingContext;
    this.clippingContextCacheKey = clippingContext !== null ? clippingContext.cacheKey : "";
    this.initialNodesCacheKey = this.getDynamicCacheKey();
    this.initialCacheKey = this.getCacheKey();
    this._nodeBuilderState = null;
    this._bindings = null;
    this._monitor = null;
    this.onDispose = null;
    this.isRenderObject = true;
    this.onMaterialDispose = () => {
      this.dispose();
    };
    this.onGeometryDispose = () => {
      this.attributes = null;
      this.attributesId = null;
    };
    this.material.addEventListener("dispose", this.onMaterialDispose);
    this.geometry.addEventListener("dispose", this.onGeometryDispose);
  }
  /**
   * Updates the clipping context.
   *
   * @param {ClippingContext} context - The clipping context to set.
   */
  updateClipping(context2) {
    this.clippingContext = context2;
  }
  /**
   * Whether the clipping requires an update or not.
   *
   * @type {boolean}
   * @readonly
   */
  get clippingNeedsUpdate() {
    if (this.clippingContext === null || this.clippingContext.cacheKey === this.clippingContextCacheKey) return false;
    this.clippingContextCacheKey = this.clippingContext.cacheKey;
    return true;
  }
  /**
   * The number of clipping planes defined in context of hardware clipping.
   *
   * @type {number}
   * @readonly
   */
  get hardwareClippingPlanes() {
    return this.material.hardwareClipping === true ? this.clippingContext.unionClippingCount : 0;
  }
  /**
   * Returns the node builder state of this render object.
   *
   * @return {NodeBuilderState} The node builder state.
   */
  getNodeBuilderState() {
    return this._nodeBuilderState || (this._nodeBuilderState = this._nodes.getForRender(this));
  }
  /**
   * Returns the node material observer of this render object.
   *
   * @return {NodeMaterialObserver} The node material observer.
   */
  getMonitor() {
    return this._monitor || (this._monitor = this.getNodeBuilderState().observer);
  }
  /**
   * Returns an array of bind groups of this render object.
   *
   * @return {Array<BindGroup>} The bindings.
   */
  getBindings() {
    return this._bindings || (this._bindings = this.getNodeBuilderState().createBindings());
  }
  /**
   * Returns a binding group by group name of this render object.
   *
   * @param {string} name - The name of the binding group.
   * @return {?BindGroup} The bindings.
   */
  getBindingGroup(name) {
    for (const bindingGroup of this.getBindings()) {
      if (bindingGroup.name === name) {
        return bindingGroup;
      }
    }
  }
  /**
   * Returns the index of the render object's geometry.
   *
   * @return {?BufferAttribute} The index. Returns `null` for non-indexed geometries.
   */
  getIndex() {
    return this._geometries.getIndex(this);
  }
  /**
   * Returns the indirect buffer attribute.
   *
   * @return {?BufferAttribute} The indirect attribute. `null` if no indirect drawing is used.
   */
  getIndirect() {
    return this._geometries.getIndirect(this);
  }
  /**
   * Returns the byte offset into the indirect attribute buffer.
   *
   * @return {number|Array<number>} The byte offset into the indirect attribute buffer.
   */
  getIndirectOffset() {
    return this._geometries.getIndirectOffset(this);
  }
  /**
   * Returns an array that acts as a key for identifying the render object in a chain map.
   *
   * @return {Array<Object>} An array with object references.
   */
  getChainArray() {
    return [this.object, this.material, this.context, this.lightsNode];
  }
  /**
   * This method is used when the geometry of a 3D object has been exchanged and the
   * respective render object now requires an update.
   *
   * @param {BufferGeometry} geometry - The geometry to set.
   */
  setGeometry(geometry) {
    this.geometry = geometry;
    this.attributes = null;
    this.attributesId = null;
  }
  /**
   * Returns the buffer attributes of the render object. The returned array holds
   * attribute definitions on geometry and node level.
   *
   * @return {Array<BufferAttribute>} An array with buffer attributes.
   */
  getAttributes() {
    if (this.attributes !== null) return this.attributes;
    const nodeAttributes = this.getNodeBuilderState().nodeAttributes;
    const geometry = this.geometry;
    const attributes = [];
    const vertexBuffers = /* @__PURE__ */ new Set();
    const attributesId = {};
    for (const nodeAttribute of nodeAttributes) {
      let attribute2;
      if (nodeAttribute.node && nodeAttribute.node.attribute) {
        attribute2 = nodeAttribute.node.attribute;
      } else {
        attribute2 = geometry.getAttribute(nodeAttribute.name);
        attributesId[nodeAttribute.name] = attribute2.version;
      }
      if (attribute2 === void 0) continue;
      attributes.push(attribute2);
      const bufferAttribute2 = attribute2.isInterleavedBufferAttribute ? attribute2.data : attribute2;
      vertexBuffers.add(bufferAttribute2);
    }
    this.attributes = attributes;
    this.attributesId = attributesId;
    this.vertexBuffers = Array.from(vertexBuffers.values());
    return attributes;
  }
  /**
   * Returns the vertex buffers of the render object.
   *
   * @return {Array<BufferAttribute|InterleavedBuffer>} An array with buffer attribute or interleaved buffers.
   */
  getVertexBuffers() {
    if (this.vertexBuffers === null) this.getAttributes();
    return this.vertexBuffers;
  }
  /**
   * Returns the draw parameters for the render object.
   *
   * @return {?{vertexCount: number, firstVertex: number, instanceCount: number, firstInstance: number}} The draw parameters.
   */
  getDrawParameters() {
    const { object, material, geometry, group: group2, drawRange } = this;
    const drawParams = this.drawParams || (this.drawParams = {
      vertexCount: 0,
      firstVertex: 0,
      instanceCount: 0,
      firstInstance: 0
    });
    const index8 = this.getIndex();
    const hasIndex = index8 !== null;
    let instanceCount = 1;
    if (geometry.isInstancedBufferGeometry === true) {
      instanceCount = geometry.instanceCount;
    } else if (object.count !== void 0) {
      instanceCount = Math.max(0, object.count);
    }
    if (instanceCount === 0) return null;
    drawParams.instanceCount = instanceCount;
    if (object.isBatchedMesh === true) return drawParams;
    let rangeFactor = 1;
    if (material.wireframe === true && !object.isPoints && !object.isLineSegments && !object.isLine && !object.isLineLoop) {
      rangeFactor = 2;
    }
    let firstVertex = drawRange.start * rangeFactor;
    let lastVertex = (drawRange.start + drawRange.count) * rangeFactor;
    if (group2 !== null) {
      firstVertex = Math.max(firstVertex, group2.start * rangeFactor);
      lastVertex = Math.min(lastVertex, (group2.start + group2.count) * rangeFactor);
    }
    const position = geometry.attributes.position;
    let itemCount = Infinity;
    if (hasIndex) {
      itemCount = index8.count;
    } else if (position !== void 0 && position !== null) {
      itemCount = position.count;
    }
    firstVertex = Math.max(firstVertex, 0);
    lastVertex = Math.min(lastVertex, itemCount);
    const count2 = lastVertex - firstVertex;
    if (count2 < 0 || count2 === Infinity) return null;
    drawParams.vertexCount = count2;
    drawParams.firstVertex = firstVertex;
    return drawParams;
  }
  /**
   * Returns the render object's geometry cache key.
   *
   * The geometry cache key is part of the material cache key.
   *
   * @return {string} The geometry cache key.
   */
  getGeometryCacheKey() {
    const { geometry } = this;
    let cacheKey = "";
    for (const name of Object.keys(geometry.attributes).sort()) {
      const attribute2 = geometry.attributes[name];
      cacheKey += name + ",";
      if (attribute2.data) cacheKey += attribute2.data.stride + ",";
      if (attribute2.offset) cacheKey += attribute2.offset + ",";
      if (attribute2.itemSize) cacheKey += attribute2.itemSize + ",";
      if (attribute2.normalized) cacheKey += "n,";
    }
    for (const name of Object.keys(geometry.morphAttributes).sort()) {
      const targets = geometry.morphAttributes[name];
      cacheKey += "morph-" + name + ",";
      for (let i2 = 0, l2 = targets.length; i2 < l2; i2++) {
        const attribute2 = targets[i2];
        cacheKey += attribute2.id + ",";
      }
    }
    if (geometry.index) {
      cacheKey += "index,";
    }
    return cacheKey;
  }
  /**
   * Returns the render object's material cache key.
   *
   * The material cache key is part of the render object cache key.
   *
   * @return {number} The material cache key.
   */
  getMaterialCacheKey() {
    const { object, material, renderer: renderer3 } = this;
    let cacheKey = material.customProgramCacheKey();
    for (const property3 of getKeys(material)) {
      if (/^(is[A-Z]|_)|^(visible|version|uuid|name|opacity|userData)$/.test(property3)) continue;
      const value = material[property3];
      let valueKey;
      if (value !== null) {
        const type = typeof value;
        if (type === "number") {
          valueKey = value !== 0 ? "1" : "0";
        } else if (type === "object") {
          valueKey = "{";
          if (value.isTexture) {
            valueKey += value.mapping;
            if (renderer3.backend.isWebGPUBackend === true) {
              valueKey += value.magFilter;
              valueKey += value.minFilter;
              valueKey += value.wrapS;
              valueKey += value.wrapT;
              valueKey += value.wrapR;
            }
          }
          valueKey += "}";
        } else {
          valueKey = String(value);
        }
      } else {
        valueKey = String(value);
      }
      cacheKey += /*property + ':' +*/
      valueKey + ",";
    }
    cacheKey += this.clippingContextCacheKey + ",";
    if (object.geometry) {
      cacheKey += this.getGeometryCacheKey();
    }
    if (object.skeleton) {
      cacheKey += object.skeleton.bones.length + ",";
    }
    if (object.isBatchedMesh) {
      cacheKey += object._matricesTexture.uuid + ",";
      if (object._colorsTexture !== null) {
        cacheKey += object._colorsTexture.uuid + ",";
      }
    }
    if (object.isInstancedMesh || object.count > 1 || Array.isArray(object.morphTargetInfluences)) {
      cacheKey += object.uuid + ",";
    }
    cacheKey += this.context.id + ",";
    cacheKey += object.receiveShadow + ",";
    return hashString(cacheKey);
  }
  /**
   * Whether the geometry requires an update or not.
   *
   * @type {boolean}
   * @readonly
   */
  get needsGeometryUpdate() {
    if (this.geometry.id !== this.object.geometry.id) return true;
    if (this.attributes !== null) {
      const attributesId = this.attributesId;
      for (const name in attributesId) {
        const attribute2 = this.geometry.getAttribute(name);
        if (attribute2 === void 0 || attributesId[name] !== attribute2.id) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Whether the render object requires an update or not.
   *
   * Note: There are two distinct places where render objects are checked for an update.
   *
   * 1. In `RenderObjects.get()` which is executed when the render object is request. This
   * method checks the `needsUpdate` flag and recreates the render object if necessary.
   * 2. In `Renderer._renderObjectDirect()` right after getting the render object via
   * `RenderObjects.get()`. The render object's NodeMaterialObserver is then used to detect
   * a need for a refresh due to material, geometry or object related value changes.
   *
   * TODO: Investigate if it's possible to merge both steps so there is only a single place
   * that performs the 'needsUpdate' check.
   *
   * @type {boolean}
   * @readonly
   */
  get needsUpdate() {
    return (
      /*this.object.static !== true &&*/
      this.initialNodesCacheKey !== this.getDynamicCacheKey() || this.clippingNeedsUpdate
    );
  }
  /**
   * Returns the dynamic cache key which represents a key that is computed per draw command.
   *
   * @return {number} The cache key.
   */
  getDynamicCacheKey() {
    let cacheKey = 0;
    if (this.material.isShadowPassMaterial !== true) {
      cacheKey = this._nodes.getCacheKey(this.scene, this.lightsNode);
    }
    if (this.camera.isArrayCamera) {
      cacheKey = hash$1(cacheKey, this.camera.cameras.length);
    }
    if (this.object.receiveShadow) {
      cacheKey = hash$1(cacheKey, 1);
    }
    cacheKey = hash$1(cacheKey, this.camera.id, this.renderer.contextNode.id, this.renderer.contextNode.version);
    return cacheKey;
  }
  /**
   * Returns the render object's cache key.
   *
   * @return {number} The cache key.
   */
  getCacheKey() {
    return this.getMaterialCacheKey() + this.getDynamicCacheKey();
  }
  /**
   * Frees internal resources.
   */
  dispose() {
    this.material.removeEventListener("dispose", this.onMaterialDispose);
    this.geometry.removeEventListener("dispose", this.onGeometryDispose);
    this.onDispose();
  }
};
var _chainKeys$5 = [];
var RenderObjects = class {
  /**
   * Constructs a new render object management component.
   *
   * @param {Renderer} renderer - The renderer.
   * @param {Nodes} nodes - Renderer component for managing nodes related logic.
   * @param {Geometries} geometries - Renderer component for managing geometries.
   * @param {Pipelines} pipelines - Renderer component for managing pipelines.
   * @param {Bindings} bindings - Renderer component for managing bindings.
   * @param {Info} info - Renderer component for managing metrics and monitoring data.
   */
  constructor(renderer3, nodes, geometries, pipelines, bindings, info) {
    this.renderer = renderer3;
    this.nodes = nodes;
    this.geometries = geometries;
    this.pipelines = pipelines;
    this.bindings = bindings;
    this.info = info;
    this.chainMaps = {};
  }
  /**
   * Returns a render object for the given object and state data.
   *
   * @param {Object3D} object - The 3D object.
   * @param {Material} material - The 3D object's material.
   * @param {Scene} scene - The scene the 3D object belongs to.
   * @param {Camera} camera - The camera the 3D object should be rendered with.
   * @param {LightsNode} lightsNode - The lights node.
   * @param {RenderContext} renderContext - The render context.
   * @param {ClippingContext} clippingContext - The clipping context.
   * @param {string} [passId] - An optional ID for identifying the pass.
   * @return {RenderObject} The render object.
   */
  get(object, material, scene3, camera3, lightsNode, renderContext, clippingContext, passId) {
    const chainMap = this.getChainMap(passId);
    _chainKeys$5[0] = object;
    _chainKeys$5[1] = material;
    _chainKeys$5[2] = renderContext;
    _chainKeys$5[3] = lightsNode;
    let renderObject = chainMap.get(_chainKeys$5);
    if (renderObject === void 0) {
      renderObject = this.createRenderObject(this.nodes, this.geometries, this.renderer, object, material, scene3, camera3, lightsNode, renderContext, clippingContext, passId);
      chainMap.set(_chainKeys$5, renderObject);
    } else {
      renderObject.updateClipping(clippingContext);
      if (renderObject.needsGeometryUpdate) {
        renderObject.setGeometry(object.geometry);
      }
      if (renderObject.version !== material.version || renderObject.needsUpdate) {
        if (renderObject.initialCacheKey !== renderObject.getCacheKey()) {
          renderObject.dispose();
          renderObject = this.get(object, material, scene3, camera3, lightsNode, renderContext, clippingContext, passId);
        } else {
          renderObject.version = material.version;
        }
      }
    }
    _chainKeys$5.length = 0;
    return renderObject;
  }
  /**
   * Returns a chain map for the given pass ID.
   *
   * @param {string} [passId='default'] - The pass ID.
   * @return {ChainMap} The chain map.
   */
  getChainMap(passId = "default") {
    return this.chainMaps[passId] || (this.chainMaps[passId] = new ChainMap());
  }
  /**
   * Frees internal resources.
   */
  dispose() {
    this.chainMaps = {};
  }
  /**
   * Factory method for creating render objects with the given list of parameters.
   *
   * @param {Nodes} nodes - Renderer component for managing nodes related logic.
   * @param {Geometries} geometries - Renderer component for managing geometries.
   * @param {Renderer} renderer - The renderer.
   * @param {Object3D} object - The 3D object.
   * @param {Material} material - The object's material.
   * @param {Scene} scene - The scene the 3D object belongs to.
   * @param {Camera} camera - The camera the object should be rendered with.
   * @param {LightsNode} lightsNode - The lights node.
   * @param {RenderContext} renderContext - The render context.
   * @param {ClippingContext} clippingContext - The clipping context.
   * @param {string} [passId] - An optional ID for identifying the pass.
   * @return {RenderObject} The render object.
   */
  createRenderObject(nodes, geometries, renderer3, object, material, scene3, camera3, lightsNode, renderContext, clippingContext, passId) {
    const chainMap = this.getChainMap(passId);
    const renderObject = new RenderObject(nodes, geometries, renderer3, object, material, scene3, camera3, lightsNode, renderContext, clippingContext);
    renderObject.onDispose = () => {
      this.pipelines.delete(renderObject);
      this.bindings.deleteForRender(renderObject);
      this.nodes.delete(renderObject);
      chainMap.delete(renderObject.getChainArray());
    };
    return renderObject;
  }
};
var DataMap = class {
  /**
   * Constructs a new data map.
   */
  constructor() {
    this.data = /* @__PURE__ */ new WeakMap();
  }
  /**
   * Returns the dictionary for the given object.
   *
   * @param {Object} object - The object.
   * @return {Object} The dictionary.
   */
  get(object) {
    let map6 = this.data.get(object);
    if (map6 === void 0) {
      map6 = {};
      this.data.set(object, map6);
    }
    return map6;
  }
  /**
   * Deletes the dictionary for the given object.
   *
   * @param {Object} object - The object.
   * @return {?Object} The deleted dictionary.
   */
  delete(object) {
    let map6 = null;
    if (this.data.has(object)) {
      map6 = this.data.get(object);
      this.data.delete(object);
    }
    return map6;
  }
  /**
   * Returns `true` if the given object has a dictionary defined.
   *
   * @param {Object} object - The object to test.
   * @return {boolean} Whether a dictionary is defined or not.
   */
  has(object) {
    return this.data.has(object);
  }
  /**
   * Frees internal resources.
   */
  dispose() {
    this.data = /* @__PURE__ */ new WeakMap();
  }
};
var AttributeType = {
  VERTEX: 1,
  INDEX: 2,
  STORAGE: 3,
  INDIRECT: 4
};
var GPU_CHUNK_BYTES = 16;
var BlendColorFactor = 211;
var OneMinusBlendColorFactor = 212;
var Attributes = class extends DataMap {
  /**
   * Constructs a new attribute management component.
   *
   * @param {Backend} backend - The renderer's backend.
   */
  constructor(backend) {
    super();
    this.backend = backend;
  }
  /**
   * Deletes the data for the given attribute.
   *
   * @param {BufferAttribute} attribute - The attribute.
   * @return {?Object} The deleted attribute data.
   */
  delete(attribute2) {
    const attributeData = super.delete(attribute2);
    if (attributeData !== null) {
      this.backend.destroyAttribute(attribute2);
    }
    return attributeData;
  }
  /**
   * Updates the given attribute. This method creates attribute buffers
   * for new attributes and updates data for existing ones.
   *
   * @param {BufferAttribute} attribute - The attribute to update.
   * @param {number} type - The attribute type.
   */
  update(attribute2, type) {
    const data = this.get(attribute2);
    if (data.version === void 0) {
      if (type === AttributeType.VERTEX) {
        this.backend.createAttribute(attribute2);
      } else if (type === AttributeType.INDEX) {
        this.backend.createIndexAttribute(attribute2);
      } else if (type === AttributeType.STORAGE) {
        this.backend.createStorageAttribute(attribute2);
      } else if (type === AttributeType.INDIRECT) {
        this.backend.createIndirectStorageAttribute(attribute2);
      }
      data.version = this._getBufferAttribute(attribute2).version;
    } else {
      const bufferAttribute2 = this._getBufferAttribute(attribute2);
      if (data.version < bufferAttribute2.version || bufferAttribute2.usage === DynamicDrawUsage) {
        this.backend.updateAttribute(attribute2);
        data.version = bufferAttribute2.version;
      }
    }
  }
  /**
   * Utility method for handling interleaved buffer attributes correctly.
   * To process them, their `InterleavedBuffer` is returned.
   *
   * @param {BufferAttribute} attribute - The attribute.
   * @return {BufferAttribute|InterleavedBuffer}
   */
  _getBufferAttribute(attribute2) {
    if (attribute2.isInterleavedBufferAttribute) attribute2 = attribute2.data;
    return attribute2;
  }
};
function getWireframeVersion(geometry) {
  return geometry.index !== null ? geometry.index.version : geometry.attributes.position.version;
}
function getWireframeIndex(geometry) {
  const indices = [];
  const geometryIndex = geometry.index;
  const geometryPosition = geometry.attributes.position;
  if (geometryIndex !== null) {
    const array4 = geometryIndex.array;
    for (let i2 = 0, l2 = array4.length; i2 < l2; i2 += 3) {
      const a3 = array4[i2 + 0];
      const b = array4[i2 + 1];
      const c5 = array4[i2 + 2];
      indices.push(a3, b, b, c5, c5, a3);
    }
  } else {
    const array4 = geometryPosition.array;
    for (let i2 = 0, l2 = array4.length / 3 - 1; i2 < l2; i2 += 3) {
      const a3 = i2 + 0;
      const b = i2 + 1;
      const c5 = i2 + 2;
      indices.push(a3, b, b, c5, c5, a3);
    }
  }
  const attribute2 = new (arrayNeedsUint32(indices) ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
  attribute2.version = getWireframeVersion(geometry);
  return attribute2;
}
var Geometries2 = class extends DataMap {
  /**
   * Constructs a new geometry management component.
   *
   * @param {Attributes} attributes - Renderer component for managing attributes.
   * @param {Info} info - Renderer component for managing metrics and monitoring data.
   */
  constructor(attributes, info) {
    super();
    this.attributes = attributes;
    this.info = info;
    this.wireframes = /* @__PURE__ */ new WeakMap();
    this.attributeCall = /* @__PURE__ */ new WeakMap();
    this._geometryDisposeListeners = /* @__PURE__ */ new Map();
  }
  /**
   * Returns `true` if the given render object has an initialized geometry.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {boolean} Whether if the given render object has an initialized geometry or not.
   */
  has(renderObject) {
    const geometry = renderObject.geometry;
    return super.has(geometry) && this.get(geometry).initialized === true;
  }
  /**
   * Prepares the geometry of the given render object for rendering.
   *
   * @param {RenderObject} renderObject - The render object.
   */
  updateForRender(renderObject) {
    if (this.has(renderObject) === false) this.initGeometry(renderObject);
    this.updateAttributes(renderObject);
  }
  /**
   * Initializes the geometry of the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   */
  initGeometry(renderObject) {
    const geometry = renderObject.geometry;
    const geometryData = this.get(geometry);
    geometryData.initialized = true;
    this.info.memory.geometries++;
    const onDispose = () => {
      this.info.memory.geometries--;
      const index8 = geometry.index;
      const geometryAttributes = renderObject.getAttributes();
      if (index8 !== null) {
        this.attributes.delete(index8);
      }
      for (const geometryAttribute of geometryAttributes) {
        this.attributes.delete(geometryAttribute);
      }
      const wireframeAttribute = this.wireframes.get(geometry);
      if (wireframeAttribute !== void 0) {
        this.attributes.delete(wireframeAttribute);
      }
      geometry.removeEventListener("dispose", onDispose);
      this._geometryDisposeListeners.delete(geometry);
    };
    geometry.addEventListener("dispose", onDispose);
    this._geometryDisposeListeners.set(geometry, onDispose);
  }
  /**
   * Updates the geometry attributes of the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   */
  updateAttributes(renderObject) {
    const attributes = renderObject.getAttributes();
    for (const attribute2 of attributes) {
      if (attribute2.isStorageBufferAttribute || attribute2.isStorageInstancedBufferAttribute) {
        this.updateAttribute(attribute2, AttributeType.STORAGE);
      } else {
        this.updateAttribute(attribute2, AttributeType.VERTEX);
      }
    }
    const index8 = this.getIndex(renderObject);
    if (index8 !== null) {
      this.updateAttribute(index8, AttributeType.INDEX);
    }
    const indirect = renderObject.geometry.indirect;
    if (indirect !== null) {
      this.updateAttribute(indirect, AttributeType.INDIRECT);
    }
  }
  /**
   * Updates the given attribute.
   *
   * @param {BufferAttribute} attribute - The attribute to update.
   * @param {number} type - The attribute type.
   */
  updateAttribute(attribute2, type) {
    const callId = this.info.render.calls;
    if (!attribute2.isInterleavedBufferAttribute) {
      if (this.attributeCall.get(attribute2) !== callId) {
        this.attributes.update(attribute2, type);
        this.attributeCall.set(attribute2, callId);
      }
    } else {
      if (this.attributeCall.get(attribute2) === void 0) {
        this.attributes.update(attribute2, type);
        this.attributeCall.set(attribute2, callId);
      } else if (this.attributeCall.get(attribute2.data) !== callId) {
        this.attributes.update(attribute2, type);
        this.attributeCall.set(attribute2.data, callId);
        this.attributeCall.set(attribute2, callId);
      }
    }
  }
  /**
   * Returns the indirect buffer attribute of the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {?BufferAttribute} The indirect attribute. `null` if no indirect drawing is used.
   */
  getIndirect(renderObject) {
    return renderObject.geometry.indirect;
  }
  /**
   * Returns the byte offset into the indirect attribute buffer of the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {number} The byte offset into the indirect attribute buffer.
   */
  getIndirectOffset(renderObject) {
    return renderObject.geometry.indirectOffset;
  }
  /**
   * Returns the index of the given render object's geometry. This is implemented
   * in a method to return a wireframe index if necessary.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {?BufferAttribute} The index. Returns `null` for non-indexed geometries.
   */
  getIndex(renderObject) {
    const { geometry, material } = renderObject;
    let index8 = geometry.index;
    if (material.wireframe === true) {
      const wireframes = this.wireframes;
      let wireframeAttribute = wireframes.get(geometry);
      if (wireframeAttribute === void 0) {
        wireframeAttribute = getWireframeIndex(geometry);
        wireframes.set(geometry, wireframeAttribute);
      } else if (wireframeAttribute.version !== getWireframeVersion(geometry)) {
        this.attributes.delete(wireframeAttribute);
        wireframeAttribute = getWireframeIndex(geometry);
        wireframes.set(geometry, wireframeAttribute);
      }
      index8 = wireframeAttribute;
    }
    return index8;
  }
  dispose() {
    for (const [geometry, onDispose] of this._geometryDisposeListeners.entries()) {
      geometry.removeEventListener("dispose", onDispose);
    }
    this._geometryDisposeListeners.clear();
  }
};
var Info = class {
  /**
   * Constructs a new info component.
   */
  constructor() {
    this.autoReset = true;
    this.frame = 0;
    this.calls = 0;
    this.render = {
      calls: 0,
      frameCalls: 0,
      drawCalls: 0,
      triangles: 0,
      points: 0,
      lines: 0,
      timestamp: 0
    };
    this.compute = {
      calls: 0,
      frameCalls: 0,
      timestamp: 0
    };
    this.memory = {
      geometries: 0,
      textures: 0
    };
  }
  /**
   * This method should be executed per draw call and updates the corresponding metrics.
   *
   * @param {Object3D} object - The 3D object that is going to be rendered.
   * @param {number} count - The vertex or index count.
   * @param {number} instanceCount - The instance count.
   */
  update(object, count2, instanceCount) {
    this.render.drawCalls++;
    if (object.isMesh || object.isSprite) {
      this.render.triangles += instanceCount * (count2 / 3);
    } else if (object.isPoints) {
      this.render.points += instanceCount * count2;
    } else if (object.isLineSegments) {
      this.render.lines += instanceCount * (count2 / 2);
    } else if (object.isLine) {
      this.render.lines += instanceCount * (count2 - 1);
    } else {
      error("WebGPUInfo: Unknown object type.");
    }
  }
  /**
   * Resets frame related metrics.
   */
  reset() {
    this.render.drawCalls = 0;
    this.render.frameCalls = 0;
    this.compute.frameCalls = 0;
    this.render.triangles = 0;
    this.render.points = 0;
    this.render.lines = 0;
  }
  /**
   * Performs a complete reset of the object.
   */
  dispose() {
    this.reset();
    this.calls = 0;
    this.render.calls = 0;
    this.compute.calls = 0;
    this.render.timestamp = 0;
    this.compute.timestamp = 0;
    this.memory.geometries = 0;
    this.memory.textures = 0;
  }
};
var Pipeline = class {
  /**
   * Constructs a new pipeline.
   *
   * @param {string} cacheKey - The pipeline's cache key.
   */
  constructor(cacheKey) {
    this.cacheKey = cacheKey;
    this.usedTimes = 0;
  }
};
var RenderPipeline = class extends Pipeline {
  /**
   * Constructs a new render pipeline.
   *
   * @param {string} cacheKey - The pipeline's cache key.
   * @param {ProgrammableStage} vertexProgram - The pipeline's vertex shader.
   * @param {ProgrammableStage} fragmentProgram - The pipeline's fragment shader.
   */
  constructor(cacheKey, vertexProgram, fragmentProgram) {
    super(cacheKey);
    this.vertexProgram = vertexProgram;
    this.fragmentProgram = fragmentProgram;
  }
};
var ComputePipeline = class extends Pipeline {
  /**
   * Constructs a new render pipeline.
   *
   * @param {string} cacheKey - The pipeline's cache key.
   * @param {ProgrammableStage} computeProgram - The pipeline's compute shader.
   */
  constructor(cacheKey, computeProgram) {
    super(cacheKey);
    this.computeProgram = computeProgram;
    this.isComputePipeline = true;
  }
};
var _id$9 = 0;
var ProgrammableStage = class {
  /**
   * Constructs a new programmable stage.
   *
   * @param {string} code - The shader code.
   * @param {('vertex'|'fragment'|'compute')} stage - The type of stage.
   * @param {string} name - The name of the shader.
   * @param {?Array<Object>} [transforms=null] - The transforms (only relevant for compute stages with WebGL 2 which uses Transform Feedback).
   * @param {?Array<Object>} [attributes=null] - The attributes (only relevant for compute stages with WebGL 2 which uses Transform Feedback).
   */
  constructor(code2, stage, name, transforms = null, attributes = null) {
    this.id = _id$9++;
    this.code = code2;
    this.stage = stage;
    this.name = name;
    this.transforms = transforms;
    this.attributes = attributes;
    this.usedTimes = 0;
  }
};
var Pipelines = class extends DataMap {
  /**
   * Constructs a new pipeline management component.
   *
   * @param {Backend} backend - The renderer's backend.
   * @param {Nodes} nodes - Renderer component for managing nodes related logic.
   */
  constructor(backend, nodes) {
    super();
    this.backend = backend;
    this.nodes = nodes;
    this.bindings = null;
    this.caches = /* @__PURE__ */ new Map();
    this.programs = {
      vertex: /* @__PURE__ */ new Map(),
      fragment: /* @__PURE__ */ new Map(),
      compute: /* @__PURE__ */ new Map()
    };
  }
  /**
   * Returns a compute pipeline for the given compute node.
   *
   * @param {Node} computeNode - The compute node.
   * @param {Array<BindGroup>} bindings - The bindings.
   * @return {ComputePipeline} The compute pipeline.
   */
  getForCompute(computeNode, bindings) {
    const { backend } = this;
    const data = this.get(computeNode);
    if (this._needsComputeUpdate(computeNode)) {
      const previousPipeline = data.pipeline;
      if (previousPipeline) {
        previousPipeline.usedTimes--;
        previousPipeline.computeProgram.usedTimes--;
      }
      const nodeBuilderState = this.nodes.getForCompute(computeNode);
      let stageCompute = this.programs.compute.get(nodeBuilderState.computeShader);
      if (stageCompute === void 0) {
        if (previousPipeline && previousPipeline.computeProgram.usedTimes === 0) this._releaseProgram(previousPipeline.computeProgram);
        stageCompute = new ProgrammableStage(nodeBuilderState.computeShader, "compute", computeNode.name, nodeBuilderState.transforms, nodeBuilderState.nodeAttributes);
        this.programs.compute.set(nodeBuilderState.computeShader, stageCompute);
        backend.createProgram(stageCompute);
      }
      const cacheKey = this._getComputeCacheKey(computeNode, stageCompute);
      let pipeline = this.caches.get(cacheKey);
      if (pipeline === void 0) {
        if (previousPipeline && previousPipeline.usedTimes === 0) this._releasePipeline(previousPipeline);
        pipeline = this._getComputePipeline(computeNode, stageCompute, cacheKey, bindings);
      }
      pipeline.usedTimes++;
      stageCompute.usedTimes++;
      data.version = computeNode.version;
      data.pipeline = pipeline;
    }
    return data.pipeline;
  }
  /**
   * Returns a render pipeline for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @param {?Array<Promise>} [promises=null] - An array of compilation promises which is only relevant in context of `Renderer.compileAsync()`.
   * @return {RenderPipeline} The render pipeline.
   */
  getForRender(renderObject, promises = null) {
    const { backend } = this;
    const data = this.get(renderObject);
    if (this._needsRenderUpdate(renderObject)) {
      const previousPipeline = data.pipeline;
      if (previousPipeline) {
        previousPipeline.usedTimes--;
        previousPipeline.vertexProgram.usedTimes--;
        previousPipeline.fragmentProgram.usedTimes--;
      }
      const nodeBuilderState = renderObject.getNodeBuilderState();
      const name = renderObject.material ? renderObject.material.name : "";
      let stageVertex = this.programs.vertex.get(nodeBuilderState.vertexShader);
      if (stageVertex === void 0) {
        if (previousPipeline && previousPipeline.vertexProgram.usedTimes === 0) this._releaseProgram(previousPipeline.vertexProgram);
        stageVertex = new ProgrammableStage(nodeBuilderState.vertexShader, "vertex", name);
        this.programs.vertex.set(nodeBuilderState.vertexShader, stageVertex);
        backend.createProgram(stageVertex);
      }
      let stageFragment = this.programs.fragment.get(nodeBuilderState.fragmentShader);
      if (stageFragment === void 0) {
        if (previousPipeline && previousPipeline.fragmentProgram.usedTimes === 0) this._releaseProgram(previousPipeline.fragmentProgram);
        stageFragment = new ProgrammableStage(nodeBuilderState.fragmentShader, "fragment", name);
        this.programs.fragment.set(nodeBuilderState.fragmentShader, stageFragment);
        backend.createProgram(stageFragment);
      }
      const cacheKey = this._getRenderCacheKey(renderObject, stageVertex, stageFragment);
      let pipeline = this.caches.get(cacheKey);
      if (pipeline === void 0) {
        if (previousPipeline && previousPipeline.usedTimes === 0) this._releasePipeline(previousPipeline);
        pipeline = this._getRenderPipeline(renderObject, stageVertex, stageFragment, cacheKey, promises);
      } else {
        renderObject.pipeline = pipeline;
      }
      pipeline.usedTimes++;
      stageVertex.usedTimes++;
      stageFragment.usedTimes++;
      data.pipeline = pipeline;
    }
    return data.pipeline;
  }
  /**
   * Deletes the pipeline for the given render object.
   *
   * @param {RenderObject} object - The render object.
   * @return {?Object} The deleted dictionary.
   */
  delete(object) {
    const pipeline = this.get(object).pipeline;
    if (pipeline) {
      pipeline.usedTimes--;
      if (pipeline.usedTimes === 0) this._releasePipeline(pipeline);
      if (pipeline.isComputePipeline) {
        pipeline.computeProgram.usedTimes--;
        if (pipeline.computeProgram.usedTimes === 0) this._releaseProgram(pipeline.computeProgram);
      } else {
        pipeline.fragmentProgram.usedTimes--;
        pipeline.vertexProgram.usedTimes--;
        if (pipeline.vertexProgram.usedTimes === 0) this._releaseProgram(pipeline.vertexProgram);
        if (pipeline.fragmentProgram.usedTimes === 0) this._releaseProgram(pipeline.fragmentProgram);
      }
    }
    return super.delete(object);
  }
  /**
   * Frees internal resources.
   */
  dispose() {
    super.dispose();
    this.caches = /* @__PURE__ */ new Map();
    this.programs = {
      vertex: /* @__PURE__ */ new Map(),
      fragment: /* @__PURE__ */ new Map(),
      compute: /* @__PURE__ */ new Map()
    };
  }
  /**
   * Updates the pipeline for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   */
  updateForRender(renderObject) {
    this.getForRender(renderObject);
  }
  /**
   * Returns a compute pipeline for the given parameters.
   *
   * @private
   * @param {Node} computeNode - The compute node.
   * @param {ProgrammableStage} stageCompute - The programmable stage representing the compute shader.
   * @param {string} cacheKey - The cache key.
   * @param {Array<BindGroup>} bindings - The bindings.
   * @return {ComputePipeline} The compute pipeline.
   */
  _getComputePipeline(computeNode, stageCompute, cacheKey, bindings) {
    cacheKey = cacheKey || this._getComputeCacheKey(computeNode, stageCompute);
    let pipeline = this.caches.get(cacheKey);
    if (pipeline === void 0) {
      pipeline = new ComputePipeline(cacheKey, stageCompute);
      this.caches.set(cacheKey, pipeline);
      this.backend.createComputePipeline(pipeline, bindings);
    }
    return pipeline;
  }
  /**
   * Returns a render pipeline for the given parameters.
   *
   * @private
   * @param {RenderObject} renderObject - The render object.
   * @param {ProgrammableStage} stageVertex - The programmable stage representing the vertex shader.
   * @param {ProgrammableStage} stageFragment - The programmable stage representing the fragment shader.
   * @param {string} cacheKey - The cache key.
   * @param {?Array<Promise>} promises - An array of compilation promises which is only relevant in context of `Renderer.compileAsync()`.
   * @return {ComputePipeline} The compute pipeline.
   */
  _getRenderPipeline(renderObject, stageVertex, stageFragment, cacheKey, promises) {
    cacheKey = cacheKey || this._getRenderCacheKey(renderObject, stageVertex, stageFragment);
    let pipeline = this.caches.get(cacheKey);
    if (pipeline === void 0) {
      pipeline = new RenderPipeline(cacheKey, stageVertex, stageFragment);
      this.caches.set(cacheKey, pipeline);
      renderObject.pipeline = pipeline;
      this.backend.createRenderPipeline(renderObject, promises);
    }
    return pipeline;
  }
  /**
   * Computes a cache key representing a compute pipeline.
   *
   * @private
   * @param {Node} computeNode - The compute node.
   * @param {ProgrammableStage} stageCompute - The programmable stage representing the compute shader.
   * @return {string} The cache key.
   */
  _getComputeCacheKey(computeNode, stageCompute) {
    return computeNode.id + "," + stageCompute.id;
  }
  /**
   * Computes a cache key representing a render pipeline.
   *
   * @private
   * @param {RenderObject} renderObject - The render object.
   * @param {ProgrammableStage} stageVertex - The programmable stage representing the vertex shader.
   * @param {ProgrammableStage} stageFragment - The programmable stage representing the fragment shader.
   * @return {string} The cache key.
   */
  _getRenderCacheKey(renderObject, stageVertex, stageFragment) {
    return stageVertex.id + "," + stageFragment.id + "," + this.backend.getRenderCacheKey(renderObject);
  }
  /**
   * Releases the given pipeline.
   *
   * @private
   * @param {Pipeline} pipeline - The pipeline to release.
   */
  _releasePipeline(pipeline) {
    this.caches.delete(pipeline.cacheKey);
  }
  /**
   * Releases the shader program.
   *
   * @private
   * @param {Object} program - The shader program to release.
   */
  _releaseProgram(program) {
    const code2 = program.code;
    const stage = program.stage;
    this.programs[stage].delete(code2);
  }
  /**
   * Returns `true` if the compute pipeline for the given compute node requires an update.
   *
   * @private
   * @param {Node} computeNode - The compute node.
   * @return {boolean} Whether the compute pipeline for the given compute node requires an update or not.
   */
  _needsComputeUpdate(computeNode) {
    const data = this.get(computeNode);
    return data.pipeline === void 0 || data.version !== computeNode.version;
  }
  /**
   * Returns `true` if the render pipeline for the given render object requires an update.
   *
   * @private
   * @param {RenderObject} renderObject - The render object.
   * @return {boolean} Whether the render object for the given render object requires an update or not.
   */
  _needsRenderUpdate(renderObject) {
    const data = this.get(renderObject);
    return data.pipeline === void 0 || this.backend.needsRenderUpdate(renderObject);
  }
};
var Bindings = class extends DataMap {
  /**
   * Constructs a new bindings management component.
   *
   * @param {Backend} backend - The renderer's backend.
   * @param {Nodes} nodes - Renderer component for managing nodes related logic.
   * @param {Textures} textures - Renderer component for managing textures.
   * @param {Attributes} attributes - Renderer component for managing attributes.
   * @param {Pipelines} pipelines - Renderer component for managing pipelines.
   * @param {Info} info - Renderer component for managing metrics and monitoring data.
   */
  constructor(backend, nodes, textures, attributes, pipelines, info) {
    super();
    this.backend = backend;
    this.textures = textures;
    this.pipelines = pipelines;
    this.attributes = attributes;
    this.nodes = nodes;
    this.info = info;
    this.pipelines.bindings = this;
  }
  /**
   * Returns the bind groups for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {Array<BindGroup>} The bind groups.
   */
  getForRender(renderObject) {
    const bindings = renderObject.getBindings();
    for (const bindGroup of bindings) {
      const groupData = this.get(bindGroup);
      if (groupData.bindGroup === void 0) {
        this._init(bindGroup);
        this.backend.createBindings(bindGroup, bindings, 0);
        groupData.bindGroup = bindGroup;
      }
    }
    return bindings;
  }
  /**
   * Returns the bind groups for the given compute node.
   *
   * @param {Node} computeNode - The compute node.
   * @return {Array<BindGroup>} The bind groups.
   */
  getForCompute(computeNode) {
    const bindings = this.nodes.getForCompute(computeNode).bindings;
    for (const bindGroup of bindings) {
      const groupData = this.get(bindGroup);
      if (groupData.bindGroup === void 0) {
        this._init(bindGroup);
        this.backend.createBindings(bindGroup, bindings, 0);
        groupData.bindGroup = bindGroup;
      }
    }
    return bindings;
  }
  /**
   * Updates the bindings for the given compute node.
   *
   * @param {Node} computeNode - The compute node.
   */
  updateForCompute(computeNode) {
    this._updateBindings(this.getForCompute(computeNode));
  }
  /**
   * Updates the bindings for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   */
  updateForRender(renderObject) {
    this._updateBindings(this.getForRender(renderObject));
  }
  /**
   * Deletes the bindings for the given compute node.
   *
   * @param {Node} computeNode - The compute node.
   */
  deleteForCompute(computeNode) {
    const bindings = this.nodes.getForCompute(computeNode).bindings;
    for (const bindGroup of bindings) {
      this.backend.deleteBindGroupData(bindGroup);
      this.delete(bindGroup);
    }
  }
  /**
   * Deletes the bindings for the given renderObject node.
   *
   * @param {RenderObject} renderObject - The renderObject.
   */
  deleteForRender(renderObject) {
    const bindings = renderObject.getBindings();
    for (const bindGroup of bindings) {
      this.backend.deleteBindGroupData(bindGroup);
      this.delete(bindGroup);
    }
  }
  /**
   * Updates the given array of bindings.
   *
   * @param {Array<BindGroup>} bindings - The bind groups.
   */
  _updateBindings(bindings) {
    for (const bindGroup of bindings) {
      this._update(bindGroup, bindings);
    }
  }
  /**
   * Initializes the given bind group.
   *
   * @param {BindGroup} bindGroup - The bind group to initialize.
   */
  _init(bindGroup) {
    for (const binding of bindGroup.bindings) {
      if (binding.isSampledTexture) {
        this.textures.updateTexture(binding.texture);
      } else if (binding.isSampler) {
        this.textures.updateSampler(binding.texture);
      } else if (binding.isStorageBuffer) {
        const attribute2 = binding.attribute;
        const attributeType = attribute2.isIndirectStorageBufferAttribute ? AttributeType.INDIRECT : AttributeType.STORAGE;
        this.attributes.update(attribute2, attributeType);
      }
    }
  }
  /**
   * Updates the given bind group.
   *
   * @param {BindGroup} bindGroup - The bind group to update.
   * @param {Array<BindGroup>} bindings - The bind groups.
   */
  _update(bindGroup, bindings) {
    const { backend } = this;
    let needsBindingsUpdate = false;
    let cacheBindings = true;
    let cacheIndex = 0;
    let version = 0;
    for (const binding of bindGroup.bindings) {
      const updatedGroup = this.nodes.updateGroup(binding);
      if (updatedGroup === false) continue;
      if (binding.isStorageBuffer) {
        const attribute2 = binding.attribute;
        const attributeType = attribute2.isIndirectStorageBufferAttribute ? AttributeType.INDIRECT : AttributeType.STORAGE;
        this.attributes.update(attribute2, attributeType);
      }
      if (binding.isUniformBuffer) {
        const updated = binding.update();
        if (updated) {
          backend.updateBinding(binding);
        }
      } else if (binding.isSampledTexture) {
        const updated = binding.update();
        const texture2 = binding.texture;
        const texturesTextureData = this.textures.get(texture2);
        if (updated) {
          this.textures.updateTexture(texture2);
          if (binding.generation !== texturesTextureData.generation) {
            binding.generation = texturesTextureData.generation;
            needsBindingsUpdate = true;
            cacheBindings = false;
          }
        }
        const textureData = backend.get(texture2);
        if (textureData.externalTexture !== void 0 || texturesTextureData.isDefaultTexture) {
          cacheBindings = false;
        } else {
          cacheIndex = cacheIndex * 10 + texture2.id;
          version += texture2.version;
        }
        if (texture2.isStorageTexture === true && texture2.mipmapsAutoUpdate === true) {
          const textureData2 = this.get(texture2);
          if (binding.store === true) {
            textureData2.needsMipmap = true;
          } else if (this.textures.needsMipmaps(texture2) && textureData2.needsMipmap === true) {
            this.backend.generateMipmaps(texture2);
            textureData2.needsMipmap = false;
          }
        }
      } else if (binding.isSampler) {
        const updated = binding.update();
        if (updated) {
          const samplerKey = this.textures.updateSampler(binding.texture);
          if (binding.samplerKey !== samplerKey) {
            binding.samplerKey = samplerKey;
            needsBindingsUpdate = true;
            cacheBindings = false;
          }
        }
      }
    }
    if (needsBindingsUpdate === true) {
      this.backend.updateBindings(bindGroup, bindings, cacheBindings ? cacheIndex : 0, version);
    }
  }
};
function painterSortStable(a3, b) {
  if (a3.groupOrder !== b.groupOrder) {
    return a3.groupOrder - b.groupOrder;
  } else if (a3.renderOrder !== b.renderOrder) {
    return a3.renderOrder - b.renderOrder;
  } else if (a3.z !== b.z) {
    return a3.z - b.z;
  } else {
    return a3.id - b.id;
  }
}
function reversePainterSortStable(a3, b) {
  if (a3.groupOrder !== b.groupOrder) {
    return a3.groupOrder - b.groupOrder;
  } else if (a3.renderOrder !== b.renderOrder) {
    return a3.renderOrder - b.renderOrder;
  } else if (a3.z !== b.z) {
    return b.z - a3.z;
  } else {
    return a3.id - b.id;
  }
}
function needsDoublePass(material) {
  const hasTransmission = material.transmission > 0 || material.transmissionNode && material.transmissionNode.isNode;
  return hasTransmission && material.side === DoubleSide && material.forceSinglePass === false;
}
var RenderList = class {
  /**
   * Constructs a render list.
   *
   * @param {Lighting} lighting - The lighting management component.
   * @param {Scene} scene - The scene.
   * @param {Camera} camera - The camera the scene is rendered with.
   */
  constructor(lighting, scene3, camera3) {
    this.renderItems = [];
    this.renderItemsIndex = 0;
    this.opaque = [];
    this.transparentDoublePass = [];
    this.transparent = [];
    this.bundles = [];
    this.lightsNode = lighting.getNode(scene3, camera3);
    this.lightsArray = [];
    this.scene = scene3;
    this.camera = camera3;
    this.occlusionQueryCount = 0;
  }
  /**
   * This method is called right at the beginning of a render call
   * before the scene is analyzed. It prepares the internal data
   * structures for the upcoming render lists generation.
   *
   * @return {RenderList} A reference to this render list.
   */
  begin() {
    this.renderItemsIndex = 0;
    this.opaque.length = 0;
    this.transparentDoublePass.length = 0;
    this.transparent.length = 0;
    this.bundles.length = 0;
    this.lightsArray.length = 0;
    this.occlusionQueryCount = 0;
    return this;
  }
  /**
   * Returns a render item for the giving render item state. The state is defined
   * by a series of object-related parameters.
   *
   * The method avoids object creation by holding render items and reusing them in
   * subsequent render calls (just with different property values).
   *
   * @param {Object3D} object - The 3D object.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} material - The 3D object's material.
   * @param {number} groupOrder - The current group order.
   * @param {number} z - Th 3D object's depth value (z value in clip space).
   * @param {?number} group - {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
   * @param {ClippingContext} clippingContext - The current clipping context.
   * @return {Object} The render item.
   */
  getNextRenderItem(object, geometry, material, groupOrder, z3, group2, clippingContext) {
    let renderItem = this.renderItems[this.renderItemsIndex];
    if (renderItem === void 0) {
      renderItem = {
        id: object.id,
        object,
        geometry,
        material,
        groupOrder,
        renderOrder: object.renderOrder,
        z: z3,
        group: group2,
        clippingContext
      };
      this.renderItems[this.renderItemsIndex] = renderItem;
    } else {
      renderItem.id = object.id;
      renderItem.object = object;
      renderItem.geometry = geometry;
      renderItem.material = material;
      renderItem.groupOrder = groupOrder;
      renderItem.renderOrder = object.renderOrder;
      renderItem.z = z3;
      renderItem.group = group2;
      renderItem.clippingContext = clippingContext;
    }
    this.renderItemsIndex++;
    return renderItem;
  }
  /**
   * Pushes the given object as a render item to the internal render lists.
   * The selected lists depend on the object properties.
   *
   * @param {Object3D} object - The 3D object.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} material - The 3D object's material.
   * @param {number} groupOrder - The current group order.
   * @param {number} z - Th 3D object's depth value (z value in clip space).
   * @param {?number} group - {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
   * @param {ClippingContext} clippingContext - The current clipping context.
   */
  push(object, geometry, material, groupOrder, z3, group2, clippingContext) {
    const renderItem = this.getNextRenderItem(object, geometry, material, groupOrder, z3, group2, clippingContext);
    if (object.occlusionTest === true) this.occlusionQueryCount++;
    if (material.transparent === true || material.transmission > 0 || material.transmissionNode && material.transmissionNode.isNode || material.backdropNode && material.backdropNode.isNode) {
      if (needsDoublePass(material)) this.transparentDoublePass.push(renderItem);
      this.transparent.push(renderItem);
    } else {
      this.opaque.push(renderItem);
    }
  }
  /**
   * Inserts the given object as a render item at the start of the internal render lists.
   * The selected lists depend on the object properties.
   *
   * @param {Object3D} object - The 3D object.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} material - The 3D object's material.
   * @param {number} groupOrder - The current group order.
   * @param {number} z - Th 3D object's depth value (z value in clip space).
   * @param {?number} group - {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
   * @param {ClippingContext} clippingContext - The current clipping context.
   */
  unshift(object, geometry, material, groupOrder, z3, group2, clippingContext) {
    const renderItem = this.getNextRenderItem(object, geometry, material, groupOrder, z3, group2, clippingContext);
    if (material.transparent === true || material.transmission > 0 || material.transmissionNode && material.transmissionNode.isNode || material.backdropNode && material.backdropNode.isNode) {
      if (needsDoublePass(material)) this.transparentDoublePass.unshift(renderItem);
      this.transparent.unshift(renderItem);
    } else {
      this.opaque.unshift(renderItem);
    }
  }
  /**
   * Pushes render bundle group data into the render list.
   *
   * @param {Object} group - Bundle group data.
   */
  pushBundle(group2) {
    this.bundles.push(group2);
  }
  /**
   * Pushes a light into the render list.
   *
   * @param {Light} light - The light.
   */
  pushLight(light) {
    this.lightsArray.push(light);
  }
  /**
   * Sorts the internal render lists.
   *
   * @param {?function(any, any): number} customOpaqueSort - A custom sort function for opaque objects.
   * @param {?function(any, any): number} customTransparentSort -  A custom sort function for transparent objects.
   */
  sort(customOpaqueSort, customTransparentSort) {
    if (this.opaque.length > 1) this.opaque.sort(customOpaqueSort || painterSortStable);
    if (this.transparentDoublePass.length > 1) this.transparentDoublePass.sort(customTransparentSort || reversePainterSortStable);
    if (this.transparent.length > 1) this.transparent.sort(customTransparentSort || reversePainterSortStable);
  }
  /**
   * This method performs finalizing tasks right after the render lists
   * have been generated.
   */
  finish() {
    this.lightsNode.setLights(this.lightsArray);
    for (let i2 = this.renderItemsIndex, il = this.renderItems.length; i2 < il; i2++) {
      const renderItem = this.renderItems[i2];
      if (renderItem.id === null) break;
      renderItem.id = null;
      renderItem.object = null;
      renderItem.geometry = null;
      renderItem.material = null;
      renderItem.groupOrder = null;
      renderItem.renderOrder = null;
      renderItem.z = null;
      renderItem.group = null;
      renderItem.clippingContext = null;
    }
  }
};
var _chainKeys$4 = [];
var RenderLists = class {
  /**
   * Constructs a render lists management component.
   *
   * @param {Lighting} lighting - The lighting management component.
   */
  constructor(lighting) {
    this.lighting = lighting;
    this.lists = new ChainMap();
  }
  /**
   * Returns a render list for the given scene and camera.
   *
   * @param {Scene} scene - The scene.
   * @param {Camera} camera - The camera.
   * @return {RenderList} The render list.
   */
  get(scene3, camera3) {
    const lists = this.lists;
    _chainKeys$4[0] = scene3;
    _chainKeys$4[1] = camera3;
    let list = lists.get(_chainKeys$4);
    if (list === void 0) {
      list = new RenderList(this.lighting, scene3, camera3);
      lists.set(_chainKeys$4, list);
    }
    _chainKeys$4.length = 0;
    return list;
  }
  /**
   * Frees all internal resources.
   */
  dispose() {
    this.lists = new ChainMap();
  }
};
var _id$8 = 0;
var RenderContext = class {
  /**
   * Constructs a new render context.
   */
  constructor() {
    this.id = _id$8++;
    this.color = true;
    this.clearColor = true;
    this.clearColorValue = { r: 0, g: 0, b: 0, a: 1 };
    this.depth = true;
    this.clearDepth = true;
    this.clearDepthValue = 1;
    this.stencil = false;
    this.clearStencil = true;
    this.clearStencilValue = 1;
    this.viewport = false;
    this.viewportValue = new Vector4();
    this.scissor = false;
    this.scissorValue = new Vector4();
    this.renderTarget = null;
    this.textures = null;
    this.depthTexture = null;
    this.activeCubeFace = 0;
    this.activeMipmapLevel = 0;
    this.sampleCount = 1;
    this.width = 0;
    this.height = 0;
    this.occlusionQueryCount = 0;
    this.clippingContext = null;
    this.isRenderContext = true;
  }
  /**
   * Returns the cache key of this render context.
   *
   * @return {number} The cache key.
   */
  getCacheKey() {
    return getCacheKey(this);
  }
};
function getCacheKey(renderContext) {
  const { textures, activeCubeFace, activeMipmapLevel } = renderContext;
  const values2 = [activeCubeFace, activeMipmapLevel];
  for (const texture2 of textures) {
    values2.push(texture2.id);
  }
  return hashArray(values2);
}
var _chainKeys$3 = [];
var _defaultScene = new Scene();
var _defaultCamera = new Camera();
var RenderContexts = class {
  /**
   * Constructs a new render context management component.
   */
  constructor() {
    this.chainMaps = {};
  }
  /**
   * Returns a render context for the given scene, camera and render target.
   *
   * @param {Scene} scene - The scene.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {?RenderTarget} [renderTarget=null] - The active render target.
   * @param {?MRT} [mrt=null] - The active multiple render target.
   * @return {RenderContext} The render context.
   */
  get(scene3, camera3, renderTarget = null, mrt2 = null) {
    _chainKeys$3[0] = scene3;
    _chainKeys$3[1] = camera3;
    if (mrt2 !== null) {
      _chainKeys$3[2] = mrt2;
    }
    let attachmentState;
    if (renderTarget === null) {
      attachmentState = "default";
    } else {
      const format3 = renderTarget.texture.format;
      const count2 = renderTarget.textures.length;
      attachmentState = `${count2}:${format3}:${renderTarget.samples}:${renderTarget.depthBuffer}:${renderTarget.stencilBuffer}`;
    }
    const chainMap = this._getChainMap(attachmentState);
    let renderState = chainMap.get(_chainKeys$3);
    if (renderState === void 0) {
      renderState = new RenderContext();
      chainMap.set(_chainKeys$3, renderState);
    }
    _chainKeys$3.length = 0;
    if (renderTarget !== null) renderState.sampleCount = renderTarget.samples === 0 ? 1 : renderTarget.samples;
    return renderState;
  }
  /**
   * Returns a render context intended for clear operations.
   *
   * @param {?RenderTarget} [renderTarget=null] - The active render target.
   * @return {RenderContext} The render context.
   */
  getForClear(renderTarget = null) {
    return this.get(_defaultScene, _defaultCamera, renderTarget);
  }
  /**
   * Returns a chain map for the given attachment state.
   *
   * @private
   * @param {string} attachmentState - The attachment state.
   * @return {ChainMap} The chain map.
   */
  _getChainMap(attachmentState) {
    return this.chainMaps[attachmentState] || (this.chainMaps[attachmentState] = new ChainMap());
  }
  /**
   * Frees internal resources.
   */
  dispose() {
    this.chainMaps = {};
  }
};
var _size$3 = new Vector3();
var Textures = class extends DataMap {
  /**
   * Constructs a new texture management component.
   *
   * @param {Renderer} renderer - The renderer.
   * @param {Backend} backend - The renderer's backend.
   * @param {Info} info - Renderer component for managing metrics and monitoring data.
   */
  constructor(renderer3, backend, info) {
    super();
    this.renderer = renderer3;
    this.backend = backend;
    this.info = info;
  }
  /**
   * Updates the given render target. Based on the given render target configuration,
   * it updates the texture states representing the attachments of the framebuffer.
   *
   * @param {RenderTarget} renderTarget - The render target to update.
   * @param {number} [activeMipmapLevel=0] - The active mipmap level.
   */
  updateRenderTarget(renderTarget, activeMipmapLevel = 0) {
    const renderTargetData = this.get(renderTarget);
    const sampleCount = renderTarget.samples === 0 ? 1 : renderTarget.samples;
    const depthTextureMips = renderTargetData.depthTextureMips || (renderTargetData.depthTextureMips = {});
    const textures = renderTarget.textures;
    const size2 = this.getSize(textures[0]);
    const mipWidth = size2.width >> activeMipmapLevel;
    const mipHeight = size2.height >> activeMipmapLevel;
    let depthTexture = renderTarget.depthTexture || depthTextureMips[activeMipmapLevel];
    const useDepthTexture = renderTarget.depthBuffer === true || renderTarget.stencilBuffer === true;
    let textureNeedsUpdate = false;
    if (depthTexture === void 0 && useDepthTexture) {
      depthTexture = new DepthTexture();
      depthTexture.format = renderTarget.stencilBuffer ? DepthStencilFormat : DepthFormat;
      depthTexture.type = renderTarget.stencilBuffer ? UnsignedInt248Type : UnsignedIntType;
      depthTexture.image.width = mipWidth;
      depthTexture.image.height = mipHeight;
      depthTexture.image.depth = size2.depth;
      depthTexture.renderTarget = renderTarget;
      depthTexture.isArrayTexture = renderTarget.multiview === true && size2.depth > 1;
      depthTextureMips[activeMipmapLevel] = depthTexture;
    }
    if (renderTargetData.width !== size2.width || size2.height !== renderTargetData.height) {
      textureNeedsUpdate = true;
      if (depthTexture) {
        depthTexture.needsUpdate = true;
        depthTexture.image.width = mipWidth;
        depthTexture.image.height = mipHeight;
        depthTexture.image.depth = depthTexture.isArrayTexture ? depthTexture.image.depth : 1;
      }
    }
    renderTargetData.width = size2.width;
    renderTargetData.height = size2.height;
    renderTargetData.textures = textures;
    renderTargetData.depthTexture = depthTexture || null;
    renderTargetData.depth = renderTarget.depthBuffer;
    renderTargetData.stencil = renderTarget.stencilBuffer;
    renderTargetData.renderTarget = renderTarget;
    if (renderTargetData.sampleCount !== sampleCount) {
      textureNeedsUpdate = true;
      if (depthTexture) {
        depthTexture.needsUpdate = true;
      }
      renderTargetData.sampleCount = sampleCount;
    }
    const options = { sampleCount };
    if (renderTarget.isXRRenderTarget !== true) {
      for (let i2 = 0; i2 < textures.length; i2++) {
        const texture2 = textures[i2];
        if (textureNeedsUpdate) texture2.needsUpdate = true;
        this.updateTexture(texture2, options);
      }
      if (depthTexture) {
        this.updateTexture(depthTexture, options);
      }
    }
    if (renderTargetData.initialized !== true) {
      renderTargetData.initialized = true;
      renderTargetData.onDispose = () => {
        this._destroyRenderTarget(renderTarget);
      };
      renderTarget.addEventListener("dispose", renderTargetData.onDispose);
    }
  }
  /**
   * Updates the given texture. Depending on the texture state, this method
   * triggers the upload of texture data to the GPU memory. If the texture data are
   * not yet ready for the upload, it uses default texture data for as a placeholder.
   *
   * @param {Texture} texture - The texture to update.
   * @param {Object} [options={}] - The options.
   */
  updateTexture(texture2, options = {}) {
    const textureData = this.get(texture2);
    if (textureData.initialized === true && textureData.version === texture2.version) return;
    const isRenderTarget = texture2.isRenderTargetTexture || texture2.isDepthTexture || texture2.isFramebufferTexture;
    const backend = this.backend;
    if (isRenderTarget && textureData.initialized === true) {
      backend.destroyTexture(texture2);
    }
    if (texture2.isFramebufferTexture) {
      const renderTarget = this.renderer.getRenderTarget();
      if (renderTarget) {
        texture2.type = renderTarget.texture.type;
      } else {
        texture2.type = UnsignedByteType;
      }
    }
    const { width, height, depth: depth2 } = this.getSize(texture2);
    options.width = width;
    options.height = height;
    options.depth = depth2;
    options.needsMipmaps = this.needsMipmaps(texture2);
    options.levels = options.needsMipmaps ? this.getMipLevels(texture2, width, height) : 1;
    if (texture2.isCubeTexture && texture2.mipmaps.length > 0) options.levels++;
    if (isRenderTarget || texture2.isStorageTexture === true || texture2.isExternalTexture === true) {
      backend.createTexture(texture2, options);
      textureData.generation = texture2.version;
    } else {
      if (texture2.version > 0) {
        const image = texture2.image;
        if (image === void 0) {
          warn("Renderer: Texture marked for update but image is undefined.");
        } else if (image.complete === false) {
          warn("Renderer: Texture marked for update but image is incomplete.");
        } else {
          if (texture2.images) {
            const images = [];
            for (const image2 of texture2.images) {
              images.push(image2);
            }
            options.images = images;
          } else {
            options.image = image;
          }
          if (textureData.isDefaultTexture === void 0 || textureData.isDefaultTexture === true) {
            backend.createTexture(texture2, options);
            textureData.isDefaultTexture = false;
            textureData.generation = texture2.version;
          }
          if (texture2.source.dataReady === true) backend.updateTexture(texture2, options);
          const skipAutoGeneration = texture2.isStorageTexture === true && texture2.mipmapsAutoUpdate === false;
          if (options.needsMipmaps && texture2.mipmaps.length === 0 && !skipAutoGeneration) {
            backend.generateMipmaps(texture2);
          }
          if (texture2.onUpdate) texture2.onUpdate(texture2);
        }
      } else {
        backend.createDefaultTexture(texture2);
        textureData.isDefaultTexture = true;
        textureData.generation = texture2.version;
      }
    }
    if (textureData.initialized !== true) {
      textureData.initialized = true;
      textureData.generation = texture2.version;
      this.info.memory.textures++;
      if (texture2.isVideoTexture && ColorManagement.enabled === true && ColorManagement.getTransfer(texture2.colorSpace) !== SRGBTransfer) {
        warn("WebGPURenderer: Video textures must use a color space with a sRGB transfer function, e.g. SRGBColorSpace.");
      }
      textureData.onDispose = () => {
        this._destroyTexture(texture2);
      };
      texture2.addEventListener("dispose", textureData.onDispose);
    }
    textureData.version = texture2.version;
  }
  /**
   * Updates the sampler for the given texture. This method has no effect
   * for the WebGL backend since it has no concept of samplers. Texture
   * parameters are configured with the `texParameter()` command for each
   * texture.
   *
   * In WebGPU, samplers are objects like textures and it's possible to share
   * them when the texture parameters match.
   *
   * @param {Texture} texture - The texture to update the sampler for.
   * @return {string} The current sampler key.
   */
  updateSampler(texture2) {
    return this.backend.updateSampler(texture2);
  }
  /**
   * Computes the size of the given texture and writes the result
   * into the target vector. This vector is also returned by the
   * method.
   *
   * If no texture data are available for the compute yet, the method
   * returns default size values.
   *
   * @param {Texture} texture - The texture to compute the size for.
   * @param {Vector3} target - The target vector.
   * @return {Vector3} The target vector.
   */
  getSize(texture2, target = _size$3) {
    let image = texture2.images ? texture2.images[0] : texture2.image;
    if (image) {
      if (image.image !== void 0) image = image.image;
      if (typeof HTMLVideoElement !== "undefined" && image instanceof HTMLVideoElement) {
        target.width = image.videoWidth || 1;
        target.height = image.videoHeight || 1;
        target.depth = 1;
      } else if (typeof VideoFrame !== "undefined" && image instanceof VideoFrame) {
        target.width = image.displayWidth || 1;
        target.height = image.displayHeight || 1;
        target.depth = 1;
      } else {
        target.width = image.width || 1;
        target.height = image.height || 1;
        target.depth = texture2.isCubeTexture ? 6 : image.depth || 1;
      }
    } else {
      target.width = target.height = target.depth = 1;
    }
    return target;
  }
  /**
   * Computes the number of mipmap levels for the given texture.
   *
   * @param {Texture} texture - The texture.
   * @param {number} width - The texture's width.
   * @param {number} height - The texture's height.
   * @return {number} The number of mipmap levels.
   */
  getMipLevels(texture2, width, height) {
    let mipLevelCount;
    if (texture2.mipmaps.length > 0) {
      mipLevelCount = texture2.mipmaps.length;
    } else {
      if (texture2.isCompressedTexture === true) {
        mipLevelCount = 1;
      } else {
        mipLevelCount = Math.floor(Math.log2(Math.max(width, height))) + 1;
      }
    }
    return mipLevelCount;
  }
  /**
   * Returns `true` if the given texture makes use of mipmapping.
   *
   * @param {Texture} texture - The texture.
   * @return {boolean} Whether mipmaps are required or not.
   */
  needsMipmaps(texture2) {
    return texture2.generateMipmaps === true || texture2.mipmaps.length > 0;
  }
  /**
   * Frees internal resources when the given render target isn't
   * required anymore.
   *
   * @param {RenderTarget} renderTarget - The render target to destroy.
   */
  _destroyRenderTarget(renderTarget) {
    if (this.has(renderTarget) === true) {
      const renderTargetData = this.get(renderTarget);
      const textures = renderTargetData.textures;
      const depthTexture = renderTargetData.depthTexture;
      renderTarget.removeEventListener("dispose", renderTargetData.onDispose);
      for (let i2 = 0; i2 < textures.length; i2++) {
        this._destroyTexture(textures[i2]);
      }
      if (depthTexture) {
        this._destroyTexture(depthTexture);
      }
      this.delete(renderTarget);
      this.backend.delete(renderTarget);
    }
  }
  /**
   * Frees internal resource when the given texture isn't
   * required anymore.
   *
   * @param {Texture} texture - The texture to destroy.
   */
  _destroyTexture(texture2) {
    if (this.has(texture2) === true) {
      const textureData = this.get(texture2);
      texture2.removeEventListener("dispose", textureData.onDispose);
      const isDefaultTexture = textureData.isDefaultTexture;
      this.backend.destroyTexture(texture2, isDefaultTexture);
      this.delete(texture2);
      this.info.memory.textures--;
    }
  }
};
var Color4 = class extends Color {
  /**
   * Constructs a new four-component color.
   * You can also pass a single THREE.Color, hex or
   * string argument to this constructor.
   *
   * @param {number|string} [r=1] - The red value.
   * @param {number} [g=1] - The green value.
   * @param {number} [b=1] - The blue value.
   * @param {number} [a=1] - The alpha value.
   */
  constructor(r2, g3, b, a3 = 1) {
    super(r2, g3, b);
    this.a = a3;
  }
  /**
   * Overwrites the default to honor alpha.
   * You can also pass a single THREE.Color, hex or
   * string argument to this method.
   *
   * @param {number|string|Color} r - The red value.
   * @param {number} [g] - The green value.
   * @param {number} [b] - The blue value.
   * @param {number} [a=1] - The alpha value.
   * @return {Color4} A reference to this object.
   */
  set(r2, g3, b, a3 = 1) {
    this.a = a3;
    return super.set(r2, g3, b);
  }
  /**
   * Overwrites the default to honor alpha.
   *
   * @param {Color4} color - The color to copy.
   * @return {Color4} A reference to this object.
   */
  copy(color3) {
    if (color3.a !== void 0) this.a = color3.a;
    return super.copy(color3);
  }
  /**
   * Overwrites the default to honor alpha.
   *
   * @return {Color4} The cloned color.
   */
  clone() {
    return new this.constructor(this.r, this.g, this.b, this.a);
  }
};
var ParameterNode = class extends PropertyNode {
  static get type() {
    return "ParameterNode";
  }
  /**
   * Constructs a new parameter node.
   *
   * @param {string} nodeType - The type of the node.
   * @param {?string} [name=null] - The name of the parameter in the shader.
   */
  constructor(nodeType, name = null) {
    super(nodeType, name);
    this.isParameterNode = true;
  }
  /**
   * Gets the type of a member variable in the parameter node.
   *
   * @param {NodeBuilder} builder - The node builder.
   * @param {string} name - The name of the member variable.
   * @returns {string}
   */
  getMemberType(builder, name) {
    const type = this.getNodeType(builder);
    const struct2 = builder.getStructTypeNode(type);
    let memberType;
    if (struct2 !== null) {
      memberType = struct2.getMemberType(builder, name);
    } else {
      error(`TSL: Member "${name}" not found in struct "${type}".`);
      memberType = "float";
    }
    return memberType;
  }
  getHash() {
    return this.uuid;
  }
  generate() {
    return this.name;
  }
};
var parameter = (type, name) => new ParameterNode(type, name);
var StackNode = class extends Node4 {
  static get type() {
    return "StackNode";
  }
  /**
   * Constructs a new stack node.
   *
   * @param {?StackNode} [parent=null] - The parent stack node.
   */
  constructor(parent2 = null) {
    super();
    this.nodes = [];
    this.outputNode = null;
    this.parent = parent2;
    this._currentCond = null;
    this._expressionNode = null;
    this._currentNode = null;
    this.isStackNode = true;
  }
  getElementType(builder) {
    return this.hasOutput ? this.outputNode.getElementType(builder) : "void";
  }
  getNodeType(builder) {
    return this.hasOutput ? this.outputNode.getNodeType(builder) : "void";
  }
  getMemberType(builder, name) {
    return this.hasOutput ? this.outputNode.getMemberType(builder, name) : "void";
  }
  /**
   * Adds a node to this stack.
   *
   * @param {Node} node - The node to add.
   * @param {number} [index=this.nodes.length] - The index where the node should be added.
   * @return {StackNode} A reference to this stack node.
   */
  addToStack(node, index8 = this.nodes.length) {
    if (node.isNode !== true) {
      error("TSL: Invalid node added to stack.");
      return this;
    }
    this.nodes.splice(index8, 0, node);
    return this;
  }
  /**
   * Adds a node to the stack before the current node.
   *
   * @param {Node} node - The node to add.
   * @return {StackNode} A reference to this stack node.
   */
  addToStackBefore(node) {
    const index8 = this._currentNode ? this.nodes.indexOf(this._currentNode) : 0;
    return this.addToStack(node, index8);
  }
  /**
   * Represent an `if` statement in TSL.
   *
   * @param {Node} boolNode - Represents the condition.
   * @param {Function} method - TSL code which is executed if the condition evaluates to `true`.
   * @return {StackNode} A reference to this stack node.
   */
  If(boolNode, method2) {
    const methodNode = new ShaderNode(method2);
    this._currentCond = select(boolNode, methodNode);
    return this.addToStack(this._currentCond);
  }
  /**
   * Represent an `elseif` statement in TSL.
   *
   * @param {Node} boolNode - Represents the condition.
   * @param {Function} method - TSL code which is executed if the condition evaluates to `true`.
   * @return {StackNode} A reference to this stack node.
   */
  ElseIf(boolNode, method2) {
    const methodNode = new ShaderNode(method2);
    const ifNode = select(boolNode, methodNode);
    this._currentCond.elseNode = ifNode;
    this._currentCond = ifNode;
    return this;
  }
  /**
   * Represent an `else` statement in TSL.
   *
   * @param {Function} method - TSL code which is executed in the `else` case.
   * @return {StackNode} A reference to this stack node.
   */
  Else(method2) {
    this._currentCond.elseNode = new ShaderNode(method2);
    return this;
  }
  /**
   * Represents a `switch` statement in TSL.
   *
   * @param {any} expression - Represents the expression.
   * @param {Function} method - TSL code which is executed if the condition evaluates to `true`.
   * @return {StackNode} A reference to this stack node.
   */
  Switch(expression2) {
    this._expressionNode = nodeObject(expression2);
    return this;
  }
  /**
   * Represents a `case` statement in TSL. The TSL version accepts an arbitrary numbers of values.
   * The last parameter must be the callback method that should be executed in the `true` case.
   *
   * @param {...any} params - The values of the `Case()` statement as well as the callback method.
   * @return {StackNode} A reference to this stack node.
   */
  Case(...params) {
    const caseNodes = [];
    if (params.length >= 2) {
      for (let i2 = 0; i2 < params.length - 1; i2++) {
        caseNodes.push(this._expressionNode.equal(nodeObject(params[i2])));
      }
    } else {
      error("TSL: Invalid parameter length. Case() requires at least two parameters.");
    }
    const method2 = params[params.length - 1];
    const methodNode = new ShaderNode(method2);
    let caseNode = caseNodes[0];
    for (let i2 = 1; i2 < caseNodes.length; i2++) {
      caseNode = caseNode.or(caseNodes[i2]);
    }
    const condNode = select(caseNode, methodNode);
    if (this._currentCond === null) {
      this._currentCond = condNode;
      return this.addToStack(this._currentCond);
    } else {
      this._currentCond.elseNode = condNode;
      this._currentCond = condNode;
      return this;
    }
  }
  /**
   * Represents the default code block of a Switch/Case statement.
   *
   * @param {Function} method - TSL code which is executed in the `else` case.
   * @return {StackNode} A reference to this stack node.
   */
  Default(method2) {
    this.Else(method2);
    return this;
  }
  setup(builder) {
    const nodeProperties = builder.getNodeProperties(this);
    let index8 = 0;
    for (const childNode of this.getChildren()) {
      if (childNode.isVarNode && childNode.isIntent(builder)) {
        if (childNode.isAssign(builder) !== true) {
          continue;
        }
      }
      nodeProperties["node" + index8++] = childNode;
    }
    return nodeProperties.outputNode || null;
  }
  get hasOutput() {
    return this.outputNode && this.outputNode.isNode;
  }
  build(builder, ...params) {
    const previousStack = getCurrentStack();
    const buildStage = builder.buildStage;
    setCurrentStack(this);
    builder.setActiveStack(this);
    const buildNode = (node) => {
      this._currentNode = node;
      if (node.isVarNode && node.isIntent(builder)) {
        if (node.isAssign(builder) !== true) {
          return;
        }
      }
      if (buildStage === "setup") {
        node.build(builder);
      } else if (buildStage === "analyze") {
        node.build(builder, this);
      } else if (buildStage === "generate") {
        const stages = builder.getDataFromNode(node, "any").stages;
        const parents = stages && stages[builder.shaderStage];
        if (node.isVarNode && parents && parents.length === 1 && parents[0] && parents[0].isStackNode) {
          return;
        }
        node.build(builder, "void");
      }
    };
    const nodes = [...this.nodes];
    for (const node of nodes) {
      buildNode(node);
    }
    this._currentNode = null;
    const newNodes = this.nodes.filter((node) => nodes.indexOf(node) === -1);
    for (const node of newNodes) {
      buildNode(node);
    }
    let result2;
    if (this.hasOutput) {
      result2 = this.outputNode.build(builder, ...params);
    } else {
      result2 = super.build(builder, ...params);
    }
    setCurrentStack(previousStack);
    builder.removeActiveStack(this);
    return result2;
  }
};
var stack = nodeProxy(StackNode).setParameterLength(0, 1);
function getMembersLayout(members) {
  return Object.entries(members).map(([name, value]) => {
    if (typeof value === "string") {
      return { name, type: value, atomic: false };
    }
    return { name, type: value.type, atomic: value.atomic || false };
  });
}
var StructTypeNode = class extends Node4 {
  static get type() {
    return "StructTypeNode";
  }
  /**
   * Creates an instance of StructTypeNode.
   *
   * @param {Object} membersLayout - The layout of the members for the struct.
   * @param {?string} [name=null] - The optional name of the struct.
   */
  constructor(membersLayout, name = null) {
    super("struct");
    this.membersLayout = getMembersLayout(membersLayout);
    this.name = name;
    this.isStructLayoutNode = true;
  }
  /**
   * Returns the length of the struct.
   * The length is calculated by summing the lengths of the struct's members.
   *
   * @returns {number} The length of the struct.
   */
  getLength() {
    const BYTES_PER_ELEMENT = Float32Array.BYTES_PER_ELEMENT;
    let maxAlignment = 1;
    let offset = 0;
    for (const member of this.membersLayout) {
      const type = member.type;
      const itemSize = getMemoryLengthFromType(type);
      const alignment = getAlignmentFromType(type) / BYTES_PER_ELEMENT;
      maxAlignment = Math.max(maxAlignment, alignment);
      const chunkOffset = offset % maxAlignment;
      const overhang = chunkOffset % alignment;
      if (overhang !== 0) {
        offset += alignment - overhang;
      }
      offset += itemSize;
    }
    return Math.ceil(offset / maxAlignment) * maxAlignment;
  }
  getMemberType(builder, name) {
    const member = this.membersLayout.find((m3) => m3.name === name);
    return member ? member.type : "void";
  }
  getNodeType(builder) {
    const structType = builder.getStructTypeFromNode(this, this.membersLayout, this.name);
    return structType.name;
  }
  setup(builder) {
    builder.getStructTypeFromNode(this, this.membersLayout, this.name);
    builder.addInclude(this);
  }
  generate(builder) {
    return this.getNodeType(builder);
  }
};
var StructNode = class extends Node4 {
  static get type() {
    return "StructNode";
  }
  constructor(structTypeNode, values2) {
    super("vec3");
    this.structTypeNode = structTypeNode;
    this.values = values2;
    this.isStructNode = true;
  }
  getNodeType(builder) {
    return this.structTypeNode.getNodeType(builder);
  }
  getMemberType(builder, name) {
    return this.structTypeNode.getMemberType(builder, name);
  }
  generate(builder) {
    const nodeVar = builder.getVarFromNode(this);
    const structType = nodeVar.type;
    const propertyName = builder.getPropertyName(nodeVar);
    builder.addLineFlowCode(`${propertyName} = ${builder.generateStruct(structType, this.structTypeNode.membersLayout, this.values)}`, this);
    return nodeVar.name;
  }
};
var struct = (membersLayout, name = null) => {
  const structLayout = new StructTypeNode(membersLayout, name);
  const struct2 = (...params) => {
    let values2 = null;
    if (params.length > 0) {
      if (params[0].isNode) {
        values2 = {};
        const names2 = Object.keys(membersLayout);
        for (let i2 = 0; i2 < params.length; i2++) {
          values2[names2[i2]] = params[i2];
        }
      } else {
        values2 = params[0];
      }
    }
    return new StructNode(structLayout, values2);
  };
  struct2.layout = structLayout;
  struct2.isStruct = true;
  return struct2;
};
var OutputStructNode = class extends Node4 {
  static get type() {
    return "OutputStructNode";
  }
  /**
   * Constructs a new output struct node. The constructor can be invoked with an
   * arbitrary number of nodes representing the members.
   *
   * @param {...Node} members - A parameter list of nodes.
   */
  constructor(...members) {
    super();
    this.members = members;
    this.isOutputStructNode = true;
  }
  getNodeType(builder) {
    const properties = builder.getNodeProperties(this);
    if (properties.membersLayout === void 0) {
      const members = this.members;
      const membersLayout = [];
      for (let i2 = 0; i2 < members.length; i2++) {
        const name = "m" + i2;
        const type = members[i2].getNodeType(builder);
        membersLayout.push({ name, type, index: i2 });
      }
      properties.membersLayout = membersLayout;
      properties.structType = builder.getOutputStructTypeFromNode(this, properties.membersLayout);
    }
    return properties.structType.name;
  }
  generate(builder) {
    const propertyName = builder.getOutputStructName();
    const members = this.members;
    const structPrefix = propertyName !== "" ? propertyName + "." : "";
    for (let i2 = 0; i2 < members.length; i2++) {
      const snippet = members[i2].build(builder);
      builder.addLineFlowCode(`${structPrefix}m${i2} = ${snippet}`, this);
    }
    return propertyName;
  }
};
var outputStruct = nodeProxy(OutputStructNode);
function getTextureIndex(textures, name) {
  for (let i2 = 0; i2 < textures.length; i2++) {
    if (textures[i2].name === name) {
      return i2;
    }
  }
  return -1;
}
var MRTNode = class extends OutputStructNode {
  static get type() {
    return "MRTNode";
  }
  /**
   * Constructs a new output struct node.
   *
   * @param {Object<string, Node>} outputNodes - The MRT outputs.
   */
  constructor(outputNodes) {
    super();
    this.outputNodes = outputNodes;
    this.isMRTNode = true;
  }
  /**
   * Returns `true` if the MRT node has an output with the given name.
   *
   * @param {string} name - The name of the output.
   * @return {NodeBuilder} Whether the MRT node has an output for the given name or not.
   */
  has(name) {
    return this.outputNodes[name] !== void 0;
  }
  /**
   * Returns the output node for the given name.
   *
   * @param {string} name - The name of the output.
   * @return {Node} The output node.
   */
  get(name) {
    return this.outputNodes[name];
  }
  /**
   * Merges the outputs of the given MRT node with the outputs of this node.
   *
   * @param {MRTNode} mrtNode - The MRT to merge.
   * @return {MRTNode} A new MRT node with merged outputs..
   */
  merge(mrtNode) {
    const outputs = { ...this.outputNodes, ...mrtNode.outputNodes };
    return mrt(outputs);
  }
  setup(builder) {
    const outputNodes = this.outputNodes;
    const mrt2 = builder.renderer.getRenderTarget();
    const members = [];
    const textures = mrt2.textures;
    for (const name in outputNodes) {
      const index8 = getTextureIndex(textures, name);
      members[index8] = vec4(outputNodes[name]);
    }
    this.members = members;
    return super.setup(builder);
  }
};
var mrt = nodeProxy(MRTNode);
var BitcastNode = class extends TempNode {
  static get type() {
    return "BitcastNode";
  }
  /**
   * Constructs a new bitcast node.
   *
   * @param {Node} valueNode - The value to convert.
   * @param {string} conversionType - The type to convert to.
   * @param {?string} [inputType = null] - The expected input data type of the bitcast operation.
   */
  constructor(valueNode, conversionType, inputType = null) {
    super();
    this.valueNode = valueNode;
    this.conversionType = conversionType;
    this.inputType = inputType;
    this.isBitcastNode = true;
  }
  getNodeType(builder) {
    if (this.inputType !== null) {
      const valueType = this.valueNode.getNodeType(builder);
      const valueLength = builder.getTypeLength(valueType);
      return builder.getTypeFromLength(valueLength, this.conversionType);
    }
    return this.conversionType;
  }
  generate(builder) {
    const type = this.getNodeType(builder);
    let inputType = "";
    if (this.inputType !== null) {
      const valueType = this.valueNode.getNodeType(builder);
      const valueTypeLength = builder.getTypeLength(valueType);
      inputType = valueTypeLength === 1 ? this.inputType : builder.changeComponentType(valueType, this.inputType);
    } else {
      inputType = this.valueNode.getNodeType(builder);
    }
    return `${builder.getBitcastMethod(type, inputType)}( ${this.valueNode.build(builder, inputType)} )`;
  }
};
var bitcast = nodeProxyIntent(BitcastNode).setParameterLength(2);
var floatBitsToInt = (value) => new BitcastNode(value, "int", "float");
var floatBitsToUint = (value) => new BitcastNode(value, "uint", "float");
var intBitsToFloat = (value) => new BitcastNode(value, "float", "int");
var uintBitsToFloat = (value) => new BitcastNode(value, "float", "uint");
var registeredBitcountFunctions = {};
var BitcountNode = class _BitcountNode extends MathNode {
  static get type() {
    return "BitcountNode";
  }
  /**
   * Constructs a new math node.
   *
   * @param {'countTrailingZeros'|'countLeadingZeros'|'countOneBits'} method - The method name.
   * @param {Node} aNode - The first input.
   */
  constructor(method2, aNode) {
    super(method2, aNode);
    this.isBitcountNode = true;
  }
  /**
   * Casts the input value of the function to an integer if necessary.
   *
   * @private
   * @param {Node<uint>|Node<int>} inputNode - The input value.
   * @param {Node<uint>} outputNode - The output value.
   * @param {string} elementType - The type of the input value.
   */
  _resolveElementType(inputNode, outputNode, elementType) {
    if (elementType === "int") {
      outputNode.assign(bitcast(inputNode, "uint"));
    } else {
      outputNode.assign(inputNode);
    }
  }
  _returnDataNode(inputType) {
    switch (inputType) {
      case "uint": {
        return uint;
      }
      case "int": {
        return int;
      }
      case "uvec2": {
        return uvec2;
      }
      case "uvec3": {
        return uvec3;
      }
      case "uvec4": {
        return uvec4;
      }
      case "ivec2": {
        return ivec2;
      }
      case "ivec3": {
        return ivec3;
      }
      case "ivec4": {
        return ivec4;
      }
    }
  }
  /**
   * Creates and registers a reusable GLSL function that emulates the behavior of countTrailingZeros.
   *
   * @private
   * @param {string} method - The name of the function to create.
   * @param {string} elementType - The type of the input value.
   * @returns {Function} - The generated function
   */
  _createTrailingZerosBaseLayout(method2, elementType) {
    const outputConvertNode = this._returnDataNode(elementType);
    const fnDef = Fn(([value]) => {
      const v2 = uint(0);
      this._resolveElementType(value, v2, elementType);
      const f3 = float(v2.bitAnd(negate(v2)));
      const uintBits = floatBitsToUint(f3);
      const numTrailingZeros = uintBits.shiftRight(23).sub(127);
      return outputConvertNode(numTrailingZeros);
    }).setLayout({
      name: method2,
      type: elementType,
      inputs: [
        { name: "value", type: elementType }
      ]
    });
    return fnDef;
  }
  /**
   * Creates and registers a reusable GLSL function that emulates the behavior of countLeadingZeros.
   *
   * @private
   * @param {string} method - The name of the function to create.
   * @param {string} elementType - The type of the input value.
   * @returns {Function} - The generated function
   */
  _createLeadingZerosBaseLayout(method2, elementType) {
    const outputConvertNode = this._returnDataNode(elementType);
    const fnDef = Fn(([value]) => {
      If(value.equal(uint(0)), () => {
        return uint(32);
      });
      const v2 = uint(0);
      const n2 = uint(0);
      this._resolveElementType(value, v2, elementType);
      If(v2.shiftRight(16).equal(0), () => {
        n2.addAssign(16);
        v2.shiftLeftAssign(16);
      });
      If(v2.shiftRight(24).equal(0), () => {
        n2.addAssign(8);
        v2.shiftLeftAssign(8);
      });
      If(v2.shiftRight(28).equal(0), () => {
        n2.addAssign(4);
        v2.shiftLeftAssign(4);
      });
      If(v2.shiftRight(30).equal(0), () => {
        n2.addAssign(2);
        v2.shiftLeftAssign(2);
      });
      If(v2.shiftRight(31).equal(0), () => {
        n2.addAssign(1);
      });
      return outputConvertNode(n2);
    }).setLayout({
      name: method2,
      type: elementType,
      inputs: [
        { name: "value", type: elementType }
      ]
    });
    return fnDef;
  }
  /**
   * Creates and registers a reusable GLSL function that emulates the behavior of countOneBits.
   *
   * @private
   * @param {string} method - The name of the function to create.
   * @param {string} elementType - The type of the input value.
   * @returns {Function} - The generated function
   */
  _createOneBitsBaseLayout(method2, elementType) {
    const outputConvertNode = this._returnDataNode(elementType);
    const fnDef = Fn(([value]) => {
      const v2 = uint(0);
      this._resolveElementType(value, v2, elementType);
      v2.assign(v2.sub(v2.shiftRight(uint(1)).bitAnd(uint(1431655765))));
      v2.assign(v2.bitAnd(uint(858993459)).add(v2.shiftRight(uint(2)).bitAnd(uint(858993459))));
      const numBits = v2.add(v2.shiftRight(uint(4))).bitAnd(uint(252645135)).mul(uint(16843009)).shiftRight(uint(24));
      return outputConvertNode(numBits);
    }).setLayout({
      name: method2,
      type: elementType,
      inputs: [
        { name: "value", type: elementType }
      ]
    });
    return fnDef;
  }
  /**
   * Creates and registers a reusable GLSL function that emulates the behavior of the specified bitcount function.
   * including considerations for component-wise bitcounts on vector type inputs.
   *
   * @private
   * @param {string} method - The name of the function to create.
   * @param {string} inputType - The type of the input value.
   * @param {number} typeLength - The vec length of the input value.
   * @param {Function} baseFn - The base function that operates on an individual component of the vector.
   * @returns {Function} - The alias function for the specified bitcount method.
   */
  _createMainLayout(method2, inputType, typeLength, baseFn) {
    const outputConvertNode = this._returnDataNode(inputType);
    const fnDef = Fn(([value]) => {
      if (typeLength === 1) {
        return outputConvertNode(baseFn(value));
      } else {
        const vec = outputConvertNode(0);
        const components = ["x", "y", "z", "w"];
        for (let i2 = 0; i2 < typeLength; i2++) {
          const component = components[i2];
          vec[component].assign(baseFn(value[component]));
        }
        return vec;
      }
    }).setLayout({
      name: method2,
      type: inputType,
      inputs: [
        { name: "value", type: inputType }
      ]
    });
    return fnDef;
  }
  setup(builder) {
    const { method: method2, aNode } = this;
    const { renderer: renderer3 } = builder;
    if (renderer3.backend.isWebGPUBackend) {
      return super.setup(builder);
    }
    const inputType = this.getInputType(builder);
    const elementType = builder.getElementType(inputType);
    const typeLength = builder.getTypeLength(inputType);
    const baseMethod = `${method2}_base_${elementType}`;
    const newMethod = `${method2}_${inputType}`;
    let baseFn = registeredBitcountFunctions[baseMethod];
    if (baseFn === void 0) {
      switch (method2) {
        case _BitcountNode.COUNT_LEADING_ZEROS: {
          baseFn = this._createLeadingZerosBaseLayout(baseMethod, elementType);
          break;
        }
        case _BitcountNode.COUNT_TRAILING_ZEROS: {
          baseFn = this._createTrailingZerosBaseLayout(baseMethod, elementType);
          break;
        }
        case _BitcountNode.COUNT_ONE_BITS: {
          baseFn = this._createOneBitsBaseLayout(baseMethod, elementType);
          break;
        }
      }
      registeredBitcountFunctions[baseMethod] = baseFn;
    }
    let fn = registeredBitcountFunctions[newMethod];
    if (fn === void 0) {
      fn = this._createMainLayout(newMethod, inputType, typeLength, baseFn);
      registeredBitcountFunctions[newMethod] = fn;
    }
    const output2 = Fn(() => {
      return fn(
        aNode
      );
    });
    return output2();
  }
};
BitcountNode.COUNT_TRAILING_ZEROS = "countTrailingZeros";
BitcountNode.COUNT_LEADING_ZEROS = "countLeadingZeros";
BitcountNode.COUNT_ONE_BITS = "countOneBits";
var countTrailingZeros = nodeProxyIntent(BitcountNode, BitcountNode.COUNT_TRAILING_ZEROS).setParameterLength(1);
var countLeadingZeros = nodeProxyIntent(BitcountNode, BitcountNode.COUNT_LEADING_ZEROS).setParameterLength(1);
var countOneBits = nodeProxyIntent(BitcountNode, BitcountNode.COUNT_ONE_BITS).setParameterLength(1);
var hash = Fn(([seed]) => {
  const state = seed.toUint().mul(747796405).add(2891336453);
  const word = state.shiftRight(state.shiftRight(28).add(4)).bitXor(state).mul(277803737);
  const result2 = word.shiftRight(22).bitXor(word);
  return result2.toFloat().mul(1 / 2 ** 32);
});
var parabola = (x3, k2) => pow2(mul(4, x3.mul(sub(1, x3))), k2);
var gain = (x3, k2) => x3.lessThan(0.5) ? parabola(x3.mul(2), k2).div(2) : sub(1, parabola(mul(sub(1, x3), 2), k2).div(2));
var pcurve = (x3, a3, b) => pow2(div(pow2(x3, a3), add4(pow2(x3, a3), pow2(sub(1, x3), b))), 1 / a3);
var sinc = (x3, k2) => sin(PI.mul(k2.mul(x3).sub(1))).div(PI.mul(k2.mul(x3).sub(1)));
var PackFloatNode = class extends TempNode {
  static get type() {
    return "PackFloatNode";
  }
  /**
   *
   * @param {'snorm' | 'unorm' | 'float16'} encoding - The numeric encoding that describes how the float values are mapped to the integer range.
   * @param {Node} vectorNode - The vector node to be packed
   */
  constructor(encoding, vectorNode) {
    super();
    this.vectorNode = vectorNode;
    this.encoding = encoding;
    this.isPackFloatNode = true;
  }
  getNodeType() {
    return "uint";
  }
  generate(builder) {
    const inputType = this.vectorNode.getNodeType(builder);
    return `${builder.getFloatPackingMethod(this.encoding)}(${this.vectorNode.build(builder, inputType)})`;
  }
};
var packSnorm2x16 = nodeProxyIntent(PackFloatNode, "snorm").setParameterLength(1);
var packUnorm2x16 = nodeProxyIntent(PackFloatNode, "unorm").setParameterLength(1);
var packHalf2x16 = nodeProxyIntent(PackFloatNode, "float16").setParameterLength(1);
var UnpackFloatNode = class extends TempNode {
  static get type() {
    return "UnpackFloatNode";
  }
  /**
   *
   * @param {'snorm' | 'unorm' | 'float16'} encoding - The numeric encoding that describes how the integer values are mapped to the float range
   * @param {Node} uintNode - The uint node to be unpacked
   */
  constructor(encoding, uintNode) {
    super();
    this.uintNode = uintNode;
    this.encoding = encoding;
    this.isUnpackFloatNode = true;
  }
  getNodeType() {
    return "vec2";
  }
  generate(builder) {
    const inputType = this.uintNode.getNodeType(builder);
    return `${builder.getFloatUnpackingMethod(this.encoding)}(${this.uintNode.build(builder, inputType)})`;
  }
};
var unpackSnorm2x16 = nodeProxyIntent(UnpackFloatNode, "snorm").setParameterLength(1);
var unpackUnorm2x16 = nodeProxyIntent(UnpackFloatNode, "unorm").setParameterLength(1);
var unpackHalf2x16 = nodeProxyIntent(UnpackFloatNode, "float16").setParameterLength(1);
var tri = Fn(([x3]) => {
  return x3.fract().sub(0.5).abs();
}).setLayout({
  name: "tri",
  type: "float",
  inputs: [
    { name: "x", type: "float" }
  ]
});
var tri3 = Fn(([p3]) => {
  return vec3(tri(p3.z.add(tri(p3.y.mul(1)))), tri(p3.z.add(tri(p3.x.mul(1)))), tri(p3.y.add(tri(p3.x.mul(1)))));
}).setLayout({
  name: "tri3",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec3" }
  ]
});
var triNoise3D = Fn(([position, speed, time3]) => {
  const p3 = vec3(position).toVar();
  const z3 = float(1.4).toVar();
  const rz = float(0).toVar();
  const bp = vec3(p3).toVar();
  Loop({ start: float(0), end: float(3), type: "float", condition: "<=" }, () => {
    const dg = vec3(tri3(bp.mul(2))).toVar();
    p3.addAssign(dg.add(time3.mul(float(0.1).mul(speed))));
    bp.mulAssign(1.8);
    z3.mulAssign(1.5);
    p3.mulAssign(1.2);
    const t5 = float(tri(p3.z.add(tri(p3.x.add(tri(p3.y)))))).toVar();
    rz.addAssign(t5.div(z3));
    bp.addAssign(0.14);
  });
  return rz;
}).setLayout({
  name: "triNoise3D",
  type: "float",
  inputs: [
    { name: "position", type: "vec3" },
    { name: "speed", type: "float" },
    { name: "time", type: "float" }
  ]
});
var FunctionOverloadingNode = class extends Node4 {
  static get type() {
    return "FunctionOverloadingNode";
  }
  /**
   * Constructs a new function overloading node.
   *
   * @param {Array<Function>} functionNodes - Array of `Fn` function definitions.
   * @param {...Node} parametersNodes - A list of parameter nodes.
   */
  constructor(functionNodes = [], ...parametersNodes) {
    super();
    this.functionNodes = functionNodes;
    this.parametersNodes = parametersNodes;
    this._candidateFn = null;
    this.global = true;
  }
  /**
   * This method is overwritten since the node type is inferred from
   * the function's return type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    const candidateFn = this.getCandidateFn(builder);
    return candidateFn.shaderNode.layout.type;
  }
  /**
   * Returns the candidate function for the current parameters.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {FunctionNode} The candidate function.
   */
  getCandidateFn(builder) {
    const params = this.parametersNodes;
    let candidateFn = this._candidateFn;
    if (candidateFn === null) {
      let bestCandidateFn = null;
      let bestScore = -1;
      for (const functionNode of this.functionNodes) {
        const shaderNode = functionNode.shaderNode;
        const layout = shaderNode.layout;
        if (layout === null) {
          throw new Error("FunctionOverloadingNode: FunctionNode must be a layout.");
        }
        const inputs = layout.inputs;
        if (params.length === inputs.length) {
          let currentScore = 0;
          for (let i2 = 0; i2 < params.length; i2++) {
            const param = params[i2];
            const input = inputs[i2];
            if (param.getNodeType(builder) === input.type) {
              currentScore++;
            }
          }
          if (currentScore > bestScore) {
            bestCandidateFn = functionNode;
            bestScore = currentScore;
          }
        }
      }
      this._candidateFn = candidateFn = bestCandidateFn;
    }
    return candidateFn;
  }
  /**
   * Sets up the node for the current parameters.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node} The setup node.
   */
  setup(builder) {
    const candidateFn = this.getCandidateFn(builder);
    return candidateFn(...this.parametersNodes);
  }
};
var overloadingBaseFn = nodeProxy(FunctionOverloadingNode);
var overloadingFn = (functionNodes) => (...params) => overloadingBaseFn(functionNodes, ...params);
var time2 = uniform(0).setGroup(renderGroup).onRenderUpdate((frame2) => frame2.time);
var deltaTime = uniform(0).setGroup(renderGroup).onRenderUpdate((frame2) => frame2.deltaTime);
var frameId = uniform(0, "uint").setGroup(renderGroup).onRenderUpdate((frame2) => frame2.frameId);
var oscSine = (t5 = time2) => t5.add(0.75).mul(Math.PI * 2).sin().mul(0.5).add(0.5);
var oscSquare = (t5 = time2) => t5.fract().round();
var oscTriangle = (t5 = time2) => t5.add(0.5).fract().mul(2).sub(1).abs();
var oscSawtooth = (t5 = time2) => t5.fract();
function replaceDefaultUV(callback, node = null) {
  return context(node, { getUV: callback });
}
var rotateUV = Fn(([uv2, rotation, center = vec2(0.5)]) => {
  return rotate(uv2.sub(center), rotation).add(center);
});
var spherizeUV = Fn(([uv2, strength, center = vec2(0.5)]) => {
  const delta = uv2.sub(center);
  const delta2 = delta.dot(delta);
  const delta4 = delta2.mul(delta2);
  const deltaOffset = delta4.mul(strength);
  return uv2.add(delta.mul(deltaOffset));
});
var billboarding = Fn(({ position = null, horizontal = true, vertical = false }) => {
  let worldMatrix;
  if (position !== null) {
    worldMatrix = modelWorldMatrix.toVar();
    worldMatrix[3][0] = position.x;
    worldMatrix[3][1] = position.y;
    worldMatrix[3][2] = position.z;
  } else {
    worldMatrix = modelWorldMatrix;
  }
  const modelViewMatrix2 = cameraViewMatrix.mul(worldMatrix);
  if (defined(horizontal)) {
    modelViewMatrix2[0][0] = modelWorldMatrix[0].length();
    modelViewMatrix2[0][1] = 0;
    modelViewMatrix2[0][2] = 0;
  }
  if (defined(vertical)) {
    modelViewMatrix2[1][0] = 0;
    modelViewMatrix2[1][1] = modelWorldMatrix[1].length();
    modelViewMatrix2[1][2] = 0;
  }
  modelViewMatrix2[2][0] = 0;
  modelViewMatrix2[2][1] = 0;
  modelViewMatrix2[2][2] = 1;
  return cameraProjectionMatrix.mul(modelViewMatrix2).mul(positionLocal);
});
var viewportSafeUV = Fn(([uv2 = null]) => {
  const depth2 = linearDepth();
  const depthDiff = linearDepth(viewportDepthTexture(uv2)).sub(depth2);
  const finalUV = depthDiff.lessThan(0).select(screenUV, uv2);
  return finalUV;
});
var SpriteSheetUVNode = class extends Node4 {
  static get type() {
    return "SpriteSheetUVNode";
  }
  /**
   * Constructs a new sprite sheet uv node.
   *
   * @param {Node<vec2>} countNode - The node that defines the number of sprites in the x and y direction (e.g 6x6).
   * @param {Node<vec2>} [uvNode=uv()] - The uv node.
   * @param {Node<float>} [frameNode=float()] - The node that defines the current frame/sprite.
   */
  constructor(countNode, uvNode = uv$1(), frameNode = float(0)) {
    super("vec2");
    this.countNode = countNode;
    this.uvNode = uvNode;
    this.frameNode = frameNode;
  }
  setup() {
    const { frameNode, uvNode, countNode } = this;
    const { width, height } = countNode;
    const frameNum = frameNode.mod(width.mul(height)).floor();
    const column = frameNum.mod(width);
    const row = height.sub(frameNum.add(1).div(width).ceil());
    const scale2 = countNode.reciprocal();
    const uvFrameOffset = vec2(column, row);
    return uvNode.add(uvFrameOffset).mul(scale2);
  }
};
var spritesheetUV = nodeProxy(SpriteSheetUVNode).setParameterLength(3);
var triplanarTextures = Fn(([textureXNode, textureYNode = null, textureZNode = null, scaleNode = float(1), positionNode = positionLocal, normalNode = normalLocal]) => {
  let bf = normalNode.abs().normalize();
  bf = bf.div(bf.dot(vec3(1)));
  const tx = positionNode.yz.mul(scaleNode);
  const ty = positionNode.zx.mul(scaleNode);
  const tz = positionNode.xy.mul(scaleNode);
  const textureX = textureXNode.value;
  const textureY = textureYNode !== null ? textureYNode.value : textureX;
  const textureZ = textureZNode !== null ? textureZNode.value : textureX;
  const cx = texture(textureX, tx).mul(bf.x);
  const cy = texture(textureY, ty).mul(bf.y);
  const cz = texture(textureZ, tz).mul(bf.z);
  return add4(cx, cy, cz);
});
var triplanarTexture = (...params) => triplanarTextures(...params);
var _reflectorPlane = new Plane();
var _normal2 = new Vector3();
var _reflectorWorldPosition = new Vector3();
var _cameraWorldPosition = new Vector3();
var _rotationMatrix = new Matrix4();
var _lookAtPosition = new Vector3(0, 0, -1);
var clipPlane = new Vector4();
var _view = new Vector3();
var _target2 = new Vector3();
var _q = new Vector4();
var _size$2 = new Vector2();
var _defaultRT = new RenderTarget();
var _defaultUV = screenUV.flipX();
_defaultRT.depthTexture = new DepthTexture(1, 1);
var _inReflector = false;
var ReflectorNode = class _ReflectorNode extends TextureNode {
  static get type() {
    return "ReflectorNode";
  }
  /**
   * Constructs a new reflector node.
   *
   * @param {Object} [parameters={}] - An object holding configuration parameters.
   * @param {Object3D} [parameters.target=new Object3D()] - The 3D object the reflector is linked to.
   * @param {number} [parameters.resolutionScale=1] - The resolution scale.
   * @param {boolean} [parameters.generateMipmaps=false] - Whether mipmaps should be generated or not.
   * @param {boolean} [parameters.bounces=true] - Whether reflectors can render other reflector nodes or not.
   * @param {boolean} [parameters.depth=false] - Whether depth data should be generated or not.
   * @param {number} [parameters.samples] - Anti-Aliasing samples of the internal render-target.
   * @param {TextureNode} [parameters.defaultTexture] - The default texture node.
   * @param {ReflectorBaseNode} [parameters.reflector] - The reflector base node.
   */
  constructor(parameters = {}) {
    super(parameters.defaultTexture || _defaultRT.texture, _defaultUV);
    this._reflectorBaseNode = parameters.reflector || new ReflectorBaseNode(this, parameters);
    this._depthNode = null;
    this.setUpdateMatrix(false);
  }
  /**
   * A reference to the internal reflector node.
   *
   * @type {ReflectorBaseNode}
   */
  get reflector() {
    return this._reflectorBaseNode;
  }
  /**
   * A reference to 3D object the reflector is linked to.
   *
   * @type {Object3D}
   */
  get target() {
    return this._reflectorBaseNode.target;
  }
  /**
   * Returns a node representing the mirror's depth. That can be used
   * to implement more advanced reflection effects like distance attenuation.
   *
   * @return {Node} The depth node.
   */
  getDepthNode() {
    if (this._depthNode === null) {
      if (this._reflectorBaseNode.depth !== true) {
        throw new Error("THREE.ReflectorNode: Depth node can only be requested when the reflector is created with { depth: true }. ");
      }
      this._depthNode = nodeObject(new _ReflectorNode({
        defaultTexture: _defaultRT.depthTexture,
        reflector: this._reflectorBaseNode
      }));
    }
    return this._depthNode;
  }
  setup(builder) {
    if (!builder.object.isQuadMesh) this._reflectorBaseNode.build(builder);
    return super.setup(builder);
  }
  clone() {
    const newNode = new this.constructor(this.reflectorNode);
    newNode.uvNode = this.uvNode;
    newNode.levelNode = this.levelNode;
    newNode.biasNode = this.biasNode;
    newNode.sampler = this.sampler;
    newNode.depthNode = this.depthNode;
    newNode.compareNode = this.compareNode;
    newNode.gradNode = this.gradNode;
    newNode.offsetNode = this.offsetNode;
    newNode._reflectorBaseNode = this._reflectorBaseNode;
    return newNode;
  }
  /**
   * Frees internal resources. Should be called when the node is no longer in use.
   */
  dispose() {
    super.dispose();
    this._reflectorBaseNode.dispose();
  }
};
var ReflectorBaseNode = class extends Node4 {
  static get type() {
    return "ReflectorBaseNode";
  }
  /**
   * Constructs a new reflector base node.
   *
   * @param {TextureNode} textureNode - Represents the rendered reflections as a texture node.
   * @param {Object} [parameters={}] - An object holding configuration parameters.
   * @param {Object3D} [parameters.target=new Object3D()] - The 3D object the reflector is linked to.
   * @param {number} [parameters.resolutionScale=1] - The resolution scale.
   * @param {boolean} [parameters.generateMipmaps=false] - Whether mipmaps should be generated or not.
   * @param {boolean} [parameters.bounces=true] - Whether reflectors can render other reflector nodes or not.
   * @param {boolean} [parameters.depth=false] - Whether depth data should be generated or not.
   * @param {number} [parameters.samples] - Anti-Aliasing samples of the internal render-target.
   */
  constructor(textureNode, parameters = {}) {
    super();
    const {
      target = new Object3D(),
      resolutionScale = 1,
      generateMipmaps = false,
      bounces = true,
      depth: depth2 = false,
      samples = 0
    } = parameters;
    this.textureNode = textureNode;
    this.target = target;
    this.resolutionScale = resolutionScale;
    if (parameters.resolution !== void 0) {
      warnOnce('ReflectorNode: The "resolution" parameter has been renamed to "resolutionScale".');
      this.resolutionScale = parameters.resolution;
    }
    this.generateMipmaps = generateMipmaps;
    this.bounces = bounces;
    this.depth = depth2;
    this.samples = samples;
    this.updateBeforeType = bounces ? NodeUpdateType.RENDER : NodeUpdateType.FRAME;
    this.virtualCameras = /* @__PURE__ */ new WeakMap();
    this.renderTargets = /* @__PURE__ */ new Map();
    this.forceUpdate = false;
    this.hasOutput = false;
  }
  /**
   * Updates the resolution of the internal render target.
   *
   * @private
   * @param {RenderTarget} renderTarget - The render target to resize.
   * @param {Renderer} renderer - The renderer that is used to determine the new size.
   */
  _updateResolution(renderTarget, renderer3) {
    const resolution = this.resolutionScale;
    renderer3.getDrawingBufferSize(_size$2);
    renderTarget.setSize(Math.round(_size$2.width * resolution), Math.round(_size$2.height * resolution));
  }
  setup(builder) {
    this._updateResolution(_defaultRT, builder.renderer);
    return super.setup(builder);
  }
  /**
   * Frees internal resources. Should be called when the node is no longer in use.
   */
  dispose() {
    super.dispose();
    for (const renderTarget of this.renderTargets.values()) {
      renderTarget.dispose();
    }
  }
  /**
   * Returns a virtual camera for the given camera. The virtual camera is used to
   * render the scene from the reflector's view so correct reflections can be produced.
   *
   * @param {Camera} camera - The scene's camera.
   * @return {Camera} The corresponding virtual camera.
   */
  getVirtualCamera(camera3) {
    let virtualCamera = this.virtualCameras.get(camera3);
    if (virtualCamera === void 0) {
      virtualCamera = camera3.clone();
      this.virtualCameras.set(camera3, virtualCamera);
    }
    return virtualCamera;
  }
  /**
   * Returns a render target for the given camera. The reflections are rendered
   * into this render target.
   *
   * @param {Camera} camera - The scene's camera.
   * @return {RenderTarget} The render target.
   */
  getRenderTarget(camera3) {
    let renderTarget = this.renderTargets.get(camera3);
    if (renderTarget === void 0) {
      renderTarget = new RenderTarget(0, 0, { type: HalfFloatType, samples: this.samples });
      if (this.generateMipmaps === true) {
        renderTarget.texture.minFilter = LinearMipMapLinearFilter;
        renderTarget.texture.generateMipmaps = true;
      }
      if (this.depth === true) {
        renderTarget.depthTexture = new DepthTexture();
      }
      this.renderTargets.set(camera3, renderTarget);
    }
    return renderTarget;
  }
  updateBefore(frame2) {
    if (this.bounces === false && _inReflector) return false;
    _inReflector = true;
    const { scene: scene3, camera: camera3, renderer: renderer3, material } = frame2;
    const { target } = this;
    const virtualCamera = this.getVirtualCamera(camera3);
    const renderTarget = this.getRenderTarget(virtualCamera);
    renderer3.getDrawingBufferSize(_size$2);
    this._updateResolution(renderTarget, renderer3);
    _reflectorWorldPosition.setFromMatrixPosition(target.matrixWorld);
    _cameraWorldPosition.setFromMatrixPosition(camera3.matrixWorld);
    _rotationMatrix.extractRotation(target.matrixWorld);
    _normal2.set(0, 0, 1);
    _normal2.applyMatrix4(_rotationMatrix);
    _view.subVectors(_reflectorWorldPosition, _cameraWorldPosition);
    const isFacingAway = _view.dot(_normal2) > 0;
    let needsClear = false;
    if (isFacingAway === true && this.forceUpdate === false) {
      if (this.hasOutput === false) {
        _inReflector = false;
        return;
      }
      needsClear = true;
    }
    _view.reflect(_normal2).negate();
    _view.add(_reflectorWorldPosition);
    _rotationMatrix.extractRotation(camera3.matrixWorld);
    _lookAtPosition.set(0, 0, -1);
    _lookAtPosition.applyMatrix4(_rotationMatrix);
    _lookAtPosition.add(_cameraWorldPosition);
    _target2.subVectors(_reflectorWorldPosition, _lookAtPosition);
    _target2.reflect(_normal2).negate();
    _target2.add(_reflectorWorldPosition);
    virtualCamera.coordinateSystem = camera3.coordinateSystem;
    virtualCamera.position.copy(_view);
    virtualCamera.up.set(0, 1, 0);
    virtualCamera.up.applyMatrix4(_rotationMatrix);
    virtualCamera.up.reflect(_normal2);
    virtualCamera.lookAt(_target2);
    virtualCamera.near = camera3.near;
    virtualCamera.far = camera3.far;
    virtualCamera.updateMatrixWorld();
    virtualCamera.projectionMatrix.copy(camera3.projectionMatrix);
    _reflectorPlane.setFromNormalAndCoplanarPoint(_normal2, _reflectorWorldPosition);
    _reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);
    clipPlane.set(_reflectorPlane.normal.x, _reflectorPlane.normal.y, _reflectorPlane.normal.z, _reflectorPlane.constant);
    const projectionMatrix = virtualCamera.projectionMatrix;
    _q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];
    _q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];
    _q.z = -1;
    _q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];
    clipPlane.multiplyScalar(1 / clipPlane.dot(_q));
    const clipBias = 0;
    projectionMatrix.elements[2] = clipPlane.x;
    projectionMatrix.elements[6] = clipPlane.y;
    projectionMatrix.elements[10] = renderer3.coordinateSystem === WebGPUCoordinateSystem ? clipPlane.z - clipBias : clipPlane.z + 1 - clipBias;
    projectionMatrix.elements[14] = clipPlane.w;
    this.textureNode.value = renderTarget.texture;
    if (this.depth === true) {
      this.textureNode.getDepthNode().value = renderTarget.depthTexture;
    }
    material.visible = false;
    const currentRenderTarget = renderer3.getRenderTarget();
    const currentMRT = renderer3.getMRT();
    const currentAutoClear = renderer3.autoClear;
    renderer3.setMRT(null);
    renderer3.setRenderTarget(renderTarget);
    renderer3.autoClear = true;
    const previousName = scene3.name;
    scene3.name = (scene3.name || "Scene") + " [ Reflector ]";
    if (needsClear) {
      renderer3.clear();
      this.hasOutput = false;
    } else {
      renderer3.render(scene3, virtualCamera);
      this.hasOutput = true;
    }
    scene3.name = previousName;
    renderer3.setMRT(currentMRT);
    renderer3.setRenderTarget(currentRenderTarget);
    renderer3.autoClear = currentAutoClear;
    material.visible = true;
    _inReflector = false;
    this.forceUpdate = false;
  }
  /**
   * The resolution scale.
   *
   * @deprecated
   * @type {number}
   * @default {1}
   */
  get resolution() {
    warnOnce('ReflectorNode: The "resolution" property has been renamed to "resolutionScale".');
    return this.resolutionScale;
  }
  set resolution(value) {
    warnOnce('ReflectorNode: The "resolution" property has been renamed to "resolutionScale".');
    this.resolutionScale = value;
  }
};
var reflector = (parameters) => new ReflectorNode(parameters);
var _camera2 = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
var QuadGeometry = class extends BufferGeometry {
  /**
   * Constructs a new quad geometry.
   *
   * @param {boolean} [flipY=false] - Whether the uv coordinates should be flipped along the vertical axis or not.
   */
  constructor(flipY = false) {
    super();
    const uv2 = flipY === false ? [0, -1, 0, 1, 2, 1] : [0, 2, 0, 0, 2, 0];
    this.setAttribute("position", new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));
    this.setAttribute("uv", new Float32BufferAttribute(uv2, 2));
  }
};
var _geometry = new QuadGeometry();
var QuadMesh = class extends Mesh {
  /**
   * Constructs a new quad mesh.
   *
   * @param {?Material} [material=null] - The material to render the quad mesh with.
   */
  constructor(material = null) {
    super(_geometry, material);
    this.camera = _camera2;
    this.isQuadMesh = true;
  }
  /**
   * Async version of `render()`.
   *
   * @async
   * @deprecated
   * @param {Renderer} renderer - The renderer.
   * @return {Promise} A Promise that resolves when the render has been finished.
   */
  async renderAsync(renderer3) {
    warnOnce('QuadMesh: "renderAsync()" has been deprecated. Use "render()" and "await renderer.init();" when creating the renderer.');
    await renderer3.init();
    renderer3.render(this, _camera2);
  }
  /**
   * Renders the quad mesh
   *
   * @param {Renderer} renderer - The renderer.
   */
  render(renderer3) {
    renderer3.render(this, _camera2);
  }
};
var _size$1 = new Vector2();
var RTTNode = class extends TextureNode {
  static get type() {
    return "RTTNode";
  }
  /**
   * Constructs a new RTT node.
   *
   * @param {Node} node - The node to render a texture with.
   * @param {?number} [width=null] - The width of the internal render target. If not width is applied, the render target is automatically resized.
   * @param {?number} [height=null] - The height of the internal render target.
   * @param {Object} [options={type:HalfFloatType}] - The options for the internal render target.
   */
  constructor(node, width = null, height = null, options = { type: HalfFloatType }) {
    const renderTarget = new RenderTarget(width, height, options);
    super(renderTarget.texture, uv$1());
    this.isRTTNode = true;
    this.node = node;
    this.width = width;
    this.height = height;
    this.pixelRatio = 1;
    this.renderTarget = renderTarget;
    this.textureNeedsUpdate = true;
    this.autoUpdate = true;
    this._rttNode = null;
    this._quadMesh = new QuadMesh(new NodeMaterial());
    this.updateBeforeType = NodeUpdateType.RENDER;
  }
  /**
   * Whether the internal render target should automatically be resized or not.
   *
   * @type {boolean}
   * @readonly
   * @default true
   */
  get autoResize() {
    return this.width === null;
  }
  setup(builder) {
    this._rttNode = this.node.context(builder.getSharedContext());
    this._quadMesh.material.name = "RTT";
    this._quadMesh.material.needsUpdate = true;
    return super.setup(builder);
  }
  /**
   * Sets the size of the internal render target
   *
   * @param {number} width - The width to set.
   * @param {number} height - The width to set.
   */
  setSize(width, height) {
    this.width = width;
    this.height = height;
    const effectiveWidth = width * this.pixelRatio;
    const effectiveHeight = height * this.pixelRatio;
    this.renderTarget.setSize(effectiveWidth, effectiveHeight);
    this.textureNeedsUpdate = true;
  }
  /**
   * Sets the pixel ratio. This will also resize the render target.
   *
   * @param {number} pixelRatio - The pixel ratio to set.
   */
  setPixelRatio(pixelRatio) {
    this.pixelRatio = pixelRatio;
    this.setSize(this.width, this.height);
  }
  updateBefore({ renderer: renderer3 }) {
    if (this.textureNeedsUpdate === false && this.autoUpdate === false) return;
    this.textureNeedsUpdate = false;
    if (this.autoResize === true) {
      const pixelRatio = renderer3.getPixelRatio();
      const size2 = renderer3.getSize(_size$1);
      const effectiveWidth = Math.floor(size2.width * pixelRatio);
      const effectiveHeight = Math.floor(size2.height * pixelRatio);
      if (effectiveWidth !== this.renderTarget.width || effectiveHeight !== this.renderTarget.height) {
        this.renderTarget.setSize(effectiveWidth, effectiveHeight);
        this.textureNeedsUpdate = true;
      }
    }
    let name = "RTT";
    if (this.node.name) {
      name = this.node.name + " [ " + name + " ]";
    }
    this._quadMesh.material.fragmentNode = this._rttNode;
    this._quadMesh.name = name;
    const currentRenderTarget = renderer3.getRenderTarget();
    renderer3.setRenderTarget(this.renderTarget);
    this._quadMesh.render(renderer3);
    renderer3.setRenderTarget(currentRenderTarget);
  }
  clone() {
    const newNode = new TextureNode(this.value, this.uvNode, this.levelNode);
    newNode.sampler = this.sampler;
    newNode.referenceNode = this;
    return newNode;
  }
};
var rtt = (node, ...params) => nodeObject(new RTTNode(nodeObject(node), ...params));
var convertToTexture = (node, ...params) => {
  if (node.isSampleNode || node.isTextureNode) return node;
  if (node.isPassNode) return node.getTextureNode();
  return rtt(node, ...params);
};
var getViewPosition = Fn(([screenPosition, depth2, projectionMatrixInverse], builder) => {
  let clipSpacePosition;
  if (builder.renderer.coordinateSystem === WebGPUCoordinateSystem) {
    screenPosition = vec2(screenPosition.x, screenPosition.y.oneMinus()).mul(2).sub(1);
    clipSpacePosition = vec4(vec3(screenPosition, depth2), 1);
  } else {
    clipSpacePosition = vec4(vec3(screenPosition.x, screenPosition.y.oneMinus(), depth2).mul(2).sub(1), 1);
  }
  const viewSpacePosition = vec4(projectionMatrixInverse.mul(clipSpacePosition));
  return viewSpacePosition.xyz.div(viewSpacePosition.w);
});
var getScreenPosition = Fn(([viewPosition, projectionMatrix]) => {
  const sampleClipPos = projectionMatrix.mul(vec4(viewPosition, 1));
  const sampleUv = sampleClipPos.xy.div(sampleClipPos.w).mul(0.5).add(0.5).toVar();
  return vec2(sampleUv.x, sampleUv.y.oneMinus());
});
var getNormalFromDepth = Fn(([uv2, depthTexture, projectionMatrixInverse]) => {
  const size2 = textureSize(textureLoad(depthTexture));
  const p3 = ivec2(uv2.mul(size2)).toVar();
  const c0 = textureLoad(depthTexture, p3).toVar();
  const l2 = textureLoad(depthTexture, p3.sub(ivec2(2, 0))).toVar();
  const l1 = textureLoad(depthTexture, p3.sub(ivec2(1, 0))).toVar();
  const r1 = textureLoad(depthTexture, p3.add(ivec2(1, 0))).toVar();
  const r2 = textureLoad(depthTexture, p3.add(ivec2(2, 0))).toVar();
  const b23 = textureLoad(depthTexture, p3.add(ivec2(0, 2))).toVar();
  const b12 = textureLoad(depthTexture, p3.add(ivec2(0, 1))).toVar();
  const t13 = textureLoad(depthTexture, p3.sub(ivec2(0, 1))).toVar();
  const t22 = textureLoad(depthTexture, p3.sub(ivec2(0, 2))).toVar();
  const dl = abs(sub(float(2).mul(l1).sub(l2), c0)).toVar();
  const dr = abs(sub(float(2).mul(r1).sub(r2), c0)).toVar();
  const db = abs(sub(float(2).mul(b12).sub(b23), c0)).toVar();
  const dt = abs(sub(float(2).mul(t13).sub(t22), c0)).toVar();
  const ce = getViewPosition(uv2, c0, projectionMatrixInverse).toVar();
  const dpdx = dl.lessThan(dr).select(ce.sub(getViewPosition(uv2.sub(vec2(float(1).div(size2.x), 0)), l1, projectionMatrixInverse)), ce.negate().add(getViewPosition(uv2.add(vec2(float(1).div(size2.x), 0)), r1, projectionMatrixInverse)));
  const dpdy = db.lessThan(dt).select(ce.sub(getViewPosition(uv2.add(vec2(0, float(1).div(size2.y))), b12, projectionMatrixInverse)), ce.negate().add(getViewPosition(uv2.sub(vec2(0, float(1).div(size2.y))), t13, projectionMatrixInverse)));
  return normalize2(cross2(dpdx, dpdy));
});
var interleavedGradientNoise = Fn(([position]) => {
  return fract(float(52.9829189).mul(fract(dot(position, vec2(0.06711056, 583715e-8)))));
}).setLayout({
  name: "interleavedGradientNoise",
  type: "float",
  inputs: [
    { name: "position", type: "vec2" }
  ]
});
var vogelDiskSample = Fn(([sampleIndex, samplesCount, phi]) => {
  const goldenAngle = float(2.399963229728653);
  const r2 = sqrt2(float(sampleIndex).add(0.5).div(float(samplesCount)));
  const theta = float(sampleIndex).mul(goldenAngle).add(phi);
  return vec2(cos(theta), sin(theta)).mul(r2);
}).setLayout({
  name: "vogelDiskSample",
  type: "vec2",
  inputs: [
    { name: "sampleIndex", type: "int" },
    { name: "samplesCount", type: "int" },
    { name: "phi", type: "float" }
  ]
});
var SampleNode = class extends Node4 {
  /**
   * Returns the type of the node.
   *
   * @type {string}
   * @readonly
   * @static
   */
  static get type() {
    return "SampleNode";
  }
  /**
   * Creates an instance of SampleNode.
   *
   * @param {Function} callback - The function to be called when sampling. Should accept a UV node and return a value.
   * @param {?Node<vec2>} [uvNode=null] - The UV node to be used in the texture sampling.
   */
  constructor(callback, uvNode = null) {
    super();
    this.callback = callback;
    this.uvNode = uvNode;
    this.isSampleNode = true;
  }
  /**
   * Sets up the node by sampling with the default UV accessor.
   *
   * @returns {Node} The result of the callback function when called with the UV node.
   */
  setup() {
    return this.sample(uv$1());
  }
  /**
   * Calls the callback function with the provided UV node.
   *
   * @param {Node<vec2>} uv - The UV node or value to be passed to the callback.
   * @returns {Node} The result of the callback function.
   */
  sample(uv2) {
    return this.callback(uv2);
  }
};
var sample = (callback, uv2 = null) => new SampleNode(callback, nodeObject(uv2));
var EventNode = class _EventNode extends Node4 {
  static get type() {
    return "EventNode";
  }
  /**
   * Creates an EventNode.
   *
   * @param {string} eventType - The type of event
   * @param {Function} callback - The callback to execute on update.
   */
  constructor(eventType, callback) {
    super("void");
    this.eventType = eventType;
    this.callback = callback;
    if (eventType === _EventNode.OBJECT) {
      this.updateType = NodeUpdateType.OBJECT;
    } else if (eventType === _EventNode.MATERIAL) {
      this.updateType = NodeUpdateType.RENDER;
    } else if (eventType === _EventNode.BEFORE_OBJECT) {
      this.updateBeforeType = NodeUpdateType.OBJECT;
    } else if (eventType === _EventNode.BEFORE_MATERIAL) {
      this.updateBeforeType = NodeUpdateType.RENDER;
    }
  }
  update(frame2) {
    this.callback(frame2);
  }
  updateBefore(frame2) {
    this.callback(frame2);
  }
};
EventNode.OBJECT = "object";
EventNode.MATERIAL = "material";
EventNode.BEFORE_OBJECT = "beforeObject";
EventNode.BEFORE_MATERIAL = "beforeMaterial";
var createEvent = (type, callback) => new EventNode(type, callback).toStack();
var OnObjectUpdate = (callback) => createEvent(EventNode.OBJECT, callback);
var OnMaterialUpdate = (callback) => createEvent(EventNode.MATERIAL, callback);
var OnBeforeObjectUpdate = (callback) => createEvent(EventNode.BEFORE_OBJECT, callback);
var OnBeforeMaterialUpdate = (callback) => createEvent(EventNode.BEFORE_MATERIAL, callback);
var StorageInstancedBufferAttribute = class extends InstancedBufferAttribute {
  /**
   * Constructs a new storage instanced buffer attribute.
   *
   * @param {number|TypedArray} count - The item count. It is also valid to pass a typed array as an argument.
   * The subsequent parameters are then obsolete.
   * @param {number} itemSize - The item size.
   * @param {TypedArray.constructor} [typeClass=Float32Array] - A typed array constructor.
   */
  constructor(count2, itemSize, typeClass = Float32Array) {
    const array4 = ArrayBuffer.isView(count2) ? count2 : new typeClass(count2 * itemSize);
    super(array4, itemSize);
    this.isStorageInstancedBufferAttribute = true;
  }
};
var StorageBufferAttribute = class extends BufferAttribute {
  /**
   * Constructs a new storage buffer attribute.
   *
   * @param {number|TypedArray} count - The item count. It is also valid to pass a typed array as an argument.
   * The subsequent parameters are then obsolete.
   * @param {number} itemSize - The item size.
   * @param {TypedArray.constructor} [typeClass=Float32Array] - A typed array constructor.
   */
  constructor(count2, itemSize, typeClass = Float32Array) {
    const array4 = ArrayBuffer.isView(count2) ? count2 : new typeClass(count2 * itemSize);
    super(array4, itemSize);
    this.isStorageBufferAttribute = true;
  }
};
var attributeArray = (count2, type = "float") => {
  let itemSize, typedArray;
  if (type.isStruct === true) {
    itemSize = type.layout.getLength();
    typedArray = getTypedArrayFromType("float");
  } else {
    itemSize = getLengthFromType(type);
    typedArray = getTypedArrayFromType(type);
  }
  const buffer2 = new StorageBufferAttribute(count2, itemSize, typedArray);
  const node = storage(buffer2, type, count2);
  return node;
};
var instancedArray = (count2, type = "float") => {
  let itemSize, typedArray;
  if (type.isStruct === true) {
    itemSize = type.layout.getLength();
    typedArray = getTypedArrayFromType("float");
  } else {
    itemSize = getLengthFromType(type);
    typedArray = getTypedArrayFromType(type);
  }
  const buffer2 = new StorageInstancedBufferAttribute(count2, itemSize, typedArray);
  const node = storage(buffer2, type, count2);
  return node;
};
var PointUVNode = class extends Node4 {
  static get type() {
    return "PointUVNode";
  }
  /**
   * Constructs a new point uv node.
   */
  constructor() {
    super("vec2");
    this.isPointUVNode = true;
  }
  generate() {
    return "vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )";
  }
};
var pointUV = nodeImmutable(PointUVNode);
var _e12 = new Euler();
var _m12 = new Matrix4();
var SceneNode = class _SceneNode extends Node4 {
  static get type() {
    return "SceneNode";
  }
  /**
   * Constructs a new scene node.
   *
   * @param {('backgroundBlurriness'|'backgroundIntensity'|'backgroundRotation')} scope - The scope defines the type of scene property that is accessed.
   * @param {?Scene} [scene=null] - A reference to the scene.
   */
  constructor(scope = _SceneNode.BACKGROUND_BLURRINESS, scene3 = null) {
    super();
    this.scope = scope;
    this.scene = scene3;
  }
  /**
   * Depending on the scope, the method returns a different type of node that represents
   * the respective scene property.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node} The output node.
   */
  setup(builder) {
    const scope = this.scope;
    const scene3 = this.scene !== null ? this.scene : builder.scene;
    let output2;
    if (scope === _SceneNode.BACKGROUND_BLURRINESS) {
      output2 = reference("backgroundBlurriness", "float", scene3);
    } else if (scope === _SceneNode.BACKGROUND_INTENSITY) {
      output2 = reference("backgroundIntensity", "float", scene3);
    } else if (scope === _SceneNode.BACKGROUND_ROTATION) {
      output2 = uniform("mat4").setName("backgroundRotation").setGroup(renderGroup).onRenderUpdate(() => {
        const background = scene3.background;
        if (background !== null && background.isTexture && background.mapping !== UVMapping) {
          _e12.copy(scene3.backgroundRotation);
          _e12.x *= -1;
          _e12.y *= -1;
          _e12.z *= -1;
          _m12.makeRotationFromEuler(_e12);
        } else {
          _m12.identity();
        }
        return _m12;
      });
    } else {
      error("SceneNode: Unknown scope:", scope);
    }
    return output2;
  }
};
SceneNode.BACKGROUND_BLURRINESS = "backgroundBlurriness";
SceneNode.BACKGROUND_INTENSITY = "backgroundIntensity";
SceneNode.BACKGROUND_ROTATION = "backgroundRotation";
var backgroundBlurriness = nodeImmutable(SceneNode, SceneNode.BACKGROUND_BLURRINESS);
var backgroundIntensity = nodeImmutable(SceneNode, SceneNode.BACKGROUND_INTENSITY);
var backgroundRotation = nodeImmutable(SceneNode, SceneNode.BACKGROUND_ROTATION);
var StorageTextureNode = class extends TextureNode {
  static get type() {
    return "StorageTextureNode";
  }
  /**
   * Constructs a new storage texture node.
   *
   * @param {StorageTexture} value - The storage texture.
   * @param {Node<vec2|vec3>} uvNode - The uv node.
   * @param {?Node} [storeNode=null] - The value node that should be stored in the texture.
   */
  constructor(value, uvNode, storeNode = null) {
    super(value, uvNode);
    this.storeNode = storeNode;
    this.mipLevel = 0;
    this.isStorageTextureNode = true;
    this.access = NodeAccess.WRITE_ONLY;
  }
  /**
   * Overwrites the default implementation to return a fixed value `'storageTexture'`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType() {
    return "storageTexture";
  }
  setup(builder) {
    super.setup(builder);
    const properties = builder.getNodeProperties(this);
    properties.storeNode = this.storeNode;
    return properties;
  }
  /**
   * Defines the node access.
   *
   * @param {string} value - The node access.
   * @return {StorageTextureNode} A reference to this node.
   */
  setAccess(value) {
    this.access = value;
    return this;
  }
  /**
   * Sets the mip level to write to.
   *
   * @param {number} level - The mip level.
   * @return {StorageTextureNode} A reference to this node.
   */
  setMipLevel(level) {
    this.mipLevel = level;
    return this;
  }
  /**
   * Generates the code snippet of the storage node. If no `storeNode`
   * is defined, the texture node is generated as normal texture.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} output - The current output.
   * @return {string} The generated code snippet.
   */
  generate(builder, output2) {
    let snippet;
    if (this.storeNode !== null) {
      snippet = this.generateStore(builder);
    } else {
      snippet = super.generate(builder, output2);
    }
    return snippet;
  }
  /**
   * Convenience method for configuring a read/write node access.
   *
   * @return {StorageTextureNode} A reference to this node.
   */
  toReadWrite() {
    return this.setAccess(NodeAccess.READ_WRITE);
  }
  /**
   * Convenience method for configuring a read-only node access.
   *
   * @return {StorageTextureNode} A reference to this node.
   */
  toReadOnly() {
    return this.setAccess(NodeAccess.READ_ONLY);
  }
  /**
   * Convenience method for configuring a write-only node access.
   *
   * @return {StorageTextureNode} A reference to this node.
   */
  toWriteOnly() {
    return this.setAccess(NodeAccess.WRITE_ONLY);
  }
  /**
   * Generates the code snippet of the storage texture node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  generateStore(builder) {
    const properties = builder.getNodeProperties(this);
    const { uvNode, storeNode, depthNode } = properties;
    const textureProperty = super.generate(builder, "property");
    const uvSnippet = uvNode.build(builder, this.value.is3DTexture === true ? "uvec3" : "uvec2");
    const storeSnippet = storeNode.build(builder, "vec4");
    const depthSnippet = depthNode ? depthNode.build(builder, "int") : null;
    const snippet = builder.generateTextureStore(builder, textureProperty, uvSnippet, depthSnippet, storeSnippet);
    builder.addLineFlowCode(snippet, this);
  }
  clone() {
    const newNode = super.clone();
    newNode.storeNode = this.storeNode;
    newNode.mipLevel = this.mipLevel;
    return newNode;
  }
};
var storageTexture = nodeProxy(StorageTextureNode).setParameterLength(1, 3);
var textureStore = (value, uvNode, storeNode) => {
  const node = storageTexture(value, uvNode, storeNode);
  if (storeNode !== null) node.toStack();
  return node;
};
var normal = Fn(({ texture: texture2, uv: uv2 }) => {
  const epsilon3 = 1e-4;
  const ret = vec3().toVar();
  If(uv2.x.lessThan(epsilon3), () => {
    ret.assign(vec3(1, 0, 0));
  }).ElseIf(uv2.y.lessThan(epsilon3), () => {
    ret.assign(vec3(0, 1, 0));
  }).ElseIf(uv2.z.lessThan(epsilon3), () => {
    ret.assign(vec3(0, 0, 1));
  }).ElseIf(uv2.x.greaterThan(1 - epsilon3), () => {
    ret.assign(vec3(-1, 0, 0));
  }).ElseIf(uv2.y.greaterThan(1 - epsilon3), () => {
    ret.assign(vec3(0, -1, 0));
  }).ElseIf(uv2.z.greaterThan(1 - epsilon3), () => {
    ret.assign(vec3(0, 0, -1));
  }).Else(() => {
    const step2 = 0.01;
    const x3 = texture2.sample(uv2.add(vec3(-step2, 0, 0))).r.sub(texture2.sample(uv2.add(vec3(step2, 0, 0))).r);
    const y3 = texture2.sample(uv2.add(vec3(0, -step2, 0))).r.sub(texture2.sample(uv2.add(vec3(0, step2, 0))).r);
    const z3 = texture2.sample(uv2.add(vec3(0, 0, -step2))).r.sub(texture2.sample(uv2.add(vec3(0, 0, step2))).r);
    ret.assign(vec3(x3, y3, z3));
  });
  return ret.normalize();
});
var Texture3DNode = class extends TextureNode {
  static get type() {
    return "Texture3DNode";
  }
  /**
   * Constructs a new 3D texture node.
   *
   * @param {Data3DTexture} value - The 3D texture.
   * @param {?Node<vec2|vec3>} [uvNode=null] - The uv node.
   * @param {?Node<int>} [levelNode=null] - The level node.
   */
  constructor(value, uvNode = null, levelNode = null) {
    super(value, uvNode, levelNode);
    this.isTexture3DNode = true;
  }
  /**
   * Overwrites the default implementation to return a fixed value `'texture3D'`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType() {
    return "texture3D";
  }
  /**
   * Returns a default uv node which is in context of 3D textures a three-dimensional
   * uv node.
   *
   * @return {Node<vec3>} The default uv node.
   */
  getDefaultUV() {
    return vec3(0.5, 0.5, 0.5);
  }
  /**
   * Overwritten with an empty implementation since the `updateMatrix` flag is ignored
   * for 3D textures. The uv transformation matrix is not applied to 3D textures.
   *
   * @param {boolean} value - The update toggle.
   */
  setUpdateMatrix() {
  }
  // Ignore .updateMatrix for 3d TextureNode
  /**
   * Overwrites the default implementation to return the unmodified uv node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node} uvNode - The uv node to setup.
   * @return {Node} The unmodified uv node.
   */
  setupUV(builder, uvNode) {
    const texture2 = this.value;
    if (builder.isFlipY() && (texture2.isRenderTargetTexture === true || texture2.isFramebufferTexture === true)) {
      if (this.sampler) {
        uvNode = uvNode.flipY();
      } else {
        uvNode = uvNode.setY(int(textureSize(this, this.levelNode).y).sub(uvNode.y).sub(1));
      }
    }
    return uvNode;
  }
  /**
   * Generates the uv code snippet.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node} uvNode - The uv node to generate code for.
   * @return {string} The generated code snippet.
   */
  generateUV(builder, uvNode) {
    return uvNode.build(builder, this.sampler === true ? "vec3" : "ivec3");
  }
  /**
   * Generates the offset code snippet.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node} offsetNode - The offset node to generate code for.
   * @return {string} The generated code snippet.
   */
  generateOffset(builder, offsetNode) {
    return offsetNode.build(builder, "ivec3");
  }
  /**
   * TODO.
   *
   * @param {Node<vec3>} uvNode - The uv node .
   * @return {Node<vec3>} TODO.
   */
  normal(uvNode) {
    return normal({ texture: this, uv: uvNode });
  }
};
var texture3D = nodeProxy(Texture3DNode).setParameterLength(1, 3);
var texture3DLoad = (...params) => texture3D(...params).setSampler(false);
var texture3DLevel = (value, uvNode, levelNode) => texture3D(value, uvNode).level(levelNode);
var UserDataNode = class extends ReferenceNode {
  static get type() {
    return "UserDataNode";
  }
  /**
   * Constructs a new user data node.
   *
   * @param {string} property - The property name that should be referenced by the node.
   * @param {string} inputType - The node data type of the reference.
   * @param {?Object} [userData=null] - A reference to the `userData` object. If not provided, the `userData` property of the 3D object that uses the node material is evaluated.
   */
  constructor(property3, inputType, userData2 = null) {
    super(property3, inputType, userData2);
    this.userData = userData2;
  }
  /**
   * Overwritten to make sure {@link ReferenceNode#reference} points to the correct
   * `userData` field.
   *
   * @param {(NodeFrame|NodeBuilder)} state - The current state to evaluate.
   * @return {Object} A reference to the `userData` field.
   */
  updateReference(state) {
    this.reference = this.userData !== null ? this.userData : state.object.userData;
    return this.reference;
  }
};
var userData = (name, inputType, userData2) => new UserDataNode(name, inputType, userData2);
var _objectData = /* @__PURE__ */ new WeakMap();
var VelocityNode = class extends TempNode {
  static get type() {
    return "VelocityNode";
  }
  /**
   * Constructs a new vertex color node.
   */
  constructor() {
    super("vec2");
    this.projectionMatrix = null;
    this.updateType = NodeUpdateType.OBJECT;
    this.updateAfterType = NodeUpdateType.OBJECT;
    this.previousModelWorldMatrix = uniform(new Matrix4());
    this.previousProjectionMatrix = uniform(new Matrix4()).setGroup(renderGroup);
    this.previousCameraViewMatrix = uniform(new Matrix4());
  }
  /**
   * Sets the given projection matrix.
   *
   * @param {Matrix4} projectionMatrix - The projection matrix to set.
   */
  setProjectionMatrix(projectionMatrix) {
    this.projectionMatrix = projectionMatrix;
  }
  /**
   * Updates velocity specific uniforms.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update({ frameId: frameId2, camera: camera3, object }) {
    const previousModelMatrix = getPreviousMatrix(object);
    this.previousModelWorldMatrix.value.copy(previousModelMatrix);
    const cameraData = getData2(camera3);
    if (cameraData.frameId !== frameId2) {
      cameraData.frameId = frameId2;
      if (cameraData.previousProjectionMatrix === void 0) {
        cameraData.previousProjectionMatrix = new Matrix4();
        cameraData.previousCameraViewMatrix = new Matrix4();
        cameraData.currentProjectionMatrix = new Matrix4();
        cameraData.currentCameraViewMatrix = new Matrix4();
        cameraData.previousProjectionMatrix.copy(this.projectionMatrix || camera3.projectionMatrix);
        cameraData.previousCameraViewMatrix.copy(camera3.matrixWorldInverse);
      } else {
        cameraData.previousProjectionMatrix.copy(cameraData.currentProjectionMatrix);
        cameraData.previousCameraViewMatrix.copy(cameraData.currentCameraViewMatrix);
      }
      cameraData.currentProjectionMatrix.copy(this.projectionMatrix || camera3.projectionMatrix);
      cameraData.currentCameraViewMatrix.copy(camera3.matrixWorldInverse);
      this.previousProjectionMatrix.value.copy(cameraData.previousProjectionMatrix);
      this.previousCameraViewMatrix.value.copy(cameraData.previousCameraViewMatrix);
    }
  }
  /**
   * Overwritten to updated velocity specific uniforms.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  updateAfter({ object }) {
    getPreviousMatrix(object).copy(object.matrixWorld);
  }
  /**
   * Implements the velocity computation based on the previous and current vertex data.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @return {Node<vec2>} The motion vector.
   */
  setup() {
    const projectionMatrix = this.projectionMatrix === null ? cameraProjectionMatrix : uniform(this.projectionMatrix);
    const previousModelViewMatrix = this.previousCameraViewMatrix.mul(this.previousModelWorldMatrix);
    const clipPositionCurrent = projectionMatrix.mul(modelViewMatrix).mul(positionLocal);
    const clipPositionPrevious = this.previousProjectionMatrix.mul(previousModelViewMatrix).mul(positionPrevious);
    const ndcPositionCurrent = clipPositionCurrent.xy.div(clipPositionCurrent.w);
    const ndcPositionPrevious = clipPositionPrevious.xy.div(clipPositionPrevious.w);
    const velocity2 = sub(ndcPositionCurrent, ndcPositionPrevious);
    return velocity2;
  }
};
function getData2(object) {
  let objectData = _objectData.get(object);
  if (objectData === void 0) {
    objectData = {};
    _objectData.set(object, objectData);
  }
  return objectData;
}
function getPreviousMatrix(object, index8 = 0) {
  const objectData = getData2(object);
  let matrix = objectData[index8];
  if (matrix === void 0) {
    objectData[index8] = matrix = new Matrix4();
    objectData[index8].copy(object.matrixWorld);
  }
  return matrix;
}
var velocity = nodeImmutable(VelocityNode);
var grayscale = Fn(([color3]) => {
  return luminance(color3.rgb);
});
var saturation = Fn(([color3, adjustment = float(1)]) => {
  return adjustment.mix(luminance(color3.rgb), color3.rgb);
});
var vibrance = Fn(([color3, adjustment = float(1)]) => {
  const average = add4(color3.r, color3.g, color3.b).div(3);
  const mx = color3.r.max(color3.g.max(color3.b));
  const amt = mx.sub(average).mul(adjustment).mul(-3);
  return mix2(color3.rgb, mx, amt);
});
var hue2 = Fn(([color3, adjustment = float(1)]) => {
  const k2 = vec3(0.57735, 0.57735, 0.57735);
  const cosAngle = adjustment.cos();
  return vec3(color3.rgb.mul(cosAngle).add(k2.cross(color3.rgb).mul(adjustment.sin()).add(k2.mul(dot(k2, color3.rgb).mul(cosAngle.oneMinus())))));
});
var luminance = (color3, luminanceCoefficients = vec3(ColorManagement.getLuminanceCoefficients(new Vector3()))) => dot(color3, luminanceCoefficients);
var cdl = Fn(([
  color3,
  slope = vec3(1),
  offset = vec3(0),
  power = vec3(1),
  saturation2 = float(1),
  // ASC CDL v1.2 explicitly requires Rec. 709 luminance coefficients.
  luminanceCoefficients = vec3(ColorManagement.getLuminanceCoefficients(new Vector3(), LinearSRGBColorSpace))
]) => {
  const luma = color3.rgb.dot(vec3(luminanceCoefficients));
  const v2 = max$1(color3.rgb.mul(slope).add(offset), 0).toVar();
  const pv = v2.pow(power).toVar();
  If(v2.r.greaterThan(0), () => {
    v2.r.assign(pv.r);
  });
  If(v2.g.greaterThan(0), () => {
    v2.g.assign(pv.g);
  });
  If(v2.b.greaterThan(0), () => {
    v2.b.assign(pv.b);
  });
  v2.assign(luma.add(v2.sub(luma).mul(saturation2)));
  return vec4(v2.rgb, color3.a);
});
var PosterizeNode = class extends TempNode {
  static get type() {
    return "PosterizeNode";
  }
  /**
   * Constructs a new posterize node.
   *
   * @param {Node} sourceNode - The input color.
   * @param {Node} stepsNode - Controls the intensity of the posterization effect. A lower number results in a more blocky appearance.
   */
  constructor(sourceNode, stepsNode) {
    super();
    this.sourceNode = sourceNode;
    this.stepsNode = stepsNode;
  }
  setup() {
    const { sourceNode, stepsNode } = this;
    return sourceNode.mul(stepsNode).floor().div(stepsNode);
  }
};
var posterize = nodeProxy(PosterizeNode).setParameterLength(2);
var _size = new Vector2();
var PassTextureNode = class extends TextureNode {
  static get type() {
    return "PassTextureNode";
  }
  /**
   * Constructs a new pass texture node.
   *
   * @param {PassNode} passNode - The pass node.
   * @param {Texture} texture - The output texture.
   */
  constructor(passNode, texture2) {
    super(texture2);
    this.passNode = passNode;
    this.setUpdateMatrix(false);
  }
  setup(builder) {
    this.passNode.build(builder);
    return super.setup(builder);
  }
  clone() {
    return new this.constructor(this.passNode, this.value);
  }
};
var PassMultipleTextureNode = class extends PassTextureNode {
  static get type() {
    return "PassMultipleTextureNode";
  }
  /**
   * Constructs a new pass texture node.
   *
   * @param {PassNode} passNode - The pass node.
   * @param {string} textureName - The output texture name.
   * @param {boolean} [previousTexture=false] - Whether previous frame data should be used or not.
   */
  constructor(passNode, textureName, previousTexture = false) {
    super(passNode, null);
    this.textureName = textureName;
    this.previousTexture = previousTexture;
  }
  /**
   * Updates the texture reference of this node.
   */
  updateTexture() {
    this.value = this.previousTexture ? this.passNode.getPreviousTexture(this.textureName) : this.passNode.getTexture(this.textureName);
  }
  setup(builder) {
    this.updateTexture();
    return super.setup(builder);
  }
  clone() {
    const newNode = new this.constructor(this.passNode, this.textureName, this.previousTexture);
    newNode.uvNode = this.uvNode;
    newNode.levelNode = this.levelNode;
    newNode.biasNode = this.biasNode;
    newNode.sampler = this.sampler;
    newNode.depthNode = this.depthNode;
    newNode.compareNode = this.compareNode;
    newNode.gradNode = this.gradNode;
    newNode.offsetNode = this.offsetNode;
    return newNode;
  }
};
var PassNode = class _PassNode extends TempNode {
  static get type() {
    return "PassNode";
  }
  /**
   * Constructs a new pass node.
   *
   * @param {('color'|'depth')} scope - The scope of the pass. The scope determines whether the node outputs color or depth.
   * @param {Scene} scene - A reference to the scene.
   * @param {Camera} camera - A reference to the camera.
   * @param {Object} options - Options for the internal render target.
   */
  constructor(scope, scene3, camera3, options = {}) {
    super("vec4");
    this.scope = scope;
    this.scene = scene3;
    this.camera = camera3;
    this.options = options;
    this._pixelRatio = 1;
    this._width = 1;
    this._height = 1;
    const depthTexture = new DepthTexture();
    depthTexture.isRenderTargetTexture = true;
    depthTexture.name = "depth";
    const renderTarget = new RenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio, { type: HalfFloatType, ...options });
    renderTarget.texture.name = "output";
    renderTarget.depthTexture = depthTexture;
    this.renderTarget = renderTarget;
    this.overrideMaterial = null;
    this.transparent = true;
    this.opaque = true;
    this.contextNode = null;
    this._contextNodeCache = null;
    this._textures = {
      output: renderTarget.texture,
      depth: depthTexture
    };
    this._textureNodes = {};
    this._linearDepthNodes = {};
    this._viewZNodes = {};
    this._previousTextures = {};
    this._previousTextureNodes = {};
    this._cameraNear = uniform(0);
    this._cameraFar = uniform(0);
    this._mrt = null;
    this._layers = null;
    this._resolutionScale = 1;
    this._viewport = null;
    this._scissor = null;
    this.isPassNode = true;
    this.updateBeforeType = NodeUpdateType.FRAME;
    this.global = true;
  }
  /**
   * Sets the resolution scale for the pass.
   * The resolution scale is a factor that is multiplied with the renderer's width and height.
   *
   * @param {number} resolutionScale - The resolution scale to set. A value of `1` means full resolution.
   * @return {PassNode} A reference to this pass.
   */
  setResolutionScale(resolutionScale) {
    this._resolutionScale = resolutionScale;
    return this;
  }
  /**
   * Gets the current resolution scale of the pass.
   *
   * @return {number} The current resolution scale. A value of `1` means full resolution.
   */
  getResolutionScale() {
    return this._resolutionScale;
  }
  /**
   * Sets the resolution for the pass.
   * The resolution is a factor that is multiplied with the renderer's width and height.
   *
   * @param {number} resolution - The resolution to set. A value of `1` means full resolution.
   * @return {PassNode} A reference to this pass.
   * @deprecated since r181. Use {@link PassNode#setResolutionScale `setResolutionScale()`} instead.
   */
  setResolution(resolution) {
    warn("PassNode: .setResolution() is deprecated. Use .setResolutionScale() instead.");
    return this.setResolutionScale(resolution);
  }
  /**
   * Gets the current resolution of the pass.
   *
   * @return {number} The current resolution. A value of `1` means full resolution.
   * @deprecated since r181. Use {@link PassNode#getResolutionScale `getResolutionScale()`} instead.
   */
  getResolution() {
    warn("PassNode: .getResolution() is deprecated. Use .getResolutionScale() instead.");
    return this.getResolutionScale();
  }
  /**
   * Sets the layer configuration that should be used when rendering the pass.
   *
   * @param {Layers} layers - The layers object to set.
   * @return {PassNode} A reference to this pass.
   */
  setLayers(layers) {
    this._layers = layers;
    return this;
  }
  /**
   * Gets the current layer configuration of the pass.
   *
   * @return {?Layers} .
   */
  getLayers() {
    return this._layers;
  }
  /**
   * Sets the given MRT node to setup MRT for this pass.
   *
   * @param {MRTNode} mrt - The MRT object.
   * @return {PassNode} A reference to this pass.
   */
  setMRT(mrt2) {
    this._mrt = mrt2;
    return this;
  }
  /**
   * Returns the current MRT node.
   *
   * @return {MRTNode} The current MRT node.
   */
  getMRT() {
    return this._mrt;
  }
  /**
   * Returns the texture for the given output name.
   *
   * @param {string} name - The output name to get the texture for.
   * @return {Texture} The texture.
   */
  getTexture(name) {
    let texture2 = this._textures[name];
    if (texture2 === void 0) {
      const refTexture = this.renderTarget.texture;
      texture2 = refTexture.clone();
      texture2.name = name;
      this._textures[name] = texture2;
      this.renderTarget.textures.push(texture2);
    }
    return texture2;
  }
  /**
   * Returns the texture holding the data of the previous frame for the given output name.
   *
   * @param {string} name - The output name to get the texture for.
   * @return {Texture} The texture holding the data of the previous frame.
   */
  getPreviousTexture(name) {
    let texture2 = this._previousTextures[name];
    if (texture2 === void 0) {
      texture2 = this.getTexture(name).clone();
      this._previousTextures[name] = texture2;
    }
    return texture2;
  }
  /**
   * Switches current and previous textures for the given output name.
   *
   * @param {string} name - The output name.
   */
  toggleTexture(name) {
    const prevTexture = this._previousTextures[name];
    if (prevTexture !== void 0) {
      const texture2 = this._textures[name];
      const index8 = this.renderTarget.textures.indexOf(texture2);
      this.renderTarget.textures[index8] = prevTexture;
      this._textures[name] = prevTexture;
      this._previousTextures[name] = texture2;
      this._textureNodes[name].updateTexture();
      this._previousTextureNodes[name].updateTexture();
    }
  }
  /**
   * Returns the texture node for the given output name.
   *
   * @param {string} [name='output'] - The output name to get the texture node for.
   * @return {TextureNode} The texture node.
   */
  getTextureNode(name = "output") {
    let textureNode = this._textureNodes[name];
    if (textureNode === void 0) {
      textureNode = new PassMultipleTextureNode(this, name);
      textureNode.updateTexture();
      this._textureNodes[name] = textureNode;
    }
    return textureNode;
  }
  /**
   * Returns the previous texture node for the given output name.
   *
   * @param {string} [name='output'] - The output name to get the previous texture node for.
   * @return {TextureNode} The previous texture node.
   */
  getPreviousTextureNode(name = "output") {
    let textureNode = this._previousTextureNodes[name];
    if (textureNode === void 0) {
      if (this._textureNodes[name] === void 0) this.getTextureNode(name);
      textureNode = new PassMultipleTextureNode(this, name, true);
      textureNode.updateTexture();
      this._previousTextureNodes[name] = textureNode;
    }
    return textureNode;
  }
  /**
   * Returns a viewZ node of this pass.
   *
   * @param {string} [name='depth'] - The output name to get the viewZ node for. In most cases the default `'depth'` can be used however the parameter exists for custom depth outputs.
   * @return {Node} The viewZ node.
   */
  getViewZNode(name = "depth") {
    let viewZNode = this._viewZNodes[name];
    if (viewZNode === void 0) {
      const cameraNear2 = this._cameraNear;
      const cameraFar2 = this._cameraFar;
      this._viewZNodes[name] = viewZNode = perspectiveDepthToViewZ(this.getTextureNode(name), cameraNear2, cameraFar2);
    }
    return viewZNode;
  }
  /**
   * Returns a linear depth node of this pass.
   *
   * @param {string} [name='depth'] - The output name to get the linear depth node for. In most cases the default `'depth'` can be used however the parameter exists for custom depth outputs.
   * @return {Node} The linear depth node.
   */
  getLinearDepthNode(name = "depth") {
    let linearDepthNode = this._linearDepthNodes[name];
    if (linearDepthNode === void 0) {
      const cameraNear2 = this._cameraNear;
      const cameraFar2 = this._cameraFar;
      const viewZNode = this.getViewZNode(name);
      this._linearDepthNodes[name] = linearDepthNode = viewZToOrthographicDepth(viewZNode, cameraNear2, cameraFar2);
    }
    return linearDepthNode;
  }
  /**
   * Precompiles the pass.
   *
   * Note that this method must be called after the pass configuration is complete.
   * So calls like `setMRT()` and `getTextureNode()` must proceed the precompilation.
   *
   * @async
   * @param {Renderer} renderer - The renderer.
   * @return {Promise} A Promise that resolves when the compile has been finished.
   * @see {@link Renderer#compileAsync}
   */
  async compileAsync(renderer3) {
    const currentRenderTarget = renderer3.getRenderTarget();
    const currentMRT = renderer3.getMRT();
    renderer3.setRenderTarget(this.renderTarget);
    renderer3.setMRT(this._mrt);
    await renderer3.compileAsync(this.scene, this.camera);
    renderer3.setRenderTarget(currentRenderTarget);
    renderer3.setMRT(currentMRT);
  }
  setup({ renderer: renderer3 }) {
    this.renderTarget.samples = this.options.samples === void 0 ? renderer3.samples : this.options.samples;
    this.renderTarget.texture.type = renderer3.getOutputBufferType();
    return this.scope === _PassNode.COLOR ? this.getTextureNode() : this.getLinearDepthNode();
  }
  updateBefore(frame2) {
    const { renderer: renderer3 } = frame2;
    const { scene: scene3 } = this;
    let camera3;
    let pixelRatio;
    const outputRenderTarget = renderer3.getOutputRenderTarget();
    if (outputRenderTarget && outputRenderTarget.isXRRenderTarget === true) {
      pixelRatio = 1;
      camera3 = renderer3.xr.getCamera();
      renderer3.xr.updateCamera(camera3);
      _size.set(outputRenderTarget.width, outputRenderTarget.height);
    } else {
      camera3 = this.camera;
      pixelRatio = renderer3.getPixelRatio();
      renderer3.getSize(_size);
    }
    this._pixelRatio = pixelRatio;
    this.setSize(_size.width, _size.height);
    const currentRenderTarget = renderer3.getRenderTarget();
    const currentMRT = renderer3.getMRT();
    const currentAutoClear = renderer3.autoClear;
    const currentTransparent = renderer3.transparent;
    const currentOpaque = renderer3.opaque;
    const currentMask = camera3.layers.mask;
    const currentContextNode = renderer3.contextNode;
    const currentOverrideMaterial = scene3.overrideMaterial;
    this._cameraNear.value = camera3.near;
    this._cameraFar.value = camera3.far;
    if (this._layers !== null) {
      camera3.layers.mask = this._layers.mask;
    }
    for (const name in this._previousTextures) {
      this.toggleTexture(name);
    }
    if (this.overrideMaterial !== null) {
      scene3.overrideMaterial = this.overrideMaterial;
    }
    renderer3.setRenderTarget(this.renderTarget);
    renderer3.setMRT(this._mrt);
    renderer3.autoClear = true;
    renderer3.transparent = this.transparent;
    renderer3.opaque = this.opaque;
    if (this.contextNode !== null) {
      if (this._contextNodeCache === null || this._contextNodeCache.version !== this.version) {
        this._contextNodeCache = {
          version: this.version,
          context: context({ ...renderer3.contextNode.getFlowContextData(), ...this.contextNode.getFlowContextData() })
        };
      }
      renderer3.contextNode = this._contextNodeCache.context;
    }
    const currentSceneName = scene3.name;
    scene3.name = this.name ? this.name : scene3.name;
    renderer3.render(scene3, camera3);
    scene3.name = currentSceneName;
    scene3.overrideMaterial = currentOverrideMaterial;
    renderer3.setRenderTarget(currentRenderTarget);
    renderer3.setMRT(currentMRT);
    renderer3.autoClear = currentAutoClear;
    renderer3.transparent = currentTransparent;
    renderer3.opaque = currentOpaque;
    renderer3.contextNode = currentContextNode;
    camera3.layers.mask = currentMask;
  }
  /**
   * Sets the size of the pass's render target. Honors the pixel ratio.
   *
   * @param {number} width - The width to set.
   * @param {number} height - The height to set.
   */
  setSize(width, height) {
    this._width = width;
    this._height = height;
    const effectiveWidth = Math.floor(this._width * this._pixelRatio * this._resolutionScale);
    const effectiveHeight = Math.floor(this._height * this._pixelRatio * this._resolutionScale);
    this.renderTarget.setSize(effectiveWidth, effectiveHeight);
    if (this._scissor !== null) this.renderTarget.scissor.copy(this._scissor);
    if (this._viewport !== null) this.renderTarget.viewport.copy(this._viewport);
  }
  /**
   * This method allows to define the pass's scissor rectangle. By default, the scissor rectangle is kept
   * in sync with the pass's dimensions. To reverse the process and use auto-sizing again, call the method
   * with `null` as the single argument.
   *
   * @param {?(number | Vector4)} x - The horizontal coordinate for the lower left corner of the box in logical pixel unit.
   * Instead of passing four arguments, the method also works with a single four-dimensional vector.
   * @param {number} y - The vertical coordinate for the lower left corner of the box in logical pixel unit.
   * @param {number} width - The width of the scissor box in logical pixel unit.
   * @param {number} height - The height of the scissor box in logical pixel unit.
   */
  setScissor(x3, y3, width, height) {
    if (x3 === null) {
      this._scissor = null;
    } else {
      if (this._scissor === null) this._scissor = new Vector4();
      if (x3.isVector4) {
        this._scissor.copy(x3);
      } else {
        this._scissor.set(x3, y3, width, height);
      }
      this._scissor.multiplyScalar(this._pixelRatio * this._resolutionScale).floor();
    }
  }
  /**
   * This method allows to define the pass's viewport. By default, the viewport is kept in sync
   * with the pass's dimensions. To reverse the process and use auto-sizing again, call the method
   * with `null` as the single argument.
   *
   * @param {number | Vector4} x - The horizontal coordinate for the lower left corner of the viewport origin in logical pixel unit.
   * @param {number} y - The vertical coordinate for the lower left corner of the viewport origin  in logical pixel unit.
   * @param {number} width - The width of the viewport in logical pixel unit.
   * @param {number} height - The height of the viewport in logical pixel unit.
   */
  setViewport(x3, y3, width, height) {
    if (x3 === null) {
      this._viewport = null;
    } else {
      if (this._viewport === null) this._viewport = new Vector4();
      if (x3.isVector4) {
        this._viewport.copy(x3);
      } else {
        this._viewport.set(x3, y3, width, height);
      }
      this._viewport.multiplyScalar(this._pixelRatio * this._resolutionScale).floor();
    }
  }
  /**
   * Sets the pixel ratio the pass's render target and updates the size.
   *
   * @param {number} pixelRatio - The pixel ratio to set.
   */
  setPixelRatio(pixelRatio) {
    this._pixelRatio = pixelRatio;
    this.setSize(this._width, this._height);
  }
  /**
   * Frees internal resources. Should be called when the node is no longer in use.
   */
  dispose() {
    this.renderTarget.dispose();
  }
};
PassNode.COLOR = "color";
PassNode.DEPTH = "depth";
var pass = (scene3, camera3, options) => new PassNode(PassNode.COLOR, scene3, camera3, options);
var passTexture = (pass2, texture2) => new PassTextureNode(pass2, texture2);
var depthPass = (scene3, camera3, options) => new PassNode(PassNode.DEPTH, scene3, camera3, options);
var ToonOutlinePassNode = class extends PassNode {
  static get type() {
    return "ToonOutlinePassNode";
  }
  /**
   * Constructs a new outline pass node.
   *
   * @param {Scene} scene - A reference to the scene.
   * @param {Camera} camera - A reference to the camera.
   * @param {Node} colorNode - Defines the outline's color.
   * @param {Node} thicknessNode - Defines the outline's thickness.
   * @param {Node} alphaNode - Defines the outline's alpha.
   */
  constructor(scene3, camera3, colorNode, thicknessNode, alphaNode) {
    super(PassNode.COLOR, scene3, camera3);
    this.colorNode = colorNode;
    this.thicknessNode = thicknessNode;
    this.alphaNode = alphaNode;
    this._materialCache = /* @__PURE__ */ new WeakMap();
    this.name = "Outline Pass";
  }
  updateBefore(frame2) {
    const { renderer: renderer3 } = frame2;
    const currentRenderObjectFunction = renderer3.getRenderObjectFunction();
    renderer3.setRenderObjectFunction((object, scene3, camera3, geometry, material, group2, lightsNode, clippingContext) => {
      if (material.isMeshToonMaterial || material.isMeshToonNodeMaterial) {
        if (material.wireframe === false) {
          const outlineMaterial = this._getOutlineMaterial(material);
          renderer3.renderObject(object, scene3, camera3, geometry, outlineMaterial, group2, lightsNode, clippingContext);
        }
      }
      renderer3.renderObject(object, scene3, camera3, geometry, material, group2, lightsNode, clippingContext);
    });
    super.updateBefore(frame2);
    renderer3.setRenderObjectFunction(currentRenderObjectFunction);
  }
  /**
   * Creates the material used for outline rendering.
   *
   * @private
   * @return {NodeMaterial} The outline material.
   */
  _createMaterial() {
    const material = new NodeMaterial();
    material.isMeshToonOutlineMaterial = true;
    material.name = "Toon_Outline";
    material.side = BackSide;
    const outlineNormal = normalLocal.negate();
    const mvp = cameraProjectionMatrix.mul(modelViewMatrix);
    const ratio = float(1);
    const pos = mvp.mul(vec4(positionLocal, 1));
    const pos2 = mvp.mul(vec4(positionLocal.add(outlineNormal), 1));
    const norm = normalize2(pos.sub(pos2));
    material.vertexNode = pos.add(norm.mul(this.thicknessNode).mul(pos.w).mul(ratio));
    material.colorNode = vec4(this.colorNode, this.alphaNode);
    return material;
  }
  /**
   * For the given toon material, this method returns a corresponding
   * outline material.
   *
   * @private
   * @param {(MeshToonMaterial|MeshToonNodeMaterial)} originalMaterial - The toon material.
   * @return {NodeMaterial} The outline material.
   */
  _getOutlineMaterial(originalMaterial) {
    let outlineMaterial = this._materialCache.get(originalMaterial);
    if (outlineMaterial === void 0) {
      outlineMaterial = this._createMaterial();
      this._materialCache.set(originalMaterial, outlineMaterial);
    }
    return outlineMaterial;
  }
};
var toonOutlinePass = (scene3, camera3, color3 = new Color(0, 0, 0), thickness2 = 3e-3, alpha = 1) => nodeObject(new ToonOutlinePassNode(scene3, camera3, nodeObject(color3), nodeObject(thickness2), nodeObject(alpha)));
var linearToneMapping = Fn(([color3, exposure]) => {
  return color3.mul(exposure).clamp();
}).setLayout({
  name: "linearToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
});
var reinhardToneMapping = Fn(([color3, exposure]) => {
  color3 = color3.mul(exposure);
  return color3.div(color3.add(1)).clamp();
}).setLayout({
  name: "reinhardToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
});
var cineonToneMapping = Fn(([color3, exposure]) => {
  color3 = color3.mul(exposure);
  color3 = color3.sub(4e-3).max(0);
  const a3 = color3.mul(color3.mul(6.2).add(0.5));
  const b = color3.mul(color3.mul(6.2).add(1.7)).add(0.06);
  return a3.div(b).pow(2.2);
}).setLayout({
  name: "cineonToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
});
var RRTAndODTFit = Fn(([color3]) => {
  const a3 = color3.mul(color3.add(0.0245786)).sub(90537e-9);
  const b = color3.mul(color3.add(0.432951).mul(0.983729)).add(0.238081);
  return a3.div(b);
});
var acesFilmicToneMapping = Fn(([color3, exposure]) => {
  const ACESInputMat = mat3(
    0.59719,
    0.35458,
    0.04823,
    0.076,
    0.90834,
    0.01566,
    0.0284,
    0.13383,
    0.83777
  );
  const ACESOutputMat = mat3(
    1.60475,
    -0.53108,
    -0.07367,
    -0.10208,
    1.10813,
    -605e-5,
    -327e-5,
    -0.07276,
    1.07602
  );
  color3 = color3.mul(exposure).div(0.6);
  color3 = ACESInputMat.mul(color3);
  color3 = RRTAndODTFit(color3);
  color3 = ACESOutputMat.mul(color3);
  return color3.clamp();
}).setLayout({
  name: "acesFilmicToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
});
var LINEAR_REC2020_TO_LINEAR_SRGB = mat3(vec3(1.6605, -0.1246, -0.0182), vec3(-0.5876, 1.1329, -0.1006), vec3(-0.0728, -83e-4, 1.1187));
var LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(vec3(0.6274, 0.0691, 0.0164), vec3(0.3293, 0.9195, 0.088), vec3(0.0433, 0.0113, 0.8956));
var agxDefaultContrastApprox = Fn(([x_immutable]) => {
  const x3 = vec3(x_immutable).toVar();
  const x22 = vec3(x3.mul(x3)).toVar();
  const x4 = vec3(x22.mul(x22)).toVar();
  return float(15.5).mul(x4.mul(x22)).sub(mul(40.14, x4.mul(x3))).add(mul(31.96, x4).sub(mul(6.868, x22.mul(x3))).add(mul(0.4298, x22).add(mul(0.1191, x3).sub(232e-5))));
});
var agxToneMapping = Fn(([color3, exposure]) => {
  const colortone = vec3(color3).toVar();
  const AgXInsetMatrix = mat3(vec3(0.856627153315983, 0.137318972929847, 0.11189821299995), vec3(0.0951212405381588, 0.761241990602591, 0.0767994186031903), vec3(0.0482516061458583, 0.101439036467562, 0.811302368396859));
  const AgXOutsetMatrix = mat3(vec3(1.1271005818144368, -0.1413297634984383, -0.14132976349843826), vec3(-0.11060664309660323, 1.157823702216272, -0.11060664309660294), vec3(-0.016493938717834573, -0.016493938717834257, 1.2519364065950405));
  const AgxMinEv = float(-12.47393);
  const AgxMaxEv = float(4.026069);
  colortone.mulAssign(exposure);
  colortone.assign(LINEAR_SRGB_TO_LINEAR_REC2020.mul(colortone));
  colortone.assign(AgXInsetMatrix.mul(colortone));
  colortone.assign(max$1(colortone, 1e-10));
  colortone.assign(log22(colortone));
  colortone.assign(colortone.sub(AgxMinEv).div(AgxMaxEv.sub(AgxMinEv)));
  colortone.assign(clamp3(colortone, 0, 1));
  colortone.assign(agxDefaultContrastApprox(colortone));
  colortone.assign(AgXOutsetMatrix.mul(colortone));
  colortone.assign(pow2(max$1(vec3(0), colortone), vec3(2.2)));
  colortone.assign(LINEAR_REC2020_TO_LINEAR_SRGB.mul(colortone));
  colortone.assign(clamp3(colortone, 0, 1));
  return colortone;
}).setLayout({
  name: "agxToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
});
var neutralToneMapping = Fn(([color3, exposure]) => {
  const StartCompression = float(0.8 - 0.04);
  const Desaturation = float(0.15);
  color3 = color3.mul(exposure);
  const x3 = min$1(color3.r, min$1(color3.g, color3.b));
  const offset = select(x3.lessThan(0.08), x3.sub(mul(6.25, x3.mul(x3))), 0.04);
  color3.subAssign(offset);
  const peak = max$1(color3.r, max$1(color3.g, color3.b));
  If(peak.lessThan(StartCompression), () => {
    return color3;
  });
  const d3 = sub(1, StartCompression);
  const newPeak = sub(1, d3.mul(d3).div(peak.add(d3.sub(StartCompression))));
  color3.mulAssign(newPeak.div(peak));
  const g3 = sub(1, div(1, Desaturation.mul(peak.sub(newPeak)).add(1)));
  return mix2(color3, vec3(newPeak), g3);
}).setLayout({
  name: "neutralToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
});
var CodeNode = class extends Node4 {
  static get type() {
    return "CodeNode";
  }
  /**
   * Constructs a new code node.
   *
   * @param {string} [code=''] - The native code.
   * @param {Array<Node>} [includes=[]] - An array of includes.
   * @param {('js'|'wgsl'|'glsl')} [language=''] - The used language.
   */
  constructor(code2 = "", includes2 = [], language = "") {
    super("code");
    this.isCodeNode = true;
    this.global = true;
    this.code = code2;
    this.includes = includes2;
    this.language = language;
  }
  /**
   * Sets the includes of this code node.
   *
   * @param {Array<Node>} includes - The includes to set.
   * @return {CodeNode} A reference to this node.
   */
  setIncludes(includes2) {
    this.includes = includes2;
    return this;
  }
  /**
   * Returns the includes of this code node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Array<Node>} The includes.
   */
  getIncludes() {
    return this.includes;
  }
  generate(builder) {
    const includes2 = this.getIncludes(builder);
    for (const include of includes2) {
      include.build(builder);
    }
    const nodeCode = builder.getCodeFromNode(this, this.getNodeType(builder));
    nodeCode.code = this.code;
    return nodeCode.code;
  }
  serialize(data) {
    super.serialize(data);
    data.code = this.code;
    data.language = this.language;
  }
  deserialize(data) {
    super.deserialize(data);
    this.code = data.code;
    this.language = data.language;
  }
};
var code = nodeProxy(CodeNode).setParameterLength(1, 3);
var js = (src, includes2) => code(src, includes2, "js");
var wgsl = (src, includes2) => code(src, includes2, "wgsl");
var glsl = (src, includes2) => code(src, includes2, "glsl");
var FunctionNode = class extends CodeNode {
  static get type() {
    return "FunctionNode";
  }
  /**
   * Constructs a new function node.
   *
   * @param {string} [code=''] - The native code.
   * @param {Array<Node>} [includes=[]] - An array of includes.
   * @param {('js'|'wgsl'|'glsl')} [language=''] - The used language.
   */
  constructor(code2 = "", includes2 = [], language = "") {
    super(code2, includes2, language);
  }
  /**
   * Returns the type of this function node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The type.
   */
  getNodeType(builder) {
    return this.getNodeFunction(builder).type;
  }
  /**
   * Returns the type of a member of this function node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} name - The name of the member.
   * @return {string} The type of the member.
   */
  getMemberType(builder, name) {
    const type = this.getNodeType(builder);
    const structType = builder.getStructTypeNode(type);
    return structType.getMemberType(builder, name);
  }
  /**
   * Returns the inputs of this function node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Array<NodeFunctionInput>} The inputs.
   */
  getInputs(builder) {
    return this.getNodeFunction(builder).inputs;
  }
  /**
   * Returns the node function for this function node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {NodeFunction} The node function.
   */
  getNodeFunction(builder) {
    const nodeData = builder.getDataFromNode(this);
    let nodeFunction = nodeData.nodeFunction;
    if (nodeFunction === void 0) {
      nodeFunction = builder.parser.parseFunction(this.code);
      nodeData.nodeFunction = nodeFunction;
    }
    return nodeFunction;
  }
  generate(builder, output2) {
    super.generate(builder);
    const nodeFunction = this.getNodeFunction(builder);
    const name = nodeFunction.name;
    const type = nodeFunction.type;
    const nodeCode = builder.getCodeFromNode(this, type);
    if (name !== "") {
      nodeCode.name = name;
    }
    const propertyName = builder.getPropertyName(nodeCode);
    const code2 = this.getNodeFunction(builder).getCode(propertyName);
    nodeCode.code = code2 + "\n";
    if (output2 === "property") {
      return propertyName;
    } else {
      return builder.format(`${propertyName}()`, type, output2);
    }
  }
};
var nativeFn = (code2, includes2 = [], language = "") => {
  for (let i2 = 0; i2 < includes2.length; i2++) {
    const include = includes2[i2];
    if (typeof include === "function") {
      includes2[i2] = include.functionNode;
    }
  }
  const functionNode = new FunctionNode(code2, includes2, language);
  const fn = (...params) => functionNode.call(...params);
  fn.functionNode = functionNode;
  return fn;
};
var glslFn = (code2, includes2) => nativeFn(code2, includes2, "glsl");
var wgslFn = (code2, includes2) => nativeFn(code2, includes2, "wgsl");
var ScriptableValueNode = class extends Node4 {
  static get type() {
    return "ScriptableValueNode";
  }
  /**
   * Constructs a new scriptable node.
   *
   * @param {any} [value=null] - The value.
   */
  constructor(value = null) {
    super();
    this._value = value;
    this._cache = null;
    this.inputType = null;
    this.outputType = null;
    this.events = new EventDispatcher();
    this.isScriptableValueNode = true;
  }
  /**
   * Whether this node represents an output or not.
   *
   * @type {boolean}
   * @readonly
   * @default true
   */
  get isScriptableOutputNode() {
    return this.outputType !== null;
  }
  set value(val) {
    if (this._value === val) return;
    if (this._cache && this.inputType === "URL" && this.value.value instanceof ArrayBuffer) {
      URL.revokeObjectURL(this._cache);
      this._cache = null;
    }
    this._value = val;
    this.events.dispatchEvent({ type: "change" });
    this.refresh();
  }
  /**
   * The node's value.
   *
   * @type {any}
   */
  get value() {
    return this._value;
  }
  /**
   * Dispatches the `refresh` event.
   */
  refresh() {
    this.events.dispatchEvent({ type: "refresh" });
  }
  /**
   * The `value` property usually represents a node or even binary data in form of array buffers.
   * In this case, this method tries to return the actual value behind the complex type.
   *
   * @return {any} The value.
   */
  getValue() {
    const value = this.value;
    if (value && this._cache === null && this.inputType === "URL" && value.value instanceof ArrayBuffer) {
      this._cache = URL.createObjectURL(new Blob([value.value]));
    } else if (value && value.value !== null && value.value !== void 0 && ((this.inputType === "URL" || this.inputType === "String") && typeof value.value === "string" || this.inputType === "Number" && typeof value.value === "number" || this.inputType === "Vector2" && value.value.isVector2 || this.inputType === "Vector3" && value.value.isVector3 || this.inputType === "Vector4" && value.value.isVector4 || this.inputType === "Color" && value.value.isColor || this.inputType === "Matrix3" && value.value.isMatrix3 || this.inputType === "Matrix4" && value.value.isMatrix4)) {
      return value.value;
    }
    return this._cache || value;
  }
  /**
   * Overwritten since the node type is inferred from the value.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    return this.value && this.value.isNode ? this.value.getNodeType(builder) : "float";
  }
  setup() {
    return this.value && this.value.isNode ? this.value : float();
  }
  serialize(data) {
    super.serialize(data);
    if (this.value !== null) {
      if (this.inputType === "ArrayBuffer") {
        data.value = arrayBufferToBase64(this.value);
      } else {
        data.value = this.value ? this.value.toJSON(data.meta).uuid : null;
      }
    } else {
      data.value = null;
    }
    data.inputType = this.inputType;
    data.outputType = this.outputType;
  }
  deserialize(data) {
    super.deserialize(data);
    let value = null;
    if (data.value !== null) {
      if (data.inputType === "ArrayBuffer") {
        value = base64ToArrayBuffer(data.value);
      } else if (data.inputType === "Texture") {
        value = data.meta.textures[data.value];
      } else {
        value = data.meta.nodes[data.value] || null;
      }
    }
    this.value = value;
    this.inputType = data.inputType;
    this.outputType = data.outputType;
  }
};
var scriptableValue = nodeProxy(ScriptableValueNode).setParameterLength(1);
var Resources = class extends Map {
  get(key, callback = null, ...params) {
    if (this.has(key)) return super.get(key);
    if (callback !== null) {
      const value = callback(...params);
      this.set(key, value);
      return value;
    }
  }
};
var Parameters = class {
  constructor(scriptableNode) {
    this.scriptableNode = scriptableNode;
  }
  get parameters() {
    return this.scriptableNode.parameters;
  }
  get layout() {
    return this.scriptableNode.getLayout();
  }
  getInputLayout(id2) {
    return this.scriptableNode.getInputLayout(id2);
  }
  get(name) {
    const param = this.parameters[name];
    const value = param ? param.getValue() : null;
    return value;
  }
};
var ScriptableNodeResources = new Resources();
var ScriptableNode = class extends Node4 {
  static get type() {
    return "ScriptableNode";
  }
  /**
   * Constructs a new scriptable node.
   *
   * @param {?CodeNode} [codeNode=null] - The code node.
   * @param {Object} [parameters={}] - The parameters definition.
   */
  constructor(codeNode = null, parameters = {}) {
    super();
    this.codeNode = codeNode;
    this.parameters = parameters;
    this._local = new Resources();
    this._output = scriptableValue(null);
    this._outputs = {};
    this._source = this.source;
    this._method = null;
    this._object = null;
    this._value = null;
    this._needsOutputUpdate = true;
    this.onRefresh = this.onRefresh.bind(this);
    this.isScriptableNode = true;
  }
  /**
   * The source code of the scriptable node.
   *
   * @type {string}
   */
  get source() {
    return this.codeNode ? this.codeNode.code : "";
  }
  /**
   * Sets the reference of a local script variable.
   *
   * @param {string} name - The variable name.
   * @param {Object} value - The reference to set.
   * @return {Resources} The resource map
   */
  setLocal(name, value) {
    return this._local.set(name, value);
  }
  /**
   * Gets the value of a local script variable.
   *
   * @param {string} name - The variable name.
   * @return {Object} The value.
   */
  getLocal(name) {
    return this._local.get(name);
  }
  /**
   * Event listener for the `refresh` event.
   */
  onRefresh() {
    this._refresh();
  }
  /**
   * Returns an input from the layout with the given id/name.
   *
   * @param {string} id - The id/name of the input.
   * @return {Object} The element entry.
   */
  getInputLayout(id2) {
    for (const element2 of this.getLayout()) {
      if (element2.inputType && (element2.id === id2 || element2.name === id2)) {
        return element2;
      }
    }
  }
  /**
   * Returns an output from the layout with the given id/name.
   *
   * @param {string} id - The id/name of the output.
   * @return {Object} The element entry.
   */
  getOutputLayout(id2) {
    for (const element2 of this.getLayout()) {
      if (element2.outputType && (element2.id === id2 || element2.name === id2)) {
        return element2;
      }
    }
  }
  /**
   * Defines a script output for the given name and value.
   *
   * @param {string} name - The name of the output.
   * @param {Node} value - The node value.
   * @return {ScriptableNode} A reference to this node.
   */
  setOutput(name, value) {
    const outputs = this._outputs;
    if (outputs[name] === void 0) {
      outputs[name] = scriptableValue(value);
    } else {
      outputs[name].value = value;
    }
    return this;
  }
  /**
   * Returns a script output for the given name.
   *
   * @param {string} name - The name of the output.
   * @return {ScriptableValueNode} The node value.
   */
  getOutput(name) {
    return this._outputs[name];
  }
  /**
   * Returns a parameter for the given name
   *
   * @param {string} name - The name of the parameter.
   * @return {ScriptableValueNode} The node value.
   */
  getParameter(name) {
    return this.parameters[name];
  }
  /**
   * Sets a value for the given parameter name.
   *
   * @param {string} name - The parameter name.
   * @param {any} value - The parameter value.
   * @return {ScriptableNode} A reference to this node.
   */
  setParameter(name, value) {
    const parameters = this.parameters;
    if (value && value.isScriptableNode) {
      this.deleteParameter(name);
      parameters[name] = value;
      parameters[name].getDefaultOutput().events.addEventListener("refresh", this.onRefresh);
    } else if (value && value.isScriptableValueNode) {
      this.deleteParameter(name);
      parameters[name] = value;
      parameters[name].events.addEventListener("refresh", this.onRefresh);
    } else if (parameters[name] === void 0) {
      parameters[name] = scriptableValue(value);
      parameters[name].events.addEventListener("refresh", this.onRefresh);
    } else {
      parameters[name].value = value;
    }
    return this;
  }
  /**
   * Returns the value of this node which is the value of
   * the default output.
   *
   * @return {Node} The value.
   */
  getValue() {
    return this.getDefaultOutput().getValue();
  }
  /**
   * Deletes a parameter from the script.
   *
   * @param {string} name - The parameter to remove.
   * @return {ScriptableNode} A reference to this node.
   */
  deleteParameter(name) {
    let valueNode = this.parameters[name];
    if (valueNode) {
      if (valueNode.isScriptableNode) valueNode = valueNode.getDefaultOutput();
      valueNode.events.removeEventListener("refresh", this.onRefresh);
    }
    return this;
  }
  /**
   * Deletes all parameters from the script.
   *
   * @return {ScriptableNode} A reference to this node.
   */
  clearParameters() {
    for (const name of Object.keys(this.parameters)) {
      this.deleteParameter(name);
    }
    this.needsUpdate = true;
    return this;
  }
  /**
   * Calls a function from the script.
   *
   * @param {string} name - The function name.
   * @param {...any} params - A list of parameters.
   * @return {any} The result of the function call.
   */
  call(name, ...params) {
    const object = this.getObject();
    const method2 = object[name];
    if (typeof method2 === "function") {
      return method2(...params);
    }
  }
  /**
   * Asynchronously calls a function from the script.
   *
   * @param {string} name - The function name.
   * @param {...any} params - A list of parameters.
   * @return {Promise<any>} The result of the function call.
   */
  async callAsync(name, ...params) {
    const object = this.getObject();
    const method2 = object[name];
    if (typeof method2 === "function") {
      return method2.constructor.name === "AsyncFunction" ? await method2(...params) : method2(...params);
    }
  }
  /**
   * Overwritten since the node types is inferred from the script's output.
   *
   * @param {NodeBuilder} builder - The current node builder
   * @return {string} The node type.
   */
  getNodeType(builder) {
    return this.getDefaultOutputNode().getNodeType(builder);
  }
  /**
   * Refreshes the script node.
   *
   * @param {?string} [output=null] - An optional output.
   */
  refresh(output2 = null) {
    if (output2 !== null) {
      this.getOutput(output2).refresh();
    } else {
      this._refresh();
    }
  }
  /**
   * Returns an object representation of the script.
   *
   * @return {Object} The result object.
   */
  getObject() {
    if (this.needsUpdate) this.dispose();
    if (this._object !== null) return this._object;
    const refresh2 = () => this.refresh();
    const setOutput = (id2, value) => this.setOutput(id2, value);
    const parameters = new Parameters(this);
    const THREE2 = ScriptableNodeResources.get("THREE");
    const TSL2 = ScriptableNodeResources.get("TSL");
    const method2 = this.getMethod();
    const params = [parameters, this._local, ScriptableNodeResources, refresh2, setOutput, THREE2, TSL2];
    this._object = method2(...params);
    const layout = this._object.layout;
    if (layout) {
      if (layout.cache === false) {
        this._local.clear();
      }
      this._output.outputType = layout.outputType || null;
      if (Array.isArray(layout.elements)) {
        for (const element2 of layout.elements) {
          const id2 = element2.id || element2.name;
          if (element2.inputType) {
            if (this.getParameter(id2) === void 0) this.setParameter(id2, null);
            this.getParameter(id2).inputType = element2.inputType;
          }
          if (element2.outputType) {
            if (this.getOutput(id2) === void 0) this.setOutput(id2, null);
            this.getOutput(id2).outputType = element2.outputType;
          }
        }
      }
    }
    return this._object;
  }
  deserialize(data) {
    super.deserialize(data);
    for (const name in this.parameters) {
      let valueNode = this.parameters[name];
      if (valueNode.isScriptableNode) valueNode = valueNode.getDefaultOutput();
      valueNode.events.addEventListener("refresh", this.onRefresh);
    }
  }
  /**
   * Returns the layout of the script.
   *
   * @return {Object} The script's layout.
   */
  getLayout() {
    return this.getObject().layout;
  }
  /**
   * Returns default node output of the script.
   *
   * @return {Node} The default node output.
   */
  getDefaultOutputNode() {
    const output2 = this.getDefaultOutput().value;
    if (output2 && output2.isNode) {
      return output2;
    }
    return float();
  }
  /**
   * Returns default output of the script.
   *
   * @return {ScriptableValueNode} The default output.
   */
  getDefaultOutput() {
    return this._exec()._output;
  }
  /**
   * Returns a function created from the node's script.
   *
   * @return {Function} The function representing the node's code.
   */
  getMethod() {
    if (this.needsUpdate) this.dispose();
    if (this._method !== null) return this._method;
    const parametersProps = ["parameters", "local", "global", "refresh", "setOutput", "THREE", "TSL"];
    const interfaceProps = ["layout", "init", "main", "dispose"];
    const properties = interfaceProps.join(", ");
    const declarations = "var " + properties + "; var output = {};\n";
    const returns = "\nreturn { ...output, " + properties + " };";
    const code2 = declarations + this.codeNode.code + returns;
    this._method = new Function(...parametersProps, code2);
    return this._method;
  }
  /**
   * Frees all internal resources.
   */
  dispose() {
    if (this._method === null) return;
    if (this._object && typeof this._object.dispose === "function") {
      this._object.dispose();
    }
    this._method = null;
    this._object = null;
    this._source = null;
    this._value = null;
    this._needsOutputUpdate = true;
    this._output.value = null;
    this._outputs = {};
  }
  setup() {
    return this.getDefaultOutputNode();
  }
  getCacheKey(force) {
    const values2 = [hashString(this.source), this.getDefaultOutputNode().getCacheKey(force)];
    for (const param in this.parameters) {
      values2.push(this.parameters[param].getCacheKey(force));
    }
    return hashArray(values2);
  }
  set needsUpdate(value) {
    if (value === true) this.dispose();
  }
  get needsUpdate() {
    return this.source !== this._source;
  }
  /**
   * Executes the `main` function of the script.
   *
   * @private
   * @return {ScriptableNode} A reference to this node.
   */
  _exec() {
    if (this.codeNode === null) return this;
    if (this._needsOutputUpdate === true) {
      this._value = this.call("main");
      this._needsOutputUpdate = false;
    }
    this._output.value = this._value;
    return this;
  }
  /**
   * Executes the refresh.
   *
   * @private
   */
  _refresh() {
    this.needsUpdate = true;
    this._exec();
    this._output.refresh();
  }
};
var scriptable = nodeProxy(ScriptableNode).setParameterLength(1, 2);
function getViewZNode(builder) {
  let viewZ;
  const getViewZ = builder.context.getViewZ;
  if (getViewZ !== void 0) {
    viewZ = getViewZ(this);
  }
  return (viewZ || positionView.z).negate();
}
var rangeFogFactor = Fn(([near, far], builder) => {
  const viewZ = getViewZNode(builder);
  return smoothstep2(near, far, viewZ);
});
var densityFogFactor = Fn(([density], builder) => {
  const viewZ = getViewZNode(builder);
  return density.mul(density, viewZ, viewZ).negate().exp().oneMinus();
});
var fog = Fn(([color3, factor]) => {
  return vec4(factor.toFloat().mix(output.rgb, color3.toVec3()), output.a);
});
function rangeFog(color3, near, far) {
  warn('TSL: "rangeFog( color, near, far )" is deprecated. Use "fog( color, rangeFogFactor( near, far ) )" instead.');
  return fog(color3, rangeFogFactor(near, far));
}
function densityFog(color3, density) {
  warn('TSL: "densityFog( color, density )" is deprecated. Use "fog( color, densityFogFactor( density ) )" instead.');
  return fog(color3, densityFogFactor(density));
}
var min2 = null;
var max3 = null;
var RangeNode = class extends Node4 {
  static get type() {
    return "RangeNode";
  }
  /**
   * Constructs a new range node.
   *
   * @param {Node<any>} [minNode=float()] - A node defining the lower bound of the range.
   * @param {Node<any>} [maxNode=float()] - A node defining the upper bound of the range.
   */
  constructor(minNode = float(), maxNode = float()) {
    super();
    this.minNode = minNode;
    this.maxNode = maxNode;
  }
  /**
   * Returns the vector length which is computed based on the range definition.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {number} The vector length.
   */
  getVectorLength(builder) {
    const minNode = this.getConstNode(this.minNode);
    const maxNode = this.getConstNode(this.maxNode);
    const minLength = builder.getTypeLength(getValueType(minNode.value));
    const maxLength = builder.getTypeLength(getValueType(maxNode.value));
    return minLength > maxLength ? minLength : maxLength;
  }
  /**
   * This method is overwritten since the node type is inferred from range definition.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    return builder.object.count > 1 ? builder.getTypeFromLength(this.getVectorLength(builder)) : "float";
  }
  /**
   * Returns a constant node from the given node by traversing it.
   *
   * @param {Node} node - The node to traverse.
   * @returns {Node} The constant node, if found.
   */
  getConstNode(node) {
    let output2 = null;
    node.traverse((n2) => {
      if (n2.isConstNode === true) {
        output2 = n2;
      }
    });
    if (output2 === null) {
      throw new Error('THREE.TSL: No "ConstNode" found in node graph.');
    }
    return output2;
  }
  setup(builder) {
    const object = builder.object;
    let output2 = null;
    if (object.count > 1) {
      const minNode = this.getConstNode(this.minNode);
      const maxNode = this.getConstNode(this.maxNode);
      const minValue = minNode.value;
      const maxValue = maxNode.value;
      const minLength = builder.getTypeLength(getValueType(minValue));
      const maxLength = builder.getTypeLength(getValueType(maxValue));
      min2 = min2 || new Vector4();
      max3 = max3 || new Vector4();
      min2.setScalar(0);
      max3.setScalar(0);
      if (minLength === 1) min2.setScalar(minValue);
      else if (minValue.isColor) min2.set(minValue.r, minValue.g, minValue.b, 1);
      else min2.set(minValue.x, minValue.y, minValue.z || 0, minValue.w || 0);
      if (maxLength === 1) max3.setScalar(maxValue);
      else if (maxValue.isColor) max3.set(maxValue.r, maxValue.g, maxValue.b, 1);
      else max3.set(maxValue.x, maxValue.y, maxValue.z || 0, maxValue.w || 0);
      const stride = 4;
      const length2 = stride * object.count;
      const array4 = new Float32Array(length2);
      for (let i2 = 0; i2 < length2; i2++) {
        const index8 = i2 % stride;
        const minElementValue = min2.getComponent(index8);
        const maxElementValue = max3.getComponent(index8);
        array4[i2] = MathUtils.lerp(minElementValue, maxElementValue, Math.random());
      }
      const nodeType = this.getNodeType(builder);
      if (object.count <= 4096) {
        output2 = buffer(array4, "vec4", object.count).element(instanceIndex).convert(nodeType);
      } else {
        const bufferAttribute2 = new InstancedBufferAttribute(array4, 4);
        builder.geometry.setAttribute("__range" + this.id, bufferAttribute2);
        output2 = instancedBufferAttribute(bufferAttribute2).convert(nodeType);
      }
    } else {
      output2 = float(0);
    }
    return output2;
  }
};
var range2 = nodeProxy(RangeNode).setParameterLength(2);
var ComputeBuiltinNode = class extends Node4 {
  static get type() {
    return "ComputeBuiltinNode";
  }
  /**
   * Constructs a new compute builtin node.
   *
   * @param {string} builtinName - The built-in name.
   * @param {string} nodeType - The node type.
   */
  constructor(builtinName, nodeType) {
    super(nodeType);
    this._builtinName = builtinName;
  }
  /**
   * This method is overwritten since hash is derived from the built-in name.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The hash.
   */
  getHash(builder) {
    return this.getBuiltinName(builder);
  }
  /**
   * This method is overwritten since the node type is simply derived from `nodeType`..
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType() {
    return this.nodeType;
  }
  /**
   * Sets the builtin name.
   *
   * @param {string} builtinName - The built-in name.
   * @return {ComputeBuiltinNode} A reference to this node.
   */
  setBuiltinName(builtinName) {
    this._builtinName = builtinName;
    return this;
  }
  /**
   * Returns the builtin name.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The builtin name.
   */
  getBuiltinName() {
    return this._builtinName;
  }
  /**
   * Whether the current node builder has the builtin or not.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {boolean} Whether the builder has the builtin or not.
   */
  hasBuiltin(builder) {
    return builder.hasBuiltin(this._builtinName);
  }
  generate(builder, output2) {
    const builtinName = this.getBuiltinName(builder);
    const nodeType = this.getNodeType(builder);
    if (builder.shaderStage === "compute") {
      return builder.format(builtinName, nodeType, output2);
    } else {
      warn(`ComputeBuiltinNode: Compute built-in value ${builtinName} can not be accessed in the ${builder.shaderStage} stage`);
      return builder.generateConst(nodeType);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.global = this.global;
    data._builtinName = this._builtinName;
  }
  deserialize(data) {
    super.deserialize(data);
    this.global = data.global;
    this._builtinName = data._builtinName;
  }
};
var computeBuiltin = (name, nodeType) => new ComputeBuiltinNode(name, nodeType);
var numWorkgroups = computeBuiltin("numWorkgroups", "uvec3");
var workgroupId = computeBuiltin("workgroupId", "uvec3");
var globalId = computeBuiltin("globalId", "uvec3");
var localId = computeBuiltin("localId", "uvec3");
var subgroupSize = computeBuiltin("subgroupSize", "uint");
var BarrierNode = class extends Node4 {
  /**
   * Constructs a new barrier node.
   *
   * @param {string} scope - The scope defines the behavior of the node.
   */
  constructor(scope) {
    super();
    this.scope = scope;
  }
  generate(builder) {
    const { scope } = this;
    const { renderer: renderer3 } = builder;
    if (renderer3.backend.isWebGLBackend === true) {
      builder.addFlowCode(`	// ${scope}Barrier 
`);
    } else {
      builder.addLineFlowCode(`${scope}Barrier()`, this);
    }
  }
};
var barrier = nodeProxy(BarrierNode);
var workgroupBarrier = () => barrier("workgroup").toStack();
var storageBarrier = () => barrier("storage").toStack();
var textureBarrier = () => barrier("texture").toStack();
var WorkgroupInfoElementNode = class extends ArrayElementNode {
  /**
   * Constructs a new workgroup info element node.
   *
   * @param {Node} workgroupInfoNode - The workgroup info node.
   * @param {Node} indexNode - The index node that defines the element access.
   */
  constructor(workgroupInfoNode, indexNode) {
    super(workgroupInfoNode, indexNode);
    this.isWorkgroupInfoElementNode = true;
  }
  generate(builder, output2) {
    let snippet;
    const isAssignContext = builder.context.assign;
    snippet = super.generate(builder);
    if (isAssignContext !== true) {
      const type = this.getNodeType(builder);
      snippet = builder.format(snippet, type, output2);
    }
    return snippet;
  }
};
var WorkgroupInfoNode = class extends Node4 {
  /**
   * Constructs a new buffer scoped to type scope.
   *
   * @param {string} scope - TODO.
   * @param {string} bufferType - The data type of a 'workgroup' scoped buffer element.
   * @param {number} [bufferCount=0] - The number of elements in the buffer.
   */
  constructor(scope, bufferType, bufferCount = 0) {
    super(bufferType);
    this.bufferType = bufferType;
    this.bufferCount = bufferCount;
    this.isWorkgroupInfoNode = true;
    this.elementType = bufferType;
    this.scope = scope;
    this.name = "";
  }
  /**
   * Sets the name of this node.
   *
   * @param {string} name - The name to set.
   * @return {WorkgroupInfoNode} A reference to this node.
   */
  setName(name) {
    this.name = name;
    return this;
  }
  /**
   * Sets the name/label of this node.
   *
   * @deprecated
   * @param {string} name - The name to set.
   * @return {WorkgroupInfoNode} A reference to this node.
   */
  label(name) {
    warn('TSL: "label()" has been deprecated. Use "setName()" instead.');
    return this.setName(name);
  }
  /**
   * Sets the scope of this node.
   *
   * @param {string} scope - The scope to set.
   * @return {WorkgroupInfoNode} A reference to this node.
   */
  setScope(scope) {
    this.scope = scope;
    return this;
  }
  /**
   * The data type of the array buffer.
   *
   * @return {string} The element type.
   */
  getElementType() {
    return this.elementType;
  }
  /**
   * Overwrites the default implementation since the input type
   * is inferred from the scope.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType() {
    return `${this.scope}Array`;
  }
  /**
   * This method can be used to access elements via an index node.
   *
   * @param {IndexNode} indexNode - indexNode.
   * @return {WorkgroupInfoElementNode} A reference to an element.
   */
  element(indexNode) {
    return new WorkgroupInfoElementNode(this, indexNode);
  }
  generate(builder) {
    const name = this.name !== "" ? this.name : `${this.scope}Array_${this.id}`;
    return builder.getScopedArray(name, this.scope.toLowerCase(), this.bufferType, this.bufferCount);
  }
};
var workgroupArray = (type, count2) => new WorkgroupInfoNode("Workgroup", type, count2);
var AtomicFunctionNode = class extends Node4 {
  static get type() {
    return "AtomicFunctionNode";
  }
  /**
   * Constructs a new atomic function node.
   *
   * @param {string} method - The signature of the atomic function to construct.
   * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.
   * @param {Node} valueNode - The value that mutates the atomic variable.
   */
  constructor(method2, pointerNode, valueNode) {
    super("uint");
    this.method = method2;
    this.pointerNode = pointerNode;
    this.valueNode = valueNode;
    this.parents = true;
  }
  /**
   * Overwrites the default implementation to return the type of
   * the pointer node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType(builder) {
    return this.pointerNode.getNodeType(builder);
  }
  /**
   * Overwritten since the node type is inferred from the input type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    return this.getInputType(builder);
  }
  generate(builder) {
    const properties = builder.getNodeProperties(this);
    const parents = properties.parents;
    const method2 = this.method;
    const type = this.getNodeType(builder);
    const inputType = this.getInputType(builder);
    const a3 = this.pointerNode;
    const b = this.valueNode;
    const params = [];
    params.push(`&${a3.build(builder, inputType)}`);
    if (b !== null) {
      params.push(b.build(builder, inputType));
    }
    const methodSnippet = `${builder.getMethod(method2, type)}( ${params.join(", ")} )`;
    const isVoid = parents ? parents.length === 1 && parents[0].isStackNode === true : false;
    if (isVoid) {
      builder.addLineFlowCode(methodSnippet, this);
    } else {
      if (properties.constNode === void 0) {
        properties.constNode = expression(methodSnippet, type).toConst();
      }
      return properties.constNode.build(builder);
    }
  }
};
AtomicFunctionNode.ATOMIC_LOAD = "atomicLoad";
AtomicFunctionNode.ATOMIC_STORE = "atomicStore";
AtomicFunctionNode.ATOMIC_ADD = "atomicAdd";
AtomicFunctionNode.ATOMIC_SUB = "atomicSub";
AtomicFunctionNode.ATOMIC_MAX = "atomicMax";
AtomicFunctionNode.ATOMIC_MIN = "atomicMin";
AtomicFunctionNode.ATOMIC_AND = "atomicAnd";
AtomicFunctionNode.ATOMIC_OR = "atomicOr";
AtomicFunctionNode.ATOMIC_XOR = "atomicXor";
var atomicNode = nodeProxy(AtomicFunctionNode);
var atomicFunc = (method2, pointerNode, valueNode) => {
  return atomicNode(method2, pointerNode, valueNode).toStack();
};
var atomicLoad = (pointerNode) => atomicFunc(AtomicFunctionNode.ATOMIC_LOAD, pointerNode, null);
var atomicStore = (pointerNode, valueNode) => atomicFunc(AtomicFunctionNode.ATOMIC_STORE, pointerNode, valueNode);
var atomicAdd = (pointerNode, valueNode) => atomicFunc(AtomicFunctionNode.ATOMIC_ADD, pointerNode, valueNode);
var atomicSub = (pointerNode, valueNode) => atomicFunc(AtomicFunctionNode.ATOMIC_SUB, pointerNode, valueNode);
var atomicMax = (pointerNode, valueNode) => atomicFunc(AtomicFunctionNode.ATOMIC_MAX, pointerNode, valueNode);
var atomicMin = (pointerNode, valueNode) => atomicFunc(AtomicFunctionNode.ATOMIC_MIN, pointerNode, valueNode);
var atomicAnd = (pointerNode, valueNode) => atomicFunc(AtomicFunctionNode.ATOMIC_AND, pointerNode, valueNode);
var atomicOr = (pointerNode, valueNode) => atomicFunc(AtomicFunctionNode.ATOMIC_OR, pointerNode, valueNode);
var atomicXor = (pointerNode, valueNode) => atomicFunc(AtomicFunctionNode.ATOMIC_XOR, pointerNode, valueNode);
var SubgroupFunctionNode = class _SubgroupFunctionNode extends TempNode {
  static get type() {
    return "SubgroupFunctionNode";
  }
  /**
   * Constructs a new function node.
   *
   * @param {string} method - The subgroup/wave intrinsic method to construct.
   * @param {Node} [aNode=null] - The method's first argument.
   * @param {Node} [bNode=null] - The method's second argument.
   */
  constructor(method2, aNode = null, bNode = null) {
    super();
    this.method = method2;
    this.aNode = aNode;
    this.bNode = bNode;
  }
  getInputType(builder) {
    const aType = this.aNode ? this.aNode.getNodeType(builder) : null;
    const bType = this.bNode ? this.bNode.getNodeType(builder) : null;
    const aLen = builder.isMatrix(aType) ? 0 : builder.getTypeLength(aType);
    const bLen = builder.isMatrix(bType) ? 0 : builder.getTypeLength(bType);
    if (aLen > bLen) {
      return aType;
    } else {
      return bType;
    }
  }
  getNodeType(builder) {
    const method2 = this.method;
    if (method2 === _SubgroupFunctionNode.SUBGROUP_ELECT) {
      return "bool";
    } else if (method2 === _SubgroupFunctionNode.SUBGROUP_BALLOT) {
      return "uvec4";
    } else {
      return this.getInputType(builder);
    }
  }
  generate(builder, output2) {
    const method2 = this.method;
    const type = this.getNodeType(builder);
    const inputType = this.getInputType(builder);
    const a3 = this.aNode;
    const b = this.bNode;
    const params = [];
    if (method2 === _SubgroupFunctionNode.SUBGROUP_BROADCAST || method2 === _SubgroupFunctionNode.SUBGROUP_SHUFFLE || method2 === _SubgroupFunctionNode.QUAD_BROADCAST) {
      const bType = b.getNodeType(builder);
      params.push(
        a3.build(builder, type),
        b.build(builder, bType === "float" ? "int" : type)
      );
    } else if (method2 === _SubgroupFunctionNode.SUBGROUP_SHUFFLE_XOR || method2 === _SubgroupFunctionNode.SUBGROUP_SHUFFLE_DOWN || method2 === _SubgroupFunctionNode.SUBGROUP_SHUFFLE_UP) {
      params.push(
        a3.build(builder, type),
        b.build(builder, "uint")
      );
    } else {
      if (a3 !== null) params.push(a3.build(builder, inputType));
      if (b !== null) params.push(b.build(builder, inputType));
    }
    const paramsString = params.length === 0 ? "()" : `( ${params.join(", ")} )`;
    return builder.format(`${builder.getMethod(method2, type)}${paramsString}`, type, output2);
  }
  serialize(data) {
    super.serialize(data);
    data.method = this.method;
  }
  deserialize(data) {
    super.deserialize(data);
    this.method = data.method;
  }
};
SubgroupFunctionNode.SUBGROUP_ELECT = "subgroupElect";
SubgroupFunctionNode.SUBGROUP_BALLOT = "subgroupBallot";
SubgroupFunctionNode.SUBGROUP_ADD = "subgroupAdd";
SubgroupFunctionNode.SUBGROUP_INCLUSIVE_ADD = "subgroupInclusiveAdd";
SubgroupFunctionNode.SUBGROUP_EXCLUSIVE_AND = "subgroupExclusiveAdd";
SubgroupFunctionNode.SUBGROUP_MUL = "subgroupMul";
SubgroupFunctionNode.SUBGROUP_INCLUSIVE_MUL = "subgroupInclusiveMul";
SubgroupFunctionNode.SUBGROUP_EXCLUSIVE_MUL = "subgroupExclusiveMul";
SubgroupFunctionNode.SUBGROUP_AND = "subgroupAnd";
SubgroupFunctionNode.SUBGROUP_OR = "subgroupOr";
SubgroupFunctionNode.SUBGROUP_XOR = "subgroupXor";
SubgroupFunctionNode.SUBGROUP_MIN = "subgroupMin";
SubgroupFunctionNode.SUBGROUP_MAX = "subgroupMax";
SubgroupFunctionNode.SUBGROUP_ALL = "subgroupAll";
SubgroupFunctionNode.SUBGROUP_ANY = "subgroupAny";
SubgroupFunctionNode.SUBGROUP_BROADCAST_FIRST = "subgroupBroadcastFirst";
SubgroupFunctionNode.QUAD_SWAP_X = "quadSwapX";
SubgroupFunctionNode.QUAD_SWAP_Y = "quadSwapY";
SubgroupFunctionNode.QUAD_SWAP_DIAGONAL = "quadSwapDiagonal";
SubgroupFunctionNode.SUBGROUP_BROADCAST = "subgroupBroadcast";
SubgroupFunctionNode.SUBGROUP_SHUFFLE = "subgroupShuffle";
SubgroupFunctionNode.SUBGROUP_SHUFFLE_XOR = "subgroupShuffleXor";
SubgroupFunctionNode.SUBGROUP_SHUFFLE_UP = "subgroupShuffleUp";
SubgroupFunctionNode.SUBGROUP_SHUFFLE_DOWN = "subgroupShuffleDown";
SubgroupFunctionNode.QUAD_BROADCAST = "quadBroadcast";
var subgroupElect = nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_ELECT).setParameterLength(0);
var subgroupBallot = nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_BALLOT).setParameterLength(1);
var subgroupAdd = nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_ADD).setParameterLength(1);
var subgroupInclusiveAdd = nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_INCLUSIVE_ADD).setParameterLength(1);
var subgroupExclusiveAdd = nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_EXCLUSIVE_AND).setParameterLength(1);
var subgroupMul = nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_MUL).setParameterLength(1);
var subgroupInclusiveMul = nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_INCLUSIVE_MUL).setParameterLength(1);
var subgroupExclusiveMul = nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_EXCLUSIVE_MUL).setParameterLength(1);
var subgroupAnd = nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_AND).setParameterLength(1);
var subgroupOr = nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_OR).setParameterLength(1);
var subgroupXor = nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_XOR).setParameterLength(1);
var subgroupMin = nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_MIN).setParameterLength(1);
var subgroupMax = nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_MAX).setParameterLength(1);
var subgroupAll = nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_ALL).setParameterLength(0);
var subgroupAny = nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_ANY).setParameterLength(0);
var subgroupBroadcastFirst = nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_BROADCAST_FIRST).setParameterLength(2);
var quadSwapX = nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.QUAD_SWAP_X).setParameterLength(1);
var quadSwapY = nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.QUAD_SWAP_Y).setParameterLength(1);
var quadSwapDiagonal = nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.QUAD_SWAP_DIAGONAL).setParameterLength(1);
var subgroupBroadcast = nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_BROADCAST).setParameterLength(2);
var subgroupShuffle = nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_SHUFFLE).setParameterLength(2);
var subgroupShuffleXor = nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_SHUFFLE_XOR).setParameterLength(2);
var subgroupShuffleUp = nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_SHUFFLE_UP).setParameterLength(2);
var subgroupShuffleDown = nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_SHUFFLE_DOWN).setParameterLength(2);
var quadBroadcast = nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.QUAD_BROADCAST).setParameterLength(1);
var uniformsLib;
function getLightData(light) {
  uniformsLib = uniformsLib || /* @__PURE__ */ new WeakMap();
  let uniforms = uniformsLib.get(light);
  if (uniforms === void 0) uniformsLib.set(light, uniforms = {});
  return uniforms;
}
function lightShadowMatrix(light) {
  const data = getLightData(light);
  return data.shadowMatrix || (data.shadowMatrix = uniform("mat4").setGroup(renderGroup).onRenderUpdate((frame2) => {
    if (light.castShadow !== true || frame2.renderer.shadowMap.enabled === false) {
      if (light.shadow.camera.coordinateSystem !== frame2.camera.coordinateSystem) {
        light.shadow.camera.coordinateSystem = frame2.camera.coordinateSystem;
        light.shadow.camera.updateProjectionMatrix();
      }
      light.shadow.updateMatrices(light);
    }
    return light.shadow.matrix;
  }));
}
function lightProjectionUV(light, position = positionWorld) {
  const spotLightCoord = lightShadowMatrix(light).mul(position);
  const projectionUV = spotLightCoord.xyz.div(spotLightCoord.w);
  return projectionUV;
}
function lightPosition(light) {
  const data = getLightData(light);
  return data.position || (data.position = uniform(new Vector3()).setGroup(renderGroup).onRenderUpdate((_2, self2) => self2.value.setFromMatrixPosition(light.matrixWorld)));
}
function lightTargetPosition(light) {
  const data = getLightData(light);
  return data.targetPosition || (data.targetPosition = uniform(new Vector3()).setGroup(renderGroup).onRenderUpdate((_2, self2) => self2.value.setFromMatrixPosition(light.target.matrixWorld)));
}
function lightViewPosition(light) {
  const data = getLightData(light);
  return data.viewPosition || (data.viewPosition = uniform(new Vector3()).setGroup(renderGroup).onRenderUpdate(({ camera: camera3 }, self2) => {
    self2.value = self2.value || new Vector3();
    self2.value.setFromMatrixPosition(light.matrixWorld);
    self2.value.applyMatrix4(camera3.matrixWorldInverse);
  }));
}
var lightTargetDirection = (light) => cameraViewMatrix.transformDirection(lightPosition(light).sub(lightTargetPosition(light)));
var sortLights = (lights2) => {
  return lights2.sort((a3, b) => a3.id - b.id);
};
var getLightNodeById = (id2, lightNodes) => {
  for (const lightNode of lightNodes) {
    if (lightNode.isAnalyticLightNode && lightNode.light.id === id2) {
      return lightNode;
    }
  }
  return null;
};
var _lightsNodeRef = /* @__PURE__ */ new WeakMap();
var _hashData = [];
var LightsNode = class extends Node4 {
  static get type() {
    return "LightsNode";
  }
  /**
   * Constructs a new lights node.
   */
  constructor() {
    super("vec3");
    this.totalDiffuseNode = property("vec3", "totalDiffuse");
    this.totalSpecularNode = property("vec3", "totalSpecular");
    this.outgoingLightNode = property("vec3", "outgoingLight");
    this._lights = [];
    this._lightNodes = null;
    this._lightNodesHash = null;
    this.global = true;
  }
  /**
   * Overwrites the default {@link Node#customCacheKey} implementation by including
   * light data into the cache key.
   *
   * @return {number} The custom cache key.
   */
  customCacheKey() {
    const lights2 = this._lights;
    for (let i2 = 0; i2 < lights2.length; i2++) {
      const light = lights2[i2];
      _hashData.push(light.id);
      _hashData.push(light.castShadow ? 1 : 0);
      if (light.isSpotLight === true) {
        const hashMap = light.map !== null ? light.map.id : -1;
        const hashColorNode = light.colorNode ? light.colorNode.getCacheKey() : -1;
        _hashData.push(hashMap, hashColorNode);
      }
    }
    const cacheKey = hashArray(_hashData);
    _hashData.length = 0;
    return cacheKey;
  }
  /**
   * Computes a hash value for identifying the current light nodes setup.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @return {string} The computed hash.
   */
  getHash(builder) {
    if (this._lightNodesHash === null) {
      if (this._lightNodes === null) this.setupLightsNode(builder);
      const hash2 = [];
      for (const lightNode of this._lightNodes) {
        hash2.push(lightNode.getHash());
      }
      this._lightNodesHash = "lights-" + hash2.join(",");
    }
    return this._lightNodesHash;
  }
  analyze(builder) {
    const properties = builder.getNodeProperties(this);
    for (const node of properties.nodes) {
      node.build(builder);
    }
    properties.outputNode.build(builder);
  }
  /**
   * Creates lighting nodes for each scene light. This makes it possible to further
   * process lights in the node system.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   */
  setupLightsNode(builder) {
    const lightNodes = [];
    const previousLightNodes = this._lightNodes;
    const lights2 = sortLights(this._lights);
    const nodeLibrary = builder.renderer.library;
    for (const light of lights2) {
      if (light.isNode) {
        lightNodes.push(nodeObject(light));
      } else {
        let lightNode = null;
        if (previousLightNodes !== null) {
          lightNode = getLightNodeById(light.id, previousLightNodes);
        }
        if (lightNode === null) {
          const lightNodeClass = nodeLibrary.getLightNodeClass(light.constructor);
          if (lightNodeClass === null) {
            warn(`LightsNode.setupNodeLights: Light node not found for ${light.constructor.name}`);
            continue;
          }
          let lightNode2 = null;
          if (!_lightsNodeRef.has(light)) {
            lightNode2 = new lightNodeClass(light);
            _lightsNodeRef.set(light, lightNode2);
          } else {
            lightNode2 = _lightsNodeRef.get(light);
          }
          lightNodes.push(lightNode2);
        }
      }
    }
    this._lightNodes = lightNodes;
  }
  /**
   * Sets up a direct light in the lighting model.
   *
   * @param {Object} builder - The builder object containing the context and stack.
   * @param {Object} lightNode - The light node.
   * @param {Object} lightData - The light object containing color and direction properties.
   */
  setupDirectLight(builder, lightNode, lightData) {
    const { lightingModel, reflectedLight } = builder.context;
    lightingModel.direct({
      ...lightData,
      lightNode,
      reflectedLight
    }, builder);
  }
  setupDirectRectAreaLight(builder, lightNode, lightData) {
    const { lightingModel, reflectedLight } = builder.context;
    lightingModel.directRectArea({
      ...lightData,
      lightNode,
      reflectedLight
    }, builder);
  }
  /**
   * Setups the internal lights by building all respective
   * light nodes.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @param {Array<LightingNode>} lightNodes - An array of lighting nodes.
   */
  setupLights(builder, lightNodes) {
    for (const lightNode of lightNodes) {
      lightNode.build(builder);
    }
  }
  getLightNodes(builder) {
    if (this._lightNodes === null) this.setupLightsNode(builder);
    return this._lightNodes;
  }
  /**
   * The implementation makes sure that for each light in the scene
   * there is a corresponding light node. By building the light nodes
   * and evaluating the lighting model the outgoing light is computed.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @return {Node<vec3>} A node representing the outgoing light.
   */
  setup(builder) {
    const currentLightsNode = builder.lightsNode;
    builder.lightsNode = this;
    let outgoingLightNode = this.outgoingLightNode;
    const context2 = builder.context;
    const lightingModel = context2.lightingModel;
    const properties = builder.getNodeProperties(this);
    if (lightingModel) {
      const { totalDiffuseNode, totalSpecularNode } = this;
      context2.outgoingLight = outgoingLightNode;
      const stack2 = builder.addStack();
      properties.nodes = stack2.nodes;
      lightingModel.start(builder);
      const { backdrop, backdropAlpha } = context2;
      const { directDiffuse, directSpecular, indirectDiffuse, indirectSpecular } = context2.reflectedLight;
      let totalDiffuse = directDiffuse.add(indirectDiffuse);
      if (backdrop !== null) {
        if (backdropAlpha !== null) {
          totalDiffuse = vec3(backdropAlpha.mix(totalDiffuse, backdrop));
        } else {
          totalDiffuse = vec3(backdrop);
        }
      }
      totalDiffuseNode.assign(totalDiffuse);
      totalSpecularNode.assign(directSpecular.add(indirectSpecular));
      outgoingLightNode.assign(totalDiffuseNode.add(totalSpecularNode));
      lightingModel.finish(builder);
      outgoingLightNode = outgoingLightNode.bypass(builder.removeStack());
    } else {
      properties.nodes = [];
    }
    builder.lightsNode = currentLightsNode;
    return outgoingLightNode;
  }
  /**
   * Configures this node with an array of lights.
   *
   * @param {Array<Light>} lights - An array of lights.
   * @return {LightsNode} A reference to this node.
   */
  setLights(lights2) {
    this._lights = lights2;
    this._lightNodes = null;
    this._lightNodesHash = null;
    return this;
  }
  /**
   * Returns an array of the scene's lights.
   *
   * @return {Array<Light>} The scene's lights.
   */
  getLights() {
    return this._lights;
  }
  /**
   * Whether the scene has lights or not.
   *
   * @type {boolean}
   */
  get hasLights() {
    return this._lights.length > 0;
  }
};
var lights = (lights2 = []) => new LightsNode().setLights(lights2);
var ShadowBaseNode = class extends Node4 {
  static get type() {
    return "ShadowBaseNode";
  }
  /**
   * Constructs a new shadow base node.
   *
   * @param {Light} light - The shadow casting light.
   */
  constructor(light) {
    super();
    this.light = light;
    this.updateBeforeType = NodeUpdateType.RENDER;
    this.isShadowBaseNode = true;
  }
  /**
   * Setups the shadow position node which is by default the predefined TSL node object `shadowPositionWorld`.
   *
   * @param {NodeBuilder} object - A configuration object that must at least hold a material reference.
   */
  setupShadowPosition({ context: context2, material }) {
    shadowPositionWorld.assign(material.receivedShadowPositionNode || context2.shadowPositionWorld || positionWorld);
  }
};
var shadowPositionWorld = property("vec3", "shadowPositionWorld");
function saveRendererState(renderer3, state = {}) {
  state.toneMapping = renderer3.toneMapping;
  state.toneMappingExposure = renderer3.toneMappingExposure;
  state.outputColorSpace = renderer3.outputColorSpace;
  state.renderTarget = renderer3.getRenderTarget();
  state.activeCubeFace = renderer3.getActiveCubeFace();
  state.activeMipmapLevel = renderer3.getActiveMipmapLevel();
  state.renderObjectFunction = renderer3.getRenderObjectFunction();
  state.pixelRatio = renderer3.getPixelRatio();
  state.mrt = renderer3.getMRT();
  state.clearColor = renderer3.getClearColor(state.clearColor || new Color());
  state.clearAlpha = renderer3.getClearAlpha();
  state.autoClear = renderer3.autoClear;
  state.scissorTest = renderer3.getScissorTest();
  return state;
}
function resetRendererState(renderer3, state) {
  state = saveRendererState(renderer3, state);
  renderer3.setMRT(null);
  renderer3.setRenderObjectFunction(null);
  renderer3.setClearColor(0, 1);
  renderer3.autoClear = true;
  return state;
}
function restoreRendererState(renderer3, state) {
  renderer3.toneMapping = state.toneMapping;
  renderer3.toneMappingExposure = state.toneMappingExposure;
  renderer3.outputColorSpace = state.outputColorSpace;
  renderer3.setRenderTarget(state.renderTarget, state.activeCubeFace, state.activeMipmapLevel);
  renderer3.setRenderObjectFunction(state.renderObjectFunction);
  renderer3.setPixelRatio(state.pixelRatio);
  renderer3.setMRT(state.mrt);
  renderer3.setClearColor(state.clearColor, state.clearAlpha);
  renderer3.autoClear = state.autoClear;
  renderer3.setScissorTest(state.scissorTest);
}
function saveSceneState(scene3, state = {}) {
  state.background = scene3.background;
  state.backgroundNode = scene3.backgroundNode;
  state.overrideMaterial = scene3.overrideMaterial;
  return state;
}
function resetSceneState(scene3, state) {
  state = saveSceneState(scene3, state);
  scene3.background = null;
  scene3.backgroundNode = null;
  scene3.overrideMaterial = null;
  return state;
}
function restoreSceneState(scene3, state) {
  scene3.background = state.background;
  scene3.backgroundNode = state.backgroundNode;
  scene3.overrideMaterial = state.overrideMaterial;
}
function saveRendererAndSceneState(renderer3, scene3, state = {}) {
  state = saveRendererState(renderer3, state);
  state = saveSceneState(scene3, state);
  return state;
}
function resetRendererAndSceneState(renderer3, scene3, state) {
  state = resetRendererState(renderer3, state);
  state = resetSceneState(scene3, state);
  return state;
}
function restoreRendererAndSceneState(renderer3, scene3, state) {
  restoreRendererState(renderer3, state);
  restoreSceneState(scene3, state);
}
var RendererUtils = Object.freeze({
  __proto__: null,
  resetRendererAndSceneState,
  resetRendererState,
  resetSceneState,
  restoreRendererAndSceneState,
  restoreRendererState,
  restoreSceneState,
  saveRendererAndSceneState,
  saveRendererState,
  saveSceneState
});
var shadowMaterialLib = /* @__PURE__ */ new WeakMap();
var BasicShadowFilter = Fn(({ depthTexture, shadowCoord, depthLayer }) => {
  let basic = texture(depthTexture, shadowCoord.xy).setName("t_basic");
  if (depthTexture.isArrayTexture) {
    basic = basic.depth(depthLayer);
  }
  return basic.compare(shadowCoord.z);
});
var PCFShadowFilter = Fn(({ depthTexture, shadowCoord, shadow: shadow2, depthLayer }) => {
  const depthCompare = (uv2, compare) => {
    let depth2 = texture(depthTexture, uv2);
    if (depthTexture.isArrayTexture) {
      depth2 = depth2.depth(depthLayer);
    }
    return depth2.compare(compare);
  };
  const mapSize = reference("mapSize", "vec2", shadow2).setGroup(renderGroup);
  const radius = reference("radius", "float", shadow2).setGroup(renderGroup);
  const texelSize = vec2(1).div(mapSize);
  const radiusScaled = radius.mul(texelSize.x);
  const phi = interleavedGradientNoise(screenCoordinate.xy).mul(6.28318530718);
  return add4(
    depthCompare(shadowCoord.xy.add(vogelDiskSample(0, 5, phi).mul(radiusScaled)), shadowCoord.z),
    depthCompare(shadowCoord.xy.add(vogelDiskSample(1, 5, phi).mul(radiusScaled)), shadowCoord.z),
    depthCompare(shadowCoord.xy.add(vogelDiskSample(2, 5, phi).mul(radiusScaled)), shadowCoord.z),
    depthCompare(shadowCoord.xy.add(vogelDiskSample(3, 5, phi).mul(radiusScaled)), shadowCoord.z),
    depthCompare(shadowCoord.xy.add(vogelDiskSample(4, 5, phi).mul(radiusScaled)), shadowCoord.z)
  ).mul(1 / 5);
});
var PCFSoftShadowFilter = Fn(({ depthTexture, shadowCoord, shadow: shadow2, depthLayer }) => {
  const depthCompare = (uv3, compare) => {
    let depth2 = texture(depthTexture, uv3);
    if (depthTexture.isArrayTexture) {
      depth2 = depth2.depth(depthLayer);
    }
    return depth2.compare(compare);
  };
  const mapSize = reference("mapSize", "vec2", shadow2).setGroup(renderGroup);
  const texelSize = vec2(1).div(mapSize);
  const dx = texelSize.x;
  const dy = texelSize.y;
  const uv2 = shadowCoord.xy;
  const f3 = fract(uv2.mul(mapSize).add(0.5));
  uv2.subAssign(f3.mul(texelSize));
  return add4(
    depthCompare(uv2, shadowCoord.z),
    depthCompare(uv2.add(vec2(dx, 0)), shadowCoord.z),
    depthCompare(uv2.add(vec2(0, dy)), shadowCoord.z),
    depthCompare(uv2.add(texelSize), shadowCoord.z),
    mix2(
      depthCompare(uv2.add(vec2(dx.negate(), 0)), shadowCoord.z),
      depthCompare(uv2.add(vec2(dx.mul(2), 0)), shadowCoord.z),
      f3.x
    ),
    mix2(
      depthCompare(uv2.add(vec2(dx.negate(), dy)), shadowCoord.z),
      depthCompare(uv2.add(vec2(dx.mul(2), dy)), shadowCoord.z),
      f3.x
    ),
    mix2(
      depthCompare(uv2.add(vec2(0, dy.negate())), shadowCoord.z),
      depthCompare(uv2.add(vec2(0, dy.mul(2))), shadowCoord.z),
      f3.y
    ),
    mix2(
      depthCompare(uv2.add(vec2(dx, dy.negate())), shadowCoord.z),
      depthCompare(uv2.add(vec2(dx, dy.mul(2))), shadowCoord.z),
      f3.y
    ),
    mix2(
      mix2(
        depthCompare(uv2.add(vec2(dx.negate(), dy.negate())), shadowCoord.z),
        depthCompare(uv2.add(vec2(dx.mul(2), dy.negate())), shadowCoord.z),
        f3.x
      ),
      mix2(
        depthCompare(uv2.add(vec2(dx.negate(), dy.mul(2))), shadowCoord.z),
        depthCompare(uv2.add(vec2(dx.mul(2), dy.mul(2))), shadowCoord.z),
        f3.x
      ),
      f3.y
    )
  ).mul(1 / 9);
});
var VSMShadowFilter = Fn(({ depthTexture, shadowCoord, depthLayer }) => {
  let distribution = texture(depthTexture).sample(shadowCoord.xy);
  if (depthTexture.isArrayTexture) {
    distribution = distribution.depth(depthLayer);
  }
  distribution = distribution.rg;
  const mean3 = distribution.x;
  const variance2 = max$1(1e-7, distribution.y.mul(distribution.y));
  const hardShadow = step(shadowCoord.z, mean3);
  If(hardShadow.equal(1), () => {
    return float(1);
  });
  const d3 = shadowCoord.z.sub(mean3);
  let p_max = variance2.div(variance2.add(d3.mul(d3)));
  p_max = clamp3(sub(p_max, 0.3).div(0.65));
  return max$1(hardShadow, p_max);
});
var linearDistance = Fn(([position, cameraNear2, cameraFar2]) => {
  let dist = positionWorld.sub(position).length();
  dist = dist.sub(cameraNear2).div(cameraFar2.sub(cameraNear2));
  dist = dist.saturate();
  return dist;
});
var linearShadowDistance = (light) => {
  const camera3 = light.shadow.camera;
  const nearDistance = reference("near", "float", camera3).setGroup(renderGroup);
  const farDistance = reference("far", "float", camera3).setGroup(renderGroup);
  const referencePosition = objectPosition(light);
  return linearDistance(referencePosition, nearDistance, farDistance);
};
var getShadowMaterial = (light) => {
  let material = shadowMaterialLib.get(light);
  if (material === void 0) {
    const depthNode = light.isPointLight ? linearShadowDistance(light) : null;
    material = new NodeMaterial();
    material.colorNode = vec4(0, 0, 0, 1);
    material.depthNode = depthNode;
    material.isShadowPassMaterial = true;
    material.name = "ShadowMaterial";
    material.fog = false;
    shadowMaterialLib.set(light, material);
  }
  return material;
};
var disposeShadowMaterial = (light) => {
  const material = shadowMaterialLib.get(light);
  if (material !== void 0) {
    material.dispose();
    shadowMaterialLib.delete(light);
  }
};
var _shadowRenderObjectLibrary = new ChainMap();
var _shadowRenderObjectKeys = [];
var getShadowRenderObjectFunction = (renderer3, shadow2, shadowType, useVelocity) => {
  _shadowRenderObjectKeys[0] = renderer3;
  _shadowRenderObjectKeys[1] = shadow2;
  let renderObjectFunction = _shadowRenderObjectLibrary.get(_shadowRenderObjectKeys);
  if (renderObjectFunction === void 0 || (renderObjectFunction.shadowType !== shadowType || renderObjectFunction.useVelocity !== useVelocity)) {
    renderObjectFunction = (object, scene3, _camera4, geometry, material, group2, ...params) => {
      if (object.castShadow === true || object.receiveShadow && shadowType === VSMShadowMap) {
        if (useVelocity) {
          getDataFromObject(object).useVelocity = true;
        }
        object.onBeforeShadow(renderer3, object, _camera4, shadow2.camera, geometry, scene3.overrideMaterial, group2);
        renderer3.renderObject(object, scene3, _camera4, geometry, material, group2, ...params);
        object.onAfterShadow(renderer3, object, _camera4, shadow2.camera, geometry, scene3.overrideMaterial, group2);
      }
    };
    renderObjectFunction.shadowType = shadowType;
    renderObjectFunction.useVelocity = useVelocity;
    _shadowRenderObjectLibrary.set(_shadowRenderObjectKeys, renderObjectFunction);
  }
  _shadowRenderObjectKeys[0] = null;
  _shadowRenderObjectKeys[1] = null;
  return renderObjectFunction;
};
var VSMPassVertical = Fn(({ samples, radius, size: size2, shadowPass, depthLayer }) => {
  const mean3 = float(0).toVar("meanVertical");
  const squaredMean = float(0).toVar("squareMeanVertical");
  const uvStride = samples.lessThanEqual(float(1)).select(float(0), float(2).div(samples.sub(1)));
  const uvStart = samples.lessThanEqual(float(1)).select(float(0), float(-1));
  Loop({ start: int(0), end: int(samples), type: "int", condition: "<" }, ({ i: i2 }) => {
    const uvOffset = uvStart.add(float(i2).mul(uvStride));
    let depth2 = shadowPass.sample(add4(screenCoordinate.xy, vec2(0, uvOffset).mul(radius)).div(size2));
    if (shadowPass.value.isArrayTexture) {
      depth2 = depth2.depth(depthLayer);
    }
    depth2 = depth2.x;
    mean3.addAssign(depth2);
    squaredMean.addAssign(depth2.mul(depth2));
  });
  mean3.divAssign(samples);
  squaredMean.divAssign(samples);
  const std_dev = sqrt2(squaredMean.sub(mean3.mul(mean3)).max(0));
  return vec2(mean3, std_dev);
});
var VSMPassHorizontal = Fn(({ samples, radius, size: size2, shadowPass, depthLayer }) => {
  const mean3 = float(0).toVar("meanHorizontal");
  const squaredMean = float(0).toVar("squareMeanHorizontal");
  const uvStride = samples.lessThanEqual(float(1)).select(float(0), float(2).div(samples.sub(1)));
  const uvStart = samples.lessThanEqual(float(1)).select(float(0), float(-1));
  Loop({ start: int(0), end: int(samples), type: "int", condition: "<" }, ({ i: i2 }) => {
    const uvOffset = uvStart.add(float(i2).mul(uvStride));
    let distribution = shadowPass.sample(add4(screenCoordinate.xy, vec2(uvOffset, 0).mul(radius)).div(size2));
    if (shadowPass.value.isArrayTexture) {
      distribution = distribution.depth(depthLayer);
    }
    mean3.addAssign(distribution.x);
    squaredMean.addAssign(add4(distribution.y.mul(distribution.y), distribution.x.mul(distribution.x)));
  });
  mean3.divAssign(samples);
  squaredMean.divAssign(samples);
  const std_dev = sqrt2(squaredMean.sub(mean3.mul(mean3)).max(0));
  return vec2(mean3, std_dev);
});
var _shadowFilterLib = [BasicShadowFilter, PCFShadowFilter, PCFSoftShadowFilter, VSMShadowFilter];
var _rendererState;
var _quadMesh = new QuadMesh();
var ShadowNode = class extends ShadowBaseNode {
  static get type() {
    return "ShadowNode";
  }
  /**
   * Constructs a new shadow node.
   *
   * @param {Light} light - The shadow casting light.
   * @param {?LightShadow} [shadow=null] - An optional light shadow.
   */
  constructor(light, shadow2 = null) {
    super(light);
    this.shadow = shadow2 || light.shadow;
    this.shadowMap = null;
    this.vsmShadowMapVertical = null;
    this.vsmShadowMapHorizontal = null;
    this.vsmMaterialVertical = null;
    this.vsmMaterialHorizontal = null;
    this._node = null;
    this._currentShadowType = null;
    this._cameraFrameId = /* @__PURE__ */ new WeakMap();
    this.isShadowNode = true;
    this.depthLayer = 0;
  }
  /**
   * Setups the shadow filtering.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @param {Object} inputs - A configuration object that defines the shadow filtering.
   * @param {Function} inputs.filterFn - This function defines the filtering type of the shadow map e.g. PCF.
   * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.
   * @param {Node<vec3>} inputs.shadowCoord - Shadow coordinates which are used to sample from the shadow map.
   * @param {LightShadow} inputs.shadow - The light shadow.
   * @return {Node<float>} The result node of the shadow filtering.
   */
  setupShadowFilter(builder, { filterFn, depthTexture, shadowCoord, shadow: shadow2, depthLayer }) {
    const frustumTest = shadowCoord.x.greaterThanEqual(0).and(shadowCoord.x.lessThanEqual(1)).and(shadowCoord.y.greaterThanEqual(0)).and(shadowCoord.y.lessThanEqual(1)).and(shadowCoord.z.lessThanEqual(1));
    const shadowNode = filterFn({ depthTexture, shadowCoord, shadow: shadow2, depthLayer });
    return frustumTest.select(shadowNode, float(1));
  }
  /**
   * Setups the shadow coordinates.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @param {Node<vec3>} shadowPosition - A node representing the shadow position.
   * @return {Node<vec3>} The shadow coordinates.
   */
  setupShadowCoord(builder, shadowPosition) {
    const { shadow: shadow2 } = this;
    const { renderer: renderer3 } = builder;
    const bias = reference("bias", "float", shadow2).setGroup(renderGroup);
    let shadowCoord = shadowPosition;
    let coordZ;
    if (shadow2.camera.isOrthographicCamera || renderer3.logarithmicDepthBuffer !== true) {
      shadowCoord = shadowCoord.xyz.div(shadowCoord.w);
      coordZ = shadowCoord.z;
      if (renderer3.coordinateSystem === WebGPUCoordinateSystem) {
        coordZ = coordZ.mul(2).sub(1);
      }
    } else {
      const w4 = shadowCoord.w;
      shadowCoord = shadowCoord.xy.div(w4);
      const cameraNearLocal = reference("near", "float", shadow2.camera).setGroup(renderGroup);
      const cameraFarLocal = reference("far", "float", shadow2.camera).setGroup(renderGroup);
      coordZ = viewZToLogarithmicDepth(w4.negate(), cameraNearLocal, cameraFarLocal);
    }
    shadowCoord = vec3(
      shadowCoord.x,
      shadowCoord.y.oneMinus(),
      // follow webgpu standards
      coordZ.add(bias)
    );
    return shadowCoord;
  }
  /**
   * Returns the shadow filtering function for the given shadow type.
   *
   * @param {number} type - The shadow type.
   * @return {Function} The filtering function.
   */
  getShadowFilterFn(type) {
    return _shadowFilterLib[type];
  }
  setupRenderTarget(shadow2, builder) {
    const depthTexture = new DepthTexture(shadow2.mapSize.width, shadow2.mapSize.height);
    depthTexture.name = "ShadowDepthTexture";
    depthTexture.compareFunction = LessCompare;
    const shadowMap = builder.createRenderTarget(shadow2.mapSize.width, shadow2.mapSize.height);
    shadowMap.texture.name = "ShadowMap";
    shadowMap.texture.type = shadow2.mapType;
    shadowMap.depthTexture = depthTexture;
    return { shadowMap, depthTexture };
  }
  /**
   * Setups the shadow output node.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @return {Node<vec3>} The shadow output node.
   */
  setupShadow(builder) {
    const { renderer: renderer3, camera: camera3 } = builder;
    const { light, shadow: shadow2 } = this;
    const shadowMapType = renderer3.shadowMap.type;
    const { depthTexture, shadowMap } = this.setupRenderTarget(shadow2, builder);
    shadow2.camera.coordinateSystem = camera3.coordinateSystem;
    shadow2.camera.updateProjectionMatrix();
    if (shadowMapType === VSMShadowMap && shadow2.isPointLightShadow !== true) {
      depthTexture.compareFunction = null;
      if (shadowMap.depth > 1) {
        if (!shadowMap._vsmShadowMapVertical) {
          shadowMap._vsmShadowMapVertical = builder.createRenderTarget(shadow2.mapSize.width, shadow2.mapSize.height, { format: RGFormat, type: HalfFloatType, depth: shadowMap.depth, depthBuffer: false });
          shadowMap._vsmShadowMapVertical.texture.name = "VSMVertical";
        }
        this.vsmShadowMapVertical = shadowMap._vsmShadowMapVertical;
        if (!shadowMap._vsmShadowMapHorizontal) {
          shadowMap._vsmShadowMapHorizontal = builder.createRenderTarget(shadow2.mapSize.width, shadow2.mapSize.height, { format: RGFormat, type: HalfFloatType, depth: shadowMap.depth, depthBuffer: false });
          shadowMap._vsmShadowMapHorizontal.texture.name = "VSMHorizontal";
        }
        this.vsmShadowMapHorizontal = shadowMap._vsmShadowMapHorizontal;
      } else {
        this.vsmShadowMapVertical = builder.createRenderTarget(shadow2.mapSize.width, shadow2.mapSize.height, { format: RGFormat, type: HalfFloatType, depthBuffer: false });
        this.vsmShadowMapHorizontal = builder.createRenderTarget(shadow2.mapSize.width, shadow2.mapSize.height, { format: RGFormat, type: HalfFloatType, depthBuffer: false });
      }
      let shadowPassVertical = texture(depthTexture);
      if (depthTexture.isArrayTexture) {
        shadowPassVertical = shadowPassVertical.depth(this.depthLayer);
      }
      let shadowPassHorizontal = texture(this.vsmShadowMapVertical.texture);
      if (depthTexture.isArrayTexture) {
        shadowPassHorizontal = shadowPassHorizontal.depth(this.depthLayer);
      }
      const samples = reference("blurSamples", "float", shadow2).setGroup(renderGroup);
      const radius = reference("radius", "float", shadow2).setGroup(renderGroup);
      const size2 = reference("mapSize", "vec2", shadow2).setGroup(renderGroup);
      let material = this.vsmMaterialVertical || (this.vsmMaterialVertical = new NodeMaterial());
      material.fragmentNode = VSMPassVertical({ samples, radius, size: size2, shadowPass: shadowPassVertical, depthLayer: this.depthLayer }).context(builder.getSharedContext());
      material.name = "VSMVertical";
      material = this.vsmMaterialHorizontal || (this.vsmMaterialHorizontal = new NodeMaterial());
      material.fragmentNode = VSMPassHorizontal({ samples, radius, size: size2, shadowPass: shadowPassHorizontal, depthLayer: this.depthLayer }).context(builder.getSharedContext());
      material.name = "VSMHorizontal";
    }
    const shadowIntensity = reference("intensity", "float", shadow2).setGroup(renderGroup);
    const normalBias = reference("normalBias", "float", shadow2).setGroup(renderGroup);
    const shadowPosition = lightShadowMatrix(light).mul(shadowPositionWorld.add(normalWorld.mul(normalBias)));
    const shadowCoord = this.setupShadowCoord(builder, shadowPosition);
    const filterFn = shadow2.filterNode || this.getShadowFilterFn(renderer3.shadowMap.type) || null;
    if (filterFn === null) {
      throw new Error("THREE.WebGPURenderer: Shadow map type not supported yet.");
    }
    const shadowDepthTexture = shadowMapType === VSMShadowMap && shadow2.isPointLightShadow !== true ? this.vsmShadowMapHorizontal.texture : depthTexture;
    const shadowNode = this.setupShadowFilter(builder, { filterFn, shadowTexture: shadowMap.texture, depthTexture: shadowDepthTexture, shadowCoord, shadow: shadow2, depthLayer: this.depthLayer });
    let shadowColor;
    if (shadowMap.texture.isCubeTexture) {
      shadowColor = cubeTexture(shadowMap.texture, shadowCoord.xyz);
    } else {
      shadowColor = texture(shadowMap.texture, shadowCoord);
      if (depthTexture.isArrayTexture) {
        shadowColor = shadowColor.depth(this.depthLayer);
      }
    }
    const shadowOutput = mix2(1, shadowNode.rgb.mix(shadowColor, 1), shadowIntensity.mul(shadowColor.a)).toVar();
    this.shadowMap = shadowMap;
    this.shadow.map = shadowMap;
    const inspectName = `${this.light.type} Shadow [ ${this.light.name || "ID: " + this.light.id} ]`;
    return shadowOutput.toInspector(`${inspectName} / Color`, () => {
      if (this.shadowMap.texture.isCubeTexture) {
        return cubeTexture(this.shadowMap.texture);
      }
      return texture(this.shadowMap.texture);
    }).toInspector(`${inspectName} / Depth`, () => {
      if (this.shadowMap.texture.isCubeTexture) {
        return cubeTexture(this.shadowMap.texture).r.oneMinus();
      }
      return textureLoad(this.shadowMap.depthTexture, uv$1().mul(textureSize(texture(this.shadowMap.depthTexture)))).r.oneMinus();
    });
  }
  /**
   * The implementation performs the setup of the output node. An output is only
   * produces if shadow mapping is globally enabled in the renderer.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @return {ShaderCallNodeInternal} The output node.
   */
  setup(builder) {
    if (builder.renderer.shadowMap.enabled === false) return;
    return Fn(() => {
      const currentShadowType = builder.renderer.shadowMap.type;
      if (this._currentShadowType !== currentShadowType) {
        this._reset();
        this._node = null;
      }
      let node = this._node;
      this.setupShadowPosition(builder);
      if (node === null) {
        this._node = node = this.setupShadow(builder);
        this._currentShadowType = currentShadowType;
      }
      if (builder.material.shadowNode) {
        warn('NodeMaterial: ".shadowNode" is deprecated. Use ".castShadowNode" instead.');
      }
      if (builder.material.receivedShadowNode) {
        node = builder.material.receivedShadowNode(node);
      }
      return node;
    })();
  }
  /**
   * Renders the shadow. The logic of this function could be included
   * into {@link ShadowNode#updateShadow} however more specialized shadow
   * nodes might require a custom shadow map rendering. By having a
   * dedicated method, it's easier to overwrite the default behavior.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  renderShadow(frame2) {
    const { shadow: shadow2, shadowMap, light } = this;
    const { renderer: renderer3, scene: scene3 } = frame2;
    shadow2.updateMatrices(light);
    shadowMap.setSize(shadow2.mapSize.width, shadow2.mapSize.height, shadowMap.depth);
    const currentSceneName = scene3.name;
    scene3.name = `Shadow Map [ ${light.name || "ID: " + light.id} ]`;
    renderer3.render(scene3, shadow2.camera);
    scene3.name = currentSceneName;
  }
  /**
   * Updates the shadow.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  updateShadow(frame2) {
    const { shadowMap, light, shadow: shadow2 } = this;
    const { renderer: renderer3, scene: scene3, camera: camera3 } = frame2;
    const shadowType = renderer3.shadowMap.type;
    const depthVersion = shadowMap.depthTexture.version;
    this._depthVersionCached = depthVersion;
    const _shadowCameraLayer = shadow2.camera.layers.mask;
    if ((shadow2.camera.layers.mask & 4294967294) === 0) {
      shadow2.camera.layers.mask = camera3.layers.mask;
    }
    const currentRenderObjectFunction = renderer3.getRenderObjectFunction();
    const currentMRT = renderer3.getMRT();
    const useVelocity = currentMRT ? currentMRT.has("velocity") : false;
    _rendererState = resetRendererAndSceneState(renderer3, scene3, _rendererState);
    scene3.overrideMaterial = getShadowMaterial(light);
    renderer3.setRenderObjectFunction(getShadowRenderObjectFunction(renderer3, shadow2, shadowType, useVelocity));
    renderer3.setClearColor(0, 0);
    renderer3.setRenderTarget(shadowMap);
    this.renderShadow(frame2);
    renderer3.setRenderObjectFunction(currentRenderObjectFunction);
    if (shadowType === VSMShadowMap && shadow2.isPointLightShadow !== true) {
      this.vsmPass(renderer3);
    }
    shadow2.camera.layers.mask = _shadowCameraLayer;
    restoreRendererAndSceneState(renderer3, scene3, _rendererState);
  }
  /**
   * For VSM additional render passes are required.
   *
   * @param {Renderer} renderer - A reference to the current renderer.
   */
  vsmPass(renderer3) {
    const { shadow: shadow2 } = this;
    const depth2 = this.shadowMap.depth;
    this.vsmShadowMapVertical.setSize(shadow2.mapSize.width, shadow2.mapSize.height, depth2);
    this.vsmShadowMapHorizontal.setSize(shadow2.mapSize.width, shadow2.mapSize.height, depth2);
    renderer3.setRenderTarget(this.vsmShadowMapVertical);
    _quadMesh.material = this.vsmMaterialVertical;
    _quadMesh.render(renderer3);
    renderer3.setRenderTarget(this.vsmShadowMapHorizontal);
    _quadMesh.material = this.vsmMaterialHorizontal;
    _quadMesh.render(renderer3);
  }
  /**
   * Frees the internal resources of this shadow node.
   */
  dispose() {
    this._reset();
    super.dispose();
  }
  /**
   * Resets the resouce state of this shadow node.
   *
   * @private
   */
  _reset() {
    this._currentShadowType = null;
    disposeShadowMaterial(this.light);
    if (this.shadowMap) {
      this.shadowMap.dispose();
      this.shadowMap = null;
    }
    if (this.vsmShadowMapVertical !== null) {
      this.vsmShadowMapVertical.dispose();
      this.vsmShadowMapVertical = null;
      this.vsmMaterialVertical.dispose();
      this.vsmMaterialVertical = null;
    }
    if (this.vsmShadowMapHorizontal !== null) {
      this.vsmShadowMapHorizontal.dispose();
      this.vsmShadowMapHorizontal = null;
      this.vsmMaterialHorizontal.dispose();
      this.vsmMaterialHorizontal = null;
    }
  }
  /**
   * The implementation performs the update of the shadow map if necessary.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  updateBefore(frame2) {
    const { shadow: shadow2 } = this;
    let needsUpdate = shadow2.needsUpdate || shadow2.autoUpdate;
    if (needsUpdate) {
      if (this._cameraFrameId[frame2.camera] === frame2.frameId) {
        needsUpdate = false;
      }
      this._cameraFrameId[frame2.camera] = frame2.frameId;
    }
    if (needsUpdate) {
      this.updateShadow(frame2);
      if (this.shadowMap.depthTexture.version === this._depthVersionCached) {
        shadow2.needsUpdate = false;
      }
    }
  }
};
var shadow = (light, shadow2) => new ShadowNode(light, shadow2);
var _clearColor$1 = new Color();
var _projScreenMatrix$12 = new Matrix4();
var _lightPositionWorld2 = new Vector3();
var _lookTarget2 = new Vector3();
var _cubeDirectionsWebGPU = [
  new Vector3(1, 0, 0),
  new Vector3(-1, 0, 0),
  new Vector3(0, -1, 0),
  new Vector3(0, 1, 0),
  new Vector3(0, 0, 1),
  new Vector3(0, 0, -1)
];
var _cubeUpsWebGPU = [
  new Vector3(0, -1, 0),
  new Vector3(0, -1, 0),
  new Vector3(0, 0, -1),
  new Vector3(0, 0, 1),
  new Vector3(0, -1, 0),
  new Vector3(0, -1, 0)
];
var _cubeDirectionsWebGL = [
  new Vector3(1, 0, 0),
  new Vector3(-1, 0, 0),
  new Vector3(0, 1, 0),
  new Vector3(0, -1, 0),
  new Vector3(0, 0, 1),
  new Vector3(0, 0, -1)
];
var _cubeUpsWebGL = [
  new Vector3(0, -1, 0),
  new Vector3(0, -1, 0),
  new Vector3(0, 0, 1),
  new Vector3(0, 0, -1),
  new Vector3(0, -1, 0),
  new Vector3(0, -1, 0)
];
var BasicPointShadowFilter = Fn(({ depthTexture, bd3D, dp }) => {
  return cubeTexture(depthTexture, bd3D).compare(dp);
});
var PointShadowFilter = Fn(({ depthTexture, bd3D, dp, shadow: shadow2 }) => {
  const radius = reference("radius", "float", shadow2).setGroup(renderGroup);
  const mapSize = reference("mapSize", "vec2", shadow2).setGroup(renderGroup);
  const texelSize = radius.div(mapSize.x);
  const absDir = abs(bd3D);
  const tangent = normalize2(cross2(bd3D, absDir.x.greaterThan(absDir.z).select(vec3(0, 1, 0), vec3(1, 0, 0))));
  const bitangent = cross2(bd3D, tangent);
  const phi = interleavedGradientNoise(screenCoordinate.xy).mul(6.28318530718);
  const sample0 = vogelDiskSample(0, 5, phi);
  const sample1 = vogelDiskSample(1, 5, phi);
  const sample22 = vogelDiskSample(2, 5, phi);
  const sample3 = vogelDiskSample(3, 5, phi);
  const sample4 = vogelDiskSample(4, 5, phi);
  return cubeTexture(depthTexture, bd3D.add(tangent.mul(sample0.x).add(bitangent.mul(sample0.y)).mul(texelSize))).compare(dp).add(cubeTexture(depthTexture, bd3D.add(tangent.mul(sample1.x).add(bitangent.mul(sample1.y)).mul(texelSize))).compare(dp)).add(cubeTexture(depthTexture, bd3D.add(tangent.mul(sample22.x).add(bitangent.mul(sample22.y)).mul(texelSize))).compare(dp)).add(cubeTexture(depthTexture, bd3D.add(tangent.mul(sample3.x).add(bitangent.mul(sample3.y)).mul(texelSize))).compare(dp)).add(cubeTexture(depthTexture, bd3D.add(tangent.mul(sample4.x).add(bitangent.mul(sample4.y)).mul(texelSize))).compare(dp)).mul(1 / 5);
});
var pointShadowFilter = Fn(({ filterFn, depthTexture, shadowCoord, shadow: shadow2 }) => {
  const lightToPosition = shadowCoord.xyz.toVar();
  const lightToPositionLength = lightToPosition.length();
  const cameraNearLocal = uniform("float").setGroup(renderGroup).onRenderUpdate(() => shadow2.camera.near);
  const cameraFarLocal = uniform("float").setGroup(renderGroup).onRenderUpdate(() => shadow2.camera.far);
  const bias = reference("bias", "float", shadow2).setGroup(renderGroup);
  const result2 = float(1).toVar();
  If(lightToPositionLength.sub(cameraFarLocal).lessThanEqual(0).and(lightToPositionLength.sub(cameraNearLocal).greaterThanEqual(0)), () => {
    const dp = lightToPositionLength.sub(cameraNearLocal).div(cameraFarLocal.sub(cameraNearLocal)).toVar();
    dp.addAssign(bias);
    const bd3D = lightToPosition.normalize();
    result2.assign(filterFn({ depthTexture, bd3D, dp, shadow: shadow2 }));
  });
  return result2;
});
var PointShadowNode = class extends ShadowNode {
  static get type() {
    return "PointShadowNode";
  }
  /**
   * Constructs a new point shadow node.
   *
   * @param {PointLight} light - The shadow casting point light.
   * @param {?PointLightShadow} [shadow=null] - An optional point light shadow.
   */
  constructor(light, shadow2 = null) {
    super(light, shadow2);
  }
  /**
   * Overwrites the default implementation to return point light shadow specific
   * filtering functions.
   *
   * @param {number} type - The shadow type.
   * @return {Function} The filtering function.
   */
  getShadowFilterFn(type) {
    return type === BasicShadowMap ? BasicPointShadowFilter : PointShadowFilter;
  }
  /**
   * Overwrites the default implementation so the unaltered shadow position is used.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @param {Node<vec3>} shadowPosition - A node representing the shadow position.
   * @return {Node<vec3>} The shadow coordinates.
   */
  setupShadowCoord(builder, shadowPosition) {
    return shadowPosition;
  }
  /**
   * Overwrites the default implementation to only use point light specific
   * shadow filter functions.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @param {Object} inputs - A configuration object that defines the shadow filtering.
   * @param {Function} inputs.filterFn - This function defines the filtering type of the shadow map e.g. PCF.
   * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's depth texture.
   * @param {Node<vec3>} inputs.shadowCoord - Shadow coordinates which are used to sample from the shadow map.
   * @param {LightShadow} inputs.shadow - The light shadow.
   * @return {Node<float>} The result node of the shadow filtering.
   */
  setupShadowFilter(builder, { filterFn, depthTexture, shadowCoord, shadow: shadow2 }) {
    return pointShadowFilter({ filterFn, depthTexture, shadowCoord, shadow: shadow2 });
  }
  /**
   * Overwrites the default implementation to create a CubeRenderTarget with CubeDepthTexture.
   *
   * @param {LightShadow} shadow - The light shadow object.
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @return {Object} An object containing the shadow map and depth texture.
   */
  setupRenderTarget(shadow2, builder) {
    const depthTexture = new CubeDepthTexture(shadow2.mapSize.width);
    depthTexture.name = "PointShadowDepthTexture";
    depthTexture.compareFunction = LessCompare;
    const shadowMap = builder.createCubeRenderTarget(shadow2.mapSize.width);
    shadowMap.texture.name = "PointShadowMap";
    shadowMap.depthTexture = depthTexture;
    return { shadowMap, depthTexture };
  }
  /**
   * Overwrites the default implementation with point light specific
   * rendering code.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  renderShadow(frame2) {
    const { shadow: shadow2, shadowMap, light } = this;
    const { renderer: renderer3, scene: scene3 } = frame2;
    const camera3 = shadow2.camera;
    const shadowMatrix = shadow2.matrix;
    const isWebGPU = renderer3.coordinateSystem === WebGPUCoordinateSystem;
    const cubeDirections = isWebGPU ? _cubeDirectionsWebGPU : _cubeDirectionsWebGL;
    const cubeUps = isWebGPU ? _cubeUpsWebGPU : _cubeUpsWebGL;
    shadowMap.setSize(shadow2.mapSize.width, shadow2.mapSize.width);
    const previousAutoClear = renderer3.autoClear;
    const previousClearColor = renderer3.getClearColor(_clearColor$1);
    const previousClearAlpha = renderer3.getClearAlpha();
    renderer3.autoClear = false;
    renderer3.setClearColor(shadow2.clearColor, shadow2.clearAlpha);
    for (let face = 0; face < 6; face++) {
      renderer3.setRenderTarget(shadowMap, face);
      renderer3.clear();
      const far = light.distance || camera3.far;
      if (far !== camera3.far) {
        camera3.far = far;
        camera3.updateProjectionMatrix();
      }
      _lightPositionWorld2.setFromMatrixPosition(light.matrixWorld);
      camera3.position.copy(_lightPositionWorld2);
      _lookTarget2.copy(camera3.position);
      _lookTarget2.add(cubeDirections[face]);
      camera3.up.copy(cubeUps[face]);
      camera3.lookAt(_lookTarget2);
      camera3.updateMatrixWorld();
      shadowMatrix.makeTranslation(-_lightPositionWorld2.x, -_lightPositionWorld2.y, -_lightPositionWorld2.z);
      _projScreenMatrix$12.multiplyMatrices(camera3.projectionMatrix, camera3.matrixWorldInverse);
      shadow2._frustum.setFromProjectionMatrix(_projScreenMatrix$12, camera3.coordinateSystem, camera3.reversedDepth);
      const currentSceneName = scene3.name;
      scene3.name = `Point Light Shadow [ ${light.name || "ID: " + light.id} ] - Face ${face + 1}`;
      renderer3.render(scene3, camera3);
      scene3.name = currentSceneName;
    }
    renderer3.autoClear = previousAutoClear;
    renderer3.setClearColor(previousClearColor, previousClearAlpha);
  }
};
var pointShadow = (light, shadow2) => new PointShadowNode(light, shadow2);
var AnalyticLightNode = class extends LightingNode {
  static get type() {
    return "AnalyticLightNode";
  }
  /**
   * Constructs a new analytic light node.
   *
   * @param {?Light} [light=null] - The light source.
   */
  constructor(light = null) {
    super();
    this.light = light;
    this.color = new Color();
    this.colorNode = light && light.colorNode || uniform(this.color).setGroup(renderGroup);
    this.baseColorNode = null;
    this.shadowNode = null;
    this.shadowColorNode = null;
    this.isAnalyticLightNode = true;
    this.updateType = NodeUpdateType.FRAME;
    if (light && light.shadow) {
      this._shadowDisposeListener = () => {
        this.disposeShadow();
      };
      light.addEventListener("dispose", this._shadowDisposeListener);
    }
  }
  dispose() {
    if (this._shadowDisposeListener) {
      this.light.removeEventListener("dispose", this._shadowDisposeListener);
    }
    super.dispose();
  }
  /**
   * Frees internal resources related to shadows.
   */
  disposeShadow() {
    if (this.shadowNode !== null) {
      this.shadowNode.dispose();
      this.shadowNode = null;
    }
    this.shadowColorNode = null;
    if (this.baseColorNode !== null) {
      this.colorNode = this.baseColorNode;
      this.baseColorNode = null;
    }
  }
  getHash() {
    return this.light.uuid;
  }
  /**
   * Returns a node representing a direction vector which points from the current
   * position in view space to the light's position in view space.
   *
   * @param {NodeBuilder} builder - The builder object used for setting up the light.
   * @return {Node<vec3>} The light vector node.
   */
  getLightVector(builder) {
    return lightViewPosition(this.light).sub(builder.context.positionView || positionView);
  }
  /**
   * Sets up the direct lighting for the analytic light node.
   *
   * @abstract
   * @param {NodeBuilder} builder - The builder object used for setting up the light.
   * @return {Object|undefined} The direct light data (color and direction).
   */
  setupDirect() {
  }
  /**
   * Sets up the direct rect area lighting for the analytic light node.
   *
   * @abstract
   * @param {NodeBuilder} builder - The builder object used for setting up the light.
   * @return {Object|undefined} The direct rect area light data.
   */
  setupDirectRectArea() {
  }
  /**
   * Setups the shadow node for this light. The method exists so concrete light classes
   * can setup different types of shadow nodes.
   *
   * @return {ShadowNode} The created shadow node.
   */
  setupShadowNode() {
    return shadow(this.light);
  }
  /**
   * Setups the shadow for this light. This method is only executed if the light
   * cast shadows and the current build object receives shadows. It incorporates
   * shadows into the lighting computation.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setupShadow(builder) {
    const { renderer: renderer3 } = builder;
    if (renderer3.shadowMap.enabled === false) return;
    let shadowColorNode = this.shadowColorNode;
    if (shadowColorNode === null) {
      const customShadowNode = this.light.shadow.shadowNode;
      let shadowNode;
      if (customShadowNode !== void 0) {
        shadowNode = nodeObject(customShadowNode);
      } else {
        shadowNode = this.setupShadowNode();
      }
      this.shadowNode = shadowNode;
      this.shadowColorNode = shadowColorNode = this.colorNode.mul(shadowNode);
      this.baseColorNode = this.colorNode;
    }
    if (builder.context.getShadow) {
      shadowColorNode = builder.context.getShadow(this, builder);
    }
    this.colorNode = shadowColorNode;
  }
  /**
   * Unlike most other nodes, lighting nodes do not return a output node in {@link Node#setup}.
   * The main purpose of lighting nodes is to configure the current {@link LightingModel} and/or
   * invocate the respective interface methods.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setup(builder) {
    this.colorNode = this.baseColorNode || this.colorNode;
    if (this.light.castShadow) {
      if (builder.object.receiveShadow) {
        this.setupShadow(builder);
      }
    } else if (this.shadowNode !== null) {
      this.shadowNode.dispose();
      this.shadowNode = null;
      this.shadowColorNode = null;
    }
    const directLightData = this.setupDirect(builder);
    const directRectAreaLightData = this.setupDirectRectArea(builder);
    if (directLightData) {
      builder.lightsNode.setupDirectLight(builder, this, directLightData);
    }
    if (directRectAreaLightData) {
      builder.lightsNode.setupDirectRectAreaLight(builder, this, directRectAreaLightData);
    }
  }
  /**
   * The update method is used to update light uniforms per frame.
   * Potentially overwritten in concrete light nodes to update light
   * specific uniforms.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update() {
    const { light } = this;
    this.color.copy(light.color).multiplyScalar(light.intensity);
  }
};
var getDistanceAttenuation = Fn(({ lightDistance, cutoffDistance, decayExponent }) => {
  const distanceFalloff = lightDistance.pow(decayExponent).max(0.01).reciprocal();
  return cutoffDistance.greaterThan(0).select(
    distanceFalloff.mul(lightDistance.div(cutoffDistance).pow4().oneMinus().clamp().pow2()),
    distanceFalloff
  );
});
var directPointLight = ({ color: color3, lightVector, cutoffDistance, decayExponent }) => {
  const lightDirection = lightVector.normalize();
  const lightDistance = lightVector.length();
  const attenuation = getDistanceAttenuation({
    lightDistance,
    cutoffDistance,
    decayExponent
  });
  const lightColor = color3.mul(attenuation);
  return { lightDirection, lightColor };
};
var PointLightNode = class extends AnalyticLightNode {
  static get type() {
    return "PointLightNode";
  }
  /**
   * Constructs a new point light node.
   *
   * @param {?PointLight} [light=null] - The point light source.
   */
  constructor(light = null) {
    super(light);
    this.cutoffDistanceNode = uniform(0).setGroup(renderGroup);
    this.decayExponentNode = uniform(2).setGroup(renderGroup);
  }
  /**
   * Overwritten to updated point light specific uniforms.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update(frame2) {
    const { light } = this;
    super.update(frame2);
    this.cutoffDistanceNode.value = light.distance;
    this.decayExponentNode.value = light.decay;
  }
  /**
   * Overwritten to setup point light specific shadow.
   *
   * @return {PointShadowNode}
   */
  setupShadowNode() {
    return pointShadow(this.light);
  }
  setupDirect(builder) {
    return directPointLight({
      color: this.colorNode,
      lightVector: this.getLightVector(builder),
      cutoffDistance: this.cutoffDistanceNode,
      decayExponent: this.decayExponentNode
    });
  }
};
var checker = Fn(([coord = uv$1()]) => {
  const uv2 = coord.mul(2);
  const cx = uv2.x.floor();
  const cy = uv2.y.floor();
  const result2 = cx.add(cy).mod(2);
  return result2.sign();
});
var shapeCircle = Fn(([coord = uv$1()], { renderer: renderer3, material }) => {
  const len2 = lengthSq(coord.mul(2).sub(1));
  let alpha;
  if (material.alphaToCoverage && renderer3.currentSamples > 0) {
    const dlen = float(len2.fwidth()).toVar();
    alpha = smoothstep2(dlen.oneMinus(), dlen.add(1), len2).oneMinus();
  } else {
    alpha = select(len2.greaterThan(1), 0, 1);
  }
  return alpha;
});
var mx_select = Fn(([b_immutable, t_immutable, f_immutable]) => {
  const f3 = float(f_immutable).toVar();
  const t5 = float(t_immutable).toVar();
  const b = bool(b_immutable).toVar();
  return select(b, t5, f3);
}).setLayout({
  name: "mx_select",
  type: "float",
  inputs: [
    { name: "b", type: "bool" },
    { name: "t", type: "float" },
    { name: "f", type: "float" }
  ]
});
var mx_negate_if = Fn(([val_immutable, b_immutable]) => {
  const b = bool(b_immutable).toVar();
  const val = float(val_immutable).toVar();
  return select(b, val.negate(), val);
}).setLayout({
  name: "mx_negate_if",
  type: "float",
  inputs: [
    { name: "val", type: "float" },
    { name: "b", type: "bool" }
  ]
});
var mx_floor = Fn(([x_immutable]) => {
  const x3 = float(x_immutable).toVar();
  return int(floor(x3));
}).setLayout({
  name: "mx_floor",
  type: "int",
  inputs: [
    { name: "x", type: "float" }
  ]
});
var mx_floorfrac = Fn(([x_immutable, i2]) => {
  const x3 = float(x_immutable).toVar();
  i2.assign(mx_floor(x3));
  return x3.sub(float(i2));
});
var mx_bilerp_0 = Fn(([v0_immutable, v1_immutable, v2_immutable, v3_immutable, s_immutable, t_immutable]) => {
  const t5 = float(t_immutable).toVar();
  const s2 = float(s_immutable).toVar();
  const v3 = float(v3_immutable).toVar();
  const v2 = float(v2_immutable).toVar();
  const v1 = float(v1_immutable).toVar();
  const v0 = float(v0_immutable).toVar();
  const s1 = float(sub(1, s2)).toVar();
  return sub(1, t5).mul(v0.mul(s1).add(v1.mul(s2))).add(t5.mul(v2.mul(s1).add(v3.mul(s2))));
}).setLayout({
  name: "mx_bilerp_0",
  type: "float",
  inputs: [
    { name: "v0", type: "float" },
    { name: "v1", type: "float" },
    { name: "v2", type: "float" },
    { name: "v3", type: "float" },
    { name: "s", type: "float" },
    { name: "t", type: "float" }
  ]
});
var mx_bilerp_1 = Fn(([v0_immutable, v1_immutable, v2_immutable, v3_immutable, s_immutable, t_immutable]) => {
  const t5 = float(t_immutable).toVar();
  const s2 = float(s_immutable).toVar();
  const v3 = vec3(v3_immutable).toVar();
  const v2 = vec3(v2_immutable).toVar();
  const v1 = vec3(v1_immutable).toVar();
  const v0 = vec3(v0_immutable).toVar();
  const s1 = float(sub(1, s2)).toVar();
  return sub(1, t5).mul(v0.mul(s1).add(v1.mul(s2))).add(t5.mul(v2.mul(s1).add(v3.mul(s2))));
}).setLayout({
  name: "mx_bilerp_1",
  type: "vec3",
  inputs: [
    { name: "v0", type: "vec3" },
    { name: "v1", type: "vec3" },
    { name: "v2", type: "vec3" },
    { name: "v3", type: "vec3" },
    { name: "s", type: "float" },
    { name: "t", type: "float" }
  ]
});
var mx_bilerp = overloadingFn([mx_bilerp_0, mx_bilerp_1]);
var mx_trilerp_0 = Fn(([v0_immutable, v1_immutable, v2_immutable, v3_immutable, v4_immutable, v5_immutable, v6_immutable, v7_immutable, s_immutable, t_immutable, r_immutable]) => {
  const r2 = float(r_immutable).toVar();
  const t5 = float(t_immutable).toVar();
  const s2 = float(s_immutable).toVar();
  const v7 = float(v7_immutable).toVar();
  const v6 = float(v6_immutable).toVar();
  const v5 = float(v5_immutable).toVar();
  const v4 = float(v4_immutable).toVar();
  const v3 = float(v3_immutable).toVar();
  const v2 = float(v2_immutable).toVar();
  const v1 = float(v1_immutable).toVar();
  const v0 = float(v0_immutable).toVar();
  const s1 = float(sub(1, s2)).toVar();
  const t13 = float(sub(1, t5)).toVar();
  const r1 = float(sub(1, r2)).toVar();
  return r1.mul(t13.mul(v0.mul(s1).add(v1.mul(s2))).add(t5.mul(v2.mul(s1).add(v3.mul(s2))))).add(r2.mul(t13.mul(v4.mul(s1).add(v5.mul(s2))).add(t5.mul(v6.mul(s1).add(v7.mul(s2))))));
}).setLayout({
  name: "mx_trilerp_0",
  type: "float",
  inputs: [
    { name: "v0", type: "float" },
    { name: "v1", type: "float" },
    { name: "v2", type: "float" },
    { name: "v3", type: "float" },
    { name: "v4", type: "float" },
    { name: "v5", type: "float" },
    { name: "v6", type: "float" },
    { name: "v7", type: "float" },
    { name: "s", type: "float" },
    { name: "t", type: "float" },
    { name: "r", type: "float" }
  ]
});
var mx_trilerp_1 = Fn(([v0_immutable, v1_immutable, v2_immutable, v3_immutable, v4_immutable, v5_immutable, v6_immutable, v7_immutable, s_immutable, t_immutable, r_immutable]) => {
  const r2 = float(r_immutable).toVar();
  const t5 = float(t_immutable).toVar();
  const s2 = float(s_immutable).toVar();
  const v7 = vec3(v7_immutable).toVar();
  const v6 = vec3(v6_immutable).toVar();
  const v5 = vec3(v5_immutable).toVar();
  const v4 = vec3(v4_immutable).toVar();
  const v3 = vec3(v3_immutable).toVar();
  const v2 = vec3(v2_immutable).toVar();
  const v1 = vec3(v1_immutable).toVar();
  const v0 = vec3(v0_immutable).toVar();
  const s1 = float(sub(1, s2)).toVar();
  const t13 = float(sub(1, t5)).toVar();
  const r1 = float(sub(1, r2)).toVar();
  return r1.mul(t13.mul(v0.mul(s1).add(v1.mul(s2))).add(t5.mul(v2.mul(s1).add(v3.mul(s2))))).add(r2.mul(t13.mul(v4.mul(s1).add(v5.mul(s2))).add(t5.mul(v6.mul(s1).add(v7.mul(s2))))));
}).setLayout({
  name: "mx_trilerp_1",
  type: "vec3",
  inputs: [
    { name: "v0", type: "vec3" },
    { name: "v1", type: "vec3" },
    { name: "v2", type: "vec3" },
    { name: "v3", type: "vec3" },
    { name: "v4", type: "vec3" },
    { name: "v5", type: "vec3" },
    { name: "v6", type: "vec3" },
    { name: "v7", type: "vec3" },
    { name: "s", type: "float" },
    { name: "t", type: "float" },
    { name: "r", type: "float" }
  ]
});
var mx_trilerp = overloadingFn([mx_trilerp_0, mx_trilerp_1]);
var mx_gradient_float_0 = Fn(([hash_immutable, x_immutable, y_immutable]) => {
  const y3 = float(y_immutable).toVar();
  const x3 = float(x_immutable).toVar();
  const hash2 = uint(hash_immutable).toVar();
  const h2 = uint(hash2.bitAnd(uint(7))).toVar();
  const u2 = float(mx_select(h2.lessThan(uint(4)), x3, y3)).toVar();
  const v2 = float(mul(2, mx_select(h2.lessThan(uint(4)), y3, x3))).toVar();
  return mx_negate_if(u2, bool(h2.bitAnd(uint(1)))).add(mx_negate_if(v2, bool(h2.bitAnd(uint(2)))));
}).setLayout({
  name: "mx_gradient_float_0",
  type: "float",
  inputs: [
    { name: "hash", type: "uint" },
    { name: "x", type: "float" },
    { name: "y", type: "float" }
  ]
});
var mx_gradient_float_1 = Fn(([hash_immutable, x_immutable, y_immutable, z_immutable]) => {
  const z3 = float(z_immutable).toVar();
  const y3 = float(y_immutable).toVar();
  const x3 = float(x_immutable).toVar();
  const hash2 = uint(hash_immutable).toVar();
  const h2 = uint(hash2.bitAnd(uint(15))).toVar();
  const u2 = float(mx_select(h2.lessThan(uint(8)), x3, y3)).toVar();
  const v2 = float(mx_select(h2.lessThan(uint(4)), y3, mx_select(h2.equal(uint(12)).or(h2.equal(uint(14))), x3, z3))).toVar();
  return mx_negate_if(u2, bool(h2.bitAnd(uint(1)))).add(mx_negate_if(v2, bool(h2.bitAnd(uint(2)))));
}).setLayout({
  name: "mx_gradient_float_1",
  type: "float",
  inputs: [
    { name: "hash", type: "uint" },
    { name: "x", type: "float" },
    { name: "y", type: "float" },
    { name: "z", type: "float" }
  ]
});
var mx_gradient_float = overloadingFn([mx_gradient_float_0, mx_gradient_float_1]);
var mx_gradient_vec3_0 = Fn(([hash_immutable, x_immutable, y_immutable]) => {
  const y3 = float(y_immutable).toVar();
  const x3 = float(x_immutable).toVar();
  const hash2 = uvec3(hash_immutable).toVar();
  return vec3(mx_gradient_float(hash2.x, x3, y3), mx_gradient_float(hash2.y, x3, y3), mx_gradient_float(hash2.z, x3, y3));
}).setLayout({
  name: "mx_gradient_vec3_0",
  type: "vec3",
  inputs: [
    { name: "hash", type: "uvec3" },
    { name: "x", type: "float" },
    { name: "y", type: "float" }
  ]
});
var mx_gradient_vec3_1 = Fn(([hash_immutable, x_immutable, y_immutable, z_immutable]) => {
  const z3 = float(z_immutable).toVar();
  const y3 = float(y_immutable).toVar();
  const x3 = float(x_immutable).toVar();
  const hash2 = uvec3(hash_immutable).toVar();
  return vec3(mx_gradient_float(hash2.x, x3, y3, z3), mx_gradient_float(hash2.y, x3, y3, z3), mx_gradient_float(hash2.z, x3, y3, z3));
}).setLayout({
  name: "mx_gradient_vec3_1",
  type: "vec3",
  inputs: [
    { name: "hash", type: "uvec3" },
    { name: "x", type: "float" },
    { name: "y", type: "float" },
    { name: "z", type: "float" }
  ]
});
var mx_gradient_vec3 = overloadingFn([mx_gradient_vec3_0, mx_gradient_vec3_1]);
var mx_gradient_scale2d_0 = Fn(([v_immutable]) => {
  const v2 = float(v_immutable).toVar();
  return mul(0.6616, v2);
}).setLayout({
  name: "mx_gradient_scale2d_0",
  type: "float",
  inputs: [
    { name: "v", type: "float" }
  ]
});
var mx_gradient_scale3d_0 = Fn(([v_immutable]) => {
  const v2 = float(v_immutable).toVar();
  return mul(0.982, v2);
}).setLayout({
  name: "mx_gradient_scale3d_0",
  type: "float",
  inputs: [
    { name: "v", type: "float" }
  ]
});
var mx_gradient_scale2d_1 = Fn(([v_immutable]) => {
  const v2 = vec3(v_immutable).toVar();
  return mul(0.6616, v2);
}).setLayout({
  name: "mx_gradient_scale2d_1",
  type: "vec3",
  inputs: [
    { name: "v", type: "vec3" }
  ]
});
var mx_gradient_scale2d = overloadingFn([mx_gradient_scale2d_0, mx_gradient_scale2d_1]);
var mx_gradient_scale3d_1 = Fn(([v_immutable]) => {
  const v2 = vec3(v_immutable).toVar();
  return mul(0.982, v2);
}).setLayout({
  name: "mx_gradient_scale3d_1",
  type: "vec3",
  inputs: [
    { name: "v", type: "vec3" }
  ]
});
var mx_gradient_scale3d = overloadingFn([mx_gradient_scale3d_0, mx_gradient_scale3d_1]);
var mx_rotl32 = Fn(([x_immutable, k_immutable]) => {
  const k2 = int(k_immutable).toVar();
  const x3 = uint(x_immutable).toVar();
  return x3.shiftLeft(k2).bitOr(x3.shiftRight(int(32).sub(k2)));
}).setLayout({
  name: "mx_rotl32",
  type: "uint",
  inputs: [
    { name: "x", type: "uint" },
    { name: "k", type: "int" }
  ]
});
var mx_bjmix = Fn(([a3, b, c5]) => {
  a3.subAssign(c5);
  a3.bitXorAssign(mx_rotl32(c5, int(4)));
  c5.addAssign(b);
  b.subAssign(a3);
  b.bitXorAssign(mx_rotl32(a3, int(6)));
  a3.addAssign(c5);
  c5.subAssign(b);
  c5.bitXorAssign(mx_rotl32(b, int(8)));
  b.addAssign(a3);
  a3.subAssign(c5);
  a3.bitXorAssign(mx_rotl32(c5, int(16)));
  c5.addAssign(b);
  b.subAssign(a3);
  b.bitXorAssign(mx_rotl32(a3, int(19)));
  a3.addAssign(c5);
  c5.subAssign(b);
  c5.bitXorAssign(mx_rotl32(b, int(4)));
  b.addAssign(a3);
});
var mx_bjfinal = Fn(([a_immutable, b_immutable, c_immutable]) => {
  const c5 = uint(c_immutable).toVar();
  const b = uint(b_immutable).toVar();
  const a3 = uint(a_immutable).toVar();
  c5.bitXorAssign(b);
  c5.subAssign(mx_rotl32(b, int(14)));
  a3.bitXorAssign(c5);
  a3.subAssign(mx_rotl32(c5, int(11)));
  b.bitXorAssign(a3);
  b.subAssign(mx_rotl32(a3, int(25)));
  c5.bitXorAssign(b);
  c5.subAssign(mx_rotl32(b, int(16)));
  a3.bitXorAssign(c5);
  a3.subAssign(mx_rotl32(c5, int(4)));
  b.bitXorAssign(a3);
  b.subAssign(mx_rotl32(a3, int(14)));
  c5.bitXorAssign(b);
  c5.subAssign(mx_rotl32(b, int(24)));
  return c5;
}).setLayout({
  name: "mx_bjfinal",
  type: "uint",
  inputs: [
    { name: "a", type: "uint" },
    { name: "b", type: "uint" },
    { name: "c", type: "uint" }
  ]
});
var mx_bits_to_01 = Fn(([bits_immutable]) => {
  const bits2 = uint(bits_immutable).toVar();
  return float(bits2).div(float(uint(int(4294967295))));
}).setLayout({
  name: "mx_bits_to_01",
  type: "float",
  inputs: [
    { name: "bits", type: "uint" }
  ]
});
var mx_fade = Fn(([t_immutable]) => {
  const t5 = float(t_immutable).toVar();
  return t5.mul(t5).mul(t5).mul(t5.mul(t5.mul(6).sub(15)).add(10));
}).setLayout({
  name: "mx_fade",
  type: "float",
  inputs: [
    { name: "t", type: "float" }
  ]
});
var mx_hash_int_0 = Fn(([x_immutable]) => {
  const x3 = int(x_immutable).toVar();
  const len = uint(uint(1)).toVar();
  const seed = uint(uint(int(3735928559)).add(len.shiftLeft(uint(2))).add(uint(13))).toVar();
  return mx_bjfinal(seed.add(uint(x3)), seed, seed);
}).setLayout({
  name: "mx_hash_int_0",
  type: "uint",
  inputs: [
    { name: "x", type: "int" }
  ]
});
var mx_hash_int_1 = Fn(([x_immutable, y_immutable]) => {
  const y3 = int(y_immutable).toVar();
  const x3 = int(x_immutable).toVar();
  const len = uint(uint(2)).toVar();
  const a3 = uint().toVar(), b = uint().toVar(), c5 = uint().toVar();
  a3.assign(b.assign(c5.assign(uint(int(3735928559)).add(len.shiftLeft(uint(2))).add(uint(13)))));
  a3.addAssign(uint(x3));
  b.addAssign(uint(y3));
  return mx_bjfinal(a3, b, c5);
}).setLayout({
  name: "mx_hash_int_1",
  type: "uint",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" }
  ]
});
var mx_hash_int_2 = Fn(([x_immutable, y_immutable, z_immutable]) => {
  const z3 = int(z_immutable).toVar();
  const y3 = int(y_immutable).toVar();
  const x3 = int(x_immutable).toVar();
  const len = uint(uint(3)).toVar();
  const a3 = uint().toVar(), b = uint().toVar(), c5 = uint().toVar();
  a3.assign(b.assign(c5.assign(uint(int(3735928559)).add(len.shiftLeft(uint(2))).add(uint(13)))));
  a3.addAssign(uint(x3));
  b.addAssign(uint(y3));
  c5.addAssign(uint(z3));
  return mx_bjfinal(a3, b, c5);
}).setLayout({
  name: "mx_hash_int_2",
  type: "uint",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "z", type: "int" }
  ]
});
var mx_hash_int_3 = Fn(([x_immutable, y_immutable, z_immutable, xx_immutable]) => {
  const xx = int(xx_immutable).toVar();
  const z3 = int(z_immutable).toVar();
  const y3 = int(y_immutable).toVar();
  const x3 = int(x_immutable).toVar();
  const len = uint(uint(4)).toVar();
  const a3 = uint().toVar(), b = uint().toVar(), c5 = uint().toVar();
  a3.assign(b.assign(c5.assign(uint(int(3735928559)).add(len.shiftLeft(uint(2))).add(uint(13)))));
  a3.addAssign(uint(x3));
  b.addAssign(uint(y3));
  c5.addAssign(uint(z3));
  mx_bjmix(a3, b, c5);
  a3.addAssign(uint(xx));
  return mx_bjfinal(a3, b, c5);
}).setLayout({
  name: "mx_hash_int_3",
  type: "uint",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "z", type: "int" },
    { name: "xx", type: "int" }
  ]
});
var mx_hash_int_4 = Fn(([x_immutable, y_immutable, z_immutable, xx_immutable, yy_immutable]) => {
  const yy = int(yy_immutable).toVar();
  const xx = int(xx_immutable).toVar();
  const z3 = int(z_immutable).toVar();
  const y3 = int(y_immutable).toVar();
  const x3 = int(x_immutable).toVar();
  const len = uint(uint(5)).toVar();
  const a3 = uint().toVar(), b = uint().toVar(), c5 = uint().toVar();
  a3.assign(b.assign(c5.assign(uint(int(3735928559)).add(len.shiftLeft(uint(2))).add(uint(13)))));
  a3.addAssign(uint(x3));
  b.addAssign(uint(y3));
  c5.addAssign(uint(z3));
  mx_bjmix(a3, b, c5);
  a3.addAssign(uint(xx));
  b.addAssign(uint(yy));
  return mx_bjfinal(a3, b, c5);
}).setLayout({
  name: "mx_hash_int_4",
  type: "uint",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "z", type: "int" },
    { name: "xx", type: "int" },
    { name: "yy", type: "int" }
  ]
});
var mx_hash_int = overloadingFn([mx_hash_int_0, mx_hash_int_1, mx_hash_int_2, mx_hash_int_3, mx_hash_int_4]);
var mx_hash_vec3_0 = Fn(([x_immutable, y_immutable]) => {
  const y3 = int(y_immutable).toVar();
  const x3 = int(x_immutable).toVar();
  const h2 = uint(mx_hash_int(x3, y3)).toVar();
  const result2 = uvec3().toVar();
  result2.x.assign(h2.bitAnd(int(255)));
  result2.y.assign(h2.shiftRight(int(8)).bitAnd(int(255)));
  result2.z.assign(h2.shiftRight(int(16)).bitAnd(int(255)));
  return result2;
}).setLayout({
  name: "mx_hash_vec3_0",
  type: "uvec3",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" }
  ]
});
var mx_hash_vec3_1 = Fn(([x_immutable, y_immutable, z_immutable]) => {
  const z3 = int(z_immutable).toVar();
  const y3 = int(y_immutable).toVar();
  const x3 = int(x_immutable).toVar();
  const h2 = uint(mx_hash_int(x3, y3, z3)).toVar();
  const result2 = uvec3().toVar();
  result2.x.assign(h2.bitAnd(int(255)));
  result2.y.assign(h2.shiftRight(int(8)).bitAnd(int(255)));
  result2.z.assign(h2.shiftRight(int(16)).bitAnd(int(255)));
  return result2;
}).setLayout({
  name: "mx_hash_vec3_1",
  type: "uvec3",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "z", type: "int" }
  ]
});
var mx_hash_vec3 = overloadingFn([mx_hash_vec3_0, mx_hash_vec3_1]);
var mx_perlin_noise_float_0 = Fn(([p_immutable]) => {
  const p3 = vec2(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar();
  const fx = float(mx_floorfrac(p3.x, X)).toVar();
  const fy = float(mx_floorfrac(p3.y, Y)).toVar();
  const u2 = float(mx_fade(fx)).toVar();
  const v2 = float(mx_fade(fy)).toVar();
  const result2 = float(mx_bilerp(mx_gradient_float(mx_hash_int(X, Y), fx, fy), mx_gradient_float(mx_hash_int(X.add(int(1)), Y), fx.sub(1), fy), mx_gradient_float(mx_hash_int(X, Y.add(int(1))), fx, fy.sub(1)), mx_gradient_float(mx_hash_int(X.add(int(1)), Y.add(int(1))), fx.sub(1), fy.sub(1)), u2, v2)).toVar();
  return mx_gradient_scale2d(result2);
}).setLayout({
  name: "mx_perlin_noise_float_0",
  type: "float",
  inputs: [
    { name: "p", type: "vec2" }
  ]
});
var mx_perlin_noise_float_1 = Fn(([p_immutable]) => {
  const p3 = vec3(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar(), Z = int().toVar();
  const fx = float(mx_floorfrac(p3.x, X)).toVar();
  const fy = float(mx_floorfrac(p3.y, Y)).toVar();
  const fz = float(mx_floorfrac(p3.z, Z)).toVar();
  const u2 = float(mx_fade(fx)).toVar();
  const v2 = float(mx_fade(fy)).toVar();
  const w4 = float(mx_fade(fz)).toVar();
  const result2 = float(mx_trilerp(mx_gradient_float(mx_hash_int(X, Y, Z), fx, fy, fz), mx_gradient_float(mx_hash_int(X.add(int(1)), Y, Z), fx.sub(1), fy, fz), mx_gradient_float(mx_hash_int(X, Y.add(int(1)), Z), fx, fy.sub(1), fz), mx_gradient_float(mx_hash_int(X.add(int(1)), Y.add(int(1)), Z), fx.sub(1), fy.sub(1), fz), mx_gradient_float(mx_hash_int(X, Y, Z.add(int(1))), fx, fy, fz.sub(1)), mx_gradient_float(mx_hash_int(X.add(int(1)), Y, Z.add(int(1))), fx.sub(1), fy, fz.sub(1)), mx_gradient_float(mx_hash_int(X, Y.add(int(1)), Z.add(int(1))), fx, fy.sub(1), fz.sub(1)), mx_gradient_float(mx_hash_int(X.add(int(1)), Y.add(int(1)), Z.add(int(1))), fx.sub(1), fy.sub(1), fz.sub(1)), u2, v2, w4)).toVar();
  return mx_gradient_scale3d(result2);
}).setLayout({
  name: "mx_perlin_noise_float_1",
  type: "float",
  inputs: [
    { name: "p", type: "vec3" }
  ]
});
var mx_perlin_noise_float = overloadingFn([mx_perlin_noise_float_0, mx_perlin_noise_float_1]);
var mx_perlin_noise_vec3_0 = Fn(([p_immutable]) => {
  const p3 = vec2(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar();
  const fx = float(mx_floorfrac(p3.x, X)).toVar();
  const fy = float(mx_floorfrac(p3.y, Y)).toVar();
  const u2 = float(mx_fade(fx)).toVar();
  const v2 = float(mx_fade(fy)).toVar();
  const result2 = vec3(mx_bilerp(mx_gradient_vec3(mx_hash_vec3(X, Y), fx, fy), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y), fx.sub(1), fy), mx_gradient_vec3(mx_hash_vec3(X, Y.add(int(1))), fx, fy.sub(1)), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y.add(int(1))), fx.sub(1), fy.sub(1)), u2, v2)).toVar();
  return mx_gradient_scale2d(result2);
}).setLayout({
  name: "mx_perlin_noise_vec3_0",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec2" }
  ]
});
var mx_perlin_noise_vec3_1 = Fn(([p_immutable]) => {
  const p3 = vec3(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar(), Z = int().toVar();
  const fx = float(mx_floorfrac(p3.x, X)).toVar();
  const fy = float(mx_floorfrac(p3.y, Y)).toVar();
  const fz = float(mx_floorfrac(p3.z, Z)).toVar();
  const u2 = float(mx_fade(fx)).toVar();
  const v2 = float(mx_fade(fy)).toVar();
  const w4 = float(mx_fade(fz)).toVar();
  const result2 = vec3(mx_trilerp(mx_gradient_vec3(mx_hash_vec3(X, Y, Z), fx, fy, fz), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y, Z), fx.sub(1), fy, fz), mx_gradient_vec3(mx_hash_vec3(X, Y.add(int(1)), Z), fx, fy.sub(1), fz), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y.add(int(1)), Z), fx.sub(1), fy.sub(1), fz), mx_gradient_vec3(mx_hash_vec3(X, Y, Z.add(int(1))), fx, fy, fz.sub(1)), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y, Z.add(int(1))), fx.sub(1), fy, fz.sub(1)), mx_gradient_vec3(mx_hash_vec3(X, Y.add(int(1)), Z.add(int(1))), fx, fy.sub(1), fz.sub(1)), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y.add(int(1)), Z.add(int(1))), fx.sub(1), fy.sub(1), fz.sub(1)), u2, v2, w4)).toVar();
  return mx_gradient_scale3d(result2);
}).setLayout({
  name: "mx_perlin_noise_vec3_1",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec3" }
  ]
});
var mx_perlin_noise_vec3 = overloadingFn([mx_perlin_noise_vec3_0, mx_perlin_noise_vec3_1]);
var mx_cell_noise_float_0 = Fn(([p_immutable]) => {
  const p3 = float(p_immutable).toVar();
  const ix = int(mx_floor(p3)).toVar();
  return mx_bits_to_01(mx_hash_int(ix));
}).setLayout({
  name: "mx_cell_noise_float_0",
  type: "float",
  inputs: [
    { name: "p", type: "float" }
  ]
});
var mx_cell_noise_float_1 = Fn(([p_immutable]) => {
  const p3 = vec2(p_immutable).toVar();
  const ix = int(mx_floor(p3.x)).toVar();
  const iy = int(mx_floor(p3.y)).toVar();
  return mx_bits_to_01(mx_hash_int(ix, iy));
}).setLayout({
  name: "mx_cell_noise_float_1",
  type: "float",
  inputs: [
    { name: "p", type: "vec2" }
  ]
});
var mx_cell_noise_float_2 = Fn(([p_immutable]) => {
  const p3 = vec3(p_immutable).toVar();
  const ix = int(mx_floor(p3.x)).toVar();
  const iy = int(mx_floor(p3.y)).toVar();
  const iz = int(mx_floor(p3.z)).toVar();
  return mx_bits_to_01(mx_hash_int(ix, iy, iz));
}).setLayout({
  name: "mx_cell_noise_float_2",
  type: "float",
  inputs: [
    { name: "p", type: "vec3" }
  ]
});
var mx_cell_noise_float_3 = Fn(([p_immutable]) => {
  const p3 = vec4(p_immutable).toVar();
  const ix = int(mx_floor(p3.x)).toVar();
  const iy = int(mx_floor(p3.y)).toVar();
  const iz = int(mx_floor(p3.z)).toVar();
  const iw = int(mx_floor(p3.w)).toVar();
  return mx_bits_to_01(mx_hash_int(ix, iy, iz, iw));
}).setLayout({
  name: "mx_cell_noise_float_3",
  type: "float",
  inputs: [
    { name: "p", type: "vec4" }
  ]
});
var mx_cell_noise_float$1 = overloadingFn([mx_cell_noise_float_0, mx_cell_noise_float_1, mx_cell_noise_float_2, mx_cell_noise_float_3]);
var mx_cell_noise_vec3_0 = Fn(([p_immutable]) => {
  const p3 = float(p_immutable).toVar();
  const ix = int(mx_floor(p3)).toVar();
  return vec3(mx_bits_to_01(mx_hash_int(ix, int(0))), mx_bits_to_01(mx_hash_int(ix, int(1))), mx_bits_to_01(mx_hash_int(ix, int(2))));
}).setLayout({
  name: "mx_cell_noise_vec3_0",
  type: "vec3",
  inputs: [
    { name: "p", type: "float" }
  ]
});
var mx_cell_noise_vec3_1 = Fn(([p_immutable]) => {
  const p3 = vec2(p_immutable).toVar();
  const ix = int(mx_floor(p3.x)).toVar();
  const iy = int(mx_floor(p3.y)).toVar();
  return vec3(mx_bits_to_01(mx_hash_int(ix, iy, int(0))), mx_bits_to_01(mx_hash_int(ix, iy, int(1))), mx_bits_to_01(mx_hash_int(ix, iy, int(2))));
}).setLayout({
  name: "mx_cell_noise_vec3_1",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec2" }
  ]
});
var mx_cell_noise_vec3_2 = Fn(([p_immutable]) => {
  const p3 = vec3(p_immutable).toVar();
  const ix = int(mx_floor(p3.x)).toVar();
  const iy = int(mx_floor(p3.y)).toVar();
  const iz = int(mx_floor(p3.z)).toVar();
  return vec3(mx_bits_to_01(mx_hash_int(ix, iy, iz, int(0))), mx_bits_to_01(mx_hash_int(ix, iy, iz, int(1))), mx_bits_to_01(mx_hash_int(ix, iy, iz, int(2))));
}).setLayout({
  name: "mx_cell_noise_vec3_2",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec3" }
  ]
});
var mx_cell_noise_vec3_3 = Fn(([p_immutable]) => {
  const p3 = vec4(p_immutable).toVar();
  const ix = int(mx_floor(p3.x)).toVar();
  const iy = int(mx_floor(p3.y)).toVar();
  const iz = int(mx_floor(p3.z)).toVar();
  const iw = int(mx_floor(p3.w)).toVar();
  return vec3(mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, int(0))), mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, int(1))), mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, int(2))));
}).setLayout({
  name: "mx_cell_noise_vec3_3",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec4" }
  ]
});
var mx_cell_noise_vec3 = overloadingFn([mx_cell_noise_vec3_0, mx_cell_noise_vec3_1, mx_cell_noise_vec3_2, mx_cell_noise_vec3_3]);
var mx_fractal_noise_float$1 = Fn(([p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable]) => {
  const diminish = float(diminish_immutable).toVar();
  const lacunarity = float(lacunarity_immutable).toVar();
  const octaves = int(octaves_immutable).toVar();
  const p3 = vec3(p_immutable).toVar();
  const result2 = float(0).toVar();
  const amplitude2 = float(1).toVar();
  Loop(octaves, () => {
    result2.addAssign(amplitude2.mul(mx_perlin_noise_float(p3)));
    amplitude2.mulAssign(diminish);
    p3.mulAssign(lacunarity);
  });
  return result2;
}).setLayout({
  name: "mx_fractal_noise_float",
  type: "float",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "octaves", type: "int" },
    { name: "lacunarity", type: "float" },
    { name: "diminish", type: "float" }
  ]
});
var mx_fractal_noise_vec3$1 = Fn(([p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable]) => {
  const diminish = float(diminish_immutable).toVar();
  const lacunarity = float(lacunarity_immutable).toVar();
  const octaves = int(octaves_immutable).toVar();
  const p3 = vec3(p_immutable).toVar();
  const result2 = vec3(0).toVar();
  const amplitude2 = float(1).toVar();
  Loop(octaves, () => {
    result2.addAssign(amplitude2.mul(mx_perlin_noise_vec3(p3)));
    amplitude2.mulAssign(diminish);
    p3.mulAssign(lacunarity);
  });
  return result2;
}).setLayout({
  name: "mx_fractal_noise_vec3",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "octaves", type: "int" },
    { name: "lacunarity", type: "float" },
    { name: "diminish", type: "float" }
  ]
});
var mx_fractal_noise_vec2$1 = Fn(([p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable]) => {
  const diminish = float(diminish_immutable).toVar();
  const lacunarity = float(lacunarity_immutable).toVar();
  const octaves = int(octaves_immutable).toVar();
  const p3 = vec3(p_immutable).toVar();
  return vec2(mx_fractal_noise_float$1(p3, octaves, lacunarity, diminish), mx_fractal_noise_float$1(p3.add(vec3(int(19), int(193), int(17))), octaves, lacunarity, diminish));
}).setLayout({
  name: "mx_fractal_noise_vec2",
  type: "vec2",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "octaves", type: "int" },
    { name: "lacunarity", type: "float" },
    { name: "diminish", type: "float" }
  ]
});
var mx_fractal_noise_vec4$1 = Fn(([p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable]) => {
  const diminish = float(diminish_immutable).toVar();
  const lacunarity = float(lacunarity_immutable).toVar();
  const octaves = int(octaves_immutable).toVar();
  const p3 = vec3(p_immutable).toVar();
  const c5 = vec3(mx_fractal_noise_vec3$1(p3, octaves, lacunarity, diminish)).toVar();
  const f3 = float(mx_fractal_noise_float$1(p3.add(vec3(int(19), int(193), int(17))), octaves, lacunarity, diminish)).toVar();
  return vec4(c5, f3);
}).setLayout({
  name: "mx_fractal_noise_vec4",
  type: "vec4",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "octaves", type: "int" },
    { name: "lacunarity", type: "float" },
    { name: "diminish", type: "float" }
  ]
});
var mx_worley_distance_0 = Fn(([p_immutable, x_immutable, y_immutable, xoff_immutable, yoff_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int(metric_immutable).toVar();
  const jitter = float(jitter_immutable).toVar();
  const yoff = int(yoff_immutable).toVar();
  const xoff = int(xoff_immutable).toVar();
  const y3 = int(y_immutable).toVar();
  const x3 = int(x_immutable).toVar();
  const p3 = vec2(p_immutable).toVar();
  const tmp2 = vec3(mx_cell_noise_vec3(vec2(x3.add(xoff), y3.add(yoff)))).toVar();
  const off = vec2(tmp2.x, tmp2.y).toVar();
  off.subAssign(0.5);
  off.mulAssign(jitter);
  off.addAssign(0.5);
  const cellpos = vec2(vec2(float(x3), float(y3)).add(off)).toVar();
  const diff = vec2(cellpos.sub(p3)).toVar();
  If(metric.equal(int(2)), () => {
    return abs(diff.x).add(abs(diff.y));
  });
  If(metric.equal(int(3)), () => {
    return max$1(abs(diff.x), abs(diff.y));
  });
  return dot(diff, diff);
}).setLayout({
  name: "mx_worley_distance_0",
  type: "float",
  inputs: [
    { name: "p", type: "vec2" },
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "xoff", type: "int" },
    { name: "yoff", type: "int" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
var mx_worley_distance_1 = Fn(([p_immutable, x_immutable, y_immutable, z_immutable, xoff_immutable, yoff_immutable, zoff_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int(metric_immutable).toVar();
  const jitter = float(jitter_immutable).toVar();
  const zoff = int(zoff_immutable).toVar();
  const yoff = int(yoff_immutable).toVar();
  const xoff = int(xoff_immutable).toVar();
  const z3 = int(z_immutable).toVar();
  const y3 = int(y_immutable).toVar();
  const x3 = int(x_immutable).toVar();
  const p3 = vec3(p_immutable).toVar();
  const off = vec3(mx_cell_noise_vec3(vec3(x3.add(xoff), y3.add(yoff), z3.add(zoff)))).toVar();
  off.subAssign(0.5);
  off.mulAssign(jitter);
  off.addAssign(0.5);
  const cellpos = vec3(vec3(float(x3), float(y3), float(z3)).add(off)).toVar();
  const diff = vec3(cellpos.sub(p3)).toVar();
  If(metric.equal(int(2)), () => {
    return abs(diff.x).add(abs(diff.y)).add(abs(diff.z));
  });
  If(metric.equal(int(3)), () => {
    return max$1(abs(diff.x), abs(diff.y), abs(diff.z));
  });
  return dot(diff, diff);
}).setLayout({
  name: "mx_worley_distance_1",
  type: "float",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "z", type: "int" },
    { name: "xoff", type: "int" },
    { name: "yoff", type: "int" },
    { name: "zoff", type: "int" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
var mx_worley_distance = overloadingFn([mx_worley_distance_0, mx_worley_distance_1]);
var mx_worley_noise_float_0 = Fn(([p_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int(metric_immutable).toVar();
  const jitter = float(jitter_immutable).toVar();
  const p3 = vec2(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar();
  const localpos = vec2(mx_floorfrac(p3.x, X), mx_floorfrac(p3.y, Y)).toVar();
  const sqdist = float(1e6).toVar();
  Loop({ start: -1, end: int(1), name: "x", condition: "<=" }, ({ x: x3 }) => {
    Loop({ start: -1, end: int(1), name: "y", condition: "<=" }, ({ y: y3 }) => {
      const dist = float(mx_worley_distance(localpos, x3, y3, X, Y, jitter, metric)).toVar();
      sqdist.assign(min$1(sqdist, dist));
    });
  });
  If(metric.equal(int(0)), () => {
    sqdist.assign(sqrt2(sqdist));
  });
  return sqdist;
}).setLayout({
  name: "mx_worley_noise_float_0",
  type: "float",
  inputs: [
    { name: "p", type: "vec2" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
var mx_worley_noise_vec2_0 = Fn(([p_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int(metric_immutable).toVar();
  const jitter = float(jitter_immutable).toVar();
  const p3 = vec2(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar();
  const localpos = vec2(mx_floorfrac(p3.x, X), mx_floorfrac(p3.y, Y)).toVar();
  const sqdist = vec2(1e6, 1e6).toVar();
  Loop({ start: -1, end: int(1), name: "x", condition: "<=" }, ({ x: x3 }) => {
    Loop({ start: -1, end: int(1), name: "y", condition: "<=" }, ({ y: y3 }) => {
      const dist = float(mx_worley_distance(localpos, x3, y3, X, Y, jitter, metric)).toVar();
      If(dist.lessThan(sqdist.x), () => {
        sqdist.y.assign(sqdist.x);
        sqdist.x.assign(dist);
      }).ElseIf(dist.lessThan(sqdist.y), () => {
        sqdist.y.assign(dist);
      });
    });
  });
  If(metric.equal(int(0)), () => {
    sqdist.assign(sqrt2(sqdist));
  });
  return sqdist;
}).setLayout({
  name: "mx_worley_noise_vec2_0",
  type: "vec2",
  inputs: [
    { name: "p", type: "vec2" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
var mx_worley_noise_vec3_0 = Fn(([p_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int(metric_immutable).toVar();
  const jitter = float(jitter_immutable).toVar();
  const p3 = vec2(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar();
  const localpos = vec2(mx_floorfrac(p3.x, X), mx_floorfrac(p3.y, Y)).toVar();
  const sqdist = vec3(1e6, 1e6, 1e6).toVar();
  Loop({ start: -1, end: int(1), name: "x", condition: "<=" }, ({ x: x3 }) => {
    Loop({ start: -1, end: int(1), name: "y", condition: "<=" }, ({ y: y3 }) => {
      const dist = float(mx_worley_distance(localpos, x3, y3, X, Y, jitter, metric)).toVar();
      If(dist.lessThan(sqdist.x), () => {
        sqdist.z.assign(sqdist.y);
        sqdist.y.assign(sqdist.x);
        sqdist.x.assign(dist);
      }).ElseIf(dist.lessThan(sqdist.y), () => {
        sqdist.z.assign(sqdist.y);
        sqdist.y.assign(dist);
      }).ElseIf(dist.lessThan(sqdist.z), () => {
        sqdist.z.assign(dist);
      });
    });
  });
  If(metric.equal(int(0)), () => {
    sqdist.assign(sqrt2(sqdist));
  });
  return sqdist;
}).setLayout({
  name: "mx_worley_noise_vec3_0",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec2" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
var mx_worley_noise_float_1 = Fn(([p_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int(metric_immutable).toVar();
  const jitter = float(jitter_immutable).toVar();
  const p3 = vec3(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar(), Z = int().toVar();
  const localpos = vec3(mx_floorfrac(p3.x, X), mx_floorfrac(p3.y, Y), mx_floorfrac(p3.z, Z)).toVar();
  const sqdist = float(1e6).toVar();
  Loop({ start: -1, end: int(1), name: "x", condition: "<=" }, ({ x: x3 }) => {
    Loop({ start: -1, end: int(1), name: "y", condition: "<=" }, ({ y: y3 }) => {
      Loop({ start: -1, end: int(1), name: "z", condition: "<=" }, ({ z: z3 }) => {
        const dist = float(mx_worley_distance(localpos, x3, y3, z3, X, Y, Z, jitter, metric)).toVar();
        sqdist.assign(min$1(sqdist, dist));
      });
    });
  });
  If(metric.equal(int(0)), () => {
    sqdist.assign(sqrt2(sqdist));
  });
  return sqdist;
}).setLayout({
  name: "mx_worley_noise_float_1",
  type: "float",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
var mx_worley_noise_float$1 = overloadingFn([mx_worley_noise_float_0, mx_worley_noise_float_1]);
var mx_worley_noise_vec2_1 = Fn(([p_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int(metric_immutable).toVar();
  const jitter = float(jitter_immutable).toVar();
  const p3 = vec3(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar(), Z = int().toVar();
  const localpos = vec3(mx_floorfrac(p3.x, X), mx_floorfrac(p3.y, Y), mx_floorfrac(p3.z, Z)).toVar();
  const sqdist = vec2(1e6, 1e6).toVar();
  Loop({ start: -1, end: int(1), name: "x", condition: "<=" }, ({ x: x3 }) => {
    Loop({ start: -1, end: int(1), name: "y", condition: "<=" }, ({ y: y3 }) => {
      Loop({ start: -1, end: int(1), name: "z", condition: "<=" }, ({ z: z3 }) => {
        const dist = float(mx_worley_distance(localpos, x3, y3, z3, X, Y, Z, jitter, metric)).toVar();
        If(dist.lessThan(sqdist.x), () => {
          sqdist.y.assign(sqdist.x);
          sqdist.x.assign(dist);
        }).ElseIf(dist.lessThan(sqdist.y), () => {
          sqdist.y.assign(dist);
        });
      });
    });
  });
  If(metric.equal(int(0)), () => {
    sqdist.assign(sqrt2(sqdist));
  });
  return sqdist;
}).setLayout({
  name: "mx_worley_noise_vec2_1",
  type: "vec2",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
var mx_worley_noise_vec2$1 = overloadingFn([mx_worley_noise_vec2_0, mx_worley_noise_vec2_1]);
var mx_worley_noise_vec3_1 = Fn(([p_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int(metric_immutable).toVar();
  const jitter = float(jitter_immutable).toVar();
  const p3 = vec3(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar(), Z = int().toVar();
  const localpos = vec3(mx_floorfrac(p3.x, X), mx_floorfrac(p3.y, Y), mx_floorfrac(p3.z, Z)).toVar();
  const sqdist = vec3(1e6, 1e6, 1e6).toVar();
  Loop({ start: -1, end: int(1), name: "x", condition: "<=" }, ({ x: x3 }) => {
    Loop({ start: -1, end: int(1), name: "y", condition: "<=" }, ({ y: y3 }) => {
      Loop({ start: -1, end: int(1), name: "z", condition: "<=" }, ({ z: z3 }) => {
        const dist = float(mx_worley_distance(localpos, x3, y3, z3, X, Y, Z, jitter, metric)).toVar();
        If(dist.lessThan(sqdist.x), () => {
          sqdist.z.assign(sqdist.y);
          sqdist.y.assign(sqdist.x);
          sqdist.x.assign(dist);
        }).ElseIf(dist.lessThan(sqdist.y), () => {
          sqdist.z.assign(sqdist.y);
          sqdist.y.assign(dist);
        }).ElseIf(dist.lessThan(sqdist.z), () => {
          sqdist.z.assign(dist);
        });
      });
    });
  });
  If(metric.equal(int(0)), () => {
    sqdist.assign(sqrt2(sqdist));
  });
  return sqdist;
}).setLayout({
  name: "mx_worley_noise_vec3_1",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
var mx_worley_noise_vec3$1 = overloadingFn([mx_worley_noise_vec3_0, mx_worley_noise_vec3_1]);
var mx_unifiednoise2d$1 = Fn(([
  noiseType_immutable,
  texcoord_immutable,
  freq_immutable,
  offset_immutable,
  jitter_immutable,
  outmin_immutable,
  outmax_immutable,
  clampoutput_immutable,
  octaves_immutable,
  lacunarity_immutable,
  diminish_immutable
]) => {
  const noiseType = int(noiseType_immutable).toVar();
  const texcoord = vec2(texcoord_immutable).toVar();
  const freq = vec2(freq_immutable).toVar();
  const offset = vec2(offset_immutable).toVar();
  const jitter = float(jitter_immutable).toVar();
  const outmin = float(outmin_immutable).toVar();
  const outmax = float(outmax_immutable).toVar();
  const clampoutput = bool(clampoutput_immutable).toVar();
  const octaves = int(octaves_immutable).toVar();
  const lacunarity = float(lacunarity_immutable).toVar();
  const diminish = float(diminish_immutable).toVar();
  const p3 = texcoord.mul(freq).add(offset);
  const result2 = float(0).toVar();
  If(noiseType.equal(int(0)), () => {
    result2.assign(mx_perlin_noise_vec3(p3));
  });
  If(noiseType.equal(int(1)), () => {
    result2.assign(mx_cell_noise_vec3(p3));
  });
  If(noiseType.equal(int(2)), () => {
    result2.assign(mx_worley_noise_vec3$1(p3, jitter, int(0)));
  });
  If(noiseType.equal(int(3)), () => {
    result2.assign(mx_fractal_noise_vec3$1(vec3(p3, 0), octaves, lacunarity, diminish));
  });
  result2.assign(result2.mul(outmax.sub(outmin)).add(outmin));
  If(clampoutput, () => {
    result2.assign(clamp3(result2, outmin, outmax));
  });
  return result2;
}).setLayout({
  name: "mx_unifiednoise2d",
  type: "float",
  inputs: [
    { name: "noiseType", type: "int" },
    { name: "texcoord", type: "vec2" },
    { name: "freq", type: "vec2" },
    { name: "offset", type: "vec2" },
    { name: "jitter", type: "float" },
    { name: "outmin", type: "float" },
    { name: "outmax", type: "float" },
    { name: "clampoutput", type: "bool" },
    { name: "octaves", type: "int" },
    { name: "lacunarity", type: "float" },
    { name: "diminish", type: "float" }
  ]
});
var mx_unifiednoise3d$1 = Fn(([
  noiseType_immutable,
  position_immutable,
  freq_immutable,
  offset_immutable,
  jitter_immutable,
  outmin_immutable,
  outmax_immutable,
  clampoutput_immutable,
  octaves_immutable,
  lacunarity_immutable,
  diminish_immutable
]) => {
  const noiseType = int(noiseType_immutable).toVar();
  const position = vec3(position_immutable).toVar();
  const freq = vec3(freq_immutable).toVar();
  const offset = vec3(offset_immutable).toVar();
  const jitter = float(jitter_immutable).toVar();
  const outmin = float(outmin_immutable).toVar();
  const outmax = float(outmax_immutable).toVar();
  const clampoutput = bool(clampoutput_immutable).toVar();
  const octaves = int(octaves_immutable).toVar();
  const lacunarity = float(lacunarity_immutable).toVar();
  const diminish = float(diminish_immutable).toVar();
  const p3 = position.mul(freq).add(offset);
  const result2 = float(0).toVar();
  If(noiseType.equal(int(0)), () => {
    result2.assign(mx_perlin_noise_vec3(p3));
  });
  If(noiseType.equal(int(1)), () => {
    result2.assign(mx_cell_noise_vec3(p3));
  });
  If(noiseType.equal(int(2)), () => {
    result2.assign(mx_worley_noise_vec3$1(p3, jitter, int(0)));
  });
  If(noiseType.equal(int(3)), () => {
    result2.assign(mx_fractal_noise_vec3$1(p3, octaves, lacunarity, diminish));
  });
  result2.assign(result2.mul(outmax.sub(outmin)).add(outmin));
  If(clampoutput, () => {
    result2.assign(clamp3(result2, outmin, outmax));
  });
  return result2;
}).setLayout({
  name: "mx_unifiednoise3d",
  type: "float",
  inputs: [
    { name: "noiseType", type: "int" },
    { name: "position", type: "vec3" },
    { name: "freq", type: "vec3" },
    { name: "offset", type: "vec3" },
    { name: "jitter", type: "float" },
    { name: "outmin", type: "float" },
    { name: "outmax", type: "float" },
    { name: "clampoutput", type: "bool" },
    { name: "octaves", type: "int" },
    { name: "lacunarity", type: "float" },
    { name: "diminish", type: "float" }
  ]
});
var mx_hsvtorgb = Fn(([hsv]) => {
  const s2 = hsv.y;
  const v2 = hsv.z;
  const result2 = vec3().toVar();
  If(s2.lessThan(1e-4), () => {
    result2.assign(vec3(v2, v2, v2));
  }).Else(() => {
    let h2 = hsv.x;
    h2 = h2.sub(floor(h2)).mul(6).toVar();
    const hi = int(trunc(h2));
    const f3 = h2.sub(float(hi));
    const p3 = v2.mul(s2.oneMinus());
    const q2 = v2.mul(s2.mul(f3).oneMinus());
    const t5 = v2.mul(s2.mul(f3.oneMinus()).oneMinus());
    If(hi.equal(int(0)), () => {
      result2.assign(vec3(v2, t5, p3));
    }).ElseIf(hi.equal(int(1)), () => {
      result2.assign(vec3(q2, v2, p3));
    }).ElseIf(hi.equal(int(2)), () => {
      result2.assign(vec3(p3, v2, t5));
    }).ElseIf(hi.equal(int(3)), () => {
      result2.assign(vec3(p3, q2, v2));
    }).ElseIf(hi.equal(int(4)), () => {
      result2.assign(vec3(t5, p3, v2));
    }).Else(() => {
      result2.assign(vec3(v2, p3, q2));
    });
  });
  return result2;
}).setLayout({
  name: "mx_hsvtorgb",
  type: "vec3",
  inputs: [
    { name: "hsv", type: "vec3" }
  ]
});
var mx_rgbtohsv = Fn(([c_immutable]) => {
  const c5 = vec3(c_immutable).toVar();
  const r2 = float(c5.x).toVar();
  const g3 = float(c5.y).toVar();
  const b = float(c5.z).toVar();
  const mincomp = float(min$1(r2, min$1(g3, b))).toVar();
  const maxcomp = float(max$1(r2, max$1(g3, b))).toVar();
  const delta = float(maxcomp.sub(mincomp)).toVar();
  const h2 = float().toVar(), s2 = float().toVar(), v2 = float().toVar();
  v2.assign(maxcomp);
  If(maxcomp.greaterThan(0), () => {
    s2.assign(delta.div(maxcomp));
  }).Else(() => {
    s2.assign(0);
  });
  If(s2.lessThanEqual(0), () => {
    h2.assign(0);
  }).Else(() => {
    If(r2.greaterThanEqual(maxcomp), () => {
      h2.assign(g3.sub(b).div(delta));
    }).ElseIf(g3.greaterThanEqual(maxcomp), () => {
      h2.assign(add4(2, b.sub(r2).div(delta)));
    }).Else(() => {
      h2.assign(add4(4, r2.sub(g3).div(delta)));
    });
    h2.mulAssign(1 / 6);
    If(h2.lessThan(0), () => {
      h2.addAssign(1);
    });
  });
  return vec3(h2, s2, v2);
}).setLayout({
  name: "mx_rgbtohsv",
  type: "vec3",
  inputs: [
    { name: "c", type: "vec3" }
  ]
});
var mx_srgb_texture_to_lin_rec709 = Fn(([color_immutable]) => {
  const color3 = vec3(color_immutable).toVar();
  const isAbove = bvec3(greaterThan(color3, vec3(0.04045))).toVar();
  const linSeg = vec3(color3.div(12.92)).toVar();
  const powSeg = vec3(pow2(max$1(color3.add(vec3(0.055)), vec3(0)).div(1.055), vec3(2.4))).toVar();
  return mix2(linSeg, powSeg, isAbove);
}).setLayout({
  name: "mx_srgb_texture_to_lin_rec709",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" }
  ]
});
var mx_aastep = (threshold2, value) => {
  threshold2 = float(threshold2);
  value = float(value);
  const afwidth = vec2(value.dFdx(), value.dFdy()).length().mul(0.7071067811865476);
  return smoothstep2(threshold2.sub(afwidth), threshold2.add(afwidth), value);
};
var _ramp = (a3, b, uv2, p3) => mix2(a3, b, uv2[p3].clamp());
var mx_ramplr = (valuel, valuer, texcoord = uv$1()) => _ramp(valuel, valuer, texcoord, "x");
var mx_ramptb = (valuet, valueb, texcoord = uv$1()) => _ramp(valuet, valueb, texcoord, "y");
var mx_ramp4 = (valuetl, valuetr, valuebl, valuebr, texcoord = uv$1()) => {
  const u2 = texcoord.x.clamp();
  const v2 = texcoord.y.clamp();
  const top = mix2(valuetl, valuetr, u2);
  const bottom = mix2(valuebl, valuebr, u2);
  return mix2(top, bottom, v2);
};
var _split = (a3, b, center, uv2, p3) => mix2(a3, b, mx_aastep(center, uv2[p3]));
var mx_splitlr = (valuel, valuer, center, texcoord = uv$1()) => _split(valuel, valuer, center, texcoord, "x");
var mx_splittb = (valuet, valueb, center, texcoord = uv$1()) => _split(valuet, valueb, center, texcoord, "y");
var mx_transform_uv = (uv_scale = 1, uv_offset = 0, uv_geo = uv$1()) => uv_geo.mul(uv_scale).add(uv_offset);
var mx_safepower = (in1, in2 = 1) => {
  in1 = float(in1);
  return in1.abs().pow(in2).mul(in1.sign());
};
var mx_contrast = (input, amount = 1, pivot = 0.5) => float(input).sub(pivot).mul(amount).add(pivot);
var mx_noise_float = (texcoord = uv$1(), amplitude2 = 1, pivot = 0) => mx_perlin_noise_float(texcoord.convert("vec2|vec3")).mul(amplitude2).add(pivot);
var mx_noise_vec3 = (texcoord = uv$1(), amplitude2 = 1, pivot = 0) => mx_perlin_noise_vec3(texcoord.convert("vec2|vec3")).mul(amplitude2).add(pivot);
var mx_noise_vec4 = (texcoord = uv$1(), amplitude2 = 1, pivot = 0) => {
  texcoord = texcoord.convert("vec2|vec3");
  const noise_vec4 = vec4(mx_perlin_noise_vec3(texcoord), mx_perlin_noise_float(texcoord.add(vec2(19, 73))));
  return noise_vec4.mul(amplitude2).add(pivot);
};
var mx_unifiednoise2d = (noiseType, texcoord = uv$1(), freq = vec2(1, 1), offset = vec2(0, 0), jitter = 1, outmin = 0, outmax = 1, clampoutput = false, octaves = 1, lacunarity = 2, diminish = 0.5) => mx_unifiednoise2d$1(noiseType, texcoord.convert("vec2|vec3"), freq, offset, jitter, outmin, outmax, clampoutput, octaves, lacunarity, diminish);
var mx_unifiednoise3d = (noiseType, texcoord = uv$1(), freq = vec2(1, 1), offset = vec2(0, 0), jitter = 1, outmin = 0, outmax = 1, clampoutput = false, octaves = 1, lacunarity = 2, diminish = 0.5) => mx_unifiednoise3d$1(noiseType, texcoord.convert("vec2|vec3"), freq, offset, jitter, outmin, outmax, clampoutput, octaves, lacunarity, diminish);
var mx_worley_noise_float = (texcoord = uv$1(), jitter = 1) => mx_worley_noise_float$1(texcoord.convert("vec2|vec3"), jitter, int(1));
var mx_worley_noise_vec2 = (texcoord = uv$1(), jitter = 1) => mx_worley_noise_vec2$1(texcoord.convert("vec2|vec3"), jitter, int(1));
var mx_worley_noise_vec3 = (texcoord = uv$1(), jitter = 1) => mx_worley_noise_vec3$1(texcoord.convert("vec2|vec3"), jitter, int(1));
var mx_cell_noise_float = (texcoord = uv$1()) => mx_cell_noise_float$1(texcoord.convert("vec2|vec3"));
var mx_fractal_noise_float = (position = uv$1(), octaves = 3, lacunarity = 2, diminish = 0.5, amplitude2 = 1) => mx_fractal_noise_float$1(position, int(octaves), lacunarity, diminish).mul(amplitude2);
var mx_fractal_noise_vec2 = (position = uv$1(), octaves = 3, lacunarity = 2, diminish = 0.5, amplitude2 = 1) => mx_fractal_noise_vec2$1(position, int(octaves), lacunarity, diminish).mul(amplitude2);
var mx_fractal_noise_vec3 = (position = uv$1(), octaves = 3, lacunarity = 2, diminish = 0.5, amplitude2 = 1) => mx_fractal_noise_vec3$1(position, int(octaves), lacunarity, diminish).mul(amplitude2);
var mx_fractal_noise_vec4 = (position = uv$1(), octaves = 3, lacunarity = 2, diminish = 0.5, amplitude2 = 1) => mx_fractal_noise_vec4$1(position, int(octaves), lacunarity, diminish).mul(amplitude2);
var mx_add = (in1, in2 = float(0)) => add4(in1, in2);
var mx_subtract = (in1, in2 = float(0)) => sub(in1, in2);
var mx_multiply = (in1, in2 = float(1)) => mul(in1, in2);
var mx_divide = (in1, in2 = float(1)) => div(in1, in2);
var mx_modulo = (in1, in2 = float(1)) => mod(in1, in2);
var mx_power = (in1, in2 = float(1)) => pow2(in1, in2);
var mx_atan2 = (in1 = float(0), in2 = float(1)) => atan(in1, in2);
var mx_timer = () => time2;
var mx_frame = () => frameId;
var mx_invert = (in1, amount = float(1)) => sub(amount, in1);
var mx_ifgreater = (value1, value2, in1, in2) => value1.greaterThan(value2).mix(in1, in2);
var mx_ifgreatereq = (value1, value2, in1, in2) => value1.greaterThanEqual(value2).mix(in1, in2);
var mx_ifequal = (value1, value2, in1, in2) => value1.equal(value2).mix(in1, in2);
var mx_separate = (in1, channelOrOut = null) => {
  if (typeof channelOrOut === "string") {
    const map6 = { x: 0, r: 0, y: 1, g: 1, z: 2, b: 2, w: 3, a: 3 };
    const c5 = channelOrOut.replace(/^out/, "").toLowerCase();
    if (map6[c5] !== void 0) return in1.element(map6[c5]);
  }
  if (typeof channelOrOut === "number") {
    return in1.element(channelOrOut);
  }
  if (typeof channelOrOut === "string" && channelOrOut.length === 1) {
    const map6 = { x: 0, r: 0, y: 1, g: 1, z: 2, b: 2, w: 3, a: 3 };
    if (map6[channelOrOut] !== void 0) return in1.element(map6[channelOrOut]);
  }
  return in1;
};
var mx_place2d = (texcoord, pivot = vec2(0.5, 0.5), scale2 = vec2(1, 1), rotate2 = float(0), offset = vec2(0, 0)) => {
  let uv2 = texcoord;
  if (pivot) uv2 = uv2.sub(pivot);
  if (scale2) uv2 = uv2.mul(scale2);
  if (rotate2) {
    const rad = rotate2.mul(Math.PI / 180);
    const cosR = rad.cos();
    const sinR = rad.sin();
    uv2 = vec2(
      uv2.x.mul(cosR).sub(uv2.y.mul(sinR)),
      uv2.x.mul(sinR).add(uv2.y.mul(cosR))
    );
  }
  if (pivot) uv2 = uv2.add(pivot);
  if (offset) uv2 = uv2.add(offset);
  return uv2;
};
var mx_rotate2d = (input, amount) => {
  input = vec2(input);
  amount = float(amount);
  const radians4 = amount.mul(Math.PI / 180);
  return rotate(input, radians4);
};
var mx_rotate3d = (input, amount, axis) => {
  input = vec3(input);
  amount = float(amount);
  axis = vec3(axis);
  const radians4 = amount.mul(Math.PI / 180);
  const nAxis = axis.normalize();
  const cosA = radians4.cos();
  const sinA = radians4.sin();
  const oneMinusCosA = float(1).sub(cosA);
  const rot = input.mul(cosA).add(nAxis.cross(input).mul(sinA)).add(nAxis.mul(nAxis.dot(input)).mul(oneMinusCosA));
  return rot;
};
var mx_heighttonormal = (input, scale2) => {
  input = vec3(input);
  scale2 = float(scale2);
  return bumpMap(input, scale2);
};
var getParallaxCorrectNormal = Fn(([normal2, cubeSize, cubePos]) => {
  const nDir = normalize2(normal2).toVar();
  const rbmax = sub(float(0.5).mul(cubeSize.sub(cubePos)), positionWorld).div(nDir).toVar();
  const rbmin = sub(float(-0.5).mul(cubeSize.sub(cubePos)), positionWorld).div(nDir).toVar();
  const rbminmax = vec3().toVar();
  rbminmax.x = nDir.x.greaterThan(float(0)).select(rbmax.x, rbmin.x);
  rbminmax.y = nDir.y.greaterThan(float(0)).select(rbmax.y, rbmin.y);
  rbminmax.z = nDir.z.greaterThan(float(0)).select(rbmax.z, rbmin.z);
  const correction = min$1(rbminmax.x, rbminmax.y, rbminmax.z).toVar();
  const boxIntersection = positionWorld.add(nDir.mul(correction)).toVar();
  return boxIntersection.sub(cubePos);
});
var getShIrradianceAt = Fn(([normal2, shCoefficients]) => {
  const x3 = normal2.x, y3 = normal2.y, z3 = normal2.z;
  let result2 = shCoefficients.element(0).mul(0.886227);
  result2 = result2.add(shCoefficients.element(1).mul(2 * 0.511664).mul(y3));
  result2 = result2.add(shCoefficients.element(2).mul(2 * 0.511664).mul(z3));
  result2 = result2.add(shCoefficients.element(3).mul(2 * 0.511664).mul(x3));
  result2 = result2.add(shCoefficients.element(4).mul(2 * 0.429043).mul(x3).mul(y3));
  result2 = result2.add(shCoefficients.element(5).mul(2 * 0.429043).mul(y3).mul(z3));
  result2 = result2.add(shCoefficients.element(6).mul(z3.mul(z3).mul(0.743125).sub(0.247708)));
  result2 = result2.add(shCoefficients.element(7).mul(2 * 0.429043).mul(x3).mul(z3));
  result2 = result2.add(shCoefficients.element(8).mul(0.429043).mul(mul(x3, x3).sub(mul(y3, y3))));
  return result2;
});
var TSL = Object.freeze({
  __proto__: null,
  BRDF_GGX,
  BRDF_Lambert,
  BasicPointShadowFilter,
  BasicShadowFilter,
  Break,
  Const,
  Continue,
  DFGLUT,
  D_GGX,
  Discard,
  EPSILON,
  F_Schlick,
  Fn,
  HALF_PI,
  INFINITY,
  If,
  Loop,
  NodeAccess,
  NodeShaderStage,
  NodeType,
  NodeUpdateType,
  OnBeforeMaterialUpdate,
  OnBeforeObjectUpdate,
  OnMaterialUpdate,
  OnObjectUpdate,
  PCFShadowFilter,
  PCFSoftShadowFilter,
  PI,
  PI2,
  PointShadowFilter,
  Return,
  Schlick_to_F0,
  ScriptableNodeResources,
  ShaderNode,
  Stack,
  Switch,
  TBNViewMatrix,
  TWO_PI,
  VSMShadowFilter,
  V_GGX_SmithCorrelated,
  Var,
  VarIntent,
  abs,
  acesFilmicToneMapping,
  acos,
  add: add4,
  addMethodChaining,
  addNodeElement,
  agxToneMapping,
  all,
  alphaT,
  and,
  anisotropy,
  anisotropyB,
  anisotropyT,
  any,
  append: append2,
  array: array2,
  arrayBuffer,
  asin,
  assign,
  atan,
  atan2,
  atomicAdd,
  atomicAnd,
  atomicFunc,
  atomicLoad,
  atomicMax,
  atomicMin,
  atomicOr,
  atomicStore,
  atomicSub,
  atomicXor,
  attenuationColor,
  attenuationDistance,
  attribute,
  attributeArray,
  backgroundBlurriness,
  backgroundIntensity,
  backgroundRotation,
  batch,
  bentNormalView,
  billboarding,
  bitAnd,
  bitNot,
  bitOr,
  bitXor,
  bitangentGeometry,
  bitangentLocal,
  bitangentView,
  bitangentWorld,
  bitcast,
  blendBurn,
  blendColor,
  blendDodge,
  blendOverlay,
  blendScreen,
  blur: blur3,
  bool,
  buffer,
  bufferAttribute,
  builtin,
  builtinAOContext,
  builtinShadowContext,
  bumpMap,
  burn,
  bvec2,
  bvec3,
  bvec4,
  bypass,
  cache,
  call,
  cameraFar,
  cameraIndex,
  cameraNear,
  cameraNormalMatrix,
  cameraPosition,
  cameraProjectionMatrix,
  cameraProjectionMatrixInverse,
  cameraViewMatrix,
  cameraViewport,
  cameraWorldMatrix,
  cbrt,
  cdl,
  ceil,
  checker,
  cineonToneMapping,
  clamp: clamp3,
  clearcoat,
  clearcoatNormalView,
  clearcoatRoughness,
  code,
  color: color2,
  colorSpaceToWorking,
  colorToDirection,
  compute,
  computeKernel,
  computeSkinning,
  context,
  convert,
  convertColorSpace,
  convertToTexture,
  cos,
  countLeadingZeros,
  countOneBits,
  countTrailingZeros,
  cross: cross2,
  cubeTexture,
  cubeTextureBase,
  dFdx,
  dFdy,
  dashSize,
  debug,
  decrement,
  decrementBefore,
  defaultBuildStages,
  defaultShaderStages,
  defined,
  degrees: degrees4,
  deltaTime,
  densityFog,
  densityFogFactor,
  depth,
  depthPass,
  determinant,
  difference: difference2,
  diffuseColor,
  diffuseContribution,
  directPointLight,
  directionToColor,
  directionToFaceDirection,
  dispersion,
  disposeShadowMaterial,
  distance: distance3,
  div,
  dodge,
  dot,
  drawIndex,
  dynamicBufferAttribute,
  element,
  emissive,
  equal,
  equals: equals2,
  equirectUV,
  exp,
  exp2,
  expression,
  faceDirection,
  faceForward,
  faceforward,
  float,
  floatBitsToInt,
  floatBitsToUint,
  floor,
  fog,
  fract,
  frameGroup,
  frameId,
  frontFacing,
  fwidth,
  gain,
  gapSize,
  getConstNodeType,
  getCurrentStack,
  getDirection,
  getDistanceAttenuation,
  getGeometryRoughness,
  getNormalFromDepth,
  getParallaxCorrectNormal,
  getRoughness,
  getScreenPosition,
  getShIrradianceAt,
  getShadowMaterial,
  getShadowRenderObjectFunction,
  getTextureIndex,
  getViewPosition,
  ggxConvolution,
  globalId,
  glsl,
  glslFn,
  grayscale,
  greaterThan,
  greaterThanEqual,
  hash,
  highpModelNormalViewMatrix,
  highpModelViewMatrix,
  hue: hue2,
  increment,
  incrementBefore,
  inspector,
  instance,
  instanceIndex,
  instancedArray,
  instancedBufferAttribute,
  instancedDynamicBufferAttribute,
  instancedMesh,
  int,
  intBitsToFloat,
  interleavedGradientNoise,
  inverse,
  inverseSqrt,
  inversesqrt,
  invocationLocalIndex,
  invocationSubgroupIndex,
  ior,
  iridescence,
  iridescenceIOR,
  iridescenceThickness,
  isolate,
  ivec2,
  ivec3,
  ivec4,
  js,
  label,
  length,
  lengthSq,
  lessThan,
  lessThanEqual,
  lightPosition,
  lightProjectionUV,
  lightShadowMatrix,
  lightTargetDirection,
  lightTargetPosition,
  lightViewPosition,
  lightingContext,
  lights,
  linearDepth,
  linearToneMapping,
  localId,
  log: log3,
  log2: log22,
  logarithmicDepthToViewZ,
  luminance,
  mat2,
  mat3,
  mat4,
  matcapUV,
  materialAO,
  materialAlphaTest,
  materialAnisotropy,
  materialAnisotropyVector,
  materialAttenuationColor,
  materialAttenuationDistance,
  materialClearcoat,
  materialClearcoatNormal,
  materialClearcoatRoughness,
  materialColor,
  materialDispersion,
  materialEmissive,
  materialEnvIntensity,
  materialEnvRotation,
  materialIOR,
  materialIridescence,
  materialIridescenceIOR,
  materialIridescenceThickness,
  materialLightMap,
  materialLineDashOffset,
  materialLineDashSize,
  materialLineGapSize,
  materialLineScale,
  materialLineWidth,
  materialMetalness,
  materialNormal,
  materialOpacity,
  materialPointSize,
  materialReference,
  materialReflectivity,
  materialRefractionRatio,
  materialRotation,
  materialRoughness,
  materialSheen,
  materialSheenRoughness,
  materialShininess,
  materialSpecular,
  materialSpecularColor,
  materialSpecularIntensity,
  materialSpecularStrength,
  materialThickness,
  materialTransmission,
  max: max$1,
  maxMipLevel,
  mediumpModelViewMatrix,
  metalness,
  min: min$1,
  mix: mix2,
  mixElement,
  mod,
  modInt,
  modelDirection,
  modelNormalMatrix,
  modelPosition,
  modelRadius,
  modelScale,
  modelViewMatrix,
  modelViewPosition,
  modelViewProjection,
  modelWorldMatrix,
  modelWorldMatrixInverse,
  morphReference,
  mrt,
  mul,
  mx_aastep,
  mx_add,
  mx_atan2,
  mx_cell_noise_float,
  mx_contrast,
  mx_divide,
  mx_fractal_noise_float,
  mx_fractal_noise_vec2,
  mx_fractal_noise_vec3,
  mx_fractal_noise_vec4,
  mx_frame,
  mx_heighttonormal,
  mx_hsvtorgb,
  mx_ifequal,
  mx_ifgreater,
  mx_ifgreatereq,
  mx_invert,
  mx_modulo,
  mx_multiply,
  mx_noise_float,
  mx_noise_vec3,
  mx_noise_vec4,
  mx_place2d,
  mx_power,
  mx_ramp4,
  mx_ramplr,
  mx_ramptb,
  mx_rgbtohsv,
  mx_rotate2d,
  mx_rotate3d,
  mx_safepower,
  mx_separate,
  mx_splitlr,
  mx_splittb,
  mx_srgb_texture_to_lin_rec709,
  mx_subtract,
  mx_timer,
  mx_transform_uv,
  mx_unifiednoise2d,
  mx_unifiednoise3d,
  mx_worley_noise_float,
  mx_worley_noise_vec2,
  mx_worley_noise_vec3,
  negate,
  neutralToneMapping,
  nodeArray,
  nodeImmutable,
  nodeObject,
  nodeObjectIntent,
  nodeObjects,
  nodeProxy,
  nodeProxyIntent,
  normalFlat,
  normalGeometry,
  normalLocal,
  normalMap,
  normalView,
  normalViewGeometry,
  normalWorld,
  normalWorldGeometry,
  normalize: normalize2,
  not,
  notEqual,
  numWorkgroups,
  objectDirection,
  objectGroup,
  objectPosition,
  objectRadius,
  objectScale,
  objectViewPosition,
  objectWorldMatrix,
  oneMinus,
  or,
  orthographicDepthToViewZ,
  oscSawtooth,
  oscSine,
  oscSquare,
  oscTriangle,
  output,
  outputStruct,
  overlay,
  overloadingFn,
  packHalf2x16,
  packSnorm2x16,
  packUnorm2x16,
  parabola,
  parallaxDirection,
  parallaxUV,
  parameter,
  pass,
  passTexture,
  pcurve,
  perspectiveDepthToViewZ,
  pmremTexture,
  pointShadow,
  pointUV,
  pointWidth,
  positionGeometry,
  positionLocal,
  positionPrevious,
  positionView,
  positionViewDirection,
  positionWorld,
  positionWorldDirection,
  posterize,
  pow: pow2,
  pow2: pow22,
  pow3,
  pow4,
  premultiplyAlpha,
  property,
  quadBroadcast,
  quadSwapDiagonal,
  quadSwapX,
  quadSwapY,
  radians: radians3,
  rand,
  range: range2,
  rangeFog,
  rangeFogFactor,
  reciprocal,
  reference,
  referenceBuffer,
  reflect,
  reflectVector,
  reflectView,
  reflector,
  refract,
  refractVector,
  refractView,
  reinhardToneMapping,
  remap,
  remapClamp,
  renderGroup,
  renderOutput,
  rendererReference,
  replaceDefaultUV,
  rotate,
  rotateUV,
  roughness,
  round,
  rtt,
  sRGBTransferEOTF,
  sRGBTransferOETF,
  sample,
  sampler,
  samplerComparison,
  saturate: saturate3,
  saturation,
  screen,
  screenCoordinate,
  screenDPR,
  screenSize,
  screenUV,
  scriptable,
  scriptableValue,
  select,
  setCurrentStack,
  setName,
  shaderStages,
  shadow,
  shadowPositionWorld,
  shapeCircle,
  sharedUniformGroup,
  sheen,
  sheenRoughness,
  shiftLeft,
  shiftRight,
  shininess,
  sign: sign2,
  sin,
  sinc,
  skinning,
  smoothstep: smoothstep2,
  smoothstepElement,
  specularColor,
  specularColorBlended,
  specularF90,
  spherizeUV,
  split,
  spritesheetUV,
  sqrt: sqrt2,
  stack,
  step,
  stepElement,
  storage,
  storageBarrier,
  storageObject,
  storageTexture,
  string,
  struct,
  sub,
  subBuild,
  subgroupAdd,
  subgroupAll,
  subgroupAnd,
  subgroupAny,
  subgroupBallot,
  subgroupBroadcast,
  subgroupBroadcastFirst,
  subgroupElect,
  subgroupExclusiveAdd,
  subgroupExclusiveMul,
  subgroupInclusiveAdd,
  subgroupInclusiveMul,
  subgroupIndex,
  subgroupMax,
  subgroupMin,
  subgroupMul,
  subgroupOr,
  subgroupShuffle,
  subgroupShuffleDown,
  subgroupShuffleUp,
  subgroupShuffleXor,
  subgroupSize,
  subgroupXor,
  tan,
  tangentGeometry,
  tangentLocal,
  tangentView,
  tangentWorld,
  texture,
  texture3D,
  texture3DLevel,
  texture3DLoad,
  textureBarrier,
  textureBicubic,
  textureBicubicLevel,
  textureCubeUV,
  textureLevel,
  textureLoad,
  textureSize,
  textureStore,
  thickness,
  time: time2,
  toneMapping,
  toneMappingExposure,
  toonOutlinePass,
  transformDirection,
  transformNormal,
  transformNormalToView,
  transformedClearcoatNormalView,
  transformedNormalView,
  transformedNormalWorld,
  transmission,
  transpose: transpose2,
  triNoise3D,
  triplanarTexture,
  triplanarTextures,
  trunc,
  uint,
  uintBitsToFloat,
  uniform,
  uniformArray,
  uniformCubeTexture,
  uniformFlow,
  uniformGroup,
  uniformTexture,
  unpackHalf2x16,
  unpackNormal,
  unpackSnorm2x16,
  unpackUnorm2x16,
  unpremultiplyAlpha,
  userData,
  uv: uv$1,
  uvec2,
  uvec3,
  uvec4,
  varying,
  varyingProperty,
  vec2,
  vec3,
  vec4,
  vectorComponents,
  velocity,
  vertexColor,
  vertexIndex,
  vertexStage,
  vibrance,
  viewZToLogarithmicDepth,
  viewZToOrthographicDepth,
  viewZToPerspectiveDepth,
  viewport,
  viewportCoordinate,
  viewportDepthTexture,
  viewportLinearDepth,
  viewportMipTexture,
  viewportResolution,
  viewportSafeUV,
  viewportSharedTexture,
  viewportSize,
  viewportTexture,
  viewportUV,
  vogelDiskSample,
  wgsl,
  wgslFn,
  workgroupArray,
  workgroupBarrier,
  workgroupId,
  workingToColorSpace,
  xor
});
var _clearColor2 = new Color4();
var Background = class extends DataMap {
  /**
   * Constructs a new background management component.
   *
   * @param {Renderer} renderer - The renderer.
   * @param {Nodes} nodes - Renderer component for managing nodes related logic.
   */
  constructor(renderer3, nodes) {
    super();
    this.renderer = renderer3;
    this.nodes = nodes;
  }
  /**
   * Updates the background for the given scene. Depending on how `Scene.background`
   * or `Scene.backgroundNode` are configured, this method might configure a simple clear
   * or add a mesh to the render list for rendering the background as a textured plane
   * or skybox.
   *
   * @param {Scene} scene - The scene.
   * @param {RenderList} renderList - The current render list.
   * @param {RenderContext} renderContext - The current render context.
   */
  update(scene3, renderList, renderContext) {
    const renderer3 = this.renderer;
    const background = this.nodes.getBackgroundNode(scene3) || scene3.background;
    let forceClear = false;
    if (background === null) {
      renderer3._clearColor.getRGB(_clearColor2);
      _clearColor2.a = renderer3._clearColor.a;
    } else if (background.isColor === true) {
      background.getRGB(_clearColor2);
      _clearColor2.a = 1;
      forceClear = true;
    } else if (background.isNode === true) {
      const sceneData = this.get(scene3);
      const backgroundNode = background;
      _clearColor2.copy(renderer3._clearColor);
      let backgroundMesh = sceneData.backgroundMesh;
      if (backgroundMesh === void 0) {
        let onBackgroundDispose = function() {
          background.removeEventListener("dispose", onBackgroundDispose);
          backgroundMesh.material.dispose();
          backgroundMesh.geometry.dispose();
        };
        const backgroundMeshNode = vec4(backgroundNode).mul(backgroundIntensity).context({
          // @TODO: Add Texture2D support using node context
          getUV: () => backgroundRotation.mul(normalWorldGeometry),
          getTextureLevel: () => backgroundBlurriness
        });
        const isOrtho = cameraProjectionMatrix.element(3).element(3).equal(1);
        const orthoScale = div(1, cameraProjectionMatrix.element(1).element(1)).mul(3);
        const modifiedPosition = isOrtho.select(positionLocal.mul(orthoScale), positionLocal);
        let viewProj = cameraProjectionMatrix.mul(modelViewMatrix.mul(vec4(modifiedPosition, 0)));
        viewProj = viewProj.setZ(viewProj.w);
        const nodeMaterial = new NodeMaterial();
        nodeMaterial.name = "Background.material";
        nodeMaterial.side = BackSide;
        nodeMaterial.depthTest = false;
        nodeMaterial.depthWrite = false;
        nodeMaterial.allowOverride = false;
        nodeMaterial.fog = false;
        nodeMaterial.lights = false;
        nodeMaterial.vertexNode = viewProj;
        nodeMaterial.colorNode = backgroundMeshNode;
        sceneData.backgroundMeshNode = backgroundMeshNode;
        sceneData.backgroundMesh = backgroundMesh = new Mesh(new SphereGeometry(1, 32, 32), nodeMaterial);
        backgroundMesh.frustumCulled = false;
        backgroundMesh.name = "Background.mesh";
        background.addEventListener("dispose", onBackgroundDispose);
      }
      const backgroundCacheKey = backgroundNode.getCacheKey();
      if (sceneData.backgroundCacheKey !== backgroundCacheKey) {
        sceneData.backgroundMeshNode.node = vec4(backgroundNode).mul(backgroundIntensity);
        sceneData.backgroundMeshNode.needsUpdate = true;
        backgroundMesh.material.needsUpdate = true;
        sceneData.backgroundCacheKey = backgroundCacheKey;
      }
      renderList.unshift(backgroundMesh, backgroundMesh.geometry, backgroundMesh.material, 0, 0, null, null);
    } else {
      error("Renderer: Unsupported background configuration.", background);
    }
    const environmentBlendMode = renderer3.xr.getEnvironmentBlendMode();
    if (environmentBlendMode === "additive") {
      _clearColor2.set(0, 0, 0, 1);
    } else if (environmentBlendMode === "alpha-blend") {
      _clearColor2.set(0, 0, 0, 0);
    }
    if (renderer3.autoClear === true || forceClear === true) {
      const clearColorValue = renderContext.clearColorValue;
      clearColorValue.r = _clearColor2.r;
      clearColorValue.g = _clearColor2.g;
      clearColorValue.b = _clearColor2.b;
      clearColorValue.a = _clearColor2.a;
      if (renderer3.backend.isWebGLBackend === true || renderer3.alpha === true) {
        clearColorValue.r *= clearColorValue.a;
        clearColorValue.g *= clearColorValue.a;
        clearColorValue.b *= clearColorValue.a;
      }
      renderContext.depthClearValue = renderer3._clearDepth;
      renderContext.stencilClearValue = renderer3._clearStencil;
      renderContext.clearColor = renderer3.autoClearColor === true;
      renderContext.clearDepth = renderer3.autoClearDepth === true;
      renderContext.clearStencil = renderer3.autoClearStencil === true;
    } else {
      renderContext.clearColor = false;
      renderContext.clearDepth = false;
      renderContext.clearStencil = false;
    }
  }
};
var _id$7 = 0;
var BindGroup = class {
  /**
   * Constructs a new bind group.
   *
   * @param {string} name - The bind group's name.
   * @param {Array<Binding>} bindings - An array of bindings.
   * @param {number} index - The group index.
   * @param {Array<Binding>} bindingsReference - An array of reference bindings.
   */
  constructor(name = "", bindings = [], index8 = 0, bindingsReference = []) {
    this.name = name;
    this.bindings = bindings;
    this.index = index8;
    this.bindingsReference = bindingsReference;
    this.id = _id$7++;
  }
};
var NodeBuilderState = class {
  /**
   * Constructs a new node builder state.
   *
   * @param {string} vertexShader - The native vertex shader code.
   * @param {string} fragmentShader - The native fragment shader code.
   * @param {string} computeShader - The native compute shader code.
   * @param {Array<NodeAttribute>} nodeAttributes - An array of node attributes.
   * @param {Array<BindGroup>} bindings - An array of bind groups.
   * @param {Array<Node>} updateNodes - An array of nodes that implement their `update()` method.
   * @param {Array<Node>} updateBeforeNodes - An array of nodes that implement their `updateBefore()` method.
   * @param {Array<Node>} updateAfterNodes - An array of nodes that implement their `updateAfter()` method.
   * @param {NodeMaterialObserver} observer - A node material observer.
   * @param {Array<Object>} transforms - An array with transform attribute objects. Only relevant when using compute shaders with WebGL 2.
   */
  constructor(vertexShader, fragmentShader, computeShader, nodeAttributes, bindings, updateNodes, updateBeforeNodes, updateAfterNodes, observer, transforms = []) {
    this.vertexShader = vertexShader;
    this.fragmentShader = fragmentShader;
    this.computeShader = computeShader;
    this.transforms = transforms;
    this.nodeAttributes = nodeAttributes;
    this.bindings = bindings;
    this.updateNodes = updateNodes;
    this.updateBeforeNodes = updateBeforeNodes;
    this.updateAfterNodes = updateAfterNodes;
    this.observer = observer;
    this.usedTimes = 0;
  }
  /**
   * This method is used to create a array of bind groups based
   * on the existing bind groups of this state. Shared groups are
   * not cloned.
   *
   * @return {Array<BindGroup>} A array of bind groups.
   */
  createBindings() {
    const bindings = [];
    for (const instanceGroup of this.bindings) {
      const shared = instanceGroup.bindings[0].groupNode.shared;
      if (shared !== true) {
        const bindingsGroup = new BindGroup(instanceGroup.name, [], instanceGroup.index, instanceGroup.bindingsReference);
        bindings.push(bindingsGroup);
        for (const instanceBinding of instanceGroup.bindings) {
          bindingsGroup.bindings.push(instanceBinding.clone());
        }
      } else {
        bindings.push(instanceGroup);
      }
    }
    return bindings;
  }
};
var NodeAttribute = class {
  /**
   * Constructs a new node attribute.
   *
   * @param {string} name - The name of the attribute.
   * @param {string} type - The type of the attribute.
   * @param {?Node} node - An optional reference to the node.
   */
  constructor(name, type, node = null) {
    this.isNodeAttribute = true;
    this.name = name;
    this.type = type;
    this.node = node;
  }
};
var NodeUniform = class {
  /**
   * Constructs a new node uniform.
   *
   * @param {string} name - The name of the uniform.
   * @param {string} type - The type of the uniform.
   * @param {UniformNode} node - An reference to the node.
   */
  constructor(name, type, node) {
    this.isNodeUniform = true;
    this.name = name;
    this.type = type;
    this.node = node;
  }
  /**
   * The value of the uniform node.
   *
   * @type {any}
   */
  get value() {
    return this.node.value;
  }
  set value(val) {
    this.node.value = val;
  }
  /**
   * The id of the uniform node.
   *
   * @type {number}
   */
  get id() {
    return this.node.id;
  }
  /**
   * The uniform node's group.
   *
   * @type {UniformGroupNode}
   */
  get groupNode() {
    return this.node.groupNode;
  }
};
var NodeVar = class {
  /**
   * Constructs a new node variable.
   *
   * @param {string} name - The name of the variable.
   * @param {string} type - The type of the variable.
   * @param {boolean} [readOnly=false] - The read-only flag.
   * @param {?number} [count=null] - The size.
   */
  constructor(name, type, readOnly = false, count2 = null) {
    this.isNodeVar = true;
    this.name = name;
    this.type = type;
    this.readOnly = readOnly;
    this.count = count2;
  }
};
var NodeVarying = class extends NodeVar {
  /**
   * Constructs a new node varying.
   *
   * @param {string} name - The name of the varying.
   * @param {string} type - The type of the varying.
   * @param {?string} interpolationType - The interpolation type of the varying.
   * @param {?string} interpolationSampling - The interpolation sampling type of the varying.
   */
  constructor(name, type, interpolationType = null, interpolationSampling = null) {
    super(name, type);
    this.needsInterpolation = false;
    this.isNodeVarying = true;
    this.interpolationType = interpolationType;
    this.interpolationSampling = interpolationSampling;
  }
};
var NodeCode = class {
  /**
   * Constructs a new code node.
   *
   * @param {string} name - The name of the code.
   * @param {string} type - The node type.
   * @param {string} [code=''] - The native shader code.
   */
  constructor(name, type, code2 = "") {
    this.name = name;
    this.type = type;
    this.code = code2;
    Object.defineProperty(this, "isNodeCode", { value: true });
  }
};
var _id$6 = 0;
var NodeCache = class {
  /**
   * Constructs a new node cache.
   *
   * @param {?NodeCache} parent - A reference to a parent cache.
   */
  constructor(parent2 = null) {
    this.id = _id$6++;
    this.nodesData = /* @__PURE__ */ new WeakMap();
    this.parent = parent2;
  }
  /**
   * Returns the data for the given node.
   *
   * @param {Node} node - The node.
   * @return {?Object} The data for the node.
   */
  getData(node) {
    let data = this.nodesData.get(node);
    if (data === void 0 && this.parent !== null) {
      data = this.parent.getData(node);
    }
    return data;
  }
  /**
   * Sets the data for a given node.
   *
   * @param {Node} node - The node.
   * @param {Object} data - The data that should be cached.
   */
  setData(node, data) {
    this.nodesData.set(node, data);
  }
};
var StructType = class {
  constructor(name, members) {
    this.name = name;
    this.members = members;
    this.output = false;
  }
};
var Uniform2 = class {
  /**
   * Constructs a new uniform.
   *
   * @param {string} name - The uniform's name.
   * @param {any} value - The uniform's value.
   */
  constructor(name, value) {
    this.name = name;
    this.value = value;
    this.boundary = 0;
    this.itemSize = 0;
    this.offset = 0;
  }
  /**
   * Sets the uniform's value.
   *
   * @param {any} value - The value to set.
   */
  setValue(value) {
    this.value = value;
  }
  /**
   * Returns the uniform's value.
   *
   * @return {any} The value.
   */
  getValue() {
    return this.value;
  }
};
var NumberUniform = class extends Uniform2 {
  /**
   * Constructs a new Number uniform.
   *
   * @param {string} name - The uniform's name.
   * @param {number} value - The uniform's value.
   */
  constructor(name, value = 0) {
    super(name, value);
    this.isNumberUniform = true;
    this.boundary = 4;
    this.itemSize = 1;
  }
};
var Vector2Uniform = class extends Uniform2 {
  /**
   * Constructs a new Number uniform.
   *
   * @param {string} name - The uniform's name.
   * @param {Vector2} value - The uniform's value.
   */
  constructor(name, value = new Vector2()) {
    super(name, value);
    this.isVector2Uniform = true;
    this.boundary = 8;
    this.itemSize = 2;
  }
};
var Vector3Uniform = class extends Uniform2 {
  /**
   * Constructs a new Number uniform.
   *
   * @param {string} name - The uniform's name.
   * @param {Vector3} value - The uniform's value.
   */
  constructor(name, value = new Vector3()) {
    super(name, value);
    this.isVector3Uniform = true;
    this.boundary = 16;
    this.itemSize = 3;
  }
};
var Vector4Uniform = class extends Uniform2 {
  /**
   * Constructs a new Number uniform.
   *
   * @param {string} name - The uniform's name.
   * @param {Vector4} value - The uniform's value.
   */
  constructor(name, value = new Vector4()) {
    super(name, value);
    this.isVector4Uniform = true;
    this.boundary = 16;
    this.itemSize = 4;
  }
};
var ColorUniform = class extends Uniform2 {
  /**
   * Constructs a new Number uniform.
   *
   * @param {string} name - The uniform's name.
   * @param {Color} value - The uniform's value.
   */
  constructor(name, value = new Color()) {
    super(name, value);
    this.isColorUniform = true;
    this.boundary = 16;
    this.itemSize = 3;
  }
};
var Matrix2Uniform = class extends Uniform2 {
  /**
   * Constructs a new Number uniform.
   *
   * @param {string} name - The uniform's name.
   * @param {Matrix2} value - The uniform's value.
   */
  constructor(name, value = new Matrix2()) {
    super(name, value);
    this.isMatrix2Uniform = true;
    this.boundary = 8;
    this.itemSize = 4;
  }
};
var Matrix3Uniform = class extends Uniform2 {
  /**
   * Constructs a new Number uniform.
   *
   * @param {string} name - The uniform's name.
   * @param {Matrix3} value - The uniform's value.
   */
  constructor(name, value = new Matrix3()) {
    super(name, value);
    this.isMatrix3Uniform = true;
    this.boundary = 48;
    this.itemSize = 12;
  }
};
var Matrix4Uniform = class extends Uniform2 {
  /**
   * Constructs a new Number uniform.
   *
   * @param {string} name - The uniform's name.
   * @param {Matrix4} value - The uniform's value.
   */
  constructor(name, value = new Matrix4()) {
    super(name, value);
    this.isMatrix4Uniform = true;
    this.boundary = 64;
    this.itemSize = 16;
  }
};
var NumberNodeUniform = class extends NumberUniform {
  /**
   * Constructs a new node-based Number uniform.
   *
   * @param {NodeUniform} nodeUniform - The node uniform.
   */
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  /**
   * Overwritten to return the value of the node uniform.
   *
   * @return {number} The value.
   */
  getValue() {
    return this.nodeUniform.value;
  }
  /**
   * Returns the node uniform data type.
   *
   * @return {string} The data type.
   */
  getType() {
    return this.nodeUniform.type;
  }
};
var Vector2NodeUniform = class extends Vector2Uniform {
  /**
   * Constructs a new node-based Vector2 uniform.
   *
   * @param {NodeUniform} nodeUniform - The node uniform.
   */
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  /**
   * Overwritten to return the value of the node uniform.
   *
   * @return {Vector2} The value.
   */
  getValue() {
    return this.nodeUniform.value;
  }
  /**
   * Returns the node uniform data type.
   *
   * @return {string} The data type.
   */
  getType() {
    return this.nodeUniform.type;
  }
};
var Vector3NodeUniform = class extends Vector3Uniform {
  /**
   * Constructs a new node-based Vector3 uniform.
   *
   * @param {NodeUniform} nodeUniform - The node uniform.
   */
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  /**
   * Overwritten to return the value of the node uniform.
   *
   * @return {Vector3} The value.
   */
  getValue() {
    return this.nodeUniform.value;
  }
  /**
   * Returns the node uniform data type.
   *
   * @return {string} The data type.
   */
  getType() {
    return this.nodeUniform.type;
  }
};
var Vector4NodeUniform = class extends Vector4Uniform {
  /**
   * Constructs a new node-based Vector4 uniform.
   *
   * @param {NodeUniform} nodeUniform - The node uniform.
   */
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  /**
   * Overwritten to return the value of the node uniform.
   *
   * @return {Vector4} The value.
   */
  getValue() {
    return this.nodeUniform.value;
  }
  /**
   * Returns the node uniform data type.
   *
   * @return {string} The data type.
   */
  getType() {
    return this.nodeUniform.type;
  }
};
var ColorNodeUniform = class extends ColorUniform {
  /**
   * Constructs a new node-based Color uniform.
   *
   * @param {NodeUniform} nodeUniform - The node uniform.
   */
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  /**
   * Overwritten to return the value of the node uniform.
   *
   * @return {Color} The value.
   */
  getValue() {
    return this.nodeUniform.value;
  }
  /**
   * Returns the node uniform data type.
   *
   * @return {string} The data type.
   */
  getType() {
    return this.nodeUniform.type;
  }
};
var Matrix2NodeUniform = class extends Matrix2Uniform {
  /**
   * Constructs a new node-based Matrix2 uniform.
   *
   * @param {NodeUniform} nodeUniform - The node uniform.
   */
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  /**
   * Overwritten to return the value of the node uniform.
   *
   * @return {Matrix2} The value.
   */
  getValue() {
    return this.nodeUniform.value;
  }
  /**
   * Returns the node uniform data type.
   *
   * @return {string} The data type.
   */
  getType() {
    return this.nodeUniform.type;
  }
};
var Matrix3NodeUniform = class extends Matrix3Uniform {
  /**
   * Constructs a new node-based Matrix3 uniform.
   *
   * @param {NodeUniform} nodeUniform - The node uniform.
   */
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  /**
   * Overwritten to return the value of the node uniform.
   *
   * @return {Matrix3} The value.
   */
  getValue() {
    return this.nodeUniform.value;
  }
  /**
   * Returns the node uniform data type.
   *
   * @return {string} The data type.
   */
  getType() {
    return this.nodeUniform.type;
  }
};
var Matrix4NodeUniform = class extends Matrix4Uniform {
  /**
   * Constructs a new node-based Matrix4 uniform.
   *
   * @param {NodeUniform} nodeUniform - The node uniform.
   */
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  /**
   * Overwritten to return the value of the node uniform.
   *
   * @return {Matrix4} The value.
   */
  getValue() {
    return this.nodeUniform.value;
  }
  /**
   * Returns the node uniform data type.
   *
   * @return {string} The data type.
   */
  getType() {
    return this.nodeUniform.type;
  }
};
var _id$5 = 0;
var sharedNodeData = /* @__PURE__ */ new WeakMap();
var rendererCache = /* @__PURE__ */ new WeakMap();
var typeFromArray = /* @__PURE__ */ new Map([
  [Int8Array, "int"],
  [Int16Array, "int"],
  [Int32Array, "int"],
  [Uint8Array, "uint"],
  [Uint16Array, "uint"],
  [Uint32Array, "uint"],
  [Float32Array, "float"]
]);
var toFloat = (value) => {
  if (/e/g.test(value)) {
    return String(value).replace(/\+/g, "");
  } else {
    value = Number(value);
    return value + (value % 1 ? "" : ".0");
  }
};
var NodeBuilder = class {
  /**
   * Constructs a new node builder.
   *
   * @param {Object3D} object - The 3D object.
   * @param {Renderer} renderer - The current renderer.
   * @param {NodeParser} parser - A reference to a node parser.
   */
  constructor(object, renderer3, parser) {
    this.object = object;
    this.material = object && object.material || null;
    this.geometry = object && object.geometry || null;
    this.renderer = renderer3;
    this.parser = parser;
    this.scene = null;
    this.camera = null;
    this.nodes = [];
    this.sequentialNodes = [];
    this.updateNodes = [];
    this.updateBeforeNodes = [];
    this.updateAfterNodes = [];
    this.hashNodes = {};
    this.observer = null;
    this.lightsNode = null;
    this.environmentNode = null;
    this.fogNode = null;
    this.clippingContext = null;
    this.vertexShader = null;
    this.fragmentShader = null;
    this.computeShader = null;
    this.flowNodes = { vertex: [], fragment: [], compute: [] };
    this.flowCode = { vertex: "", fragment: "", compute: "" };
    this.uniforms = { vertex: [], fragment: [], compute: [], index: 0 };
    this.structs = { vertex: [], fragment: [], compute: [], index: 0 };
    this.types = { vertex: [], fragment: [], compute: [], index: 0 };
    this.bindings = { vertex: {}, fragment: {}, compute: {} };
    this.bindingsIndexes = {};
    this.bindGroups = null;
    this.attributes = [];
    this.bufferAttributes = [];
    this.varyings = [];
    this.codes = {};
    this.vars = {};
    this.declarations = {};
    this.flow = { code: "" };
    this.chaining = [];
    this.stack = stack();
    this.stacks = [];
    this.tab = "	";
    this.currentFunctionNode = null;
    this.context = {
      material: this.material
    };
    this.cache = new NodeCache();
    this.globalCache = this.cache;
    this.flowsData = /* @__PURE__ */ new WeakMap();
    this.shaderStage = null;
    this.buildStage = null;
    this.subBuildLayers = [];
    this.activeStacks = [];
    this.subBuildFn = null;
    this.fnCall = null;
    Object.defineProperty(this, "id", { value: _id$5++ });
  }
  /**
   * Whether the material is opaque or not.
   *
   * @return {boolean} Whether the material is opaque or not.
   */
  isOpaque() {
    const material = this.material;
    return material.transparent === false && material.blending === NormalBlending && material.alphaToCoverage === false;
  }
  /**
   * Returns the bind groups of the current renderer.
   *
   * @return {ChainMap} The cache.
   */
  getBindGroupsCache() {
    let bindGroupsCache = rendererCache.get(this.renderer);
    if (bindGroupsCache === void 0) {
      bindGroupsCache = new ChainMap();
      rendererCache.set(this.renderer, bindGroupsCache);
    }
    return bindGroupsCache;
  }
  /**
   * Factory method for creating an instance of {@link RenderTarget} with the given
   * dimensions and options.
   *
   * @param {number} width - The width of the render target.
   * @param {number} height - The height of the render target.
   * @param {Object} options - The options of the render target.
   * @return {RenderTarget} The render target.
   */
  createRenderTarget(width, height, options) {
    return new RenderTarget(width, height, options);
  }
  /**
   * Factory method for creating an instance of {@link CubeRenderTarget} with the given
   * dimensions and options.
   *
   * @param {number} size - The size of the cube render target.
   * @param {Object} options - The options of the cube render target.
   * @return {CubeRenderTarget} The cube render target.
   */
  createCubeRenderTarget(size2, options) {
    return new CubeRenderTarget(size2, options);
  }
  /**
   * Whether the given node is included in the internal array of nodes or not.
   *
   * @param {Node} node - The node to test.
   * @return {boolean} Whether the given node is included in the internal array of nodes or not.
   */
  includes(node) {
    return this.nodes.includes(node);
  }
  /**
   * Returns the output struct name which is required by
   * {@link OutputStructNode}.
   *
   * @abstract
   * @return {string} The name of the output struct.
   */
  getOutputStructName() {
  }
  /**
   * Returns a bind group for the given group name and binding.
   *
   * @private
   * @param {string} groupName - The group name.
   * @param {Array<NodeUniformsGroup>} bindings - List of bindings.
   * @return {BindGroup} The bind group
   */
  _getBindGroup(groupName, bindings) {
    const bindGroupsCache = this.getBindGroupsCache();
    const bindingsArray = [];
    let sharedGroup = true;
    for (const binding of bindings) {
      bindingsArray.push(binding);
      sharedGroup = sharedGroup && binding.groupNode.shared !== true;
    }
    let bindGroup;
    if (sharedGroup) {
      bindGroup = bindGroupsCache.get(bindingsArray);
      if (bindGroup === void 0) {
        bindGroup = new BindGroup(groupName, bindingsArray, this.bindingsIndexes[groupName].group, bindingsArray);
        bindGroupsCache.set(bindingsArray, bindGroup);
      }
    } else {
      bindGroup = new BindGroup(groupName, bindingsArray, this.bindingsIndexes[groupName].group, bindingsArray);
    }
    return bindGroup;
  }
  /**
   * Returns an array of node uniform groups for the given group name and shader stage.
   *
   * @param {string} groupName - The group name.
   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
   * @return {Array<NodeUniformsGroup>} The array of node uniform groups.
   */
  getBindGroupArray(groupName, shaderStage) {
    const bindings = this.bindings[shaderStage];
    let bindGroup = bindings[groupName];
    if (bindGroup === void 0) {
      if (this.bindingsIndexes[groupName] === void 0) {
        this.bindingsIndexes[groupName] = { binding: 0, group: Object.keys(this.bindingsIndexes).length };
      }
      bindings[groupName] = bindGroup = [];
    }
    return bindGroup;
  }
  /**
   * Returns a list bindings of all shader stages separated by groups.
   *
   * @return {Array<BindGroup>} The list of bindings.
   */
  getBindings() {
    let bindingsGroups = this.bindGroups;
    if (bindingsGroups === null) {
      const groups2 = {};
      const bindings = this.bindings;
      for (const shaderStage of shaderStages) {
        for (const groupName in bindings[shaderStage]) {
          const uniforms = bindings[shaderStage][groupName];
          const groupUniforms = groups2[groupName] || (groups2[groupName] = []);
          groupUniforms.push(...uniforms);
        }
      }
      bindingsGroups = [];
      for (const groupName in groups2) {
        const group2 = groups2[groupName];
        const bindingsGroup = this._getBindGroup(groupName, group2);
        bindingsGroups.push(bindingsGroup);
      }
      this.bindGroups = bindingsGroups;
    }
    return bindingsGroups;
  }
  /**
   * Sorts the bind groups and updates {@link NodeBuilder#bindingsIndexes}.
   */
  sortBindingGroups() {
    const bindingsGroups = this.getBindings();
    bindingsGroups.sort((a3, b) => a3.bindings[0].groupNode.order - b.bindings[0].groupNode.order);
    for (let i2 = 0; i2 < bindingsGroups.length; i2++) {
      const bindingGroup = bindingsGroups[i2];
      this.bindingsIndexes[bindingGroup.name].group = i2;
      bindingGroup.index = i2;
    }
  }
  /**
   * The builder maintains each node in a hash-based dictionary.
   * This method sets the given node (value) with the given hash (key) into this dictionary.
   *
   * @param {Node} node - The node to add.
   * @param {number} hash - The hash of the node.
   */
  setHashNode(node, hash2) {
    this.hashNodes[hash2] = node;
  }
  /**
   * Adds a node to this builder.
   *
   * @param {Node} node - The node to add.
   */
  addNode(node) {
    if (this.nodes.includes(node) === false) {
      this.nodes.push(node);
      this.setHashNode(node, node.getHash(this));
    }
  }
  /**
   * It is used to add Nodes that will be used as FRAME and RENDER events,
   * and need to follow a certain sequence in the calls to work correctly.
   * This function should be called after 'setup()' in the 'build()' process to ensure that the child nodes are processed first.
   *
   * @param {Node} node - The node to add.
   */
  addSequentialNode(node) {
    if (this.sequentialNodes.includes(node) === false) {
      this.sequentialNodes.push(node);
    }
  }
  /**
   * Checks the update types of nodes
   */
  buildUpdateNodes() {
    for (const node of this.nodes) {
      const updateType = node.getUpdateType();
      if (updateType !== NodeUpdateType.NONE) {
        this.updateNodes.push(node);
      }
    }
    for (const node of this.sequentialNodes) {
      const updateBeforeType = node.getUpdateBeforeType();
      const updateAfterType = node.getUpdateAfterType();
      if (updateBeforeType !== NodeUpdateType.NONE) {
        this.updateBeforeNodes.push(node);
      }
      if (updateAfterType !== NodeUpdateType.NONE) {
        this.updateAfterNodes.push(node);
      }
    }
  }
  /**
   * A reference the current node which is the
   * last node in the chain of nodes.
   *
   * @type {Node}
   */
  get currentNode() {
    return this.chaining[this.chaining.length - 1];
  }
  /**
   * Whether the given texture is filtered or not.
   *
   * @param {Texture} texture - The texture to check.
   * @return {boolean} Whether the given texture is filtered or not.
   */
  isFilteredTexture(texture2) {
    return texture2.magFilter === LinearFilter || texture2.magFilter === LinearMipmapNearestFilter || texture2.magFilter === NearestMipmapLinearFilter || texture2.magFilter === LinearMipmapLinearFilter || texture2.minFilter === LinearFilter || texture2.minFilter === LinearMipmapNearestFilter || texture2.minFilter === NearestMipmapLinearFilter || texture2.minFilter === LinearMipmapLinearFilter;
  }
  /**
   * Adds the given node to the internal node chain.
   * This is used to check recursive calls in node-graph.
   *
   * @param {Node} node - The node to add.
   */
  addChain(node) {
    this.chaining.push(node);
  }
  /**
   * Removes the given node from the internal node chain.
   *
   * @param {Node} node - The node to remove.
   */
  removeChain(node) {
    const lastChain = this.chaining.pop();
    if (lastChain !== node) {
      throw new Error("NodeBuilder: Invalid node chaining!");
    }
  }
  /**
   * Returns the native shader method name for a given generic name. E.g.
   * the method name `textureDimensions` matches the WGSL name but must be
   * resolved to `textureSize` in GLSL.
   *
   * @abstract
   * @param {string} method - The method name to resolve.
   * @return {string} The resolved method name.
   */
  getMethod(method2) {
    return method2;
  }
  /**
   * Returns the native snippet for a ternary operation. E.g. GLSL would output
   * a ternary op as `cond ? x : y` whereas WGSL would output it as `select(y, x, cond)`
   *
   * @abstract
   * @param {string} condSnippet - The condition determining which expression gets resolved.
   * @param {string} ifSnippet - The expression to resolve to if the condition is true.
   * @param {string} elseSnippet - The expression to resolve to if the condition is false.
   * @return {string} The resolved method name.
   */
  getTernary() {
    return null;
  }
  /**
   * Returns a node for the given hash, see {@link NodeBuilder#setHashNode}.
   *
   * @param {number} hash - The hash of the node.
   * @return {Node} The found node.
   */
  getNodeFromHash(hash2) {
    return this.hashNodes[hash2];
  }
  /**
   * Adds the Node to a target flow so that it can generate code in the 'generate' process.
   *
   * @param {('vertex'|'fragment'|'compute')} shaderStage - The shader stage.
   * @param {Node} node - The node to add.
   * @return {Node} The node.
   */
  addFlow(shaderStage, node) {
    this.flowNodes[shaderStage].push(node);
    return node;
  }
  /**
   * Sets builder's context.
   *
   * @param {Object} context - The context to set.
   */
  setContext(context2) {
    this.context = context2;
  }
  /**
   * Returns the builder's current context.
   *
   * @return {Object} The builder's current context.
   */
  getContext() {
    return this.context;
  }
  /**
   * Adds context data to the builder's current context.
   *
   * @param {Object} context - The context to add.
   * @return {Object} The previous context.
   */
  addContext(context2) {
    const previousContext = this.getContext();
    this.setContext({ ...this.context, ...context2 });
    return previousContext;
  }
  /**
   * Gets a context used in shader construction that can be shared across different materials.
   * This is necessary since the renderer cache can reuse shaders generated in one material and use them in another.
   *
   * @return {Object} The builder's current context without material.
   */
  getSharedContext() {
    const context2 = { ...this.context };
    delete context2.material;
    delete context2.getUV;
    delete context2.getOutput;
    delete context2.getTextureLevel;
    delete context2.getAO;
    delete context2.getShadow;
    return context2;
  }
  /**
   * Sets builder's cache.
   *
   * @param {NodeCache} cache - The cache to set.
   */
  setCache(cache2) {
    this.cache = cache2;
  }
  /**
   * Returns the builder's current cache.
   *
   * @return {NodeCache} The builder's current cache.
   */
  getCache() {
    return this.cache;
  }
  /**
   * Returns a cache for the given node.
   *
   * @param {Node} node - The node.
   * @param {boolean} [parent=true] - Whether this node refers to a shared parent cache or not.
   * @return {NodeCache} The cache.
   */
  getCacheFromNode(node, parent2 = true) {
    const data = this.getDataFromNode(node);
    if (data.cache === void 0) data.cache = new NodeCache(parent2 ? this.getCache() : null);
    return data.cache;
  }
  /**
   * Whether the requested feature is available or not.
   *
   * @abstract
   * @param {string} name - The requested feature.
   * @return {boolean} Whether the requested feature is supported or not.
   */
  isAvailable() {
    return false;
  }
  /**
   * Returns the vertexIndex input variable as a native shader string.
   *
   * @abstract
   * @return {string} The instanceIndex shader string.
   */
  getVertexIndex() {
    warn("Abstract function.");
  }
  /**
   * Contextually returns either the vertex stage instance index builtin
   * or the linearized index of an compute invocation within a grid of workgroups.
   *
   * @abstract
   * @return {string} The instanceIndex shader string.
   */
  getInstanceIndex() {
    warn("Abstract function.");
  }
  /**
   * Returns the drawIndex input variable as a native shader string.
   * Only relevant for WebGL and its `WEBGL_multi_draw` extension.
   *
   * @abstract
   * @return {?string} The drawIndex shader string.
   */
  getDrawIndex() {
    warn("Abstract function.");
  }
  /**
   * Returns the frontFacing input variable as a native shader string.
   *
   * @abstract
   * @return {string} The frontFacing shader string.
   */
  getFrontFacing() {
    warn("Abstract function.");
  }
  /**
   * Returns the fragCoord input variable as a native shader string.
   *
   * @abstract
   * @return {string} The fragCoord shader string.
   */
  getFragCoord() {
    warn("Abstract function.");
  }
  /**
   * Whether to flip texture data along its vertical axis or not. WebGL needs
   * this method evaluate to `true`, WebGPU to `false`.
   *
   * @abstract
   * @return {boolean} Whether to flip texture data along its vertical axis or not.
   */
  isFlipY() {
    return false;
  }
  /**
   * Calling this method increases the usage count for the given node by one.
   *
   * @param {Node} node - The node to increase the usage count for.
   * @return {number} The updated usage count.
   */
  increaseUsage(node) {
    const nodeData = this.getDataFromNode(node);
    nodeData.usageCount = nodeData.usageCount === void 0 ? 1 : nodeData.usageCount + 1;
    return nodeData.usageCount;
  }
  /**
   * Generates a texture sample shader string for the given texture data.
   *
   * @abstract
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The texture property name.
   * @param {string} uvSnippet - Snippet defining the texture coordinates.
   * @return {string} The generated shader string.
   */
  generateTexture() {
    warn("Abstract function.");
  }
  /**
   * Generates a texture LOD shader string for the given texture data.
   *
   * @abstract
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The texture property name.
   * @param {string} uvSnippet - Snippet defining the texture coordinates.
   * @param {?string} depthSnippet - Snippet defining the 0-based texture array index to sample.
   * @param {string} levelSnippet - Snippet defining the mip level.
   * @return {string} The generated shader string.
   */
  generateTextureLod() {
    warn("Abstract function.");
  }
  /**
   * Generates the array declaration string.
   *
   * @param {string} type - The type.
   * @param {?number} [count] - The count.
   * @return {string} The generated value as a shader string.
   */
  generateArrayDeclaration(type, count2) {
    return this.getType(type) + "[ " + count2 + " ]";
  }
  /**
   * Generates the array shader string for the given type and value.
   *
   * @param {string} type - The type.
   * @param {?number} [count] - The count.
   * @param {?Array<Node>} [values=null] - The default values.
   * @return {string} The generated value as a shader string.
   */
  generateArray(type, count2, values2 = null) {
    let snippet = this.generateArrayDeclaration(type, count2) + "( ";
    for (let i2 = 0; i2 < count2; i2++) {
      const value = values2 ? values2[i2] : null;
      if (value !== null) {
        snippet += value.build(this, type);
      } else {
        snippet += this.generateConst(type);
      }
      if (i2 < count2 - 1) snippet += ", ";
    }
    snippet += " )";
    return snippet;
  }
  /**
   * Generates the struct shader string.
   *
   * @param {string} type - The type.
   * @param {Array<Object>} [membersLayout] - The count.
   * @param {?Array<Node>} [values=null] - The default values.
   * @return {string} The generated value as a shader string.
   */
  generateStruct(type, membersLayout, values2 = null) {
    const snippets = [];
    for (const member of membersLayout) {
      const { name, type: type2 } = member;
      if (values2 && values2[name] && values2[name].isNode) {
        snippets.push(values2[name].build(this, type2));
      } else {
        snippets.push(this.generateConst(type2));
      }
    }
    return type + "( " + snippets.join(", ") + " )";
  }
  /**
   * Generates the shader string for the given type and value.
   *
   * @param {string} type - The type.
   * @param {?any} [value=null] - The value.
   * @return {string} The generated value as a shader string.
   */
  generateConst(type, value = null) {
    if (value === null) {
      if (type === "float" || type === "int" || type === "uint") value = 0;
      else if (type === "bool") value = false;
      else if (type === "color") value = new Color();
      else if (type === "vec2" || type === "uvec2" || type === "ivec2") value = new Vector2();
      else if (type === "vec3" || type === "uvec3" || type === "ivec3") value = new Vector3();
      else if (type === "vec4" || type === "uvec4" || type === "ivec4") value = new Vector4();
    }
    if (type === "float") return toFloat(value);
    if (type === "int") return `${Math.round(value)}`;
    if (type === "uint") return value >= 0 ? `${Math.round(value)}u` : "0u";
    if (type === "bool") return value ? "true" : "false";
    if (type === "color") return `${this.getType("vec3")}( ${toFloat(value.r)}, ${toFloat(value.g)}, ${toFloat(value.b)} )`;
    const typeLength = this.getTypeLength(type);
    const componentType = this.getComponentType(type);
    const generateConst = (value2) => this.generateConst(componentType, value2);
    if (typeLength === 2) {
      return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)} )`;
    } else if (typeLength === 3) {
      return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)}, ${generateConst(value.z)} )`;
    } else if (typeLength === 4 && type !== "mat2") {
      return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)}, ${generateConst(value.z)}, ${generateConst(value.w)} )`;
    } else if (typeLength >= 4 && value && (value.isMatrix2 || value.isMatrix3 || value.isMatrix4)) {
      return `${this.getType(type)}( ${value.elements.map(generateConst).join(", ")} )`;
    } else if (typeLength > 4) {
      return `${this.getType(type)}()`;
    }
    throw new Error(`NodeBuilder: Type '${type}' not found in generate constant attempt.`);
  }
  /**
   * It might be necessary to convert certain data types to different ones
   * so this method can be used to hide the conversion.
   *
   * @param {string} type - The type.
   * @return {string} The updated type.
   */
  getType(type) {
    if (type === "color") return "vec3";
    return type;
  }
  /**
   * Whether the given attribute name is defined in the geometry or not.
   *
   * @param {string} name - The attribute name.
   * @return {boolean} Whether the given attribute name is defined in the geometry.
   */
  hasGeometryAttribute(name) {
    return this.geometry && this.geometry.getAttribute(name) !== void 0;
  }
  /**
   * Returns a node attribute for the given name and type.
   *
   * @param {string} name - The attribute's name.
   * @param {string} type - The attribute's type.
   * @return {NodeAttribute} The node attribute.
   */
  getAttribute(name, type) {
    const attributes = this.attributes;
    for (const attribute3 of attributes) {
      if (attribute3.name === name) {
        return attribute3;
      }
    }
    const attribute2 = new NodeAttribute(name, type);
    this.registerDeclaration(attribute2);
    attributes.push(attribute2);
    return attribute2;
  }
  /**
   * Returns for the given node and shader stage the property name for the shader.
   *
   * @param {Node} node - The node.
   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
   * @return {string} The property name.
   */
  getPropertyName(node) {
    return node.name;
  }
  /**
   * Whether the given type is a vector type or not.
   *
   * @param {string} type - The type to check.
   * @return {boolean} Whether the given type is a vector type or not.
   */
  isVector(type) {
    return /vec\d/.test(type);
  }
  /**
   * Whether the given type is a matrix type or not.
   *
   * @param {string} type - The type to check.
   * @return {boolean} Whether the given type is a matrix type or not.
   */
  isMatrix(type) {
    return /mat\d/.test(type);
  }
  /**
   * Whether the given type is a reference type or not.
   *
   * @param {string} type - The type to check.
   * @return {boolean} Whether the given type is a reference type or not.
   */
  isReference(type) {
    return type === "void" || type === "property" || type === "sampler" || type === "samplerComparison" || type === "texture" || type === "cubeTexture" || type === "storageTexture" || type === "depthTexture" || type === "texture3D";
  }
  /**
   * Checks if the given texture requires a manual conversion to the working color space.
   *
   * @abstract
   * @param {Texture} texture - The texture to check.
   * @return {boolean} Whether the given texture requires a conversion to working color space or not.
   */
  needsToWorkingColorSpace() {
    return false;
  }
  /**
   * Returns the component type of a given texture.
   *
   * @param {Texture} texture - The texture.
   * @return {string} The component type.
   */
  getComponentTypeFromTexture(texture2) {
    const type = texture2.type;
    if (texture2.isDataTexture) {
      if (type === IntType) return "int";
      if (type === UnsignedIntType) return "uint";
    }
    return "float";
  }
  /**
   * Returns the element type for a given type.
   *
   * @param {string} type - The type.
   * @return {string} The element type.
   */
  getElementType(type) {
    if (type === "mat2") return "vec2";
    if (type === "mat3") return "vec3";
    if (type === "mat4") return "vec4";
    return this.getComponentType(type);
  }
  /**
   * Returns the component type for a given type.
   *
   * @param {string} type - The type.
   * @return {string} The component type.
   */
  getComponentType(type) {
    type = this.getVectorType(type);
    if (type === "float" || type === "bool" || type === "int" || type === "uint") return type;
    const componentType = /(b|i|u|)(vec|mat)([2-4])/.exec(type);
    if (componentType === null) return null;
    if (componentType[1] === "b") return "bool";
    if (componentType[1] === "i") return "int";
    if (componentType[1] === "u") return "uint";
    return "float";
  }
  /**
   * Returns the vector type for a given type.
   *
   * @param {string} type - The type.
   * @return {string} The vector type.
   */
  getVectorType(type) {
    if (type === "color") return "vec3";
    if (type === "texture" || type === "cubeTexture" || type === "storageTexture" || type === "texture3D") return "vec4";
    return type;
  }
  /**
   * Returns the data type for the given the length and component type.
   *
   * @param {number} length - The length.
   * @param {string} [componentType='float'] - The component type.
   * @return {string} The type.
   */
  getTypeFromLength(length2, componentType = "float") {
    if (length2 === 1) return componentType;
    let baseType = getTypeFromLength(length2);
    const prefix = componentType === "float" ? "" : componentType[0];
    if (/mat2/.test(componentType) === true) {
      baseType = baseType.replace("vec", "mat");
    }
    return prefix + baseType;
  }
  /**
   * Returns the type for a given typed array.
   *
   * @param {TypedArray} array - The typed array.
   * @return {string} The type.
   */
  getTypeFromArray(array4) {
    return typeFromArray.get(array4.constructor);
  }
  /**
   * Returns the type is an integer type.
   *
   * @param {string} type - The type.
   * @return {boolean} Whether the type is an integer type or not.
   */
  isInteger(type) {
    return /int|uint|(i|u)vec/.test(type);
  }
  /**
   * Returns the type for a given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   * @return {string} The type.
   */
  getTypeFromAttribute(attribute2) {
    let dataAttribute = attribute2;
    if (attribute2.isInterleavedBufferAttribute) dataAttribute = attribute2.data;
    const array4 = dataAttribute.array;
    const itemSize = attribute2.itemSize;
    const normalized = attribute2.normalized;
    let arrayType;
    if (!(attribute2 instanceof Float16BufferAttribute) && normalized !== true) {
      arrayType = this.getTypeFromArray(array4);
    }
    return this.getTypeFromLength(itemSize, arrayType);
  }
  /**
   * Returns the length for the given data type.
   *
   * @param {string} type - The data type.
   * @return {number} The length.
   */
  getTypeLength(type) {
    const vecType = this.getVectorType(type);
    const vecNum = /vec([2-4])/.exec(vecType);
    if (vecNum !== null) return Number(vecNum[1]);
    if (vecType === "float" || vecType === "bool" || vecType === "int" || vecType === "uint") return 1;
    if (/mat2/.test(type) === true) return 4;
    if (/mat3/.test(type) === true) return 9;
    if (/mat4/.test(type) === true) return 16;
    return 0;
  }
  /**
   * Returns the vector type for a given matrix type.
   *
   * @param {string} type - The matrix type.
   * @return {string} The vector type.
   */
  getVectorFromMatrix(type) {
    return type.replace("mat", "vec");
  }
  /**
   * For a given type this method changes the component type to the
   * given value. E.g. `vec4` should be changed to the new component type
   * `uint` which results in `uvec4`.
   *
   * @param {string} type - The type.
   * @param {string} newComponentType - The new component type.
   * @return {string} The new type.
   */
  changeComponentType(type, newComponentType) {
    return this.getTypeFromLength(this.getTypeLength(type), newComponentType);
  }
  /**
   * Returns the integer type pendant for the given type.
   *
   * @param {string} type - The type.
   * @return {string} The integer type.
   */
  getIntegerType(type) {
    const componentType = this.getComponentType(type);
    if (componentType === "int" || componentType === "uint") return type;
    return this.changeComponentType(type, "int");
  }
  /**
   * Adds an active stack to the internal stack.
   *
   * @param {StackNode} stack - The stack node to add.
   */
  setActiveStack(stack2) {
    this.activeStacks.push(stack2);
  }
  /**
   * Removes the active stack from the internal stack.
   *
   * @param {StackNode} stack - The stack node to remove.
   */
  removeActiveStack(stack2) {
    if (this.activeStacks[this.activeStacks.length - 1] === stack2) {
      this.activeStacks.pop();
    } else {
      throw new Error("NodeBuilder: Invalid active stack removal.");
    }
  }
  /**
   * Returns the active stack.
   *
   * @return {StackNode} The active stack.
   */
  getActiveStack() {
    return this.activeStacks[this.activeStacks.length - 1];
  }
  /**
   * Returns the base stack.
   *
   * @return {StackNode} The base stack.
   */
  getBaseStack() {
    return this.activeStacks[0];
  }
  /**
   * Adds a stack node to the internal stack.
   *
   * @return {StackNode} The added stack node.
   */
  addStack() {
    this.stack = stack(this.stack);
    const previousStack = getCurrentStack();
    this.stacks.push(previousStack);
    setCurrentStack(this.stack);
    return this.stack;
  }
  /**
   * Removes the last stack node from the internal stack.
   *
   * @return {StackNode} The removed stack node.
   */
  removeStack() {
    const lastStack = this.stack;
    for (const node of lastStack.nodes) {
      const nodeData = this.getDataFromNode(node);
      nodeData.stack = lastStack;
    }
    this.stack = lastStack.parent;
    setCurrentStack(this.stacks.pop());
    return lastStack;
  }
  /**
   * The builder maintains (cached) data for each node during the building process. This method
   * can be used to get these data for a specific shader stage and cache.
   *
   * @param {Node} node - The node to get the data for.
   * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
   * @param {?NodeCache} cache - An optional cache.
   * @return {Object} The node data.
   */
  getDataFromNode(node, shaderStage = this.shaderStage, cache2 = null) {
    cache2 = cache2 === null ? node.isGlobal(this) ? this.globalCache : this.cache : cache2;
    let nodeData = cache2.getData(node);
    if (nodeData === void 0) {
      nodeData = {};
      cache2.setData(node, nodeData);
    }
    if (nodeData[shaderStage] === void 0) nodeData[shaderStage] = {};
    let data = nodeData[shaderStage];
    const subBuilds = nodeData.any ? nodeData.any.subBuilds : null;
    const subBuild2 = this.getClosestSubBuild(subBuilds);
    if (subBuild2) {
      if (data.subBuildsCache === void 0) data.subBuildsCache = {};
      data = data.subBuildsCache[subBuild2] || (data.subBuildsCache[subBuild2] = {});
      data.subBuilds = subBuilds;
    }
    return data;
  }
  /**
   * Returns the properties for the given node and shader stage.
   *
   * Properties are typically used within a build stage to reference a node's
   * child node or nodes manually assigned to the properties in a separate build stage.
   * A typical usage pattern for defining nodes manually would be assigning dependency nodes
   * to the current node's properties in the setup stage and building those properties in the generate stage.
   *
   * @param {Node} node - The node to get the properties for.
   * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage='any'] - The shader stage.
   * @return {Object} The node properties.
   */
  getNodeProperties(node, shaderStage = "any") {
    const nodeData = this.getDataFromNode(node, shaderStage);
    return nodeData.properties || (nodeData.properties = { outputNode: null });
  }
  /**
   * Returns an instance of {@link NodeAttribute} for the given buffer attribute node.
   *
   * @param {BufferAttributeNode} node - The buffer attribute node.
   * @param {string} type - The node type.
   * @return {NodeAttribute} The node attribute.
   */
  getBufferAttributeFromNode(node, type) {
    const nodeData = this.getDataFromNode(node, "vertex");
    let bufferAttribute2 = nodeData.bufferAttribute;
    if (bufferAttribute2 === void 0) {
      const index8 = this.uniforms.index++;
      bufferAttribute2 = new NodeAttribute("nodeAttribute" + index8, type, node);
      this.bufferAttributes.push(bufferAttribute2);
      nodeData.bufferAttribute = bufferAttribute2;
    }
    return bufferAttribute2;
  }
  /**
   * Returns an instance of {@link StructType} for the given struct name and shader stage
   * or null if not found.
   *
   * @param {string} name - The name of the struct.
   * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
   * @return {?StructType} The struct type or null if not found.
   */
  getStructTypeNode(name, shaderStage = this.shaderStage) {
    return this.types[shaderStage][name] || null;
  }
  /**
   * Returns an instance of {@link StructType} for the given output struct node.
   *
   * @param {OutputStructNode} node - The output struct node.
   * @param {Array<Object>} membersLayout - The output struct types.
   * @param {?string} [name=null] - The name of the struct.
   * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
   * @return {StructType} The struct type attribute.
   */
  getStructTypeFromNode(node, membersLayout, name = null, shaderStage = this.shaderStage) {
    const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);
    let structType = nodeData.structType;
    if (structType === void 0) {
      const index8 = this.structs.index++;
      if (name === null) name = "StructType" + index8;
      structType = new StructType(name, membersLayout);
      this.structs[shaderStage].push(structType);
      this.types[shaderStage][name] = node;
      nodeData.structType = structType;
    }
    return structType;
  }
  /**
   * Returns an instance of {@link StructType} for the given output struct node.
   *
   * @param {OutputStructNode} node - The output struct node.
   * @param {Array<Object>} membersLayout - The output struct types.
   * @return {StructType} The struct type attribute.
   */
  getOutputStructTypeFromNode(node, membersLayout) {
    const structType = this.getStructTypeFromNode(node, membersLayout, "OutputType", "fragment");
    structType.output = true;
    return structType;
  }
  /**
   * Returns an instance of {@link NodeUniform} for the given uniform node.
   *
   * @param {UniformNode} node - The uniform node.
   * @param {string} type - The uniform type.
   * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
   * @param {?string} name - The name of the uniform.
   * @return {NodeUniform} The node uniform.
   */
  getUniformFromNode(node, type, shaderStage = this.shaderStage, name = null) {
    const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);
    let nodeUniform = nodeData.uniform;
    if (nodeUniform === void 0) {
      const index8 = this.uniforms.index++;
      nodeUniform = new NodeUniform(name || "nodeUniform" + index8, type, node);
      this.uniforms[shaderStage].push(nodeUniform);
      this.registerDeclaration(nodeUniform);
      nodeData.uniform = nodeUniform;
    }
    return nodeUniform;
  }
  /**
   * Returns an instance of {@link NodeVar} for the given variable node.
   *
   * @param {VarNode} node - The variable node.
   * @param {?string} name - The variable's name.
   * @param {string} [type=node.getNodeType( this )] - The variable's type.
   * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
   * @param {boolean} [readOnly=false] - Whether the variable is read-only or not.
   *
   * @return {NodeVar} The node variable.
   */
  getVarFromNode(node, name = null, type = node.getNodeType(this), shaderStage = this.shaderStage, readOnly = false) {
    const nodeData = this.getDataFromNode(node, shaderStage);
    const subBuildVariable = this.getSubBuildProperty("variable", nodeData.subBuilds);
    let nodeVar = nodeData[subBuildVariable];
    if (nodeVar === void 0) {
      const idNS = readOnly ? "_const" : "_var";
      const vars = this.vars[shaderStage] || (this.vars[shaderStage] = []);
      const id2 = this.vars[idNS] || (this.vars[idNS] = 0);
      if (name === null) {
        name = (readOnly ? "nodeConst" : "nodeVar") + id2;
        this.vars[idNS]++;
      }
      if (subBuildVariable !== "variable") {
        name = this.getSubBuildProperty(name, nodeData.subBuilds);
      }
      const count2 = node.getArrayCount(this);
      nodeVar = new NodeVar(name, type, readOnly, count2);
      if (!readOnly) {
        vars.push(nodeVar);
      }
      this.registerDeclaration(nodeVar);
      nodeData[subBuildVariable] = nodeVar;
    }
    return nodeVar;
  }
  /**
   * Returns whether a Node or its flow is deterministic, useful for use in `const`.
   *
   * @param {Node} node - The varying node.
   * @return {boolean} Returns true if deterministic.
   */
  isDeterministic(node) {
    if (node.isMathNode) {
      return this.isDeterministic(node.aNode) && (node.bNode ? this.isDeterministic(node.bNode) : true) && (node.cNode ? this.isDeterministic(node.cNode) : true);
    } else if (node.isOperatorNode) {
      return this.isDeterministic(node.aNode) && (node.bNode ? this.isDeterministic(node.bNode) : true);
    } else if (node.isArrayNode) {
      if (node.values !== null) {
        for (const n2 of node.values) {
          if (!this.isDeterministic(n2)) {
            return false;
          }
        }
      }
      return true;
    } else if (node.isConstNode) {
      return true;
    }
    return false;
  }
  /**
   * Returns an instance of {@link NodeVarying} for the given varying node.
   *
   * @param {(VaryingNode|PropertyNode)} node - The varying node.
   * @param {?string} name - The varying's name.
   * @param {string} [type=node.getNodeType( this )] - The varying's type.
   * @param {?string} interpolationType - The interpolation type of the varying.
   * @param {?string} interpolationSampling - The interpolation sampling type of the varying.
   * @return {NodeVar} The node varying.
   */
  getVaryingFromNode(node, name = null, type = node.getNodeType(this), interpolationType = null, interpolationSampling = null) {
    const nodeData = this.getDataFromNode(node, "any");
    const subBuildVarying = this.getSubBuildProperty("varying", nodeData.subBuilds);
    let nodeVarying = nodeData[subBuildVarying];
    if (nodeVarying === void 0) {
      const varyings = this.varyings;
      const index8 = varyings.length;
      if (name === null) name = "nodeVarying" + index8;
      if (subBuildVarying !== "varying") {
        name = this.getSubBuildProperty(name, nodeData.subBuilds);
      }
      nodeVarying = new NodeVarying(name, type, interpolationType, interpolationSampling);
      varyings.push(nodeVarying);
      this.registerDeclaration(nodeVarying);
      nodeData[subBuildVarying] = nodeVarying;
    }
    return nodeVarying;
  }
  /**
   * Registers a node declaration in the current shader stage.
   *
   * @param {Object} node - The node to be registered.
   */
  registerDeclaration(node) {
    const shaderStage = this.shaderStage;
    const declarations = this.declarations[shaderStage] || (this.declarations[shaderStage] = {});
    const property3 = this.getPropertyName(node);
    let index8 = 1;
    let name = property3;
    while (declarations[name] !== void 0) {
      name = property3 + "_" + index8++;
    }
    if (index8 > 1) {
      node.name = name;
      warn(`TSL: Declaration name '${property3}' of '${node.type}' already in use. Renamed to '${name}'.`);
    }
    declarations[name] = node;
  }
  /**
   * Returns an instance of {@link NodeCode} for the given code node.
   *
   * @param {CodeNode} node - The code node.
   * @param {string} type - The node type.
   * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
   * @return {NodeCode} The node code.
   */
  getCodeFromNode(node, type, shaderStage = this.shaderStage) {
    const nodeData = this.getDataFromNode(node);
    let nodeCode = nodeData.code;
    if (nodeCode === void 0) {
      const codes = this.codes[shaderStage] || (this.codes[shaderStage] = []);
      const index8 = codes.length;
      nodeCode = new NodeCode("nodeCode" + index8, type);
      codes.push(nodeCode);
      nodeData.code = nodeCode;
    }
    return nodeCode;
  }
  /**
  	 * Adds a code flow based on the code-block hierarchy.
  
  	 * This is used so that code-blocks like If,Else create their variables locally if the Node
  	 * is only used inside one of these conditionals in the current shader stage.
  	 *
  	 * @param {Node} node - The node to add.
  	 * @param {Node} nodeBlock - Node-based code-block. Usually 'ConditionalNode'.
  	 */
  addFlowCodeHierarchy(node, nodeBlock) {
    const { flowCodes, flowCodeBlock } = this.getDataFromNode(node);
    let needsFlowCode = true;
    let nodeBlockHierarchy = nodeBlock;
    while (nodeBlockHierarchy) {
      if (flowCodeBlock.get(nodeBlockHierarchy) === true) {
        needsFlowCode = false;
        break;
      }
      nodeBlockHierarchy = this.getDataFromNode(nodeBlockHierarchy).parentNodeBlock;
    }
    if (needsFlowCode) {
      for (const flowCode of flowCodes) {
        this.addLineFlowCode(flowCode);
      }
    }
  }
  /**
   * Add a inline-code to the current flow code-block.
   *
   * @param {Node} node - The node to add.
   * @param {string} code - The code to add.
   * @param {Node} nodeBlock - Current ConditionalNode
   */
  addLineFlowCodeBlock(node, code2, nodeBlock) {
    const nodeData = this.getDataFromNode(node);
    const flowCodes = nodeData.flowCodes || (nodeData.flowCodes = []);
    const codeBlock = nodeData.flowCodeBlock || (nodeData.flowCodeBlock = /* @__PURE__ */ new WeakMap());
    flowCodes.push(code2);
    codeBlock.set(nodeBlock, true);
  }
  /**
   * Add a inline-code to the current flow.
   *
   * @param {string} code - The code to add.
   * @param {?Node} [node= null] - Optional Node, can help the system understand if the Node is part of a code-block.
   * @return {NodeBuilder} A reference to this node builder.
   */
  addLineFlowCode(code2, node = null) {
    if (code2 === "") return this;
    if (node !== null && this.context.nodeBlock) {
      this.addLineFlowCodeBlock(node, code2, this.context.nodeBlock);
    }
    code2 = this.tab + code2;
    if (!/;\s*$/.test(code2)) {
      code2 = code2 + ";\n";
    }
    this.flow.code += code2;
    return this;
  }
  /**
   * Adds a code to the current code flow.
   *
   * @param {string} code - Shader code.
   * @return {NodeBuilder} A reference to this node builder.
   */
  addFlowCode(code2) {
    this.flow.code += code2;
    return this;
  }
  /**
   * Add tab in the code that will be generated so that other snippets respect the current tabulation.
   * Typically used in codes with If,Else.
   *
   * @return {NodeBuilder} A reference to this node builder.
   */
  addFlowTab() {
    this.tab += "	";
    return this;
  }
  /**
   * Removes a tab.
   *
   * @return {NodeBuilder} A reference to this node builder.
   */
  removeFlowTab() {
    this.tab = this.tab.slice(0, -1);
    return this;
  }
  /**
   * Gets the current flow data based on a Node.
   *
   * @param {Node} node - Node that the flow was started.
   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
   * @return {Object} The flow data.
   */
  getFlowData(node) {
    return this.flowsData.get(node);
  }
  /**
   * Executes the node flow based on a root node to generate the final shader code.
   *
   * @param {Node} node - The node to execute.
   * @return {Object} The code flow.
   */
  flowNode(node) {
    const output2 = node.getNodeType(this);
    const flowData = this.flowChildNode(node, output2);
    this.flowsData.set(node, flowData);
    return flowData;
  }
  /**
   * Includes a node in the current function node.
   *
   * @param {Node} node - The node to include.
   * @returns {void}
   */
  addInclude(node) {
    if (this.currentFunctionNode !== null) {
      this.currentFunctionNode.includes.push(node);
    }
  }
  /**
   * Returns the native shader operator name for a given generic name.
   * It is a similar type of method like {@link NodeBuilder#getMethod}.
   *
   * @param {ShaderNodeInternal} shaderNode - The shader node to build the function node with.
   * @return {FunctionNode} The build function node.
   */
  buildFunctionNode(shaderNode) {
    const fn = new FunctionNode();
    const previous = this.currentFunctionNode;
    this.currentFunctionNode = fn;
    fn.code = this.buildFunctionCode(shaderNode);
    this.currentFunctionNode = previous;
    return fn;
  }
  /**
   * Generates a code flow based on a TSL function: Fn().
   *
   * @param {ShaderNodeInternal} shaderNode - A function code will be generated based on the input.
   * @return {Object}
   */
  flowShaderNode(shaderNode) {
    const layout = shaderNode.layout;
    const inputs = {
      [Symbol.iterator]() {
        let index8 = 0;
        const values2 = Object.values(this);
        return {
          next: () => ({
            value: values2[index8],
            done: index8++ >= values2.length
          })
        };
      }
    };
    for (const input of layout.inputs) {
      inputs[input.name] = new ParameterNode(input.type, input.name);
    }
    shaderNode.layout = null;
    const callNode = shaderNode.call(inputs);
    const flowData = this.flowStagesNode(callNode, layout.type);
    shaderNode.layout = layout;
    return flowData;
  }
  /**
   * Executes the node in a specific build stage.
   *
   * This function can be used to arbitrarily execute the specified build stage
   * outside of the standard build process. For instance, if a node's type depends
   * on properties created by the 'setup' stage, then flowBuildStage(node, 'setup')
   * can be used to execute the setup build stage and access its generated nodes
   * before the standard build process begins.
   *
   * @param {Node} node - The node to execute.
   * @param {string} buildStage - The build stage to execute the node in.
   * @param {?(Node|string)} [output=null] - Expected output type. For example 'vec3'.
   * @return {?(Node|string)} The result of the node build.
   */
  flowBuildStage(node, buildStage, output2 = null) {
    const previousBuildStage = this.getBuildStage();
    this.setBuildStage(buildStage);
    const result2 = node.build(this, output2);
    this.setBuildStage(previousBuildStage);
    return result2;
  }
  /**
   * Runs the node flow through all the steps of creation, 'setup', 'analyze', 'generate'.
   *
   * @param {Node} node - The node to execute.
   * @param {?string} output - Expected output type. For example 'vec3'.
   * @return {Object}
   */
  flowStagesNode(node, output2 = null) {
    const previousFlow = this.flow;
    const previousVars = this.vars;
    const previousDeclarations = this.declarations;
    const previousCache = this.cache;
    const previousBuildStage = this.buildStage;
    const previousStack = this.stack;
    const flow2 = {
      code: ""
    };
    this.flow = flow2;
    this.vars = {};
    this.declarations = {};
    this.cache = new NodeCache();
    this.stack = stack();
    for (const buildStage of defaultBuildStages) {
      this.setBuildStage(buildStage);
      flow2.result = node.build(this, output2);
    }
    flow2.vars = this.getVars(this.shaderStage);
    this.flow = previousFlow;
    this.vars = previousVars;
    this.declarations = previousDeclarations;
    this.cache = previousCache;
    this.stack = previousStack;
    this.setBuildStage(previousBuildStage);
    return flow2;
  }
  /**
   * Returns the native shader operator name for a given generic name.
   * It is a similar type of method like {@link NodeBuilder#getMethod}.
   *
   * @abstract
   * @param {string} op - The operator name to resolve.
   * @return {?string} The resolved operator name.
   */
  getFunctionOperator() {
    return null;
  }
  /**
   * Builds the given shader node.
   *
   * @abstract
   * @param {ShaderNodeInternal} shaderNode - The shader node.
   * @return {string} The function code.
   */
  buildFunctionCode() {
    warn("Abstract function.");
  }
  /**
   * Generates a code flow based on a child Node.
   *
   * @param {Node} node - The node to execute.
   * @param {?string} output - Expected output type. For example 'vec3'.
   * @return {Object} The code flow.
   */
  flowChildNode(node, output2 = null) {
    const previousFlow = this.flow;
    const flow2 = {
      code: ""
    };
    this.flow = flow2;
    flow2.result = node.build(this, output2);
    this.flow = previousFlow;
    return flow2;
  }
  /**
   * Executes a flow of code in a different stage.
   *
   * Some nodes like `varying()` have the ability to compute code in vertex-stage and
   * return the value in fragment-stage even if it is being executed in an input fragment.
   *
   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
   * @param {Node} node - The node to execute.
   * @param {?string} output - Expected output type. For example 'vec3'.
   * @param {?string} propertyName - The property name to assign the result.
   * @return {?(Object|Node)} The code flow or node.build() result.
   */
  flowNodeFromShaderStage(shaderStage, node, output2 = null, propertyName = null) {
    const previousTab = this.tab;
    const previousCache = this.cache;
    const previousShaderStage = this.shaderStage;
    const previousContext = this.context;
    this.setShaderStage(shaderStage);
    const context2 = { ...this.context };
    delete context2.nodeBlock;
    this.cache = this.globalCache;
    this.tab = "	";
    this.context = context2;
    let result2 = null;
    if (this.buildStage === "generate") {
      const flowData = this.flowChildNode(node, output2);
      if (propertyName !== null) {
        flowData.code += `${this.tab + propertyName} = ${flowData.result};
`;
      }
      this.flowCode[shaderStage] = this.flowCode[shaderStage] + flowData.code;
      result2 = flowData;
    } else {
      result2 = node.build(this);
    }
    this.setShaderStage(previousShaderStage);
    this.cache = previousCache;
    this.tab = previousTab;
    this.context = previousContext;
    return result2;
  }
  /**
   * Returns an array holding all node attributes of this node builder.
   *
   * @return {Array<NodeAttribute>} The node attributes of this builder.
   */
  getAttributesArray() {
    return this.attributes.concat(this.bufferAttributes);
  }
  /**
   * Returns the attribute definitions as a shader string for the given shader stage.
   *
   * @abstract
   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
   * @return {string} The attribute code section.
   */
  getAttributes() {
    warn("Abstract function.");
  }
  /**
   * Returns the varying definitions as a shader string for the given shader stage.
   *
   * @abstract
   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
   * @return {string} The varying code section.
   */
  getVaryings() {
    warn("Abstract function.");
  }
  /**
   * Returns a single variable definition as a shader string for the given variable type and name.
   *
   * @param {string} type - The variable's type.
   * @param {string} name - The variable's name.
   * @param {?number} [count=null] - The array length.
   * @return {string} The shader string.
   */
  getVar(type, name, count2 = null) {
    return `${count2 !== null ? this.generateArrayDeclaration(type, count2) : this.getType(type)} ${name}`;
  }
  /**
   * Returns the variable definitions as a shader string for the given shader stage.
   *
   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
   * @return {string} The variable code section.
   */
  getVars(shaderStage) {
    let snippet = "";
    const vars = this.vars[shaderStage];
    if (vars !== void 0) {
      for (const variable of vars) {
        snippet += `${this.getVar(variable.type, variable.name)}; `;
      }
    }
    return snippet;
  }
  /**
   * Returns the uniform definitions as a shader string for the given shader stage.
   *
   * @abstract
   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
   * @return {string} The uniform code section.
   */
  getUniforms() {
    warn("Abstract function.");
  }
  /**
   * Returns the native code definitions as a shader string for the given shader stage.
   *
   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
   * @return {string} The native code section.
   */
  getCodes(shaderStage) {
    const codes = this.codes[shaderStage];
    let code2 = "";
    if (codes !== void 0) {
      for (const nodeCode of codes) {
        code2 += nodeCode.code + "\n";
      }
    }
    return code2;
  }
  /**
   * Returns the hash of this node builder.
   *
   * @return {string} The hash.
   */
  getHash() {
    return this.vertexShader + this.fragmentShader + this.computeShader;
  }
  /**
   * Sets the current shader stage.
   *
   * @param {?('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage to set.
   */
  setShaderStage(shaderStage) {
    this.shaderStage = shaderStage;
  }
  /**
   * Returns the current shader stage.
   *
   * @return {?('vertex'|'fragment'|'compute'|'any')} The current shader stage.
   */
  getShaderStage() {
    return this.shaderStage;
  }
  /**
   * Sets the current build stage.
   *
   * @param {?('setup'|'analyze'|'generate')} buildStage - The build stage to set.
   */
  setBuildStage(buildStage) {
    this.buildStage = buildStage;
  }
  /**
   * Returns the current build stage.
   *
   * @return {?('setup'|'analyze'|'generate')} The current build stage.
   */
  getBuildStage() {
    return this.buildStage;
  }
  /**
   * Controls the code build of the shader stages.
   *
   * @abstract
   */
  buildCode() {
    warn("Abstract function.");
  }
  /**
   * Returns the current sub-build layer.
   *
   * @return {SubBuildNode} The current sub-build layers.
   */
  get subBuild() {
    return this.subBuildLayers[this.subBuildLayers.length - 1] || null;
  }
  /**
   * Adds a sub-build layer to the node builder.
   *
   * @param {SubBuildNode} subBuild - The sub-build layer to add.
   */
  addSubBuild(subBuild2) {
    this.subBuildLayers.push(subBuild2);
  }
  /**
   * Removes the last sub-build layer from the node builder.
   *
   * @return {SubBuildNode} The removed sub-build layer.
   */
  removeSubBuild() {
    return this.subBuildLayers.pop();
  }
  /**
   * Returns the closest sub-build layer for the given data.
   *
   * @param {Node|Set<string>|Array<string>} data - The data to get the closest sub-build layer from.
   * @return {?string} The closest sub-build name or null if none found.
   */
  getClosestSubBuild(data) {
    let subBuilds;
    if (data && data.isNode) {
      if (data.isShaderCallNodeInternal) {
        subBuilds = data.shaderNode.subBuilds;
      } else if (data.isStackNode) {
        subBuilds = [data.subBuild];
      } else {
        subBuilds = this.getDataFromNode(data, "any").subBuilds;
      }
    } else if (data instanceof Set) {
      subBuilds = [...data];
    } else {
      subBuilds = data;
    }
    if (!subBuilds) return null;
    const subBuildLayers = this.subBuildLayers;
    for (let i2 = subBuilds.length - 1; i2 >= 0; i2--) {
      const subBuild2 = subBuilds[i2];
      if (subBuildLayers.includes(subBuild2)) {
        return subBuild2;
      }
    }
    return null;
  }
  /**
   * Returns the output node of a sub-build layer.
   *
   * @param {Node} node - The node to get the output from.
   * @return {string} The output node name.
   */
  getSubBuildOutput(node) {
    return this.getSubBuildProperty("outputNode", node);
  }
  /**
   * Returns the sub-build property name for the given property and node.
   *
   * @param {string} [property=''] - The property name.
   * @param {?Node} [node=null] - The node to get the sub-build from.
   * @return {string} The sub-build property name.
   */
  getSubBuildProperty(property3 = "", node = null) {
    let subBuild2;
    if (node !== null) {
      subBuild2 = this.getClosestSubBuild(node);
    } else {
      subBuild2 = this.subBuildFn;
    }
    let result2;
    if (subBuild2) {
      result2 = property3 ? subBuild2 + "_" + property3 : subBuild2;
    } else {
      result2 = property3;
    }
    return result2;
  }
  /**
   * Central build method which controls the build for the given object.
   *
   * @return {NodeBuilder} A reference to this node builder.
   */
  build() {
    const { object, material, renderer: renderer3 } = this;
    if (material !== null) {
      let nodeMaterial = renderer3.library.fromMaterial(material);
      if (nodeMaterial === null) {
        error(`NodeMaterial: Material "${material.type}" is not compatible.`);
        nodeMaterial = new NodeMaterial();
      }
      nodeMaterial.build(this);
    } else {
      this.addFlow("compute", object);
    }
    for (const buildStage of defaultBuildStages) {
      this.setBuildStage(buildStage);
      if (this.context.vertex && this.context.vertex.isNode) {
        this.flowNodeFromShaderStage("vertex", this.context.vertex);
      }
      for (const shaderStage of shaderStages) {
        this.setShaderStage(shaderStage);
        const flowNodes = this.flowNodes[shaderStage];
        for (const node of flowNodes) {
          if (buildStage === "generate") {
            this.flowNode(node);
          } else {
            node.build(this);
          }
        }
      }
    }
    this.setBuildStage(null);
    this.setShaderStage(null);
    this.buildCode();
    this.buildUpdateNodes();
    return this;
  }
  /**
   * Returns shared data object for the given node.
   *
   * @param {Node} node - The node to get shared data from.
   * @return {Object} The shared data.
   */
  getSharedDataFromNode(node) {
    let data = sharedNodeData.get(node);
    if (data === void 0) {
      data = {};
    }
    return data;
  }
  /**
   * Returns a uniform representation which is later used for UBO generation and rendering.
   *
   * @param {NodeUniform} uniformNode - The uniform node.
   * @param {string} type - The requested type.
   * @return {Uniform} The uniform.
   */
  getNodeUniform(uniformNode, type) {
    const nodeData = this.getSharedDataFromNode(uniformNode);
    let node = nodeData.cache;
    if (node === void 0) {
      if (type === "float" || type === "int" || type === "uint") node = new NumberNodeUniform(uniformNode);
      else if (type === "vec2" || type === "ivec2" || type === "uvec2") node = new Vector2NodeUniform(uniformNode);
      else if (type === "vec3" || type === "ivec3" || type === "uvec3") node = new Vector3NodeUniform(uniformNode);
      else if (type === "vec4" || type === "ivec4" || type === "uvec4") node = new Vector4NodeUniform(uniformNode);
      else if (type === "color") node = new ColorNodeUniform(uniformNode);
      else if (type === "mat2") node = new Matrix2NodeUniform(uniformNode);
      else if (type === "mat3") node = new Matrix3NodeUniform(uniformNode);
      else if (type === "mat4") node = new Matrix4NodeUniform(uniformNode);
      else {
        throw new Error(`Uniform "${type}" not implemented.`);
      }
      nodeData.cache = node;
    }
    return node;
  }
  /**
   * Formats the given shader snippet from a given type into another one. E.g.
   * this method might be used to convert a simple float string `"1.0"` into a
   * `vec3` representation: `"vec3<f32>( 1.0 )"`.
   *
   * @param {string} snippet - The shader snippet.
   * @param {string} fromType - The source type.
   * @param {string} toType - The target type.
   * @return {string} The updated shader string.
   */
  format(snippet, fromType, toType) {
    fromType = this.getVectorType(fromType);
    toType = this.getVectorType(toType);
    if (fromType === toType || toType === null || this.isReference(toType)) {
      return snippet;
    }
    const fromTypeLength = this.getTypeLength(fromType);
    const toTypeLength = this.getTypeLength(toType);
    if (fromTypeLength === 16 && toTypeLength === 9) {
      return `${this.getType(toType)}( ${snippet}[ 0 ].xyz, ${snippet}[ 1 ].xyz, ${snippet}[ 2 ].xyz )`;
    }
    if (fromTypeLength === 9 && toTypeLength === 4) {
      return `${this.getType(toType)}( ${snippet}[ 0 ].xy, ${snippet}[ 1 ].xy )`;
    }
    if (fromTypeLength > 4) {
      return snippet;
    }
    if (toTypeLength > 4 || toTypeLength === 0) {
      return snippet;
    }
    if (fromTypeLength === toTypeLength) {
      return `${this.getType(toType)}( ${snippet} )`;
    }
    if (fromTypeLength > toTypeLength) {
      snippet = toType === "bool" ? `all( ${snippet} )` : `${snippet}.${"xyz".slice(0, toTypeLength)}`;
      return this.format(snippet, this.getTypeFromLength(toTypeLength, this.getComponentType(fromType)), toType);
    }
    if (toTypeLength === 4 && fromTypeLength > 1) {
      return `${this.getType(toType)}( ${this.format(snippet, fromType, "vec3")}, 1.0 )`;
    }
    if (fromTypeLength === 2) {
      return `${this.getType(toType)}( ${this.format(snippet, fromType, "vec2")}, 0.0 )`;
    }
    if (fromTypeLength === 1 && toTypeLength > 1 && fromType !== this.getComponentType(toType)) {
      snippet = `${this.getType(this.getComponentType(toType))}( ${snippet} )`;
    }
    return `${this.getType(toType)}( ${snippet} )`;
  }
  /**
   * Returns a signature with the engine's current revision.
   *
   * @return {string} The signature.
   */
  getSignature() {
    return `// Three.js r${REVISION} - Node System
`;
  }
};
var NodeFrame = class {
  /**
   * Constructs a new node fame.
   */
  constructor() {
    this.time = 0;
    this.deltaTime = 0;
    this.frameId = 0;
    this.renderId = 0;
    this.updateMap = /* @__PURE__ */ new WeakMap();
    this.updateBeforeMap = /* @__PURE__ */ new WeakMap();
    this.updateAfterMap = /* @__PURE__ */ new WeakMap();
    this.renderer = null;
    this.material = null;
    this.camera = null;
    this.object = null;
    this.scene = null;
  }
  /**
   * Returns a dictionary for a given node and update map which
   * is used to correctly call node update methods per frame or render.
   *
   * @private
   * @param {WeakMap<Node, Object>} referenceMap - The reference weak map.
   * @param {Node} nodeRef - The reference to the current node.
   * @return {Object<string,WeakMap<Object, number>>} The dictionary.
   */
  _getMaps(referenceMap, nodeRef) {
    let maps = referenceMap.get(nodeRef);
    if (maps === void 0) {
      maps = {
        renderId: 0,
        frameId: 0
      };
      referenceMap.set(nodeRef, maps);
    }
    return maps;
  }
  /**
   * This method executes the {@link Node#updateBefore} for the given node.
   * It makes sure {@link Node#updateBeforeType} is honored meaning the update
   * is only executed once per frame, render or object depending on the update
   * type.
   *
   * @param {Node} node - The node that should be updated.
   */
  updateBeforeNode(node) {
    const updateType = node.getUpdateBeforeType();
    const reference2 = node.updateReference(this);
    if (updateType === NodeUpdateType.FRAME) {
      const nodeUpdateBeforeMap = this._getMaps(this.updateBeforeMap, reference2);
      if (nodeUpdateBeforeMap.frameId !== this.frameId) {
        const previousFrameId = nodeUpdateBeforeMap.frameId;
        nodeUpdateBeforeMap.frameId = this.frameId;
        if (node.updateBefore(this) === false) {
          nodeUpdateBeforeMap.frameId = previousFrameId;
        }
      }
    } else if (updateType === NodeUpdateType.RENDER) {
      const nodeUpdateBeforeMap = this._getMaps(this.updateBeforeMap, reference2);
      if (nodeUpdateBeforeMap.renderId !== this.renderId) {
        const previousRenderId = nodeUpdateBeforeMap.renderId;
        nodeUpdateBeforeMap.renderId = this.renderId;
        if (node.updateBefore(this) === false) {
          nodeUpdateBeforeMap.renderId = previousRenderId;
        }
      }
    } else if (updateType === NodeUpdateType.OBJECT) {
      node.updateBefore(this);
    }
  }
  /**
   * This method executes the {@link Node#updateAfter} for the given node.
   * It makes sure {@link Node#updateAfterType} is honored meaning the update
   * is only executed once per frame, render or object depending on the update
   * type.
   *
   * @param {Node} node - The node that should be updated.
   */
  updateAfterNode(node) {
    const updateType = node.getUpdateAfterType();
    const reference2 = node.updateReference(this);
    if (updateType === NodeUpdateType.FRAME) {
      const nodeUpdateAfterMap = this._getMaps(this.updateAfterMap, reference2);
      if (nodeUpdateAfterMap.frameId !== this.frameId) {
        if (node.updateAfter(this) !== false) {
          nodeUpdateAfterMap.frameId = this.frameId;
        }
      }
    } else if (updateType === NodeUpdateType.RENDER) {
      const nodeUpdateAfterMap = this._getMaps(this.updateAfterMap, reference2);
      if (nodeUpdateAfterMap.renderId !== this.renderId) {
        if (node.updateAfter(this) !== false) {
          nodeUpdateAfterMap.renderId = this.renderId;
        }
      }
    } else if (updateType === NodeUpdateType.OBJECT) {
      node.updateAfter(this);
    }
  }
  /**
   * This method executes the {@link Node#update} for the given node.
   * It makes sure {@link Node#updateType} is honored meaning the update
   * is only executed once per frame, render or object depending on the update
   * type.
   *
   * @param {Node} node - The node that should be updated.
   */
  updateNode(node) {
    const updateType = node.getUpdateType();
    const reference2 = node.updateReference(this);
    if (updateType === NodeUpdateType.FRAME) {
      const nodeUpdateMap = this._getMaps(this.updateMap, reference2);
      if (nodeUpdateMap.frameId !== this.frameId) {
        if (node.update(this) !== false) {
          nodeUpdateMap.frameId = this.frameId;
        }
      }
    } else if (updateType === NodeUpdateType.RENDER) {
      const nodeUpdateMap = this._getMaps(this.updateMap, reference2);
      if (nodeUpdateMap.renderId !== this.renderId) {
        if (node.update(this) !== false) {
          nodeUpdateMap.renderId = this.renderId;
        }
      }
    } else if (updateType === NodeUpdateType.OBJECT) {
      node.update(this);
    }
  }
  /**
   * Updates the internal state of the node frame. This method is
   * called by the renderer in its internal animation loop.
   */
  update() {
    this.frameId++;
    if (this.lastTime === void 0) this.lastTime = performance.now();
    this.deltaTime = (performance.now() - this.lastTime) / 1e3;
    this.lastTime = performance.now();
    this.time += this.deltaTime;
  }
};
var NodeFunctionInput = class {
  /**
   * Constructs a new node function input.
   *
   * @param {string} type - The input type.
   * @param {string} name - The input name.
   * @param {?number} [count=null] - If the input is an Array, count will be the length.
   * @param {('in'|'out'|'inout')} [qualifier=''] - The parameter qualifier (only relevant for GLSL).
   * @param {boolean} [isConst=false] - Whether the input uses a const qualifier or not (only relevant for GLSL).
   */
  constructor(type, name, count2 = null, qualifier = "", isConst = false) {
    this.type = type;
    this.name = name;
    this.count = count2;
    this.qualifier = qualifier;
    this.isConst = isConst;
  }
};
NodeFunctionInput.isNodeFunctionInput = true;
var DirectionalLightNode = class extends AnalyticLightNode {
  static get type() {
    return "DirectionalLightNode";
  }
  /**
   * Constructs a new directional light node.
   *
   * @param {?DirectionalLight} [light=null] - The directional light source.
   */
  constructor(light = null) {
    super(light);
  }
  setupDirect() {
    const lightColor = this.colorNode;
    const lightDirection = lightTargetDirection(this.light);
    return { lightDirection, lightColor };
  }
};
var _matrix41 = new Matrix4();
var _matrix42 = new Matrix4();
var _ltcLib = null;
var RectAreaLightNode = class extends AnalyticLightNode {
  static get type() {
    return "RectAreaLightNode";
  }
  /**
   * Constructs a new rect area light node.
   *
   * @param {?RectAreaLight} [light=null] - The rect area light source.
   */
  constructor(light = null) {
    super(light);
    this.halfHeight = uniform(new Vector3()).setGroup(renderGroup);
    this.halfWidth = uniform(new Vector3()).setGroup(renderGroup);
    this.updateType = NodeUpdateType.RENDER;
  }
  /**
   * Overwritten to updated rect area light specific uniforms.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update(frame2) {
    super.update(frame2);
    const { light } = this;
    const viewMatrix = frame2.camera.matrixWorldInverse;
    _matrix42.identity();
    _matrix41.copy(light.matrixWorld);
    _matrix41.premultiply(viewMatrix);
    _matrix42.extractRotation(_matrix41);
    this.halfWidth.value.set(light.width * 0.5, 0, 0);
    this.halfHeight.value.set(0, light.height * 0.5, 0);
    this.halfWidth.value.applyMatrix4(_matrix42);
    this.halfHeight.value.applyMatrix4(_matrix42);
  }
  setupDirectRectArea(builder) {
    let ltc_1, ltc_2;
    if (builder.isAvailable("float32Filterable")) {
      ltc_1 = texture(_ltcLib.LTC_FLOAT_1);
      ltc_2 = texture(_ltcLib.LTC_FLOAT_2);
    } else {
      ltc_1 = texture(_ltcLib.LTC_HALF_1);
      ltc_2 = texture(_ltcLib.LTC_HALF_2);
    }
    const { colorNode, light } = this;
    const lightPosition2 = lightViewPosition(light);
    return {
      lightColor: colorNode,
      lightPosition: lightPosition2,
      halfWidth: this.halfWidth,
      halfHeight: this.halfHeight,
      ltc_1,
      ltc_2
    };
  }
  /**
   * Used to configure the internal BRDF approximation texture data.
   *
   * @param {RectAreaLightTexturesLib} ltc - The BRDF approximation texture data.
   */
  static setLTC(ltc) {
    _ltcLib = ltc;
  }
};
var SpotLightNode = class extends AnalyticLightNode {
  static get type() {
    return "SpotLightNode";
  }
  /**
   * Constructs a new spot light node.
   *
   * @param {?SpotLight} [light=null] - The spot light source.
   */
  constructor(light = null) {
    super(light);
    this.coneCosNode = uniform(0).setGroup(renderGroup);
    this.penumbraCosNode = uniform(0).setGroup(renderGroup);
    this.cutoffDistanceNode = uniform(0).setGroup(renderGroup);
    this.decayExponentNode = uniform(0).setGroup(renderGroup);
    this.colorNode = uniform(this.color).setGroup(renderGroup);
  }
  /**
   * Overwritten to updated spot light specific uniforms.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update(frame2) {
    super.update(frame2);
    const { light } = this;
    this.coneCosNode.value = Math.cos(light.angle);
    this.penumbraCosNode.value = Math.cos(light.angle * (1 - light.penumbra));
    this.cutoffDistanceNode.value = light.distance;
    this.decayExponentNode.value = light.decay;
  }
  /**
   * Computes the spot attenuation for the given angle.
   *
   * @param {NodeBuilder} builder - The node builder.
   * @param {Node<float>} angleCosine - The angle to compute the spot attenuation for.
   * @return {Node<float>} The spot attenuation.
   */
  getSpotAttenuation(builder, angleCosine) {
    const { coneCosNode, penumbraCosNode } = this;
    return smoothstep2(coneCosNode, penumbraCosNode, angleCosine);
  }
  getLightCoord(builder) {
    const properties = builder.getNodeProperties(this);
    let projectionUV = properties.projectionUV;
    if (projectionUV === void 0) {
      projectionUV = lightProjectionUV(this.light, builder.context.positionWorld);
      properties.projectionUV = projectionUV;
    }
    return projectionUV;
  }
  setupDirect(builder) {
    const { colorNode, cutoffDistanceNode, decayExponentNode, light } = this;
    const lightVector = this.getLightVector(builder);
    const lightDirection = lightVector.normalize();
    const angleCos = lightDirection.dot(lightTargetDirection(light));
    const spotAttenuation = this.getSpotAttenuation(builder, angleCos);
    const lightDistance = lightVector.length();
    const lightAttenuation = getDistanceAttenuation({
      lightDistance,
      cutoffDistance: cutoffDistanceNode,
      decayExponent: decayExponentNode
    });
    let lightColor = colorNode.mul(spotAttenuation).mul(lightAttenuation);
    let projected, lightCoord;
    if (light.colorNode) {
      lightCoord = this.getLightCoord(builder);
      projected = light.colorNode(lightCoord);
    } else if (light.map) {
      lightCoord = this.getLightCoord(builder);
      projected = texture(light.map, lightCoord.xy).onRenderUpdate(() => light.map);
    }
    if (projected) {
      const inSpotLightMap = lightCoord.mul(2).sub(1).abs().lessThan(1).all();
      lightColor = inSpotLightMap.select(lightColor.mul(projected), lightColor);
    }
    return { lightColor, lightDirection };
  }
};
var IESSpotLightNode = class extends SpotLightNode {
  static get type() {
    return "IESSpotLightNode";
  }
  /**
   * Overwrites the default implementation to compute an IES conform spot attenuation.
   *
   * @param {NodeBuilder} builder - The node builder.
   * @param {Node<float>} angleCosine - The angle to compute the spot attenuation for.
   * @return {Node<float>} The spot attenuation.
   */
  getSpotAttenuation(builder, angleCosine) {
    const iesMap = this.light.iesMap;
    let spotAttenuation = null;
    if (iesMap && iesMap.isTexture === true) {
      const angle2 = angleCosine.acos().mul(1 / Math.PI);
      spotAttenuation = texture(iesMap, vec2(angle2, 0), 0).r;
    } else {
      spotAttenuation = super.getSpotAttenuation(angleCosine);
    }
    return spotAttenuation;
  }
};
var sdBox = Fn(([p3, b]) => {
  const d3 = p3.abs().sub(b);
  return length(max$1(d3, 0)).add(min$1(max$1(d3.x, d3.y), 0));
});
var ProjectorLightNode = class extends SpotLightNode {
  static get type() {
    return "ProjectorLightNode";
  }
  update(frame2) {
    super.update(frame2);
    const light = this.light;
    this.penumbraCosNode.value = Math.min(Math.cos(light.angle * (1 - light.penumbra)), 0.99999);
    if (light.aspect === null) {
      let aspect = 1;
      if (light.map !== null) {
        aspect = light.map.width / light.map.height;
      }
      light.shadow.aspect = aspect;
    } else {
      light.shadow.aspect = light.aspect;
    }
  }
  /**
   * Overwrites the default implementation to compute projection attenuation.
   *
   * @param {NodeBuilder} builder - The node builder.
   * @return {Node<float>} The spot attenuation.
   */
  getSpotAttenuation(builder) {
    const attenuation = float(0);
    const penumbraCos = this.penumbraCosNode;
    const spotLightCoord = lightShadowMatrix(this.light).mul(builder.context.positionWorld || positionWorld);
    If(spotLightCoord.w.greaterThan(0), () => {
      const projectionUV = spotLightCoord.xyz.div(spotLightCoord.w);
      const boxDist = sdBox(projectionUV.xy.sub(vec2(0.5)), vec2(0.5));
      const angleFactor = div(-1, sub(1, acos(penumbraCos)).sub(1));
      attenuation.assign(saturate3(boxDist.mul(-2).mul(angleFactor)));
    });
    return attenuation;
  }
};
var AmbientLightNode = class extends AnalyticLightNode {
  static get type() {
    return "AmbientLightNode";
  }
  /**
   * Constructs a new ambient light node.
   *
   * @param {?AmbientLight} [light=null] - The ambient light source.
   */
  constructor(light = null) {
    super(light);
  }
  setup({ context: context2 }) {
    context2.irradiance.addAssign(this.colorNode);
  }
};
var HemisphereLightNode = class extends AnalyticLightNode {
  static get type() {
    return "HemisphereLightNode";
  }
  /**
   * Constructs a new hemisphere light node.
   *
   * @param {?HemisphereLight} [light=null] - The hemisphere light source.
   */
  constructor(light = null) {
    super(light);
    this.lightPositionNode = lightPosition(light);
    this.lightDirectionNode = this.lightPositionNode.normalize();
    this.groundColorNode = uniform(new Color()).setGroup(renderGroup);
  }
  /**
   * Overwritten to updated hemisphere light specific uniforms.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update(frame2) {
    const { light } = this;
    super.update(frame2);
    this.lightPositionNode.object3d = light;
    this.groundColorNode.value.copy(light.groundColor).multiplyScalar(light.intensity);
  }
  setup(builder) {
    const { colorNode, groundColorNode, lightDirectionNode } = this;
    const dotNL = normalWorld.dot(lightDirectionNode);
    const hemiDiffuseWeight = dotNL.mul(0.5).add(0.5);
    const irradiance = mix2(groundColorNode, colorNode, hemiDiffuseWeight);
    builder.context.irradiance.addAssign(irradiance);
  }
};
var LightProbeNode = class extends AnalyticLightNode {
  static get type() {
    return "LightProbeNode";
  }
  /**
   * Constructs a new light probe node.
   *
   * @param {?LightProbe} [light=null] - The light probe.
   */
  constructor(light = null) {
    super(light);
    const array4 = [];
    for (let i2 = 0; i2 < 9; i2++) array4.push(new Vector3());
    this.lightProbe = uniformArray(array4);
  }
  /**
   * Overwritten to updated light probe specific uniforms.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update(frame2) {
    const { light } = this;
    super.update(frame2);
    for (let i2 = 0; i2 < 9; i2++) {
      this.lightProbe.array[i2].copy(light.sh.coefficients[i2]).multiplyScalar(light.intensity);
    }
  }
  setup(builder) {
    const irradiance = getShIrradianceAt(normalWorld, this.lightProbe);
    builder.context.irradiance.addAssign(irradiance);
  }
};
var NodeParser = class {
  /**
   * The method parses the given native code an returns a node function.
   *
   * @abstract
   * @param {string} source - The native shader code.
   * @return {NodeFunction} A node function.
   */
  parseFunction() {
    warn("Abstract function.");
  }
};
var NodeFunction = class {
  /**
   * Constructs a new node function.
   *
   * @param {string} type - The node type. This type is the return type of the node function.
   * @param {Array<NodeFunctionInput>} inputs - The function's inputs.
   * @param {string} [name=''] - The function's name.
   * @param {string} [precision=''] - The precision qualifier.
   */
  constructor(type, inputs, name = "", precision = "") {
    this.type = type;
    this.inputs = inputs;
    this.name = name;
    this.precision = precision;
  }
  /**
   * This method returns the native code of the node function.
   *
   * @abstract
   * @param {string} name - The function's name.
   * @return {string} A shader code.
   */
  getCode() {
    warn("Abstract function.");
  }
};
NodeFunction.isNodeFunction = true;
var declarationRegexp$1 = /^\s*(highp|mediump|lowp)?\s*([a-z_0-9]+)\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)/i;
var propertiesRegexp$1 = /[a-z_0-9]+/ig;
var pragmaMain = "#pragma main";
var parse$1 = (source) => {
  source = source.trim();
  const pragmaMainIndex = source.indexOf(pragmaMain);
  const mainCode = pragmaMainIndex !== -1 ? source.slice(pragmaMainIndex + pragmaMain.length) : source;
  const declaration = mainCode.match(declarationRegexp$1);
  if (declaration !== null && declaration.length === 5) {
    const inputsCode = declaration[4];
    const propsMatches = [];
    let nameMatch = null;
    while ((nameMatch = propertiesRegexp$1.exec(inputsCode)) !== null) {
      propsMatches.push(nameMatch);
    }
    const inputs = [];
    let i2 = 0;
    while (i2 < propsMatches.length) {
      const isConst = propsMatches[i2][0] === "const";
      if (isConst === true) {
        i2++;
      }
      let qualifier = propsMatches[i2][0];
      if (qualifier === "in" || qualifier === "out" || qualifier === "inout") {
        i2++;
      } else {
        qualifier = "";
      }
      const type2 = propsMatches[i2++][0];
      let count2 = Number.parseInt(propsMatches[i2][0]);
      if (Number.isNaN(count2) === false) i2++;
      else count2 = null;
      const name2 = propsMatches[i2++][0];
      inputs.push(new NodeFunctionInput(type2, name2, count2, qualifier, isConst));
    }
    const blockCode = mainCode.substring(declaration[0].length);
    const name = declaration[3] !== void 0 ? declaration[3] : "";
    const type = declaration[2];
    const precision = declaration[1] !== void 0 ? declaration[1] : "";
    const headerCode = pragmaMainIndex !== -1 ? source.slice(0, pragmaMainIndex) : "";
    return {
      type,
      inputs,
      name,
      precision,
      inputsCode,
      blockCode,
      headerCode
    };
  } else {
    throw new Error("FunctionNode: Function is not a GLSL code.");
  }
};
var GLSLNodeFunction = class extends NodeFunction {
  /**
   * Constructs a new GLSL node function.
   *
   * @param {string} source - The GLSL source.
   */
  constructor(source) {
    const { type, inputs, name, precision, inputsCode, blockCode, headerCode } = parse$1(source);
    super(type, inputs, name, precision);
    this.inputsCode = inputsCode;
    this.blockCode = blockCode;
    this.headerCode = headerCode;
  }
  /**
   * This method returns the GLSL code of the node function.
   *
   * @param {string} [name=this.name] - The function's name.
   * @return {string} The shader code.
   */
  getCode(name = this.name) {
    let code2;
    const blockCode = this.blockCode;
    if (blockCode !== "") {
      const { type, inputsCode, headerCode, precision } = this;
      let declarationCode = `${type} ${name} ( ${inputsCode.trim()} )`;
      if (precision !== "") {
        declarationCode = `${precision} ${declarationCode}`;
      }
      code2 = headerCode + declarationCode + blockCode;
    } else {
      code2 = "";
    }
    return code2;
  }
};
var GLSLNodeParser = class extends NodeParser {
  /**
   * The method parses the given GLSL code an returns a node function.
   *
   * @param {string} source - The GLSL code.
   * @return {GLSLNodeFunction} A node function.
   */
  parseFunction(source) {
    return new GLSLNodeFunction(source);
  }
};
var _outputNodeMap = /* @__PURE__ */ new WeakMap();
var _chainKeys$2 = [];
var _cacheKeyValues = [];
var Nodes = class extends DataMap {
  /**
   * Constructs a new nodes management component.
   *
   * @param {Renderer} renderer - The renderer.
   * @param {Backend} backend - The renderer's backend.
   */
  constructor(renderer3, backend) {
    super();
    this.renderer = renderer3;
    this.backend = backend;
    this.nodeFrame = new NodeFrame();
    this.nodeBuilderCache = /* @__PURE__ */ new Map();
    this.callHashCache = new ChainMap();
    this.groupsData = new ChainMap();
    this.cacheLib = {};
  }
  /**
   * Returns `true` if the given node uniforms group must be updated or not.
   *
   * @param {NodeUniformsGroup} nodeUniformsGroup - The node uniforms group.
   * @return {boolean} Whether the node uniforms group requires an update or not.
   */
  updateGroup(nodeUniformsGroup) {
    const groupNode = nodeUniformsGroup.groupNode;
    const name = groupNode.name;
    if (name === objectGroup.name) return true;
    if (name === renderGroup.name) {
      const uniformsGroupData = this.get(nodeUniformsGroup);
      const renderId = this.nodeFrame.renderId;
      if (uniformsGroupData.renderId !== renderId) {
        uniformsGroupData.renderId = renderId;
        return true;
      }
      return false;
    }
    if (name === frameGroup.name) {
      const uniformsGroupData = this.get(nodeUniformsGroup);
      const frameId2 = this.nodeFrame.frameId;
      if (uniformsGroupData.frameId !== frameId2) {
        uniformsGroupData.frameId = frameId2;
        return true;
      }
      return false;
    }
    _chainKeys$2[0] = groupNode;
    _chainKeys$2[1] = nodeUniformsGroup;
    let groupData = this.groupsData.get(_chainKeys$2);
    if (groupData === void 0) this.groupsData.set(_chainKeys$2, groupData = {});
    _chainKeys$2.length = 0;
    if (groupData.version !== groupNode.version) {
      groupData.version = groupNode.version;
      return true;
    }
    return false;
  }
  /**
   * Returns the cache key for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {number} The cache key.
   */
  getForRenderCacheKey(renderObject) {
    return renderObject.initialCacheKey;
  }
  /**
   * Returns a node builder state for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {NodeBuilderState} The node builder state.
   */
  getForRender(renderObject) {
    const renderObjectData = this.get(renderObject);
    let nodeBuilderState = renderObjectData.nodeBuilderState;
    if (nodeBuilderState === void 0) {
      const { nodeBuilderCache } = this;
      const cacheKey = this.getForRenderCacheKey(renderObject);
      nodeBuilderState = nodeBuilderCache.get(cacheKey);
      if (nodeBuilderState === void 0) {
        const createNodeBuilder = (material) => {
          const nodeBuilder2 = this.backend.createNodeBuilder(renderObject.object, this.renderer);
          nodeBuilder2.scene = renderObject.scene;
          nodeBuilder2.material = material;
          nodeBuilder2.camera = renderObject.camera;
          nodeBuilder2.context.material = material;
          nodeBuilder2.lightsNode = renderObject.lightsNode;
          nodeBuilder2.environmentNode = this.getEnvironmentNode(renderObject.scene);
          nodeBuilder2.fogNode = this.getFogNode(renderObject.scene);
          nodeBuilder2.clippingContext = renderObject.clippingContext;
          if (this.renderer.getOutputRenderTarget() ? this.renderer.getOutputRenderTarget().multiview : false) {
            nodeBuilder2.enableMultiview();
          }
          return nodeBuilder2;
        };
        let nodeBuilder = createNodeBuilder(renderObject.material);
        try {
          nodeBuilder.build();
        } catch (e3) {
          nodeBuilder = createNodeBuilder(new NodeMaterial());
          nodeBuilder.build();
          error("TSL: " + e3);
        }
        nodeBuilderState = this._createNodeBuilderState(nodeBuilder);
        nodeBuilderCache.set(cacheKey, nodeBuilderState);
      }
      nodeBuilderState.usedTimes++;
      renderObjectData.nodeBuilderState = nodeBuilderState;
    }
    return nodeBuilderState;
  }
  /**
   * Deletes the given object from the internal data map
   *
   * @param {any} object - The object to delete.
   * @return {?Object} The deleted dictionary.
   */
  delete(object) {
    if (object.isRenderObject) {
      const nodeBuilderState = this.get(object).nodeBuilderState;
      nodeBuilderState.usedTimes--;
      if (nodeBuilderState.usedTimes === 0) {
        this.nodeBuilderCache.delete(this.getForRenderCacheKey(object));
      }
    }
    return super.delete(object);
  }
  /**
   * Returns a node builder state for the given compute node.
   *
   * @param {Node} computeNode - The compute node.
   * @return {NodeBuilderState} The node builder state.
   */
  getForCompute(computeNode) {
    const computeData = this.get(computeNode);
    let nodeBuilderState = computeData.nodeBuilderState;
    if (nodeBuilderState === void 0) {
      const nodeBuilder = this.backend.createNodeBuilder(computeNode, this.renderer);
      nodeBuilder.build();
      nodeBuilderState = this._createNodeBuilderState(nodeBuilder);
      computeData.nodeBuilderState = nodeBuilderState;
    }
    return nodeBuilderState;
  }
  /**
   * Creates a node builder state for the given node builder.
   *
   * @private
   * @param {NodeBuilder} nodeBuilder - The node builder.
   * @return {NodeBuilderState} The node builder state.
   */
  _createNodeBuilderState(nodeBuilder) {
    return new NodeBuilderState(
      nodeBuilder.vertexShader,
      nodeBuilder.fragmentShader,
      nodeBuilder.computeShader,
      nodeBuilder.getAttributesArray(),
      nodeBuilder.getBindings(),
      nodeBuilder.updateNodes,
      nodeBuilder.updateBeforeNodes,
      nodeBuilder.updateAfterNodes,
      nodeBuilder.observer,
      nodeBuilder.transforms
    );
  }
  /**
   * Returns an environment node for the current configured
   * scene environment.
   *
   * @param {Scene} scene - The scene.
   * @return {Node} A node representing the current scene environment.
   */
  getEnvironmentNode(scene3) {
    this.updateEnvironment(scene3);
    let environmentNode = null;
    if (scene3.environmentNode && scene3.environmentNode.isNode) {
      environmentNode = scene3.environmentNode;
    } else {
      const sceneData = this.get(scene3);
      if (sceneData.environmentNode) {
        environmentNode = sceneData.environmentNode;
      }
    }
    return environmentNode;
  }
  /**
   * Returns a background node for the current configured
   * scene background.
   *
   * @param {Scene} scene - The scene.
   * @return {Node} A node representing the current scene background.
   */
  getBackgroundNode(scene3) {
    this.updateBackground(scene3);
    let backgroundNode = null;
    if (scene3.backgroundNode && scene3.backgroundNode.isNode) {
      backgroundNode = scene3.backgroundNode;
    } else {
      const sceneData = this.get(scene3);
      if (sceneData.backgroundNode) {
        backgroundNode = sceneData.backgroundNode;
      }
    }
    return backgroundNode;
  }
  /**
   * Returns a fog node for the current configured scene fog.
   *
   * @param {Scene} scene - The scene.
   * @return {Node} A node representing the current scene fog.
   */
  getFogNode(scene3) {
    this.updateFog(scene3);
    return scene3.fogNode || this.get(scene3).fogNode || null;
  }
  /**
   * Returns a cache key for the given scene and lights node.
   * This key is used by `RenderObject` as a part of the dynamic
   * cache key (a key that must be checked every time the render
   * objects is drawn).
   *
   * @param {Scene} scene - The scene.
   * @param {LightsNode} lightsNode - The lights node.
   * @return {number} The cache key.
   */
  getCacheKey(scene3, lightsNode) {
    _chainKeys$2[0] = scene3;
    _chainKeys$2[1] = lightsNode;
    const callId = this.renderer.info.calls;
    const cacheKeyData = this.callHashCache.get(_chainKeys$2) || {};
    if (cacheKeyData.callId !== callId) {
      const environmentNode = this.getEnvironmentNode(scene3);
      const fogNode = this.getFogNode(scene3);
      if (lightsNode) _cacheKeyValues.push(lightsNode.getCacheKey(true));
      if (environmentNode) _cacheKeyValues.push(environmentNode.getCacheKey());
      if (fogNode) _cacheKeyValues.push(fogNode.getCacheKey());
      _cacheKeyValues.push(this.renderer.getOutputRenderTarget() && this.renderer.getOutputRenderTarget().multiview ? 1 : 0);
      _cacheKeyValues.push(this.renderer.shadowMap.enabled ? 1 : 0);
      _cacheKeyValues.push(this.renderer.shadowMap.type);
      cacheKeyData.callId = callId;
      cacheKeyData.cacheKey = hashArray(_cacheKeyValues);
      this.callHashCache.set(_chainKeys$2, cacheKeyData);
      _cacheKeyValues.length = 0;
    }
    _chainKeys$2.length = 0;
    return cacheKeyData.cacheKey;
  }
  /**
   * A boolean that indicates whether tone mapping should be enabled
   * or not.
   *
   * @type {boolean}
   */
  get isToneMappingState() {
    return this.renderer.getRenderTarget() ? false : true;
  }
  /**
   * If a scene background is configured, this method makes sure to
   * represent the background with a corresponding node-based implementation.
   *
   * @param {Scene} scene - The scene.
   */
  updateBackground(scene3) {
    const sceneData = this.get(scene3);
    const background = scene3.background;
    if (background) {
      const forceUpdate = scene3.backgroundBlurriness === 0 && sceneData.backgroundBlurriness > 0 || scene3.backgroundBlurriness > 0 && sceneData.backgroundBlurriness === 0;
      if (sceneData.background !== background || forceUpdate) {
        const backgroundNode = this.getCacheNode("background", background, () => {
          if (background.isCubeTexture === true || (background.mapping === EquirectangularReflectionMapping || background.mapping === EquirectangularRefractionMapping || background.mapping === CubeUVReflectionMapping)) {
            if (scene3.backgroundBlurriness > 0 || background.mapping === CubeUVReflectionMapping) {
              return pmremTexture(background);
            } else {
              let envMap;
              if (background.isCubeTexture === true) {
                envMap = cubeTexture(background);
              } else {
                envMap = texture(background);
              }
              return cubeMapNode(envMap);
            }
          } else if (background.isTexture === true) {
            return texture(background, screenUV.flipY()).setUpdateMatrix(true);
          } else if (background.isColor !== true) {
            error("WebGPUNodes: Unsupported background configuration.", background);
          }
        }, forceUpdate);
        sceneData.backgroundNode = backgroundNode;
        sceneData.background = background;
        sceneData.backgroundBlurriness = scene3.backgroundBlurriness;
      }
    } else if (sceneData.backgroundNode) {
      delete sceneData.backgroundNode;
      delete sceneData.background;
    }
  }
  /**
   * This method is part of the caching of nodes which are used to represents the
   * scene's background, fog or environment.
   *
   * @param {string} type - The type of object to cache.
   * @param {Object} object - The object.
   * @param {Function} callback - A callback that produces a node representation for the given object.
   * @param {boolean} [forceUpdate=false] - Whether an update should be enforced or not.
   * @return {Node} The node representation.
   */
  getCacheNode(type, object, callback, forceUpdate = false) {
    const nodeCache = this.cacheLib[type] || (this.cacheLib[type] = /* @__PURE__ */ new WeakMap());
    let node = nodeCache.get(object);
    if (node === void 0 || forceUpdate) {
      node = callback();
      nodeCache.set(object, node);
    }
    return node;
  }
  /**
   * If a scene fog is configured, this method makes sure to
   * represent the fog with a corresponding node-based implementation.
   *
   * @param {Scene} scene - The scene.
   */
  updateFog(scene3) {
    const sceneData = this.get(scene3);
    const sceneFog = scene3.fog;
    if (sceneFog) {
      if (sceneData.fog !== sceneFog) {
        const fogNode = this.getCacheNode("fog", sceneFog, () => {
          if (sceneFog.isFogExp2) {
            const color3 = reference("color", "color", sceneFog).setGroup(renderGroup);
            const density = reference("density", "float", sceneFog).setGroup(renderGroup);
            return fog(color3, densityFogFactor(density));
          } else if (sceneFog.isFog) {
            const color3 = reference("color", "color", sceneFog).setGroup(renderGroup);
            const near = reference("near", "float", sceneFog).setGroup(renderGroup);
            const far = reference("far", "float", sceneFog).setGroup(renderGroup);
            return fog(color3, rangeFogFactor(near, far));
          } else {
            error("Renderer: Unsupported fog configuration.", sceneFog);
          }
        });
        sceneData.fogNode = fogNode;
        sceneData.fog = sceneFog;
      }
    } else {
      delete sceneData.fogNode;
      delete sceneData.fog;
    }
  }
  /**
   * If a scene environment is configured, this method makes sure to
   * represent the environment with a corresponding node-based implementation.
   *
   * @param {Scene} scene - The scene.
   */
  updateEnvironment(scene3) {
    const sceneData = this.get(scene3);
    const environment = scene3.environment;
    if (environment) {
      if (sceneData.environment !== environment) {
        const environmentNode = this.getCacheNode("environment", environment, () => {
          if (environment.isCubeTexture === true) {
            return cubeTexture(environment);
          } else if (environment.isTexture === true) {
            return texture(environment);
          } else {
            error("Nodes: Unsupported environment configuration.", environment);
          }
        });
        sceneData.environmentNode = environmentNode;
        sceneData.environment = environment;
      }
    } else if (sceneData.environmentNode) {
      delete sceneData.environmentNode;
      delete sceneData.environment;
    }
  }
  getNodeFrame(renderer3 = this.renderer, scene3 = null, object = null, camera3 = null, material = null) {
    const nodeFrame = this.nodeFrame;
    nodeFrame.renderer = renderer3;
    nodeFrame.scene = scene3;
    nodeFrame.object = object;
    nodeFrame.camera = camera3;
    nodeFrame.material = material;
    return nodeFrame;
  }
  getNodeFrameForRender(renderObject) {
    return this.getNodeFrame(renderObject.renderer, renderObject.scene, renderObject.object, renderObject.camera, renderObject.material);
  }
  /**
   * Returns the current output cache key.
   *
   * @return {string} The output cache key.
   */
  getOutputCacheKey() {
    const renderer3 = this.renderer;
    return renderer3.toneMapping + "," + renderer3.currentColorSpace + "," + renderer3.xr.isPresenting;
  }
  /**
   * Checks if the output configuration (tone mapping and color space) for
   * the given target has changed.
   *
   * @param {Texture} outputTarget - The output target.
   * @return {boolean} Whether the output configuration has changed or not.
   */
  hasOutputChange(outputTarget) {
    const cacheKey = _outputNodeMap.get(outputTarget);
    return cacheKey !== this.getOutputCacheKey();
  }
  /**
   * Returns a node that represents the output configuration (tone mapping and
   * color space) for the current target.
   *
   * @param {Texture} outputTarget - The output target.
   * @return {Node} The output node.
   */
  getOutputNode(outputTarget) {
    const renderer3 = this.renderer;
    const cacheKey = this.getOutputCacheKey();
    const output2 = outputTarget.isArrayTexture ? texture3D(outputTarget, vec3(screenUV, builtin("gl_ViewID_OVR"))).renderOutput(renderer3.toneMapping, renderer3.currentColorSpace) : texture(outputTarget, screenUV).renderOutput(renderer3.toneMapping, renderer3.currentColorSpace);
    _outputNodeMap.set(outputTarget, cacheKey);
    return output2;
  }
  /**
   * Triggers the call of `updateBefore()` methods
   * for all nodes of the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   */
  updateBefore(renderObject) {
    const nodeBuilder = renderObject.getNodeBuilderState();
    for (const node of nodeBuilder.updateBeforeNodes) {
      this.getNodeFrameForRender(renderObject).updateBeforeNode(node);
    }
  }
  /**
   * Triggers the call of `updateAfter()` methods
   * for all nodes of the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   */
  updateAfter(renderObject) {
    const nodeBuilder = renderObject.getNodeBuilderState();
    for (const node of nodeBuilder.updateAfterNodes) {
      this.getNodeFrameForRender(renderObject).updateAfterNode(node);
    }
  }
  /**
   * Triggers the call of `update()` methods
   * for all nodes of the given compute node.
   *
   * @param {Node} computeNode - The compute node.
   */
  updateForCompute(computeNode) {
    const nodeFrame = this.getNodeFrame();
    const nodeBuilder = this.getForCompute(computeNode);
    for (const node of nodeBuilder.updateNodes) {
      nodeFrame.updateNode(node);
    }
  }
  /**
   * Triggers the call of `update()` methods
   * for all nodes of the given compute node.
   *
   * @param {RenderObject} renderObject - The render object.
   */
  updateForRender(renderObject) {
    const nodeFrame = this.getNodeFrameForRender(renderObject);
    const nodeBuilder = renderObject.getNodeBuilderState();
    for (const node of nodeBuilder.updateNodes) {
      nodeFrame.updateNode(node);
    }
  }
  /**
   * Returns `true` if the given render object requires a refresh.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {boolean} Whether the given render object requires a refresh or not.
   */
  needsRefresh(renderObject) {
    const nodeFrame = this.getNodeFrameForRender(renderObject);
    const monitor = renderObject.getMonitor();
    return monitor.needsRefresh(renderObject, nodeFrame);
  }
  /**
   * Frees the internal resources.
   */
  dispose() {
    super.dispose();
    this.nodeFrame = new NodeFrame();
    this.nodeBuilderCache = /* @__PURE__ */ new Map();
    this.cacheLib = {};
  }
};
var _plane2 = new Plane();
var ClippingContext = class _ClippingContext {
  /**
   * Constructs a new clipping context.
   *
   * @param {?ClippingContext} [parentContext=null] - A reference to the parent clipping context.
   */
  constructor(parentContext = null) {
    this.version = 0;
    this.clipIntersection = null;
    this.cacheKey = "";
    this.shadowPass = false;
    this.viewNormalMatrix = new Matrix3();
    this.clippingGroupContexts = /* @__PURE__ */ new WeakMap();
    this.intersectionPlanes = [];
    this.unionPlanes = [];
    this.parentVersion = null;
    if (parentContext !== null) {
      this.viewNormalMatrix = parentContext.viewNormalMatrix;
      this.clippingGroupContexts = parentContext.clippingGroupContexts;
      this.shadowPass = parentContext.shadowPass;
      this.viewMatrix = parentContext.viewMatrix;
    }
  }
  /**
   * Projects the given source clipping planes and writes the result into the
   * destination array.
   *
   * @param {Array<Plane>} source - The source clipping planes.
   * @param {Array<Vector4>} destination - The destination.
   * @param {number} offset - The offset.
   */
  projectPlanes(source, destination, offset) {
    const l2 = source.length;
    for (let i2 = 0; i2 < l2; i2++) {
      _plane2.copy(source[i2]).applyMatrix4(this.viewMatrix, this.viewNormalMatrix);
      const v2 = destination[offset + i2];
      const normal2 = _plane2.normal;
      v2.x = -normal2.x;
      v2.y = -normal2.y;
      v2.z = -normal2.z;
      v2.w = _plane2.constant;
    }
  }
  /**
   * Updates the root clipping context of a scene.
   *
   * @param {Scene} scene - The scene.
   * @param {Camera} camera - The camera that is used to render the scene.
   */
  updateGlobal(scene3, camera3) {
    this.shadowPass = scene3.overrideMaterial !== null && scene3.overrideMaterial.isShadowPassMaterial;
    this.viewMatrix = camera3.matrixWorldInverse;
    this.viewNormalMatrix.getNormalMatrix(this.viewMatrix);
  }
  /**
   * Updates the clipping context.
   *
   * @param {ClippingContext} parentContext - The parent context.
   * @param {ClippingGroup} clippingGroup - The clipping group this context belongs to.
   */
  update(parentContext, clippingGroup) {
    let update9 = false;
    if (parentContext.version !== this.parentVersion) {
      this.intersectionPlanes = Array.from(parentContext.intersectionPlanes);
      this.unionPlanes = Array.from(parentContext.unionPlanes);
      this.parentVersion = parentContext.version;
    }
    if (this.clipIntersection !== clippingGroup.clipIntersection) {
      this.clipIntersection = clippingGroup.clipIntersection;
      if (this.clipIntersection) {
        this.unionPlanes.length = parentContext.unionPlanes.length;
      } else {
        this.intersectionPlanes.length = parentContext.intersectionPlanes.length;
      }
    }
    const srcClippingPlanes = clippingGroup.clippingPlanes;
    const l2 = srcClippingPlanes.length;
    let dstClippingPlanes;
    let offset;
    if (this.clipIntersection) {
      dstClippingPlanes = this.intersectionPlanes;
      offset = parentContext.intersectionPlanes.length;
    } else {
      dstClippingPlanes = this.unionPlanes;
      offset = parentContext.unionPlanes.length;
    }
    if (dstClippingPlanes.length !== offset + l2) {
      dstClippingPlanes.length = offset + l2;
      for (let i2 = 0; i2 < l2; i2++) {
        dstClippingPlanes[offset + i2] = new Vector4();
      }
      update9 = true;
    }
    this.projectPlanes(srcClippingPlanes, dstClippingPlanes, offset);
    if (update9) {
      this.version++;
      this.cacheKey = `${this.intersectionPlanes.length}:${this.unionPlanes.length}`;
    }
  }
  /**
   * Returns a clipping context for the given clipping group.
   *
   * @param {ClippingGroup} clippingGroup - The clipping group.
   * @return {ClippingContext} The clipping context.
   */
  getGroupContext(clippingGroup) {
    if (this.shadowPass && !clippingGroup.clipShadows) return this;
    let context2 = this.clippingGroupContexts.get(clippingGroup);
    if (context2 === void 0) {
      context2 = new _ClippingContext(this);
      this.clippingGroupContexts.set(clippingGroup, context2);
    }
    context2.update(this, clippingGroup);
    return context2;
  }
  /**
   * The count of union clipping planes.
   *
   * @type {number}
   * @readonly
   */
  get unionClippingCount() {
    return this.unionPlanes.length;
  }
};
var RenderBundle = class {
  /**
   * Constructs a new bundle group.
   *
   * @param {BundleGroup} bundleGroup - The bundle group.
   * @param {Camera} camera - The camera the bundle group is rendered with.
   */
  constructor(bundleGroup, camera3) {
    this.bundleGroup = bundleGroup;
    this.camera = camera3;
  }
};
var _chainKeys$1 = [];
var RenderBundles = class {
  /**
   * Constructs a new render bundle management component.
   */
  constructor() {
    this.bundles = new ChainMap();
  }
  /**
   * Returns a render bundle for the given bundle group and camera.
   *
   * @param {BundleGroup} bundleGroup - The bundle group.
   * @param {Camera} camera - The camera the bundle group is rendered with.
   * @return {RenderBundle} The render bundle.
   */
  get(bundleGroup, camera3) {
    const bundles = this.bundles;
    _chainKeys$1[0] = bundleGroup;
    _chainKeys$1[1] = camera3;
    let bundle = bundles.get(_chainKeys$1);
    if (bundle === void 0) {
      bundle = new RenderBundle(bundleGroup, camera3);
      bundles.set(_chainKeys$1, bundle);
    }
    _chainKeys$1.length = 0;
    return bundle;
  }
  /**
   * Frees all internal resources.
   */
  dispose() {
    this.bundles = new ChainMap();
  }
};
var NodeLibrary = class {
  /**
   * Constructs a new node library.
   */
  constructor() {
    this.lightNodes = /* @__PURE__ */ new WeakMap();
    this.materialNodes = /* @__PURE__ */ new Map();
    this.toneMappingNodes = /* @__PURE__ */ new Map();
  }
  /**
   * Returns a matching node material instance for the given material object.
   *
   * This method also assigns/copies the properties of the given material object
   * to the node material. This is done to make sure the current material
   * configuration carries over to the node version.
   *
   * @param {Material} material - A material.
   * @return {NodeMaterial} The corresponding node material.
   */
  fromMaterial(material) {
    if (material.isNodeMaterial) return material;
    let nodeMaterial = null;
    const nodeMaterialClass = this.getMaterialNodeClass(material.type);
    if (nodeMaterialClass !== null) {
      nodeMaterial = new nodeMaterialClass();
      for (const key in material) {
        nodeMaterial[key] = material[key];
      }
    }
    return nodeMaterial;
  }
  /**
   * Adds a tone mapping node function for a tone mapping technique (constant).
   *
   * @param {Function} toneMappingNode - The tone mapping node function.
   * @param {number} toneMapping - The tone mapping.
   */
  addToneMapping(toneMappingNode, toneMapping2) {
    this.addType(toneMappingNode, toneMapping2, this.toneMappingNodes);
  }
  /**
   * Returns a tone mapping node function for a tone mapping technique (constant).
   *
   * @param {number} toneMapping - The tone mapping.
   * @return {?Function} The tone mapping node function. Returns `null` if no node function is found.
   */
  getToneMappingFunction(toneMapping2) {
    return this.toneMappingNodes.get(toneMapping2) || null;
  }
  /**
   * Returns a node material class definition for a material type.
   *
   * @param {string} materialType - The material type.
   * @return {?NodeMaterial.constructor} The node material class definition. Returns `null` if no node material is found.
   */
  getMaterialNodeClass(materialType) {
    return this.materialNodes.get(materialType) || null;
  }
  /**
   * Adds a node material class definition for a given material type.
   *
   * @param {NodeMaterial.constructor} materialNodeClass - The node material class definition.
   * @param {string} materialClassType - The material type.
   */
  addMaterial(materialNodeClass, materialClassType) {
    this.addType(materialNodeClass, materialClassType, this.materialNodes);
  }
  /**
   * Returns a light node class definition for a light class definition.
   *
   * @param {Light.constructor} light - The light class definition.
   * @return {?AnalyticLightNode.constructor} The light node class definition. Returns `null` if no light node is found.
   */
  getLightNodeClass(light) {
    return this.lightNodes.get(light) || null;
  }
  /**
   * Adds a light node class definition for a given light class definition.
   *
   * @param {AnalyticLightNode.constructor} lightNodeClass - The light node class definition.
   * @param {Light.constructor} lightClass - The light class definition.
   */
  addLight(lightNodeClass, lightClass) {
    this.addClass(lightNodeClass, lightClass, this.lightNodes);
  }
  /**
   * Adds a node class definition for the given type to the provided type library.
   *
   * @param {Node.constructor} nodeClass - The node class definition.
   * @param {number|string} type - The object type.
   * @param {Map<number|string,Node.constructor>} library - The type library.
   */
  addType(nodeClass, type, library) {
    if (library.has(type)) {
      warn(`Redefinition of node ${type}`);
      return;
    }
    if (typeof nodeClass !== "function") throw new Error(`Node class ${nodeClass.name} is not a class.`);
    if (typeof type === "function" || typeof type === "object") throw new Error(`Base class ${type} is not a class.`);
    library.set(type, nodeClass);
  }
  /**
   * Adds a node class definition for the given class definition to the provided type library.
   *
   * @param {Node.constructor} nodeClass - The node class definition.
   * @param {Node.constructor} baseClass - The class definition.
   * @param {WeakMap<Node.constructor, Node.constructor>} library - The type library.
   */
  addClass(nodeClass, baseClass, library) {
    if (library.has(baseClass)) {
      warn(`Redefinition of node ${baseClass.name}`);
      return;
    }
    if (typeof nodeClass !== "function") throw new Error(`Node class ${nodeClass.name} is not a class.`);
    if (typeof baseClass !== "function") throw new Error(`Base class ${baseClass.name} is not a class.`);
    library.set(baseClass, nodeClass);
  }
};
var _defaultLights = new LightsNode();
var _chainKeys = [];
var Lighting = class extends ChainMap {
  /**
   * Constructs a lighting management component.
   */
  constructor() {
    super();
  }
  /**
   * Creates a new lights node for the given array of lights.
   *
   * @param {Array<Light>} lights - The render object.
   * @return {LightsNode} The lights node.
   */
  createNode(lights2 = []) {
    return new LightsNode().setLights(lights2);
  }
  /**
   * Returns a lights node for the given scene and camera.
   *
   * @param {Scene} scene - The scene.
   * @param {Camera} camera - The camera.
   * @return {LightsNode} The lights node.
   */
  getNode(scene3, camera3) {
    if (scene3.isQuadMesh) return _defaultLights;
    _chainKeys[0] = scene3;
    _chainKeys[1] = camera3;
    let node = this.get(_chainKeys);
    if (node === void 0) {
      node = this.createNode();
      this.set(_chainKeys, node);
    }
    _chainKeys.length = 0;
    return node;
  }
};
var XRRenderTarget = class extends RenderTarget {
  /**
   * Constructs a new XR render target.
   *
   * @param {number} [width=1] - The width of the render target.
   * @param {number} [height=1] - The height of the render target.
   * @param {Object} [options={}] - The configuration options.
   */
  constructor(width = 1, height = 1, options = {}) {
    super(width, height, options);
    this.isXRRenderTarget = true;
    this._hasExternalTextures = false;
    this._autoAllocateDepthBuffer = true;
    this._isOpaqueFramebuffer = false;
  }
  copy(source) {
    super.copy(source);
    this._hasExternalTextures = source._hasExternalTextures;
    this._autoAllocateDepthBuffer = source._autoAllocateDepthBuffer;
    this._isOpaqueFramebuffer = source._isOpaqueFramebuffer;
    return this;
  }
};
var _cameraLPos = new Vector3();
var _cameraRPos = new Vector3();
var XRManager = class extends EventDispatcher {
  /**
   * Constructs a new XR manager.
   *
   * @param {Renderer} renderer - The renderer.
   * @param {boolean} [multiview=false] - Enables multiview if the device supports it.
   */
  constructor(renderer3, multiview = false) {
    super();
    this.enabled = false;
    this.isPresenting = false;
    this.cameraAutoUpdate = true;
    this._renderer = renderer3;
    this._cameraL = new PerspectiveCamera();
    this._cameraL.viewport = new Vector4();
    this._cameraR = new PerspectiveCamera();
    this._cameraR.viewport = new Vector4();
    this._cameras = [this._cameraL, this._cameraR];
    this._cameraXR = new ArrayCamera();
    this._currentDepthNear = null;
    this._currentDepthFar = null;
    this._controllers = [];
    this._controllerInputSources = [];
    this._xrRenderTarget = null;
    this._layers = [];
    this._sessionUsesLayers = false;
    this._supportsGlBinding = typeof XRWebGLBinding !== "undefined";
    this._frameBufferTargets = null;
    this._createXRLayer = createXRLayer.bind(this);
    this._gl = null;
    this._currentAnimationContext = null;
    this._currentAnimationLoop = null;
    this._currentPixelRatio = null;
    this._currentSize = new Vector2();
    this._onSessionEvent = onSessionEvent.bind(this);
    this._onSessionEnd = onSessionEnd.bind(this);
    this._onInputSourcesChange = onInputSourcesChange.bind(this);
    this._onAnimationFrame = onAnimationFrame.bind(this);
    this._referenceSpace = null;
    this._referenceSpaceType = "local-floor";
    this._customReferenceSpace = null;
    this._framebufferScaleFactor = 1;
    this._foveation = 1;
    this._session = null;
    this._glBaseLayer = null;
    this._glBinding = null;
    this._glProjLayer = null;
    this._xrFrame = null;
    this._supportsLayers = this._supportsGlBinding && "createProjectionLayer" in XRWebGLBinding.prototype;
    this._useMultiviewIfPossible = multiview;
    this._useMultiview = false;
  }
  /**
   * Returns an instance of `THREE.Group` that represents the transformation
   * of a XR controller in target ray space. The requested controller is defined
   * by the given index.
   *
   * @param {number} index - The index of the XR controller.
   * @return {Group} A group that represents the controller's transformation.
   */
  getController(index8) {
    const controller = this._getController(index8);
    return controller.getTargetRaySpace();
  }
  /**
   * Returns an instance of `THREE.Group` that represents the transformation
   * of a XR controller in grip space. The requested controller is defined
   * by the given index.
   *
   * @param {number} index - The index of the XR controller.
   * @return {Group} A group that represents the controller's transformation.
   */
  getControllerGrip(index8) {
    const controller = this._getController(index8);
    return controller.getGripSpace();
  }
  /**
   * Returns an instance of `THREE.Group` that represents the transformation
   * of a XR controller in hand space. The requested controller is defined
   * by the given index.
   *
   * @param {number} index - The index of the XR controller.
   * @return {Group} A group that represents the controller's transformation.
   */
  getHand(index8) {
    const controller = this._getController(index8);
    return controller.getHandSpace();
  }
  /**
   * Returns the foveation value.
   *
   * @return {number|undefined} The foveation value. Returns `undefined` if no base or projection layer is defined.
   */
  getFoveation() {
    if (this._glProjLayer === null && this._glBaseLayer === null) {
      return void 0;
    }
    return this._foveation;
  }
  /**
   * Sets the foveation value.
   *
   * @param {number} foveation - A number in the range `[0,1]` where `0` means no foveation (full resolution)
   * and `1` means maximum foveation (the edges render at lower resolution).
   */
  setFoveation(foveation) {
    this._foveation = foveation;
    if (this._glProjLayer !== null) {
      this._glProjLayer.fixedFoveation = foveation;
    }
    if (this._glBaseLayer !== null && this._glBaseLayer.fixedFoveation !== void 0) {
      this._glBaseLayer.fixedFoveation = foveation;
    }
  }
  /**
   * Returns the framebuffer scale factor.
   *
   * @return {number} The framebuffer scale factor.
   */
  getFramebufferScaleFactor() {
    return this._framebufferScaleFactor;
  }
  /**
   * Sets the framebuffer scale factor.
   *
   * This method can not be used during a XR session.
   *
   * @param {number} factor - The framebuffer scale factor.
   */
  setFramebufferScaleFactor(factor) {
    this._framebufferScaleFactor = factor;
    if (this.isPresenting === true) {
      warn("XRManager: Cannot change framebuffer scale while presenting.");
    }
  }
  /**
   * Returns the reference space type.
   *
   * @return {XRReferenceSpaceType} The reference space type.
   */
  getReferenceSpaceType() {
    return this._referenceSpaceType;
  }
  /**
   * Sets the reference space type.
   *
   * This method can not be used during a XR session.
   *
   * @param {XRReferenceSpaceType} type - The reference space type.
   */
  setReferenceSpaceType(type) {
    this._referenceSpaceType = type;
    if (this.isPresenting === true) {
      warn("XRManager: Cannot change reference space type while presenting.");
    }
  }
  /**
   * Returns the XR reference space.
   *
   * @return {XRReferenceSpace} The XR reference space.
   */
  getReferenceSpace() {
    return this._customReferenceSpace || this._referenceSpace;
  }
  /**
   * Sets a custom XR reference space.
   *
   * @param {XRReferenceSpace} space - The XR reference space.
   */
  setReferenceSpace(space) {
    this._customReferenceSpace = space;
  }
  /**
   * Returns the XR camera.
   *
   * @return {ArrayCamera} The XR camera.
   */
  getCamera() {
    return this._cameraXR;
  }
  /**
   * Returns the environment blend mode from the current XR session.
   *
   * @return {'opaque'|'additive'|'alpha-blend'|undefined} The environment blend mode. Returns `undefined` when used outside of a XR session.
   */
  getEnvironmentBlendMode() {
    if (this._session !== null) {
      return this._session.environmentBlendMode;
    }
  }
  /**
   * Returns the current XR binding.
   *
   * Creates a new binding if needed and the browser is
   * capable of doing so.
   *
   * @return {?XRWebGLBinding} The XR binding. Returns `null` if one cannot be created.
   */
  getBinding() {
    if (this._glBinding === null && this._supportsGlBinding) {
      this._glBinding = new XRWebGLBinding(this._session, this._gl);
    }
    return this._glBinding;
  }
  /**
   * Returns the current XR frame.
   *
   * @return {?XRFrame} The XR frame. Returns `null` when used outside a XR session.
   */
  getFrame() {
    return this._xrFrame;
  }
  /**
   * Returns `true` if the engine renders to a multiview target.
   *
   * @return {boolean} Whether the engine renders to a multiview render target or not.
   */
  useMultiview() {
    return this._useMultiview;
  }
  /**
   * This method can be used in XR applications to create a quadratic layer that presents a separate
   * rendered scene.
   *
   * @param {number} width - The width of the layer plane in world units.
   * @param {number} height - The height of the layer plane in world units.
   * @param {Vector3} translation - The position/translation of the layer plane in world units.
   * @param {Quaternion} quaternion - The orientation of the layer plane expressed as a quaternion.
   * @param {number} pixelwidth - The width of the layer's render target in pixels.
   * @param {number} pixelheight - The height of the layer's render target in pixels.
   * @param {Function} rendercall - A callback function that renders the layer. Similar to code in
   * the default animation loop, this method can be used to update/transform 3D object in the layer's scene.
   * @param {Object} [attributes={}] - Allows to configure the layer's render target.
   * @return {Mesh} A mesh representing the quadratic XR layer. This mesh should be added to the XR scene.
   */
  createQuadLayer(width, height, translation, quaternion, pixelwidth, pixelheight, rendercall, attributes = {}) {
    const geometry = new PlaneGeometry(width, height);
    const renderTarget = new XRRenderTarget(
      pixelwidth,
      pixelheight,
      {
        format: RGBAFormat,
        type: UnsignedByteType,
        depthTexture: new DepthTexture(
          pixelwidth,
          pixelheight,
          attributes.stencil ? UnsignedInt248Type : UnsignedIntType,
          void 0,
          void 0,
          void 0,
          void 0,
          void 0,
          void 0,
          attributes.stencil ? DepthStencilFormat : DepthFormat
        ),
        stencilBuffer: attributes.stencil,
        resolveDepthBuffer: false,
        resolveStencilBuffer: false
      }
    );
    renderTarget._autoAllocateDepthBuffer = true;
    const material = new MeshBasicMaterial({ color: 16777215, side: FrontSide });
    material.map = renderTarget.texture;
    material.map.offset.y = 1;
    material.map.repeat.y = -1;
    const plane = new Mesh(geometry, material);
    plane.position.copy(translation);
    plane.quaternion.copy(quaternion);
    const layer = {
      type: "quad",
      width,
      height,
      translation,
      quaternion,
      pixelwidth,
      pixelheight,
      plane,
      material,
      rendercall,
      renderTarget
    };
    this._layers.push(layer);
    if (this._session !== null) {
      layer.plane.material = new MeshBasicMaterial({ color: 16777215, side: FrontSide });
      layer.plane.material.blending = CustomBlending;
      layer.plane.material.blendEquation = AddEquation;
      layer.plane.material.blendSrc = ZeroFactor;
      layer.plane.material.blendDst = ZeroFactor;
      layer.xrlayer = this._createXRLayer(layer);
      const xrlayers = this._session.renderState.layers;
      xrlayers.unshift(layer.xrlayer);
      this._session.updateRenderState({ layers: xrlayers });
    } else {
      renderTarget.isXRRenderTarget = false;
    }
    return plane;
  }
  /**
   * This method can be used in XR applications to create a cylindrical layer that presents a separate
   * rendered scene.
   *
   * @param {number} radius - The radius of the cylinder in world units.
   * @param {number} centralAngle - The central angle of the cylinder in radians.
   * @param {number} aspectratio - The aspect ratio.
   * @param {Vector3} translation - The position/translation of the layer plane in world units.
   * @param {Quaternion} quaternion - The orientation of the layer plane expressed as a quaternion.
   * @param {number} pixelwidth - The width of the layer's render target in pixels.
   * @param {number} pixelheight - The height of the layer's render target in pixels.
   * @param {Function} rendercall - A callback function that renders the layer. Similar to code in
   * the default animation loop, this method can be used to update/transform 3D object in the layer's scene.
   * @param {Object} [attributes={}] - Allows to configure the layer's render target.
   * @return {Mesh} A mesh representing the cylindrical XR layer. This mesh should be added to the XR scene.
   */
  createCylinderLayer(radius, centralAngle, aspectratio, translation, quaternion, pixelwidth, pixelheight, rendercall, attributes = {}) {
    const geometry = new CylinderGeometry(radius, radius, radius * centralAngle / aspectratio, 64, 64, true, Math.PI - centralAngle / 2, centralAngle);
    const renderTarget = new XRRenderTarget(
      pixelwidth,
      pixelheight,
      {
        format: RGBAFormat,
        type: UnsignedByteType,
        depthTexture: new DepthTexture(
          pixelwidth,
          pixelheight,
          attributes.stencil ? UnsignedInt248Type : UnsignedIntType,
          void 0,
          void 0,
          void 0,
          void 0,
          void 0,
          void 0,
          attributes.stencil ? DepthStencilFormat : DepthFormat
        ),
        stencilBuffer: attributes.stencil,
        resolveDepthBuffer: false,
        resolveStencilBuffer: false
      }
    );
    renderTarget._autoAllocateDepthBuffer = true;
    const material = new MeshBasicMaterial({ color: 16777215, side: BackSide });
    material.map = renderTarget.texture;
    material.map.offset.y = 1;
    material.map.repeat.y = -1;
    const plane = new Mesh(geometry, material);
    plane.position.copy(translation);
    plane.quaternion.copy(quaternion);
    const layer = {
      type: "cylinder",
      radius,
      centralAngle,
      aspectratio,
      translation,
      quaternion,
      pixelwidth,
      pixelheight,
      plane,
      material,
      rendercall,
      renderTarget
    };
    this._layers.push(layer);
    if (this._session !== null) {
      layer.plane.material = new MeshBasicMaterial({ color: 16777215, side: BackSide });
      layer.plane.material.blending = CustomBlending;
      layer.plane.material.blendEquation = AddEquation;
      layer.plane.material.blendSrc = ZeroFactor;
      layer.plane.material.blendDst = ZeroFactor;
      layer.xrlayer = this._createXRLayer(layer);
      const xrlayers = this._session.renderState.layers;
      xrlayers.unshift(layer.xrlayer);
      this._session.updateRenderState({ layers: xrlayers });
    } else {
      renderTarget.isXRRenderTarget = false;
    }
    return plane;
  }
  /**
   * Renders the XR layers that have been previously added to the scene.
   *
   * This method is usually called in your animation loop before rendering
   * the actual scene via `renderer.render( scene, camera );`.
   */
  renderLayers() {
    const translationObject = new Vector3();
    const quaternionObject = new Quaternion();
    const renderer3 = this._renderer;
    const wasPresenting = this.isPresenting;
    const rendererOutputTarget = renderer3.getOutputRenderTarget();
    const rendererFramebufferTarget = renderer3._frameBufferTarget;
    this.isPresenting = false;
    const rendererSize = new Vector2();
    renderer3.getSize(rendererSize);
    const rendererQuad = renderer3._quad;
    for (const layer of this._layers) {
      layer.renderTarget.isXRRenderTarget = this._session !== null;
      layer.renderTarget._hasExternalTextures = layer.renderTarget.isXRRenderTarget;
      if (layer.renderTarget.isXRRenderTarget && this._sessionUsesLayers) {
        layer.xrlayer.transform = new XRRigidTransform(layer.plane.getWorldPosition(translationObject), layer.plane.getWorldQuaternion(quaternionObject));
        const glSubImage = this._glBinding.getSubImage(layer.xrlayer, this._xrFrame);
        renderer3.backend.setXRRenderTargetTextures(
          layer.renderTarget,
          glSubImage.colorTexture,
          void 0
        );
        renderer3._setXRLayerSize(layer.renderTarget.width, layer.renderTarget.height);
        renderer3.setOutputRenderTarget(layer.renderTarget);
        renderer3.setRenderTarget(null);
        renderer3._frameBufferTarget = null;
        this._frameBufferTargets || (this._frameBufferTargets = /* @__PURE__ */ new WeakMap());
        const { frameBufferTarget, quad } = this._frameBufferTargets.get(layer.renderTarget) || { frameBufferTarget: null, quad: null };
        if (!frameBufferTarget) {
          renderer3._quad = new QuadMesh(new NodeMaterial());
          this._frameBufferTargets.set(layer.renderTarget, { frameBufferTarget: renderer3._getFrameBufferTarget(), quad: renderer3._quad });
        } else {
          renderer3._frameBufferTarget = frameBufferTarget;
          renderer3._quad = quad;
        }
        layer.rendercall();
        renderer3._frameBufferTarget = null;
      } else {
        renderer3.setRenderTarget(layer.renderTarget);
        layer.rendercall();
      }
    }
    renderer3.setRenderTarget(null);
    renderer3.setOutputRenderTarget(rendererOutputTarget);
    renderer3._frameBufferTarget = rendererFramebufferTarget;
    renderer3._setXRLayerSize(rendererSize.x, rendererSize.y);
    renderer3._quad = rendererQuad;
    this.isPresenting = wasPresenting;
  }
  /**
   * Returns the current XR session.
   *
   * @return {?XRSession} The XR session. Returns `null` when used outside a XR session.
   */
  getSession() {
    return this._session;
  }
  /**
   * After a XR session has been requested usually with one of the `*Button` modules, it
   * is injected into the renderer with this method. This method triggers the start of
   * the actual XR rendering.
   *
   * @async
   * @param {XRSession} session - The XR session to set.
   * @return {Promise} A Promise that resolves when the session has been set.
   */
  async setSession(session) {
    const renderer3 = this._renderer;
    const backend = renderer3.backend;
    this._gl = renderer3.getContext();
    const gl = this._gl;
    const attributes = gl.getContextAttributes();
    this._session = session;
    if (session !== null) {
      if (backend.isWebGPUBackend === true) throw new Error('THREE.XRManager: XR is currently not supported with a WebGPU backend. Use WebGL by passing "{ forceWebGL: true }" to the constructor of the renderer.');
      session.addEventListener("select", this._onSessionEvent);
      session.addEventListener("selectstart", this._onSessionEvent);
      session.addEventListener("selectend", this._onSessionEvent);
      session.addEventListener("squeeze", this._onSessionEvent);
      session.addEventListener("squeezestart", this._onSessionEvent);
      session.addEventListener("squeezeend", this._onSessionEvent);
      session.addEventListener("end", this._onSessionEnd);
      session.addEventListener("inputsourceschange", this._onInputSourcesChange);
      await backend.makeXRCompatible();
      this._currentPixelRatio = renderer3.getPixelRatio();
      renderer3.getSize(this._currentSize);
      this._currentAnimationContext = renderer3._animation.getContext();
      this._currentAnimationLoop = renderer3._animation.getAnimationLoop();
      renderer3._animation.stop();
      if (this._supportsLayers === true) {
        let depthFormat = null;
        let depthType = null;
        let glDepthFormat = null;
        if (renderer3.depth) {
          glDepthFormat = renderer3.stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;
          depthFormat = renderer3.stencil ? DepthStencilFormat : DepthFormat;
          depthType = renderer3.stencil ? UnsignedInt248Type : UnsignedIntType;
        }
        const projectionlayerInit = {
          colorFormat: gl.RGBA8,
          depthFormat: glDepthFormat,
          scaleFactor: this._framebufferScaleFactor,
          clearOnAccess: false
        };
        if (this._useMultiviewIfPossible && renderer3.hasFeature("OVR_multiview2")) {
          projectionlayerInit.textureType = "texture-array";
          this._useMultiview = true;
        }
        this._glBinding = this.getBinding();
        const glProjLayer = this._glBinding.createProjectionLayer(projectionlayerInit);
        const layersArray = [glProjLayer];
        this._glProjLayer = glProjLayer;
        renderer3.setPixelRatio(1);
        renderer3._setXRLayerSize(glProjLayer.textureWidth, glProjLayer.textureHeight);
        const depth2 = this._useMultiview ? 2 : 1;
        const depthTexture = new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, void 0, void 0, void 0, void 0, void 0, void 0, depthFormat, depth2);
        this._xrRenderTarget = new XRRenderTarget(
          glProjLayer.textureWidth,
          glProjLayer.textureHeight,
          {
            format: RGBAFormat,
            type: UnsignedByteType,
            colorSpace: renderer3.outputColorSpace,
            depthTexture,
            stencilBuffer: renderer3.stencil,
            samples: attributes.antialias ? 4 : 0,
            resolveDepthBuffer: glProjLayer.ignoreDepthValues === false,
            resolveStencilBuffer: glProjLayer.ignoreDepthValues === false,
            depth: this._useMultiview ? 2 : 1,
            multiview: this._useMultiview
          }
        );
        this._xrRenderTarget._hasExternalTextures = true;
        this._xrRenderTarget.depth = this._useMultiview ? 2 : 1;
        this._sessionUsesLayers = session.enabledFeatures.includes("layers");
        this._referenceSpace = await session.requestReferenceSpace(this.getReferenceSpaceType());
        if (this._sessionUsesLayers) {
          for (const layer of this._layers) {
            layer.plane.material = new MeshBasicMaterial({ color: 16777215, side: layer.type === "cylinder" ? BackSide : FrontSide });
            layer.plane.material.blending = CustomBlending;
            layer.plane.material.blendEquation = AddEquation;
            layer.plane.material.blendSrc = ZeroFactor;
            layer.plane.material.blendDst = ZeroFactor;
            layer.xrlayer = this._createXRLayer(layer);
            layersArray.unshift(layer.xrlayer);
          }
        }
        session.updateRenderState({ layers: layersArray });
      } else {
        const layerInit = {
          antialias: renderer3.currentSamples > 0,
          alpha: true,
          depth: renderer3.depth,
          stencil: renderer3.stencil,
          framebufferScaleFactor: this.getFramebufferScaleFactor()
        };
        const glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
        this._glBaseLayer = glBaseLayer;
        session.updateRenderState({ baseLayer: glBaseLayer });
        renderer3.setPixelRatio(1);
        renderer3._setXRLayerSize(glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight);
        this._xrRenderTarget = new XRRenderTarget(
          glBaseLayer.framebufferWidth,
          glBaseLayer.framebufferHeight,
          {
            format: RGBAFormat,
            type: UnsignedByteType,
            colorSpace: renderer3.outputColorSpace,
            stencilBuffer: renderer3.stencil,
            resolveDepthBuffer: glBaseLayer.ignoreDepthValues === false,
            resolveStencilBuffer: glBaseLayer.ignoreDepthValues === false
          }
        );
        this._xrRenderTarget._isOpaqueFramebuffer = true;
        this._referenceSpace = await session.requestReferenceSpace(this.getReferenceSpaceType());
      }
      this.setFoveation(this.getFoveation());
      renderer3._animation.setAnimationLoop(this._onAnimationFrame);
      renderer3._animation.setContext(session);
      renderer3._animation.start();
      this.isPresenting = true;
      this.dispatchEvent({ type: "sessionstart" });
    }
  }
  /**
   * This method is called by the renderer per frame and updates the XR camera
   * and it sub cameras based on the given camera. The given camera is the "user"
   * camera created on application level and used for non-XR rendering.
   *
   * @param {PerspectiveCamera} camera - The camera.
   */
  updateCamera(camera3) {
    const session = this._session;
    if (session === null) return;
    const depthNear = camera3.near;
    const depthFar = camera3.far;
    const cameraXR = this._cameraXR;
    const cameraL = this._cameraL;
    const cameraR = this._cameraR;
    cameraXR.near = cameraR.near = cameraL.near = depthNear;
    cameraXR.far = cameraR.far = cameraL.far = depthFar;
    cameraXR.isMultiViewCamera = this._useMultiview;
    if (this._currentDepthNear !== cameraXR.near || this._currentDepthFar !== cameraXR.far) {
      session.updateRenderState({
        depthNear: cameraXR.near,
        depthFar: cameraXR.far
      });
      this._currentDepthNear = cameraXR.near;
      this._currentDepthFar = cameraXR.far;
    }
    cameraXR.layers.mask = camera3.layers.mask | 6;
    cameraL.layers.mask = cameraXR.layers.mask & 3;
    cameraR.layers.mask = cameraXR.layers.mask & 5;
    const parent2 = camera3.parent;
    const cameras = cameraXR.cameras;
    updateCamera(cameraXR, parent2);
    for (let i2 = 0; i2 < cameras.length; i2++) {
      updateCamera(cameras[i2], parent2);
    }
    if (cameras.length === 2) {
      setProjectionFromUnion(cameraXR, cameraL, cameraR);
    } else {
      cameraXR.projectionMatrix.copy(cameraL.projectionMatrix);
    }
    updateUserCamera(camera3, cameraXR, parent2);
  }
  /**
   * Returns a WebXR controller for the given controller index.
   *
   * @private
   * @param {number} index - The controller index.
   * @return {WebXRController} The XR controller.
   */
  _getController(index8) {
    let controller = this._controllers[index8];
    if (controller === void 0) {
      controller = new WebXRController();
      this._controllers[index8] = controller;
    }
    return controller;
  }
};
function setProjectionFromUnion(camera3, cameraL, cameraR) {
  _cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);
  _cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);
  const ipd = _cameraLPos.distanceTo(_cameraRPos);
  const projL = cameraL.projectionMatrix.elements;
  const projR = cameraR.projectionMatrix.elements;
  const near = projL[14] / (projL[10] - 1);
  const far = projL[14] / (projL[10] + 1);
  const topFov = (projL[9] + 1) / projL[5];
  const bottomFov = (projL[9] - 1) / projL[5];
  const leftFov = (projL[8] - 1) / projL[0];
  const rightFov = (projR[8] + 1) / projR[0];
  const left = near * leftFov;
  const right = near * rightFov;
  const zOffset = ipd / (-leftFov + rightFov);
  const xOffset = zOffset * -leftFov;
  cameraL.matrixWorld.decompose(camera3.position, camera3.quaternion, camera3.scale);
  camera3.translateX(xOffset);
  camera3.translateZ(zOffset);
  camera3.matrixWorld.compose(camera3.position, camera3.quaternion, camera3.scale);
  camera3.matrixWorldInverse.copy(camera3.matrixWorld).invert();
  if (projL[10] === -1) {
    camera3.projectionMatrix.copy(cameraL.projectionMatrix);
    camera3.projectionMatrixInverse.copy(cameraL.projectionMatrixInverse);
  } else {
    const near2 = near + zOffset;
    const far2 = far + zOffset;
    const left2 = left - xOffset;
    const right2 = right + (ipd - xOffset);
    const top2 = topFov * far / far2 * near2;
    const bottom2 = bottomFov * far / far2 * near2;
    camera3.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
    camera3.projectionMatrixInverse.copy(camera3.projectionMatrix).invert();
  }
}
function updateCamera(camera3, parent2) {
  if (parent2 === null) {
    camera3.matrixWorld.copy(camera3.matrix);
  } else {
    camera3.matrixWorld.multiplyMatrices(parent2.matrixWorld, camera3.matrix);
  }
  camera3.matrixWorldInverse.copy(camera3.matrixWorld).invert();
}
function updateUserCamera(camera3, cameraXR, parent2) {
  if (parent2 === null) {
    camera3.matrix.copy(cameraXR.matrixWorld);
  } else {
    camera3.matrix.copy(parent2.matrixWorld);
    camera3.matrix.invert();
    camera3.matrix.multiply(cameraXR.matrixWorld);
  }
  camera3.matrix.decompose(camera3.position, camera3.quaternion, camera3.scale);
  camera3.updateMatrixWorld(true);
  camera3.projectionMatrix.copy(cameraXR.projectionMatrix);
  camera3.projectionMatrixInverse.copy(cameraXR.projectionMatrixInverse);
  if (camera3.isPerspectiveCamera) {
    camera3.fov = RAD2DEG * 2 * Math.atan(1 / camera3.projectionMatrix.elements[5]);
    camera3.zoom = 1;
  }
}
function onSessionEvent(event) {
  const controllerIndex = this._controllerInputSources.indexOf(event.inputSource);
  if (controllerIndex === -1) {
    return;
  }
  const controller = this._controllers[controllerIndex];
  if (controller !== void 0) {
    const referenceSpace = this.getReferenceSpace();
    controller.update(event.inputSource, event.frame, referenceSpace);
    controller.dispatchEvent({ type: event.type, data: event.inputSource });
  }
}
function onSessionEnd() {
  const session = this._session;
  const renderer3 = this._renderer;
  session.removeEventListener("select", this._onSessionEvent);
  session.removeEventListener("selectstart", this._onSessionEvent);
  session.removeEventListener("selectend", this._onSessionEvent);
  session.removeEventListener("squeeze", this._onSessionEvent);
  session.removeEventListener("squeezestart", this._onSessionEvent);
  session.removeEventListener("squeezeend", this._onSessionEvent);
  session.removeEventListener("end", this._onSessionEnd);
  session.removeEventListener("inputsourceschange", this._onInputSourcesChange);
  for (let i2 = 0; i2 < this._controllers.length; i2++) {
    const inputSource = this._controllerInputSources[i2];
    if (inputSource === null) continue;
    this._controllerInputSources[i2] = null;
    this._controllers[i2].disconnect(inputSource);
  }
  this._currentDepthNear = null;
  this._currentDepthFar = null;
  renderer3._resetXRState();
  this._session = null;
  this._xrRenderTarget = null;
  this._glBinding = null;
  this._glBaseLayer = null;
  this._glProjLayer = null;
  if (this._sessionUsesLayers === true) {
    for (const layer of this._layers) {
      layer.renderTarget = new XRRenderTarget(
        layer.pixelwidth,
        layer.pixelheight,
        {
          format: RGBAFormat,
          type: UnsignedByteType,
          depthTexture: new DepthTexture(
            layer.pixelwidth,
            layer.pixelheight,
            layer.stencilBuffer ? UnsignedInt248Type : UnsignedIntType,
            void 0,
            void 0,
            void 0,
            void 0,
            void 0,
            void 0,
            layer.stencilBuffer ? DepthStencilFormat : DepthFormat
          ),
          stencilBuffer: layer.stencilBuffer,
          resolveDepthBuffer: false,
          resolveStencilBuffer: false
        }
      );
      layer.renderTarget.isXRRenderTarget = false;
      layer.plane.material = layer.material;
      layer.material.map = layer.renderTarget.texture;
      layer.material.map.offset.y = 1;
      layer.material.map.repeat.y = -1;
      delete layer.xrlayer;
    }
  }
  this.isPresenting = false;
  this._useMultiview = false;
  renderer3._animation.stop();
  renderer3._animation.setAnimationLoop(this._currentAnimationLoop);
  renderer3._animation.setContext(this._currentAnimationContext);
  renderer3._animation.start();
  renderer3.setPixelRatio(this._currentPixelRatio);
  renderer3.setSize(this._currentSize.width, this._currentSize.height, false);
  this.dispatchEvent({ type: "sessionend" });
}
function onInputSourcesChange(event) {
  const controllers = this._controllers;
  const controllerInputSources = this._controllerInputSources;
  for (let i2 = 0; i2 < event.removed.length; i2++) {
    const inputSource = event.removed[i2];
    const index8 = controllerInputSources.indexOf(inputSource);
    if (index8 >= 0) {
      controllerInputSources[index8] = null;
      controllers[index8].disconnect(inputSource);
    }
  }
  for (let i2 = 0; i2 < event.added.length; i2++) {
    const inputSource = event.added[i2];
    let controllerIndex = controllerInputSources.indexOf(inputSource);
    if (controllerIndex === -1) {
      for (let i3 = 0; i3 < controllers.length; i3++) {
        if (i3 >= controllerInputSources.length) {
          controllerInputSources.push(inputSource);
          controllerIndex = i3;
          break;
        } else if (controllerInputSources[i3] === null) {
          controllerInputSources[i3] = inputSource;
          controllerIndex = i3;
          break;
        }
      }
      if (controllerIndex === -1) break;
    }
    const controller = controllers[controllerIndex];
    if (controller) {
      controller.connect(inputSource);
    }
  }
}
function createXRLayer(layer) {
  if (layer.type === "quad") {
    return this._glBinding.createQuadLayer({
      transform: new XRRigidTransform(layer.translation, layer.quaternion),
      width: layer.width / 2,
      height: layer.height / 2,
      space: this._referenceSpace,
      viewPixelWidth: layer.pixelwidth,
      viewPixelHeight: layer.pixelheight,
      clearOnAccess: false
    });
  } else {
    return this._glBinding.createCylinderLayer({
      transform: new XRRigidTransform(layer.translation, layer.quaternion),
      radius: layer.radius,
      centralAngle: layer.centralAngle,
      aspectRatio: layer.aspectRatio,
      space: this._referenceSpace,
      viewPixelWidth: layer.pixelwidth,
      viewPixelHeight: layer.pixelheight,
      clearOnAccess: false
    });
  }
}
function onAnimationFrame(time3, frame2) {
  if (frame2 === void 0) return;
  const cameraXR = this._cameraXR;
  const renderer3 = this._renderer;
  const backend = renderer3.backend;
  const glBaseLayer = this._glBaseLayer;
  const referenceSpace = this.getReferenceSpace();
  const pose = frame2.getViewerPose(referenceSpace);
  this._xrFrame = frame2;
  if (pose !== null) {
    const views = pose.views;
    if (this._glBaseLayer !== null) {
      backend.setXRTarget(glBaseLayer.framebuffer);
    }
    let cameraXRNeedsUpdate = false;
    if (views.length !== cameraXR.cameras.length) {
      cameraXR.cameras.length = 0;
      cameraXRNeedsUpdate = true;
    }
    for (let i2 = 0; i2 < views.length; i2++) {
      const view = views[i2];
      let viewport2;
      if (this._supportsLayers === true) {
        const glSubImage = this._glBinding.getViewSubImage(this._glProjLayer, view);
        viewport2 = glSubImage.viewport;
        if (i2 === 0) {
          backend.setXRRenderTargetTextures(
            this._xrRenderTarget,
            glSubImage.colorTexture,
            this._glProjLayer.ignoreDepthValues && !this._useMultiview ? void 0 : glSubImage.depthStencilTexture
          );
        }
      } else {
        viewport2 = glBaseLayer.getViewport(view);
      }
      let camera3 = this._cameras[i2];
      if (camera3 === void 0) {
        camera3 = new PerspectiveCamera();
        camera3.layers.enable(i2);
        camera3.viewport = new Vector4();
        this._cameras[i2] = camera3;
      }
      camera3.matrix.fromArray(view.transform.matrix);
      camera3.matrix.decompose(camera3.position, camera3.quaternion, camera3.scale);
      camera3.projectionMatrix.fromArray(view.projectionMatrix);
      camera3.projectionMatrixInverse.copy(camera3.projectionMatrix).invert();
      camera3.viewport.set(viewport2.x, viewport2.y, viewport2.width, viewport2.height);
      if (i2 === 0) {
        cameraXR.matrix.copy(camera3.matrix);
        cameraXR.matrix.decompose(cameraXR.position, cameraXR.quaternion, cameraXR.scale);
      }
      if (cameraXRNeedsUpdate === true) {
        cameraXR.cameras.push(camera3);
      }
    }
    renderer3.setOutputRenderTarget(this._xrRenderTarget);
  }
  for (let i2 = 0; i2 < this._controllers.length; i2++) {
    const inputSource = this._controllerInputSources[i2];
    const controller = this._controllers[i2];
    if (inputSource !== null && controller !== void 0) {
      controller.update(inputSource, frame2, referenceSpace);
    }
  }
  if (this._currentAnimationLoop) this._currentAnimationLoop(time3, frame2);
  if (frame2.detectedPlanes) {
    this.dispatchEvent({ type: "planesdetected", data: frame2 });
  }
  this._xrFrame = null;
}
var CanvasTarget = class extends EventDispatcher {
  /**
   * Constructs a new CanvasTarget.
   *
   * @param {HTMLCanvasElement|OffscreenCanvas} domElement - The canvas element to render to.
   */
  constructor(domElement) {
    super();
    this.domElement = domElement;
    this._pixelRatio = 1;
    this._width = this.domElement.width;
    this._height = this.domElement.height;
    this._viewport = new Vector4(0, 0, this._width, this._height);
    this._scissor = new Vector4(0, 0, this._width, this._height);
    this._scissorTest = false;
    this.colorTexture = new FramebufferTexture();
    this.depthTexture = new DepthTexture();
  }
  /**
   * Returns the pixel ratio.
   *
   * @return {number} The pixel ratio.
   */
  getPixelRatio() {
    return this._pixelRatio;
  }
  /**
   * Returns the drawing buffer size in physical pixels. This method honors the pixel ratio.
   *
   * @param {Vector2} target - The method writes the result in this target object.
   * @return {Vector2} The drawing buffer size.
   */
  getDrawingBufferSize(target) {
    return target.set(this._width * this._pixelRatio, this._height * this._pixelRatio).floor();
  }
  /**
   * Returns the renderer's size in logical pixels. This method does not honor the pixel ratio.
   *
   * @param {Vector2} target - The method writes the result in this target object.
   * @return {Vector2} The renderer's size in logical pixels.
   */
  getSize(target) {
    return target.set(this._width, this._height);
  }
  /**
   * Sets the given pixel ratio and resizes the canvas if necessary.
   *
   * @param {number} [value=1] - The pixel ratio.
   */
  setPixelRatio(value = 1) {
    if (this._pixelRatio === value) return;
    this._pixelRatio = value;
    this.setSize(this._width, this._height, false);
  }
  /**
   * This method allows to define the drawing buffer size by specifying
   * width, height and pixel ratio all at once. The size of the drawing
   * buffer is computed with this formula:
   * ```js
   * size.x = width * pixelRatio;
   * size.y = height * pixelRatio;
   * ```
   *
   * @param {number} width - The width in logical pixels.
   * @param {number} height - The height in logical pixels.
   * @param {number} pixelRatio - The pixel ratio.
   */
  setDrawingBufferSize(width, height, pixelRatio) {
    if (this.xr && this.xr.isPresenting) return;
    this._width = width;
    this._height = height;
    this._pixelRatio = pixelRatio;
    this.domElement.width = Math.floor(width * pixelRatio);
    this.domElement.height = Math.floor(height * pixelRatio);
    this.setViewport(0, 0, width, height);
    this._dispatchResize();
  }
  /**
   * Sets the size of the renderer.
   *
   * @param {number} width - The width in logical pixels.
   * @param {number} height - The height in logical pixels.
   * @param {boolean} [updateStyle=true] - Whether to update the `style` attribute of the canvas or not.
   */
  setSize(width, height, updateStyle = true) {
    if (this.xr && this.xr.isPresenting) return;
    this._width = width;
    this._height = height;
    this.domElement.width = Math.floor(width * this._pixelRatio);
    this.domElement.height = Math.floor(height * this._pixelRatio);
    if (updateStyle === true) {
      this.domElement.style.width = width + "px";
      this.domElement.style.height = height + "px";
    }
    this.setViewport(0, 0, width, height);
    this._dispatchResize();
  }
  /**
   * Returns the scissor rectangle.
   *
   * @param {Vector4} target - The method writes the result in this target object.
   * @return {Vector4} The scissor rectangle.
   */
  getScissor(target) {
    const scissor = this._scissor;
    target.x = scissor.x;
    target.y = scissor.y;
    target.width = scissor.width;
    target.height = scissor.height;
    return target;
  }
  /**
   * Defines the scissor rectangle.
   *
   * @param {number | Vector4} x - The horizontal coordinate for the lower left corner of the box in logical pixel unit.
   * Instead of passing four arguments, the method also works with a single four-dimensional vector.
   * @param {number} y - The vertical coordinate for the lower left corner of the box in logical pixel unit.
   * @param {number} width - The width of the scissor box in logical pixel unit.
   * @param {number} height - The height of the scissor box in logical pixel unit.
   */
  setScissor(x3, y3, width, height) {
    const scissor = this._scissor;
    if (x3.isVector4) {
      scissor.copy(x3);
    } else {
      scissor.set(x3, y3, width, height);
    }
  }
  /**
   * Returns the scissor test value.
   *
   * @return {boolean} Whether the scissor test should be enabled or not.
   */
  getScissorTest() {
    return this._scissorTest;
  }
  /**
   * Defines the scissor test.
   *
   * @param {boolean} boolean - Whether the scissor test should be enabled or not.
   */
  setScissorTest(boolean) {
    this._scissorTest = boolean;
  }
  /**
   * Returns the viewport definition.
   *
   * @param {Vector4} target - The method writes the result in this target object.
   * @return {Vector4} The viewport definition.
   */
  getViewport(target) {
    return target.copy(this._viewport);
  }
  /**
   * Defines the viewport.
   *
   * @param {number | Vector4} x - The horizontal coordinate for the lower left corner of the viewport origin in logical pixel unit.
   * @param {number} y - The vertical coordinate for the lower left corner of the viewport origin  in logical pixel unit.
   * @param {number} width - The width of the viewport in logical pixel unit.
   * @param {number} height - The height of the viewport in logical pixel unit.
   * @param {number} minDepth - The minimum depth value of the viewport. WebGPU only.
   * @param {number} maxDepth - The maximum depth value of the viewport. WebGPU only.
   */
  setViewport(x3, y3, width, height, minDepth = 0, maxDepth = 1) {
    const viewport2 = this._viewport;
    if (x3.isVector4) {
      viewport2.copy(x3);
    } else {
      viewport2.set(x3, y3, width, height);
    }
    viewport2.minDepth = minDepth;
    viewport2.maxDepth = maxDepth;
  }
  /**
   * Dispatches the resize event.
   *
   * @private
   */
  _dispatchResize() {
    this.dispatchEvent({ type: "resize" });
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   *
   * @fires RenderTarget#dispose
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
};
var _scene = new Scene();
var _drawingBufferSize = new Vector2();
var _screen = new Vector4();
var _frustum2 = new Frustum();
var _frustumArray = new FrustumArray();
var _projScreenMatrix2 = new Matrix4();
var _vector4 = new Vector4();
var Renderer = class {
  /**
   * Renderer options.
   *
   * @typedef {Object} Renderer~Options
   * @property {boolean} [logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.
   * @property {boolean} [alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.
   * @property {boolean} [depth=true] - Whether the default framebuffer should have a depth buffer or not.
   * @property {boolean} [stencil=false] - Whether the default framebuffer should have a stencil buffer or not.
   * @property {boolean} [antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.
   * @property {number} [samples=0] - When `antialias` is `true`, `4` samples are used by default. This parameter can set to any other integer value than 0
   * to overwrite the default.
   * @property {?Function} [getFallback=null] - This callback function can be used to provide a fallback backend, if the primary backend can't be targeted.
   * @property {number} [outputBufferType=HalfFloatType] - Defines the type of output buffers. The default `HalfFloatType` is recommend for best
   * quality. To save memory and bandwidth, `UnsignedByteType` might be used. This will reduce rendering quality though.
   * @property {boolean} [multiview=false] - If set to `true`, the renderer will use multiview during WebXR rendering if supported.
   */
  /**
  	 * Constructs a new renderer.
  	 *
  	 * @param {Backend} backend - The backend the renderer is targeting (e.g. WebGPU or WebGL 2).
  	 * @param {Renderer~Options} [parameters] - The configuration parameter.
  
  	 */
  constructor(backend, parameters = {}) {
    this.isRenderer = true;
    const {
      logarithmicDepthBuffer = false,
      alpha = true,
      depth: depth2 = true,
      stencil = false,
      antialias = false,
      samples = 0,
      getFallback = null,
      outputBufferType = HalfFloatType,
      multiview = false
    } = parameters;
    this.backend = backend;
    this.autoClear = true;
    this.autoClearColor = true;
    this.autoClearDepth = true;
    this.autoClearStencil = true;
    this.alpha = alpha;
    this.logarithmicDepthBuffer = logarithmicDepthBuffer;
    this.outputColorSpace = SRGBColorSpace;
    this.toneMapping = NoToneMapping;
    this.toneMappingExposure = 1;
    this.sortObjects = true;
    this.depth = depth2;
    this.stencil = stencil;
    this.info = new Info();
    this.contextNode = context();
    this.library = new NodeLibrary();
    this.lighting = new Lighting();
    this._samples = samples || antialias === true ? 4 : 0;
    this._onCanvasTargetResize = this._onCanvasTargetResize.bind(this);
    this._canvasTarget = new CanvasTarget(backend.getDomElement());
    this._canvasTarget.addEventListener("resize", this._onCanvasTargetResize);
    this._canvasTarget.isDefaultCanvasTarget = true;
    this._inspector = new InspectorBase();
    this._inspector.setRenderer(this);
    this._getFallback = getFallback;
    this._attributes = null;
    this._geometries = null;
    this._nodes = null;
    this._animation = null;
    this._bindings = null;
    this._objects = null;
    this._pipelines = null;
    this._bundles = null;
    this._renderLists = null;
    this._renderContexts = null;
    this._textures = null;
    this._background = null;
    this._quad = new QuadMesh(new NodeMaterial());
    this._quad.name = "Output Color Transform";
    this._quad.material.name = "outputColorTransform";
    this._currentRenderContext = null;
    this._opaqueSort = null;
    this._transparentSort = null;
    this._frameBufferTarget = null;
    const alphaClear = this.alpha === true ? 0 : 1;
    this._clearColor = new Color4(0, 0, 0, alphaClear);
    this._clearDepth = 1;
    this._clearStencil = 0;
    this._renderTarget = null;
    this._activeCubeFace = 0;
    this._activeMipmapLevel = 0;
    this._outputRenderTarget = null;
    this._mrt = null;
    this._renderObjectFunction = null;
    this._currentRenderObjectFunction = null;
    this._currentRenderBundle = null;
    this._handleObjectFunction = this._renderObjectDirect;
    this._isDeviceLost = false;
    this.onDeviceLost = this._onDeviceLost;
    this._outputBufferType = outputBufferType;
    this._cacheShadowNodes = /* @__PURE__ */ new WeakMap();
    this._initialized = false;
    this._initPromise = null;
    this._compilationPromises = null;
    this.transparent = true;
    this.opaque = true;
    this.shadowMap = {
      enabled: false,
      type: PCFShadowMap
    };
    this.xr = new XRManager(this, multiview);
    this.debug = {
      checkShaderErrors: true,
      onShaderError: null,
      getShaderAsync: async (scene3, camera3, object) => {
        await this.compileAsync(scene3, camera3);
        const renderList = this._renderLists.get(scene3, camera3);
        const renderContext = this._renderContexts.get(scene3, camera3, this._renderTarget, this._mrt);
        const material = scene3.overrideMaterial || object.material;
        const renderObject = this._objects.get(object, material, scene3, camera3, renderList.lightsNode, renderContext, renderContext.clippingContext);
        const { fragmentShader, vertexShader } = renderObject.getNodeBuilderState();
        return { fragmentShader, vertexShader };
      }
    };
  }
  /**
   * Initializes the renderer so it is ready for usage.
   *
   * @async
   * @return {Promise<this>} A Promise that resolves when the renderer has been initialized.
   */
  async init() {
    if (this._initPromise !== null) {
      return this._initPromise;
    }
    this._initPromise = new Promise(async (resolve, reject2) => {
      let backend = this.backend;
      try {
        await backend.init(this);
      } catch (error2) {
        if (this._getFallback !== null) {
          try {
            this.backend = backend = this._getFallback(error2);
            await backend.init(this);
          } catch (error3) {
            reject2(error3);
            return;
          }
        } else {
          reject2(error2);
          return;
        }
      }
      this._nodes = new Nodes(this, backend);
      this._animation = new Animation(this, this._nodes, this.info);
      this._attributes = new Attributes(backend);
      this._background = new Background(this, this._nodes);
      this._geometries = new Geometries2(this._attributes, this.info);
      this._textures = new Textures(this, backend, this.info);
      this._pipelines = new Pipelines(backend, this._nodes);
      this._bindings = new Bindings(backend, this._nodes, this._textures, this._attributes, this._pipelines, this.info);
      this._objects = new RenderObjects(this, this._nodes, this._geometries, this._pipelines, this._bindings, this.info);
      this._renderLists = new RenderLists(this.lighting);
      this._bundles = new RenderBundles();
      this._renderContexts = new RenderContexts();
      this._animation.start();
      this._initialized = true;
      this._inspector.init();
      resolve(this);
    });
    return this._initPromise;
  }
  /**
   * A reference to the canvas element the renderer is drawing to.
   * This value of this property will automatically be created by
   * the renderer.
   *
   * @type {HTMLCanvasElement|OffscreenCanvas}
   */
  get domElement() {
    return this._canvasTarget.domElement;
  }
  /**
   * The coordinate system of the renderer. The value of this property
   * depends on the selected backend. Either `THREE.WebGLCoordinateSystem` or
   * `THREE.WebGPUCoordinateSystem`.
   *
   * @readonly
   * @type {number}
   */
  get coordinateSystem() {
    return this.backend.coordinateSystem;
  }
  /**
   * Compiles all materials in the given scene. This can be useful to avoid a
   * phenomenon which is called "shader compilation stutter", which occurs when
   * rendering an object with a new shader for the first time.
   *
   * If you want to add a 3D object to an existing scene, use the third optional
   * parameter for applying the target scene. Note that the (target) scene's lighting
   * and environment must be configured before calling this method.
   *
   * @async
   * @param {Object3D} scene - The scene or 3D object to precompile.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {?Scene} targetScene - If the first argument is a 3D object, this parameter must represent the scene the 3D object is going to be added.
   * @return {Promise} A Promise that resolves when the compile has been finished.
   */
  async compileAsync(scene3, camera3, targetScene = null) {
    if (this._isDeviceLost === true) return;
    if (this._initialized === false) await this.init();
    const nodeFrame = this._nodes.nodeFrame;
    const previousRenderId = nodeFrame.renderId;
    const previousRenderContext = this._currentRenderContext;
    const previousRenderObjectFunction = this._currentRenderObjectFunction;
    const previousCompilationPromises = this._compilationPromises;
    const sceneRef = scene3.isScene === true ? scene3 : _scene;
    if (targetScene === null) targetScene = scene3;
    const renderTarget = this._renderTarget;
    const renderContext = this._renderContexts.get(targetScene, camera3, renderTarget, this._mrt);
    const activeMipmapLevel = this._activeMipmapLevel;
    const compilationPromises = [];
    this._currentRenderContext = renderContext;
    this._currentRenderObjectFunction = this.renderObject;
    this._handleObjectFunction = this._createObjectPipeline;
    this._compilationPromises = compilationPromises;
    nodeFrame.renderId++;
    nodeFrame.update();
    renderContext.depth = this.depth;
    renderContext.stencil = this.stencil;
    if (!renderContext.clippingContext) renderContext.clippingContext = new ClippingContext();
    renderContext.clippingContext.updateGlobal(sceneRef, camera3);
    sceneRef.onBeforeRender(this, scene3, camera3, renderTarget);
    const renderList = this._renderLists.get(scene3, camera3);
    renderList.begin();
    this._projectObject(scene3, camera3, 0, renderList, renderContext.clippingContext);
    if (targetScene !== scene3) {
      targetScene.traverseVisible(function(object) {
        if (object.isLight && object.layers.test(camera3.layers)) {
          renderList.pushLight(object);
        }
      });
    }
    renderList.finish();
    if (renderTarget !== null) {
      this._textures.updateRenderTarget(renderTarget, activeMipmapLevel);
      const renderTargetData = this._textures.get(renderTarget);
      renderContext.textures = renderTargetData.textures;
      renderContext.depthTexture = renderTargetData.depthTexture;
    } else {
      renderContext.textures = null;
      renderContext.depthTexture = null;
    }
    this._background.update(sceneRef, renderList, renderContext);
    const opaqueObjects = renderList.opaque;
    const transparentObjects = renderList.transparent;
    const transparentDoublePassObjects = renderList.transparentDoublePass;
    const lightsNode = renderList.lightsNode;
    if (this.opaque === true && opaqueObjects.length > 0) this._renderObjects(opaqueObjects, camera3, sceneRef, lightsNode);
    if (this.transparent === true && transparentObjects.length > 0) this._renderTransparents(transparentObjects, transparentDoublePassObjects, camera3, sceneRef, lightsNode);
    nodeFrame.renderId = previousRenderId;
    this._currentRenderContext = previousRenderContext;
    this._currentRenderObjectFunction = previousRenderObjectFunction;
    this._compilationPromises = previousCompilationPromises;
    this._handleObjectFunction = this._renderObjectDirect;
    await Promise.all(compilationPromises);
  }
  /**
   * Renders the scene in an async fashion.
   *
   * @async
   * @deprecated
   * @param {Object3D} scene - The scene or 3D object to render.
   * @param {Camera} camera - The camera.
   * @return {Promise} A Promise that resolves when the render has been finished.
   */
  async renderAsync(scene3, camera3) {
    warnOnce('Renderer: "renderAsync()" has been deprecated. Use "render()" and "await renderer.init();" when creating the renderer.');
    await this.init();
    this.render(scene3, camera3);
  }
  /**
   * Can be used to synchronize CPU operations with GPU tasks. So when this method is called,
   * the CPU waits for the GPU to complete its operation (e.g. a compute task).
   *
   * @async
   * @deprecated
   * @return {Promise} A Promise that resolves when synchronization has been finished.
   */
  async waitForGPU() {
    error("Renderer: waitForGPU() has been removed. Read https://github.com/mrdoob/three.js/issues/32012 for more information.");
  }
  //
  set inspector(value) {
    if (this._inspector !== null) {
      this._inspector.setRenderer(null);
    }
    this._inspector = value;
    this._inspector.setRenderer(this);
  }
  /**
   * The inspector instance. The inspector can be any class that extends from `InspectorBase`.
   *
   * @type {InspectorBase}
   */
  get inspector() {
    return this._inspector;
  }
  /**
   * Enables or disables high precision for model-view and normal-view matrices.
   * When enabled, will use CPU 64-bit precision for higher precision instead of GPU 32-bit for higher performance.
   *
   * NOTE: 64-bit precision is not compatible with `InstancedMesh` and `SkinnedMesh`.
   *
   * @param {boolean} value - Whether to enable or disable high precision.
   * @type {boolean}
   */
  set highPrecision(value) {
    const contextNodeData = this.contextNode.value;
    if (value === true) {
      contextNodeData.modelViewMatrix = highpModelViewMatrix;
      contextNodeData.modelNormalViewMatrix = highpModelNormalViewMatrix;
    } else if (this.highPrecision) {
      delete contextNodeData.modelViewMatrix;
      delete contextNodeData.modelNormalViewMatrix;
    }
  }
  /**
   * Returns whether high precision is enabled or not.
   *
   * @return {boolean} Whether high precision is enabled or not.
   * @type {boolean}
   */
  get highPrecision() {
    const contextNodeData = this.contextNode.value;
    return contextNodeData.modelViewMatrix === highpModelViewMatrix && contextNodeData.modelNormalViewMatrix === highpModelNormalViewMatrix;
  }
  /**
   * Sets the given MRT configuration.
   *
   * @param {MRTNode} mrt - The MRT node to set.
   * @return {Renderer} A reference to this renderer.
   */
  setMRT(mrt2) {
    this._mrt = mrt2;
    return this;
  }
  /**
   * Returns the MRT configuration.
   *
   * @return {MRTNode} The MRT configuration.
   */
  getMRT() {
    return this._mrt;
  }
  /**
   * Returns the output buffer type.
   *
   * @return {number} The output buffer type.
   */
  getOutputBufferType() {
    return this._outputBufferType;
  }
  /**
   * Returns the output buffer type.
   *
   * @deprecated since r182. Use `.getOutputBufferType()` instead.
   * @return {number} The output buffer type.
   */
  getColorBufferType() {
    warnOnce('Renderer: ".getColorBufferType()" has been renamed to ".getOutputBufferType()".');
    return this.getOutputBufferType();
  }
  /**
   * Default implementation of the device lost callback.
   *
   * @private
   * @param {Object} info - Information about the context lost.
   */
  _onDeviceLost(info) {
    let errorMessage = `THREE.WebGPURenderer: ${info.api} Device Lost:

Message: ${info.message}`;
    if (info.reason) {
      errorMessage += `
Reason: ${info.reason}`;
    }
    error(errorMessage);
    this._isDeviceLost = true;
  }
  /**
   * Renders the given render bundle.
   *
   * @private
   * @param {Object} bundle - Render bundle data.
   * @param {Scene} sceneRef - The scene the render bundle belongs to.
   * @param {LightsNode} lightsNode - The lights node.
   */
  _renderBundle(bundle, sceneRef, lightsNode) {
    const { bundleGroup, camera: camera3, renderList } = bundle;
    const renderContext = this._currentRenderContext;
    const renderBundle = this._bundles.get(bundleGroup, camera3);
    const renderBundleData = this.backend.get(renderBundle);
    if (renderBundleData.renderContexts === void 0) renderBundleData.renderContexts = /* @__PURE__ */ new Set();
    const needsUpdate = bundleGroup.version !== renderBundleData.version;
    const renderBundleNeedsUpdate = renderBundleData.renderContexts.has(renderContext) === false || needsUpdate;
    renderBundleData.renderContexts.add(renderContext);
    if (renderBundleNeedsUpdate) {
      this.backend.beginBundle(renderContext);
      if (renderBundleData.renderObjects === void 0 || needsUpdate) {
        renderBundleData.renderObjects = [];
      }
      this._currentRenderBundle = renderBundle;
      const {
        transparentDoublePass: transparentDoublePassObjects,
        transparent: transparentObjects,
        opaque: opaqueObjects
      } = renderList;
      if (this.opaque === true && opaqueObjects.length > 0) this._renderObjects(opaqueObjects, camera3, sceneRef, lightsNode);
      if (this.transparent === true && transparentObjects.length > 0) this._renderTransparents(transparentObjects, transparentDoublePassObjects, camera3, sceneRef, lightsNode);
      this._currentRenderBundle = null;
      this.backend.finishBundle(renderContext, renderBundle);
      renderBundleData.version = bundleGroup.version;
    } else {
      const { renderObjects } = renderBundleData;
      for (let i2 = 0, l2 = renderObjects.length; i2 < l2; i2++) {
        const renderObject = renderObjects[i2];
        if (this._nodes.needsRefresh(renderObject)) {
          this._nodes.updateBefore(renderObject);
          this._nodes.updateForRender(renderObject);
          this._bindings.updateForRender(renderObject);
          this._nodes.updateAfter(renderObject);
        }
      }
    }
    this.backend.addBundle(renderContext, renderBundle);
  }
  /**
   * Renders the scene or 3D object with the given camera. This method can only be called
   * if the renderer has been initialized. When using `render()` inside an animation loop,
   * it's guaranteed the renderer will be initialized. The animation loop must be defined
   * with {@link Renderer#setAnimationLoop} though.
   *
   * For all other use cases (like when using on-demand rendering), you must call
   * {@link Renderer#init} before rendering.
   *
   * The target of the method is the default framebuffer (meaning the canvas)
   * or alternatively a render target when specified via `setRenderTarget()`.
   *
   * @param {Object3D} scene - The scene or 3D object to render.
   * @param {Camera} camera - The camera to render the scene with.
   */
  render(scene3, camera3) {
    if (this._initialized === false) {
      throw new Error('Renderer: .render() called before the backend is initialized. Use "await renderer.init();" before rendering.');
    }
    this._renderScene(scene3, camera3);
  }
  /**
   * Returns whether the renderer has been initialized or not.
   *
   * @readonly
   * @return {boolean} Whether the renderer has been initialized or not.
   */
  get initialized() {
    return this._initialized;
  }
  /**
   * Returns an internal render target which is used when computing the output tone mapping
   * and color space conversion. Unlike in `WebGLRenderer`, this is done in a separate render
   * pass and not inline to achieve more correct results.
   *
   * @private
   * @return {?RenderTarget} The render target. The method returns `null` if no output conversion should be applied.
   */
  _getFrameBufferTarget() {
    const { currentToneMapping, currentColorSpace } = this;
    const useToneMapping = currentToneMapping !== NoToneMapping;
    const useColorSpace = currentColorSpace !== ColorManagement.workingColorSpace;
    if (useToneMapping === false && useColorSpace === false) return null;
    const { width, height } = this.getDrawingBufferSize(_drawingBufferSize);
    const { depth: depth2, stencil } = this;
    let frameBufferTarget = this._frameBufferTarget;
    if (frameBufferTarget === null) {
      frameBufferTarget = new RenderTarget(width, height, {
        depthBuffer: depth2,
        stencilBuffer: stencil,
        type: this._outputBufferType,
        format: RGBAFormat,
        colorSpace: ColorManagement.workingColorSpace,
        generateMipmaps: false,
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        samples: this.samples
      });
      frameBufferTarget.isPostProcessingRenderTarget = true;
      this._frameBufferTarget = frameBufferTarget;
    }
    const outputRenderTarget = this.getOutputRenderTarget();
    frameBufferTarget.depthBuffer = depth2;
    frameBufferTarget.stencilBuffer = stencil;
    if (outputRenderTarget !== null) {
      frameBufferTarget.setSize(outputRenderTarget.width, outputRenderTarget.height, outputRenderTarget.depth);
    } else {
      frameBufferTarget.setSize(width, height, 1);
    }
    const canvasTarget = this._canvasTarget;
    frameBufferTarget.viewport.copy(canvasTarget._viewport);
    frameBufferTarget.scissor.copy(canvasTarget._scissor);
    frameBufferTarget.viewport.multiplyScalar(canvasTarget._pixelRatio);
    frameBufferTarget.scissor.multiplyScalar(canvasTarget._pixelRatio);
    frameBufferTarget.scissorTest = canvasTarget._scissorTest;
    frameBufferTarget.multiview = outputRenderTarget !== null ? outputRenderTarget.multiview : false;
    frameBufferTarget.resolveDepthBuffer = outputRenderTarget !== null ? outputRenderTarget.resolveDepthBuffer : true;
    frameBufferTarget._autoAllocateDepthBuffer = outputRenderTarget !== null ? outputRenderTarget._autoAllocateDepthBuffer : false;
    return frameBufferTarget;
  }
  /**
   * Renders the scene or 3D object with the given camera.
   *
   * @private
   * @param {Object3D} scene - The scene or 3D object to render.
   * @param {Camera} camera - The camera to render the scene with.
   * @param {boolean} [useFrameBufferTarget=true] - Whether to use a framebuffer target or not.
   * @return {RenderContext} The current render context.
   */
  _renderScene(scene3, camera3, useFrameBufferTarget = true) {
    if (this._isDeviceLost === true) return;
    const frameBufferTarget = useFrameBufferTarget ? this._getFrameBufferTarget() : null;
    const nodeFrame = this._nodes.nodeFrame;
    const previousRenderId = nodeFrame.renderId;
    const previousRenderContext = this._currentRenderContext;
    const previousRenderObjectFunction = this._currentRenderObjectFunction;
    const sceneRef = scene3.isScene === true ? scene3 : _scene;
    const outputRenderTarget = this._renderTarget || this._outputRenderTarget;
    const activeCubeFace = this._activeCubeFace;
    const activeMipmapLevel = this._activeMipmapLevel;
    let renderTarget;
    if (frameBufferTarget !== null) {
      renderTarget = frameBufferTarget;
      this.setRenderTarget(renderTarget);
    } else {
      renderTarget = outputRenderTarget;
    }
    const renderContext = this._renderContexts.get(scene3, camera3, renderTarget, this._mrt);
    this._currentRenderContext = renderContext;
    this._currentRenderObjectFunction = this._renderObjectFunction || this.renderObject;
    this.info.calls++;
    this.info.render.calls++;
    this.info.render.frameCalls++;
    nodeFrame.renderId = this.info.calls;
    this.backend.updateTimeStampUID(renderContext);
    this.inspector.beginRender(this.backend.getTimestampUID(renderContext), scene3, camera3, renderTarget);
    const coordinateSystem = this.coordinateSystem;
    const xr = this.xr;
    if (camera3.coordinateSystem !== coordinateSystem && xr.isPresenting === false) {
      camera3.coordinateSystem = coordinateSystem;
      camera3.updateProjectionMatrix();
      if (camera3.isArrayCamera) {
        for (const subCamera of camera3.cameras) {
          subCamera.coordinateSystem = coordinateSystem;
          subCamera.updateProjectionMatrix();
        }
      }
    }
    if (scene3.matrixWorldAutoUpdate === true) scene3.updateMatrixWorld();
    if (camera3.parent === null && camera3.matrixWorldAutoUpdate === true) camera3.updateMatrixWorld();
    if (xr.enabled === true && xr.isPresenting === true) {
      if (xr.cameraAutoUpdate === true) xr.updateCamera(camera3);
      camera3 = xr.getCamera();
    }
    const canvasTarget = this._canvasTarget;
    let viewport2 = canvasTarget._viewport;
    let scissor = canvasTarget._scissor;
    let pixelRatio = canvasTarget._pixelRatio;
    if (renderTarget !== null) {
      viewport2 = renderTarget.viewport;
      scissor = renderTarget.scissor;
      pixelRatio = 1;
    }
    this.getDrawingBufferSize(_drawingBufferSize);
    _screen.set(0, 0, _drawingBufferSize.width, _drawingBufferSize.height);
    const minDepth = viewport2.minDepth === void 0 ? 0 : viewport2.minDepth;
    const maxDepth = viewport2.maxDepth === void 0 ? 1 : viewport2.maxDepth;
    renderContext.viewportValue.copy(viewport2).multiplyScalar(pixelRatio).floor();
    renderContext.viewportValue.width >>= activeMipmapLevel;
    renderContext.viewportValue.height >>= activeMipmapLevel;
    renderContext.viewportValue.minDepth = minDepth;
    renderContext.viewportValue.maxDepth = maxDepth;
    renderContext.viewport = renderContext.viewportValue.equals(_screen) === false;
    renderContext.scissorValue.copy(scissor).multiplyScalar(pixelRatio).floor();
    renderContext.scissor = canvasTarget._scissorTest && renderContext.scissorValue.equals(_screen) === false;
    renderContext.scissorValue.width >>= activeMipmapLevel;
    renderContext.scissorValue.height >>= activeMipmapLevel;
    if (!renderContext.clippingContext) renderContext.clippingContext = new ClippingContext();
    renderContext.clippingContext.updateGlobal(sceneRef, camera3);
    sceneRef.onBeforeRender(this, scene3, camera3, renderTarget);
    const frustum = camera3.isArrayCamera ? _frustumArray : _frustum2;
    if (!camera3.isArrayCamera) {
      _projScreenMatrix2.multiplyMatrices(camera3.projectionMatrix, camera3.matrixWorldInverse);
      frustum.setFromProjectionMatrix(_projScreenMatrix2, camera3.coordinateSystem, camera3.reversedDepth);
    }
    const renderList = this._renderLists.get(scene3, camera3);
    renderList.begin();
    this._projectObject(scene3, camera3, 0, renderList, renderContext.clippingContext);
    renderList.finish();
    if (this.sortObjects === true) {
      renderList.sort(this._opaqueSort, this._transparentSort);
    }
    if (renderTarget !== null) {
      this._textures.updateRenderTarget(renderTarget, activeMipmapLevel);
      const renderTargetData = this._textures.get(renderTarget);
      renderContext.textures = renderTargetData.textures;
      renderContext.depthTexture = renderTargetData.depthTexture;
      renderContext.width = renderTargetData.width;
      renderContext.height = renderTargetData.height;
      renderContext.renderTarget = renderTarget;
      renderContext.depth = renderTarget.depthBuffer;
      renderContext.stencil = renderTarget.stencilBuffer;
    } else {
      renderContext.textures = null;
      renderContext.depthTexture = null;
      renderContext.width = _drawingBufferSize.width;
      renderContext.height = _drawingBufferSize.height;
      renderContext.depth = this.depth;
      renderContext.stencil = this.stencil;
    }
    renderContext.width >>= activeMipmapLevel;
    renderContext.height >>= activeMipmapLevel;
    renderContext.activeCubeFace = activeCubeFace;
    renderContext.activeMipmapLevel = activeMipmapLevel;
    renderContext.occlusionQueryCount = renderList.occlusionQueryCount;
    renderContext.scissorValue.max(_vector4.set(0, 0, 0, 0));
    if (renderContext.scissorValue.x + renderContext.scissorValue.width > renderContext.width) {
      renderContext.scissorValue.width = Math.max(renderContext.width - renderContext.scissorValue.x, 0);
    }
    if (renderContext.scissorValue.y + renderContext.scissorValue.height > renderContext.height) {
      renderContext.scissorValue.height = Math.max(renderContext.height - renderContext.scissorValue.y, 0);
    }
    this._background.update(sceneRef, renderList, renderContext);
    renderContext.camera = camera3;
    this.backend.beginRender(renderContext);
    const {
      bundles,
      lightsNode,
      transparentDoublePass: transparentDoublePassObjects,
      transparent: transparentObjects,
      opaque: opaqueObjects
    } = renderList;
    if (bundles.length > 0) this._renderBundles(bundles, sceneRef, lightsNode);
    if (this.opaque === true && opaqueObjects.length > 0) this._renderObjects(opaqueObjects, camera3, sceneRef, lightsNode);
    if (this.transparent === true && transparentObjects.length > 0) this._renderTransparents(transparentObjects, transparentDoublePassObjects, camera3, sceneRef, lightsNode);
    this.backend.finishRender(renderContext);
    nodeFrame.renderId = previousRenderId;
    this._currentRenderContext = previousRenderContext;
    this._currentRenderObjectFunction = previousRenderObjectFunction;
    if (frameBufferTarget !== null) {
      this.setRenderTarget(outputRenderTarget, activeCubeFace, activeMipmapLevel);
      this._renderOutput(renderTarget);
    }
    sceneRef.onAfterRender(this, scene3, camera3, renderTarget);
    this.inspector.finishRender(this.backend.getTimestampUID(renderContext));
    return renderContext;
  }
  _setXRLayerSize(width, height) {
    this._canvasTarget._width = width;
    this._canvasTarget._height = height;
    this.setViewport(0, 0, width, height);
  }
  /**
   * The output pass performs tone mapping and color space conversion.
   *
   * @private
   * @param {RenderTarget} renderTarget - The current render target.
   */
  _renderOutput(renderTarget) {
    const quad = this._quad;
    if (this._nodes.hasOutputChange(renderTarget.texture)) {
      quad.material.fragmentNode = this._nodes.getOutputNode(renderTarget.texture);
      quad.material.needsUpdate = true;
    }
    const currentAutoClear = this.autoClear;
    const currentXR = this.xr.enabled;
    this.autoClear = false;
    this.xr.enabled = false;
    this._renderScene(quad, quad.camera, false);
    this.autoClear = currentAutoClear;
    this.xr.enabled = currentXR;
  }
  /**
   * Returns the maximum available anisotropy for texture filtering.
   *
   * @return {number} The maximum available anisotropy.
   */
  getMaxAnisotropy() {
    return this.backend.getMaxAnisotropy();
  }
  /**
   * Returns the active cube face.
   *
   * @return {number} The active cube face.
   */
  getActiveCubeFace() {
    return this._activeCubeFace;
  }
  /**
   * Returns the active mipmap level.
   *
   * @return {number} The active mipmap level.
   */
  getActiveMipmapLevel() {
    return this._activeMipmapLevel;
  }
  /**
   * Applications are advised to always define the animation loop
   * with this method and not manually with `requestAnimationFrame()`
   * for best compatibility.
   *
   * @async
   * @param {?onAnimationCallback} callback - The application's animation loop.
   * @return {Promise} A Promise that resolves when the set has been executed.
   */
  async setAnimationLoop(callback) {
    if (this._initialized === false) await this.init();
    this._animation.setAnimationLoop(callback);
  }
  /**
   * Returns the current animation loop callback.
   *
   * @return {?Function} The current animation loop callback.
   */
  getAnimationLoop() {
    return this._animation.getAnimationLoop();
  }
  /**
   * Can be used to transfer buffer data from a storage buffer attribute
   * from the GPU to the CPU in context of compute shaders.
   *
   * @async
   * @param {StorageBufferAttribute} attribute - The storage buffer attribute.
   * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.
   */
  async getArrayBufferAsync(attribute2) {
    return await this.backend.getArrayBufferAsync(attribute2);
  }
  /**
   * Returns the rendering context.
   *
   * @return {GPUCanvasContext|WebGL2RenderingContext} The rendering context.
   */
  getContext() {
    return this.backend.getContext();
  }
  /**
   * Returns the pixel ratio.
   *
   * @return {number} The pixel ratio.
   */
  getPixelRatio() {
    return this._canvasTarget.getPixelRatio();
  }
  /**
   * Returns the drawing buffer size in physical pixels. This method honors the pixel ratio.
   *
   * @param {Vector2} target - The method writes the result in this target object.
   * @return {Vector2} The drawing buffer size.
   */
  getDrawingBufferSize(target) {
    return this._canvasTarget.getDrawingBufferSize(target);
  }
  /**
   * Returns the renderer's size in logical pixels. This method does not honor the pixel ratio.
   *
   * @param {Vector2} target - The method writes the result in this target object.
   * @return {Vector2} The renderer's size in logical pixels.
   */
  getSize(target) {
    return this._canvasTarget.getSize(target);
  }
  /**
   * Sets the given pixel ratio and resizes the canvas if necessary.
   *
   * @param {number} [value=1] - The pixel ratio.
   */
  setPixelRatio(value = 1) {
    this._canvasTarget.setPixelRatio(value);
  }
  /**
   * This method allows to define the drawing buffer size by specifying
   * width, height and pixel ratio all at once. The size of the drawing
   * buffer is computed with this formula:
   * ```js
   * size.x = width * pixelRatio;
   * size.y = height * pixelRatio;
   * ```
   *
   * @param {number} width - The width in logical pixels.
   * @param {number} height - The height in logical pixels.
   * @param {number} pixelRatio - The pixel ratio.
   */
  setDrawingBufferSize(width, height, pixelRatio) {
    if (this.xr && this.xr.isPresenting) return;
    this._canvasTarget.setDrawingBufferSize(width, height, pixelRatio);
  }
  /**
   * Sets the size of the renderer.
   *
   * @param {number} width - The width in logical pixels.
   * @param {number} height - The height in logical pixels.
   * @param {boolean} [updateStyle=true] - Whether to update the `style` attribute of the canvas or not.
   */
  setSize(width, height, updateStyle = true) {
    if (this.xr && this.xr.isPresenting) return;
    this._canvasTarget.setSize(width, height, updateStyle);
  }
  /**
   * Defines a manual sort function for the opaque render list.
   * Pass `null` to use the default sort.
   *
   * @param {Function} method - The sort function.
   */
  setOpaqueSort(method2) {
    this._opaqueSort = method2;
  }
  /**
   * Defines a manual sort function for the transparent render list.
   * Pass `null` to use the default sort.
   *
   * @param {Function} method - The sort function.
   */
  setTransparentSort(method2) {
    this._transparentSort = method2;
  }
  /**
   * Returns the scissor rectangle.
   *
   * @param {Vector4} target - The method writes the result in this target object.
   * @return {Vector4} The scissor rectangle.
   */
  getScissor(target) {
    return this._canvasTarget.getScissor(target);
  }
  /**
   * Defines the scissor rectangle.
   *
   * @param {number | Vector4} x - The horizontal coordinate for the upper left corner of the box in logical pixel unit.
   * Instead of passing four arguments, the method also works with a single four-dimensional vector.
   * @param {number} y - The vertical coordinate for the upper left corner of the box in logical pixel unit.
   * @param {number} width - The width of the scissor box in logical pixel unit.
   * @param {number} height - The height of the scissor box in logical pixel unit.
   */
  setScissor(x3, y3, width, height) {
    this._canvasTarget.setScissor(x3, y3, width, height);
  }
  /**
   * Returns the scissor test value.
   *
   * @return {boolean} Whether the scissor test should be enabled or not.
   */
  getScissorTest() {
    return this._canvasTarget.getScissorTest();
  }
  /**
   * Defines the scissor test.
   *
   * @param {boolean} boolean - Whether the scissor test should be enabled or not.
   */
  setScissorTest(boolean) {
    this._canvasTarget.setScissorTest(boolean);
    this.backend.setScissorTest(boolean);
  }
  /**
   * Returns the viewport definition.
   *
   * @param {Vector4} target - The method writes the result in this target object.
   * @return {Vector4} The viewport definition.
   */
  getViewport(target) {
    return this._canvasTarget.getViewport(target);
  }
  /**
   * Defines the viewport.
   *
   * @param {number | Vector4} x - The horizontal coordinate for the upper left corner of the viewport origin in logical pixel unit.
   * @param {number} y - The vertical coordinate for the upper left corner of the viewport origin  in logical pixel unit.
   * @param {number} width - The width of the viewport in logical pixel unit.
   * @param {number} height - The height of the viewport in logical pixel unit.
   * @param {number} minDepth - The minimum depth value of the viewport. WebGPU only.
   * @param {number} maxDepth - The maximum depth value of the viewport. WebGPU only.
   */
  setViewport(x3, y3, width, height, minDepth = 0, maxDepth = 1) {
    this._canvasTarget.setViewport(x3, y3, width, height, minDepth, maxDepth);
  }
  /**
   * Returns the clear color.
   *
   * @param {Color} target - The method writes the result in this target object.
   * @return {Color} The clear color.
   */
  getClearColor(target) {
    return target.copy(this._clearColor);
  }
  /**
   * Defines the clear color and optionally the clear alpha.
   *
   * @param {Color} color - The clear color.
   * @param {number} [alpha=1] - The clear alpha.
   */
  setClearColor(color3, alpha = 1) {
    this._clearColor.set(color3);
    this._clearColor.a = alpha;
  }
  /**
   * Returns the clear alpha.
   *
   * @return {number} The clear alpha.
   */
  getClearAlpha() {
    return this._clearColor.a;
  }
  /**
   * Defines the clear alpha.
   *
   * @param {number} alpha - The clear alpha.
   */
  setClearAlpha(alpha) {
    this._clearColor.a = alpha;
  }
  /**
   * Returns the clear depth.
   *
   * @return {number} The clear depth.
   */
  getClearDepth() {
    return this._clearDepth;
  }
  /**
   * Defines the clear depth.
   *
   * @param {number} depth - The clear depth.
   */
  setClearDepth(depth2) {
    this._clearDepth = depth2;
  }
  /**
   * Returns the clear stencil.
   *
   * @return {number} The clear stencil.
   */
  getClearStencil() {
    return this._clearStencil;
  }
  /**
   * Defines the clear stencil.
   *
   * @param {number} stencil - The clear stencil.
   */
  setClearStencil(stencil) {
    this._clearStencil = stencil;
  }
  /**
   * This method performs an occlusion query for the given 3D object.
   * It returns `true` if the given 3D object is fully occluded by other
   * 3D objects in the scene.
   *
   * @param {Object3D} object - The 3D object to test.
   * @return {boolean} Whether the 3D object is fully occluded or not.
   */
  isOccluded(object) {
    const renderContext = this._currentRenderContext;
    return renderContext && this.backend.isOccluded(renderContext, object);
  }
  /**
   * Performs a manual clear operation. This method ignores `autoClear` properties.
   *
   * @param {boolean} [color=true] - Whether the color buffer should be cleared or not.
   * @param {boolean} [depth=true] - Whether the depth buffer should be cleared or not.
   * @param {boolean} [stencil=true] - Whether the stencil buffer should be cleared or not.
   */
  clear(color3 = true, depth2 = true, stencil = true) {
    if (this._initialized === false) {
      throw new Error('Renderer: .clear() called before the backend is initialized. Use "await renderer.init();" before before using this method.');
    }
    const renderTarget = this._renderTarget || this._getFrameBufferTarget();
    let renderContext = null;
    if (renderTarget !== null) {
      this._textures.updateRenderTarget(renderTarget);
      const renderTargetData = this._textures.get(renderTarget);
      renderContext = this._renderContexts.getForClear(renderTarget);
      renderContext.textures = renderTargetData.textures;
      renderContext.depthTexture = renderTargetData.depthTexture;
      renderContext.width = renderTargetData.width;
      renderContext.height = renderTargetData.height;
      renderContext.renderTarget = renderTarget;
      renderContext.depth = renderTarget.depthBuffer;
      renderContext.stencil = renderTarget.stencilBuffer;
      renderContext.clearColorValue = this.backend.getClearColor();
      renderContext.activeCubeFace = this.getActiveCubeFace();
      renderContext.activeMipmapLevel = this.getActiveMipmapLevel();
    }
    this.backend.clear(color3, depth2, stencil, renderContext);
    if (renderTarget !== null && this._renderTarget === null) {
      this._renderOutput(renderTarget);
    }
  }
  /**
   * Performs a manual clear operation of the color buffer. This method ignores `autoClear` properties.
   */
  clearColor() {
    this.clear(true, false, false);
  }
  /**
   * Performs a manual clear operation of the depth buffer. This method ignores `autoClear` properties.
   */
  clearDepth() {
    this.clear(false, true, false);
  }
  /**
   * Performs a manual clear operation of the stencil buffer. This method ignores `autoClear` properties.
   */
  clearStencil() {
    this.clear(false, false, true);
  }
  /**
   * Async version of {@link Renderer#clear}.
   *
   * @async
   * @deprecated
   * @param {boolean} [color=true] - Whether the color buffer should be cleared or not.
   * @param {boolean} [depth=true] - Whether the depth buffer should be cleared or not.
   * @param {boolean} [stencil=true] - Whether the stencil buffer should be cleared or not.
   * @return {Promise} A Promise that resolves when the clear operation has been executed.
   */
  async clearAsync(color3 = true, depth2 = true, stencil = true) {
    warnOnce('Renderer: "clearAsync()" has been deprecated. Use "clear()" and "await renderer.init();" when creating the renderer.');
    await this.init();
    this.clear(color3, depth2, stencil);
  }
  /**
   * Async version of {@link Renderer#clearColor}.
   *
   * @async
   * @deprecated
   * @return {Promise} A Promise that resolves when the clear operation has been executed.
   */
  async clearColorAsync() {
    warnOnce('Renderer: "clearColorAsync()" has been deprecated. Use "clearColor()" and "await renderer.init();" when creating the renderer.');
    this.clear(true, false, false);
  }
  /**
   * Async version of {@link Renderer#clearDepth}.
   *
   * @async
   * @deprecated
   * @return {Promise} A Promise that resolves when the clear operation has been executed.
   */
  async clearDepthAsync() {
    warnOnce('Renderer: "clearDepthAsync()" has been deprecated. Use "clearDepth()" and "await renderer.init();" when creating the renderer.');
    this.clear(false, true, false);
  }
  /**
   * Async version of {@link Renderer#clearStencil}.
   *
   * @async
   * @deprecated
   * @return {Promise} A Promise that resolves when the clear operation has been executed.
   */
  async clearStencilAsync() {
    warnOnce('Renderer: "clearStencilAsync()" has been deprecated. Use "clearStencil()" and "await renderer.init();" when creating the renderer.');
    this.clear(false, false, true);
  }
  /**
   * Returns `true` if a framebuffer target is needed to perform tone mapping or color space conversion.
   * If this is the case, the renderer allocates an internal render target for that purpose.
   *
   */
  get needsFrameBufferTarget() {
    const useToneMapping = this.currentToneMapping !== NoToneMapping;
    const useColorSpace = this.currentColorSpace !== ColorManagement.workingColorSpace;
    return useToneMapping || useColorSpace;
  }
  /**
   * The number of samples used for multi-sample anti-aliasing (MSAA).
   *
   * @type {number}
   * @default 0
   */
  get samples() {
    return this._samples;
  }
  /**
   * The current number of samples used for multi-sample anti-aliasing (MSAA).
   *
   * When rendering to a custom render target, the number of samples of that render target is used.
   * If the renderer needs an internal framebuffer target for tone mapping or color space conversion,
   * the number of samples is set to 0.
   *
   * @type {number}
   */
  get currentSamples() {
    let samples = this._samples;
    if (this._renderTarget !== null) {
      samples = this._renderTarget.samples;
    } else if (this.needsFrameBufferTarget) {
      samples = 0;
    }
    return samples;
  }
  /**
   * The current tone mapping of the renderer. When not producing screen output,
   * the tone mapping is always `NoToneMapping`.
   *
   * @type {number}
   */
  get currentToneMapping() {
    return this.isOutputTarget ? this.toneMapping : NoToneMapping;
  }
  /**
   * The current color space of the renderer. When not producing screen output,
   * the color space is always the working color space.
   *
   * @type {string}
   */
  get currentColorSpace() {
    return this.isOutputTarget ? this.outputColorSpace : ColorManagement.workingColorSpace;
  }
  /**
   * Returns `true` if the rendering settings are set to screen output.
   *
   * @returns {boolean} True if the current render target is the same of output render target or `null`, otherwise false.
   */
  get isOutputTarget() {
    return this._renderTarget === this._outputRenderTarget || this._renderTarget === null;
  }
  /**
   * Frees all internal resources of the renderer. Call this method if the renderer
   * is no longer in use by your app.
   */
  dispose() {
    if (this._initialized === true) {
      this.info.dispose();
      this.backend.dispose();
      this._animation.dispose();
      this._objects.dispose();
      this._geometries.dispose();
      this._pipelines.dispose();
      this._nodes.dispose();
      this._bindings.dispose();
      this._renderLists.dispose();
      this._renderContexts.dispose();
      this._textures.dispose();
      if (this._frameBufferTarget !== null) this._frameBufferTarget.dispose();
      Object.values(this.backend.timestampQueryPool).forEach((queryPool) => {
        if (queryPool !== null) queryPool.dispose();
      });
    }
    this.setRenderTarget(null);
    this.setAnimationLoop(null);
  }
  /**
   * Sets the given render target. Calling this method means the renderer does not
   * target the default framebuffer (meaning the canvas) anymore but a custom framebuffer.
   * Use `null` as the first argument to reset the state.
   *
   * @param {?RenderTarget} renderTarget - The render target to set.
   * @param {number} [activeCubeFace=0] - The active cube face.
   * @param {number} [activeMipmapLevel=0] - The active mipmap level.
   */
  setRenderTarget(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
    this._renderTarget = renderTarget;
    this._activeCubeFace = activeCubeFace;
    this._activeMipmapLevel = activeMipmapLevel;
  }
  /**
   * Returns the current render target.
   *
   * @return {?RenderTarget} The render target. Returns `null` if no render target is set.
   */
  getRenderTarget() {
    return this._renderTarget;
  }
  /**
   * Sets the output render target for the renderer.
   *
   * @param {Object} renderTarget - The render target to set as the output target.
   */
  setOutputRenderTarget(renderTarget) {
    this._outputRenderTarget = renderTarget;
  }
  /**
   * Returns the current output target.
   *
   * @return {?RenderTarget} The current output render target. Returns `null` if no output target is set.
   */
  getOutputRenderTarget() {
    return this._outputRenderTarget;
  }
  /**
   * Sets the canvas target. The canvas target manages the HTML canvas
   * or the offscreen canvas the renderer draws into.
   *
   * @param {CanvasTarget} canvasTarget - The canvas target.
   */
  setCanvasTarget(canvasTarget) {
    this._canvasTarget.removeEventListener("resize", this._onCanvasTargetResize);
    this._canvasTarget = canvasTarget;
    this._canvasTarget.addEventListener("resize", this._onCanvasTargetResize);
  }
  /**
   * Returns the current canvas target.
   *
   * @return {CanvasTarget} The current canvas target.
   */
  getCanvasTarget() {
    return this._canvasTarget;
  }
  /**
   * Resets the renderer to the initial state before WebXR started.
   *
   * @private
   */
  _resetXRState() {
    this.backend.setXRTarget(null);
    this.setOutputRenderTarget(null);
    this.setRenderTarget(null);
    this._frameBufferTarget.dispose();
    this._frameBufferTarget = null;
  }
  /**
   * Callback for {@link Renderer#setRenderObjectFunction}.
   *
   * @callback renderObjectFunction
   * @param {Object3D} object - The 3D object.
   * @param {Scene} scene - The scene the 3D object belongs to.
   * @param {Camera} camera - The camera the object should be rendered with.
   * @param {BufferGeometry} geometry - The object's geometry.
   * @param {Material} material - The object's material.
   * @param {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
   * @param {LightsNode} lightsNode - The current lights node.
   * @param {ClippingContext} clippingContext - The clipping context.
   * @param {?string} [passId=null] - An optional ID for identifying the pass.
   */
  /**
   * Sets the given render object function. Calling this method overwrites the default implementation
   * which is {@link Renderer#renderObject}. Defining a custom function can be useful
   * if you want to modify the way objects are rendered. For example you can define things like "every
   * object that has material of a certain type should perform a pre-pass with a special overwrite material".
   * The custom function must always call `renderObject()` in its implementation.
   *
   * Use `null` as the first argument to reset the state.
   *
   * @param {?renderObjectFunction} renderObjectFunction - The render object function.
   */
  setRenderObjectFunction(renderObjectFunction) {
    this._renderObjectFunction = renderObjectFunction;
  }
  /**
   * Returns the current render object function.
   *
   * @return {?Function} The current render object function. Returns `null` if no function is set.
   */
  getRenderObjectFunction() {
    return this._renderObjectFunction;
  }
  /**
   * Execute a single or an array of compute nodes. This method can only be called
   * if the renderer has been initialized.
   *
   * @param {Node|Array<Node>} computeNodes - The compute node(s).
   * @param {number|Array<number>|IndirectStorageBufferAttribute} [dispatchSize=null]
   * - A single number representing count, or
   * - An array [x, y, z] representing dispatch size, or
   * - A IndirectStorageBufferAttribute for indirect dispatch size.
   * @return {Promise|undefined} A Promise that resolve when the compute has finished. Only returned when the renderer has not been initialized.
   */
  compute(computeNodes, dispatchSize = null) {
    if (this._isDeviceLost === true) return;
    if (this._initialized === false) {
      warn("Renderer: .compute() called before the backend is initialized. Try using .computeAsync() instead.");
      return this.computeAsync(computeNodes, dispatchSize);
    }
    const nodeFrame = this._nodes.nodeFrame;
    const previousRenderId = nodeFrame.renderId;
    this.info.calls++;
    this.info.compute.calls++;
    this.info.compute.frameCalls++;
    nodeFrame.renderId = this.info.calls;
    this.backend.updateTimeStampUID(computeNodes);
    this.inspector.beginCompute(this.backend.getTimestampUID(computeNodes), computeNodes);
    const backend = this.backend;
    const pipelines = this._pipelines;
    const bindings = this._bindings;
    const nodes = this._nodes;
    const computeList = Array.isArray(computeNodes) ? computeNodes : [computeNodes];
    if (computeList[0] === void 0 || computeList[0].isComputeNode !== true) {
      throw new Error("THREE.Renderer: .compute() expects a ComputeNode.");
    }
    backend.beginCompute(computeNodes);
    for (const computeNode of computeList) {
      if (pipelines.has(computeNode) === false) {
        const dispose = () => {
          computeNode.removeEventListener("dispose", dispose);
          pipelines.delete(computeNode);
          bindings.deleteForCompute(computeNode);
          nodes.delete(computeNode);
        };
        computeNode.addEventListener("dispose", dispose);
        const onInitFn = computeNode.onInitFunction;
        if (onInitFn !== null) {
          onInitFn.call(computeNode, { renderer: this });
        }
      }
      nodes.updateForCompute(computeNode);
      bindings.updateForCompute(computeNode);
      const computeBindings = bindings.getForCompute(computeNode);
      const computePipeline = pipelines.getForCompute(computeNode, computeBindings);
      backend.compute(computeNodes, computeNode, computeBindings, computePipeline, dispatchSize);
    }
    backend.finishCompute(computeNodes);
    nodeFrame.renderId = previousRenderId;
    this.inspector.finishCompute(this.backend.getTimestampUID(computeNodes));
  }
  /**
   * Execute a single or an array of compute nodes.
   *
   * @async
   * @param {Node|Array<Node>} computeNodes - The compute node(s).
   * @param {number|Array<number>|IndirectStorageBufferAttribute} [dispatchSize=null]
   * - A single number representing count, or
   * - An array [x, y, z] representing dispatch size, or
   * - A IndirectStorageBufferAttribute for indirect dispatch size.
   * @return {Promise} A Promise that resolve when the compute has finished.
   */
  async computeAsync(computeNodes, dispatchSize = null) {
    if (this._initialized === false) await this.init();
    this.compute(computeNodes, dispatchSize);
  }
  /**
   * Checks if the given feature is supported by the selected backend.
   *
   * @async
   * @deprecated
   * @param {string} name - The feature's name.
   * @return {Promise<boolean>} A Promise that resolves with a bool that indicates whether the feature is supported or not.
   */
  async hasFeatureAsync(name) {
    warnOnce('Renderer: "hasFeatureAsync()" has been deprecated. Use "hasFeature()" and "await renderer.init();" when creating the renderer.');
    await this.init();
    return this.hasFeature(name);
  }
  async resolveTimestampsAsync(type = "render") {
    if (this._initialized === false) await this.init();
    return this.backend.resolveTimestampsAsync(type);
  }
  /**
   * Checks if the given feature is supported by the selected backend. If the
   * renderer has not been initialized, this method always returns `false`.
   *
   * @param {string} name - The feature's name.
   * @return {boolean} Whether the feature is supported or not.
   */
  hasFeature(name) {
    if (this._initialized === false) {
      throw new Error('Renderer: .hasFeature() called before the backend is initialized. Use "await renderer.init();" before before using this method.');
    }
    return this.backend.hasFeature(name);
  }
  /**
   * Returns `true` when the renderer has been initialized.
   *
   * @return {boolean} Whether the renderer has been initialized or not.
   */
  hasInitialized() {
    return this._initialized;
  }
  /**
   * Initializes the given textures. Useful for preloading a texture rather than waiting until first render
   * (which can cause noticeable lags due to decode and GPU upload overhead).
   *
   * @async
   * @deprecated
   * @param {Texture} texture - The texture.
   * @return {Promise} A Promise that resolves when the texture has been initialized.
   */
  async initTextureAsync(texture2) {
    warnOnce('Renderer: "initTextureAsync()" has been deprecated. Use "initTexture()" and "await renderer.init();" when creating the renderer.');
    await this.init();
    this.initTexture(texture2);
  }
  /**
   * Initializes the given texture. Useful for preloading a texture rather than waiting until first render
   * (which can cause noticeable lags due to decode and GPU upload overhead).
   *
   * This method can only be used if the renderer has been initialized.
   *
   * @param {Texture} texture - The texture.
   */
  initTexture(texture2) {
    if (this._initialized === false) {
      throw new Error('Renderer: .initTexture() called before the backend is initialized. Use "await renderer.init();" before before using this method.');
    }
    this._textures.updateTexture(texture2);
  }
  /**
   * Copies the current bound framebuffer into the given texture.
   *
   * @param {FramebufferTexture} framebufferTexture - The texture.
   * @param {?(Vector2|Vector4)} [rectangle=null] - A two or four dimensional vector that defines the rectangular portion of the framebuffer that should be copied.
   */
  copyFramebufferToTexture(framebufferTexture, rectangle = null) {
    if (rectangle !== null) {
      if (rectangle.isVector2) {
        rectangle = _vector4.set(rectangle.x, rectangle.y, framebufferTexture.image.width, framebufferTexture.image.height).floor();
      } else if (rectangle.isVector4) {
        rectangle = _vector4.copy(rectangle).floor();
      } else {
        error("Renderer.copyFramebufferToTexture: Invalid rectangle.");
        return;
      }
    } else {
      rectangle = _vector4.set(0, 0, framebufferTexture.image.width, framebufferTexture.image.height);
    }
    let renderContext = this._currentRenderContext;
    let renderTarget;
    if (renderContext !== null) {
      renderTarget = renderContext.renderTarget;
    } else {
      renderTarget = this._renderTarget || this._getFrameBufferTarget();
      if (renderTarget !== null) {
        this._textures.updateRenderTarget(renderTarget);
        renderContext = this._textures.get(renderTarget);
      }
    }
    this._textures.updateTexture(framebufferTexture, { renderTarget });
    this.backend.copyFramebufferToTexture(framebufferTexture, renderContext, rectangle);
    this._inspector.copyFramebufferToTexture(framebufferTexture);
  }
  /**
   * Copies data of the given source texture into a destination texture.
   *
   * @param {Texture} srcTexture - The source texture.
   * @param {Texture} dstTexture - The destination texture.
   * @param {Box2|Box3} [srcRegion=null] - A bounding box which describes the source region. Can be two or three-dimensional.
   * @param {Vector2|Vector3} [dstPosition=null] - A vector that represents the origin of the destination region. Can be two or three-dimensional.
   * @param {number} [srcLevel=0] - The source mip level to copy from.
   * @param {number} [dstLevel=0] - The destination mip level to copy to.
   */
  copyTextureToTexture(srcTexture, dstTexture, srcRegion = null, dstPosition = null, srcLevel = 0, dstLevel = 0) {
    this._textures.updateTexture(srcTexture);
    this._textures.updateTexture(dstTexture);
    this.backend.copyTextureToTexture(srcTexture, dstTexture, srcRegion, dstPosition, srcLevel, dstLevel);
    this._inspector.copyTextureToTexture(srcTexture, dstTexture);
  }
  /**
   * Reads pixel data from the given render target.
   *
   * @async
   * @param {RenderTarget} renderTarget - The render target to read from.
   * @param {number} x - The `x` coordinate of the copy region's origin.
   * @param {number} y - The `y` coordinate of the copy region's origin.
   * @param {number} width - The width of the copy region.
   * @param {number} height - The height of the copy region.
   * @param {number} [textureIndex=0] - The texture index of a MRT render target.
   * @param {number} [faceIndex=0] - The active cube face index.
   * @return {Promise<TypedArray>} A Promise that resolves when the read has been finished. The resolve provides the read data as a typed array.
   */
  async readRenderTargetPixelsAsync(renderTarget, x3, y3, width, height, textureIndex = 0, faceIndex = 0) {
    return this.backend.copyTextureToBuffer(renderTarget.textures[textureIndex], x3, y3, width, height, faceIndex);
  }
  /**
   * Analyzes the given 3D object's hierarchy and builds render lists from the
   * processed hierarchy.
   *
   * @private
   * @param {Object3D} object - The 3D object to process (usually a scene).
   * @param {Camera} camera - The camera the object is rendered with.
   * @param {number} groupOrder - The group order is derived from the `renderOrder` of groups and is used to group 3D objects within groups.
   * @param {RenderList} renderList - The current render list.
   * @param {ClippingContext} clippingContext - The current clipping context.
   */
  _projectObject(object, camera3, groupOrder, renderList, clippingContext) {
    if (object.visible === false) return;
    const visible = object.layers.test(camera3.layers);
    if (visible) {
      if (object.isGroup) {
        groupOrder = object.renderOrder;
        if (object.isClippingGroup && object.enabled) clippingContext = clippingContext.getGroupContext(object);
      } else if (object.isLOD) {
        if (object.autoUpdate === true) object.update(camera3);
      } else if (object.isLight) {
        renderList.pushLight(object);
      } else if (object.isSprite) {
        const frustum = camera3.isArrayCamera ? _frustumArray : _frustum2;
        if (!object.frustumCulled || frustum.intersectsSprite(object, camera3)) {
          if (this.sortObjects === true) {
            _vector4.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
          }
          const { geometry, material } = object;
          if (material.visible) {
            renderList.push(object, geometry, material, groupOrder, _vector4.z, null, clippingContext);
          }
        }
      } else if (object.isLineLoop) {
        error("Renderer: Objects of type THREE.LineLoop are not supported. Please use THREE.Line or THREE.LineSegments.");
      } else if (object.isMesh || object.isLine || object.isPoints) {
        const frustum = camera3.isArrayCamera ? _frustumArray : _frustum2;
        if (!object.frustumCulled || frustum.intersectsObject(object, camera3)) {
          const { geometry, material } = object;
          if (this.sortObjects === true) {
            if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
            _vector4.copy(geometry.boundingSphere.center).applyMatrix4(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
          }
          if (Array.isArray(material)) {
            const groups2 = geometry.groups;
            for (let i2 = 0, l2 = groups2.length; i2 < l2; i2++) {
              const group2 = groups2[i2];
              const groupMaterial = material[group2.materialIndex];
              if (groupMaterial && groupMaterial.visible) {
                renderList.push(object, geometry, groupMaterial, groupOrder, _vector4.z, group2, clippingContext);
              }
            }
          } else if (material.visible) {
            renderList.push(object, geometry, material, groupOrder, _vector4.z, null, clippingContext);
          }
        }
      }
    }
    if (object.isBundleGroup === true && this.backend.beginBundle !== void 0) {
      const baseRenderList = renderList;
      renderList = this._renderLists.get(object, camera3);
      renderList.begin();
      baseRenderList.pushBundle({
        bundleGroup: object,
        camera: camera3,
        renderList
      });
      renderList.finish();
    }
    const children2 = object.children;
    for (let i2 = 0, l2 = children2.length; i2 < l2; i2++) {
      this._projectObject(children2[i2], camera3, groupOrder, renderList, clippingContext);
    }
  }
  /**
   * Renders the given render bundles.
   *
   * @private
   * @param {Array<Object>} bundles - Array with render bundle data.
   * @param {Scene} sceneRef - The scene the render bundles belong to.
   * @param {LightsNode} lightsNode - The current lights node.
   */
  _renderBundles(bundles, sceneRef, lightsNode) {
    for (const bundle of bundles) {
      this._renderBundle(bundle, sceneRef, lightsNode);
    }
  }
  /**
   * Renders the transparent objects from the given render lists.
   *
   * @private
   * @param {Array<Object>} renderList - The transparent render list.
   * @param {Array<Object>} doublePassList - The list of transparent objects which require a double pass (e.g. because of transmission).
   * @param {Camera} camera - The camera the render list should be rendered with.
   * @param {Scene} scene - The scene the render list belongs to.
   * @param {LightsNode} lightsNode - The current lights node.
   */
  _renderTransparents(renderList, doublePassList, camera3, scene3, lightsNode) {
    if (doublePassList.length > 0) {
      for (const { material } of doublePassList) {
        material.side = BackSide;
      }
      this._renderObjects(doublePassList, camera3, scene3, lightsNode, "backSide");
      for (const { material } of doublePassList) {
        material.side = FrontSide;
      }
      this._renderObjects(renderList, camera3, scene3, lightsNode);
      for (const { material } of doublePassList) {
        material.side = DoubleSide;
      }
    } else {
      this._renderObjects(renderList, camera3, scene3, lightsNode);
    }
  }
  /**
   * Renders the objects from the given render list.
   *
   * @private
   * @param {Array<Object>} renderList - The render list.
   * @param {Camera} camera - The camera the render list should be rendered with.
   * @param {Scene} scene - The scene the render list belongs to.
   * @param {LightsNode} lightsNode - The current lights node.
   * @param {?string} [passId=null] - An optional ID for identifying the pass.
   */
  _renderObjects(renderList, camera3, scene3, lightsNode, passId = null) {
    for (let i2 = 0, il = renderList.length; i2 < il; i2++) {
      const { object, geometry, material, group: group2, clippingContext } = renderList[i2];
      this._currentRenderObjectFunction(object, scene3, camera3, geometry, material, group2, lightsNode, clippingContext, passId);
    }
  }
  /**
   * Retrieves shadow nodes for the given material. This is used to setup shadow passes.
   * The result is cached per material and updated when the material's version changes.
   *
   * @private
   * @param {Material} material
   * @returns {Object} - The shadow nodes for the material.
   */
  _getShadowNodes(material) {
    const version = material.version;
    let cache2 = this._cacheShadowNodes.get(material);
    if (cache2 === void 0 || cache2.version !== version) {
      const hasMap = material.map !== null;
      const hasColorNode = material.colorNode && material.colorNode.isNode;
      const hasCastShadowNode = material.castShadowNode && material.castShadowNode.isNode;
      let positionNode = null;
      let colorNode = null;
      let depthNode = null;
      if (hasMap || hasColorNode || hasCastShadowNode) {
        let shadowRGB;
        let shadowAlpha;
        if (hasCastShadowNode) {
          shadowRGB = material.castShadowNode.rgb;
          shadowAlpha = material.castShadowNode.a;
        } else {
          shadowRGB = vec3(0);
          shadowAlpha = float(1);
        }
        if (hasMap) {
          shadowAlpha = shadowAlpha.mul(reference("map", "texture", material).a);
        }
        if (hasColorNode) {
          shadowAlpha = shadowAlpha.mul(material.colorNode.a);
        }
        colorNode = vec4(shadowRGB, shadowAlpha);
      }
      if (material.depthNode && material.depthNode.isNode) {
        depthNode = material.depthNode;
      }
      if (material.castShadowPositionNode && material.castShadowPositionNode.isNode) {
        positionNode = material.castShadowPositionNode;
      } else if (material.positionNode && material.positionNode.isNode) {
        positionNode = material.positionNode;
      }
      cache2 = {
        version,
        colorNode,
        depthNode,
        positionNode
      };
      this._cacheShadowNodes.set(material, cache2);
    }
    return cache2;
  }
  /**
   * This method represents the default render object function that manages the render lifecycle
   * of the object.
   *
   * @param {Object3D} object - The 3D object.
   * @param {Scene} scene - The scene the 3D object belongs to.
   * @param {Camera} camera - The camera the object should be rendered with.
   * @param {BufferGeometry} geometry - The object's geometry.
   * @param {Material} material - The object's material.
   * @param {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
   * @param {LightsNode} lightsNode - The current lights node.
   * @param {?ClippingContext} clippingContext - The clipping context.
   * @param {?string} [passId=null] - An optional ID for identifying the pass.
   */
  renderObject(object, scene3, camera3, geometry, material, group2, lightsNode, clippingContext = null, passId = null) {
    let materialOverride = false;
    let materialColorNode;
    let materialDepthNode;
    let materialPositionNode;
    let materialSide;
    object.onBeforeRender(this, scene3, camera3, geometry, material, group2);
    if (material.allowOverride === true && scene3.overrideMaterial !== null) {
      const overrideMaterial = scene3.overrideMaterial;
      materialOverride = true;
      materialColorNode = scene3.overrideMaterial.colorNode;
      materialDepthNode = scene3.overrideMaterial.depthNode;
      materialPositionNode = scene3.overrideMaterial.positionNode;
      materialSide = scene3.overrideMaterial.side;
      if (material.positionNode && material.positionNode.isNode) {
        overrideMaterial.positionNode = material.positionNode;
      }
      overrideMaterial.alphaTest = material.alphaTest;
      overrideMaterial.alphaMap = material.alphaMap;
      overrideMaterial.transparent = material.transparent || material.transmission > 0 || material.transmissionNode && material.transmissionNode.isNode || material.backdropNode && material.backdropNode.isNode;
      if (overrideMaterial.isShadowPassMaterial) {
        const { colorNode, depthNode, positionNode } = this._getShadowNodes(material);
        overrideMaterial.side = material.shadowSide === null ? material.side : material.shadowSide;
        if (colorNode !== null) overrideMaterial.colorNode = colorNode;
        if (depthNode !== null) overrideMaterial.depthNode = depthNode;
        if (positionNode !== null) overrideMaterial.positionNode = positionNode;
      }
      material = overrideMaterial;
    }
    if (material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false) {
      material.side = BackSide;
      this._handleObjectFunction(object, material, scene3, camera3, lightsNode, group2, clippingContext, "backSide");
      material.side = FrontSide;
      this._handleObjectFunction(object, material, scene3, camera3, lightsNode, group2, clippingContext, passId);
      material.side = DoubleSide;
    } else {
      this._handleObjectFunction(object, material, scene3, camera3, lightsNode, group2, clippingContext, passId);
    }
    if (materialOverride) {
      scene3.overrideMaterial.colorNode = materialColorNode;
      scene3.overrideMaterial.depthNode = materialDepthNode;
      scene3.overrideMaterial.positionNode = materialPositionNode;
      scene3.overrideMaterial.side = materialSide;
    }
    object.onAfterRender(this, scene3, camera3, geometry, material, group2);
  }
  /**
   * This method represents the default `_handleObjectFunction` implementation which creates
   * a render object from the given data and performs the draw command with the selected backend.
   *
   * @private
   * @param {Object3D} object - The 3D object.
   * @param {Material} material - The object's material.
   * @param {Scene} scene - The scene the 3D object belongs to.
   * @param {Camera} camera - The camera the object should be rendered with.
   * @param {LightsNode} lightsNode - The current lights node.
   * @param {?{start: number, count: number}} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
   * @param {ClippingContext} clippingContext - The clipping context.
   * @param {string} [passId] - An optional ID for identifying the pass.
   */
  _renderObjectDirect(object, material, scene3, camera3, lightsNode, group2, clippingContext, passId) {
    const renderObject = this._objects.get(object, material, scene3, camera3, lightsNode, this._currentRenderContext, clippingContext, passId);
    renderObject.drawRange = object.geometry.drawRange;
    renderObject.group = group2;
    const needsRefresh = this._nodes.needsRefresh(renderObject);
    if (needsRefresh) {
      this._nodes.updateBefore(renderObject);
      this._geometries.updateForRender(renderObject);
      this._nodes.updateForRender(renderObject);
      this._bindings.updateForRender(renderObject);
    }
    this._pipelines.updateForRender(renderObject);
    if (this._currentRenderBundle !== null) {
      const renderBundleData = this.backend.get(this._currentRenderBundle);
      renderBundleData.renderObjects.push(renderObject);
      renderObject.bundle = this._currentRenderBundle.bundleGroup;
    }
    this.backend.draw(renderObject, this.info);
    if (needsRefresh) this._nodes.updateAfter(renderObject);
  }
  /**
   * A different implementation for `_handleObjectFunction` which only makes sure the object is ready for rendering.
   * Used in `compileAsync()`.
   *
   * @private
   * @param {Object3D} object - The 3D object.
   * @param {Material} material - The object's material.
   * @param {Scene} scene - The scene the 3D object belongs to.
   * @param {Camera} camera - The camera the object should be rendered with.
   * @param {LightsNode} lightsNode - The current lights node.
   * @param {?{start: number, count: number}} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
   * @param {ClippingContext} clippingContext - The clipping context.
   * @param {string} [passId] - An optional ID for identifying the pass.
   */
  _createObjectPipeline(object, material, scene3, camera3, lightsNode, group2, clippingContext, passId) {
    const renderObject = this._objects.get(object, material, scene3, camera3, lightsNode, this._currentRenderContext, clippingContext, passId);
    renderObject.drawRange = object.geometry.drawRange;
    renderObject.group = group2;
    this._nodes.updateBefore(renderObject);
    this._geometries.updateForRender(renderObject);
    this._nodes.updateForRender(renderObject);
    this._bindings.updateForRender(renderObject);
    this._pipelines.getForRender(renderObject, this._compilationPromises);
    this._nodes.updateAfter(renderObject);
  }
  /**
   * Callback when the canvas has been resized.
   *
   * @private
   */
  _onCanvasTargetResize() {
    if (this._initialized) this.backend.updateSize();
  }
  /**
   * Alias for `compileAsync()`.
   *
   * @method
   * @param {Object3D} scene - The scene or 3D object to precompile.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {Scene} targetScene - If the first argument is a 3D object, this parameter must represent the scene the 3D object is going to be added.
   * @return {function(Object3D, Camera, ?Scene): Promise|undefined} A Promise that resolves when the compile has been finished.
   */
  get compile() {
    return this.compileAsync;
  }
};
var Binding = class {
  /**
   * Constructs a new binding.
   *
   * @param {string} [name=''] - The binding's name.
   */
  constructor(name = "") {
    this.name = name;
    this.visibility = 0;
  }
  /**
   * Makes sure binding's resource is visible for the given shader stage.
   *
   * @param {number} visibility - The shader stage.
   */
  setVisibility(visibility) {
    this.visibility |= visibility;
  }
  /**
   * The shader stages in which the binding's resource is visible.
   *
   * @return {number} The visibility bitmask.
   */
  getVisibility() {
    return this.visibility;
  }
  /**
   * Clones the binding.
   *
   * @return {Binding} The cloned binding.
   */
  clone() {
    return Object.assign(new this.constructor(), this);
  }
};
function getFloatLength(floatLength) {
  return floatLength + (GPU_CHUNK_BYTES - floatLength % GPU_CHUNK_BYTES) % GPU_CHUNK_BYTES;
}
var Buffer = class extends Binding {
  /**
   * Constructs a new buffer.
   *
   * @param {string} name - The buffer's name.
   * @param {TypedArray} [buffer=null] - The buffer.
   */
  constructor(name, buffer2 = null) {
    super(name);
    this.isBuffer = true;
    this.bytesPerElement = Float32Array.BYTES_PER_ELEMENT;
    this._buffer = buffer2;
    this._updateRanges = [];
  }
  /**
   * The array of update ranges.
   *
   * @type {Array<{start: number, count: number}>}
   */
  get updateRanges() {
    return this._updateRanges;
  }
  /**
   * Adds an update range.
   *
   * @param {number} start - The start index.
   * @param {number} count - The number of elements.
   */
  addUpdateRange(start2, count2) {
    this.updateRanges.push({ start: start2, count: count2 });
  }
  /**
   * Clears all update ranges.
   */
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  /**
   * The buffer's byte length.
   *
   * @type {number}
   * @readonly
   */
  get byteLength() {
    return getFloatLength(this._buffer.byteLength);
  }
  /**
   * A reference to the internal buffer.
   *
   * @type {Float32Array}
   * @readonly
   */
  get buffer() {
    return this._buffer;
  }
  /**
   * Updates the binding.
   *
   * @return {boolean} Whether the buffer has been updated and must be
   * uploaded to the GPU.
   */
  update() {
    return true;
  }
};
var UniformBuffer = class extends Buffer {
  /**
   * Constructs a new uniform buffer.
   *
   * @param {string} name - The buffer's name.
   * @param {TypedArray} [buffer=null] - The buffer.
   */
  constructor(name, buffer2 = null) {
    super(name, buffer2);
    this.isUniformBuffer = true;
  }
};
var _id$4 = 0;
var NodeUniformBuffer = class extends UniformBuffer {
  /**
   * Constructs a new node-based uniform buffer.
   *
   * @param {BufferNode} nodeUniform - The uniform buffer node.
   * @param {UniformGroupNode} groupNode - The uniform group node.
   */
  constructor(nodeUniform, groupNode) {
    super("UniformBuffer_" + _id$4++, nodeUniform ? nodeUniform.value : null);
    this.nodeUniform = nodeUniform;
    this.groupNode = groupNode;
    this.isNodeUniformBuffer = true;
  }
  /**
   * The array of update ranges.
   *
   * @param {Array<{start: number, count: number}>} value - The update ranges.
   */
  set updateRanges(value) {
    this.nodeUniform.updateRanges = value;
  }
  /**
   * The array of update ranges.
   *
   * @type {Array<{start: number, count: number}>}
   */
  get updateRanges() {
    return this.nodeUniform.updateRanges;
  }
  /**
   * Adds a range of data in the data array to be updated on the GPU.
   *
   * @param {number} start - Position at which to start update.
   * @param {number} count - The number of components to update.
   */
  addUpdateRange(start2, count2) {
    this.nodeUniform.addUpdateRange(start2, count2);
  }
  /**
   * Clears all update ranges.
   */
  clearUpdateRanges() {
    this.nodeUniform.clearUpdateRanges();
  }
  /**
   * The uniform buffer.
   *
   * @type {Float32Array}
   */
  get buffer() {
    return this.nodeUniform.value;
  }
};
var UniformsGroup2 = class extends UniformBuffer {
  /**
   * Constructs a new uniforms group.
   *
   * @param {string} name - The group's name.
   */
  constructor(name) {
    super(name);
    this.isUniformsGroup = true;
    this._values = null;
    this.uniforms = [];
  }
  /**
   * Adds a uniform to this group.
   *
   * @param {Uniform} uniform - The uniform to add.
   * @return {UniformsGroup} A reference to this group.
   */
  addUniform(uniform2) {
    this.uniforms.push(uniform2);
    return this;
  }
  /**
   * Removes a uniform from this group.
   *
   * @param {Uniform} uniform - The uniform to remove.
   * @return {UniformsGroup} A reference to this group.
   */
  removeUniform(uniform2) {
    const index8 = this.uniforms.indexOf(uniform2);
    if (index8 !== -1) {
      this.uniforms.splice(index8, 1);
    }
    return this;
  }
  /**
   * An array with the raw uniform values.
   *
   * @type {Array<number>}
   */
  get values() {
    if (this._values === null) {
      this._values = Array.from(this.buffer);
    }
    return this._values;
  }
  /**
   * A Float32 array buffer with the uniform values.
   *
   * @type {Float32Array}
   */
  get buffer() {
    let buffer2 = this._buffer;
    if (buffer2 === null) {
      const byteLength = this.byteLength;
      buffer2 = new Float32Array(new ArrayBuffer(byteLength));
      this._buffer = buffer2;
    }
    return buffer2;
  }
  /**
   * The byte length of the buffer with correct buffer alignment.
   *
   * @type {number}
   */
  get byteLength() {
    const bytesPerElement = this.bytesPerElement;
    let offset = 0;
    for (let i2 = 0, l2 = this.uniforms.length; i2 < l2; i2++) {
      const uniform2 = this.uniforms[i2];
      const boundary = uniform2.boundary;
      const itemSize = uniform2.itemSize * bytesPerElement;
      const chunkOffset = offset % GPU_CHUNK_BYTES;
      const chunkPadding = chunkOffset % boundary;
      const chunkStart = chunkOffset + chunkPadding;
      offset += chunkPadding;
      if (chunkStart !== 0 && GPU_CHUNK_BYTES - chunkStart < itemSize) {
        offset += GPU_CHUNK_BYTES - chunkStart;
      }
      uniform2.offset = offset / bytesPerElement;
      offset += itemSize;
    }
    return Math.ceil(offset / GPU_CHUNK_BYTES) * GPU_CHUNK_BYTES;
  }
  /**
   * Updates this group by updating each uniform object of
   * the internal uniform list. The uniform objects check if their
   * values has actually changed so this method only returns
   * `true` if there is a real value change.
   *
   * @return {boolean} Whether the uniforms have been updated and
   * must be uploaded to the GPU.
   */
  update() {
    let updated = false;
    for (const uniform2 of this.uniforms) {
      if (this.updateByType(uniform2) === true) {
        updated = true;
      }
    }
    return updated;
  }
  /**
   * Updates a given uniform by calling an update method matching
   * the uniforms type.
   *
   * @param {Uniform} uniform - The uniform to update.
   * @return {boolean} Whether the uniform has been updated or not.
   */
  updateByType(uniform2) {
    if (uniform2.isNumberUniform) return this.updateNumber(uniform2);
    if (uniform2.isVector2Uniform) return this.updateVector2(uniform2);
    if (uniform2.isVector3Uniform) return this.updateVector3(uniform2);
    if (uniform2.isVector4Uniform) return this.updateVector4(uniform2);
    if (uniform2.isColorUniform) return this.updateColor(uniform2);
    if (uniform2.isMatrix3Uniform) return this.updateMatrix3(uniform2);
    if (uniform2.isMatrix4Uniform) return this.updateMatrix4(uniform2);
    error("WebGPUUniformsGroup: Unsupported uniform type.", uniform2);
  }
  /**
   * Updates a given Number uniform.
   *
   * @param {NumberUniform} uniform - The Number uniform.
   * @return {boolean} Whether the uniform has been updated or not.
   */
  updateNumber(uniform2) {
    let updated = false;
    const a3 = this.values;
    const v2 = uniform2.getValue();
    const offset = uniform2.offset;
    const type = uniform2.getType();
    if (a3[offset] !== v2) {
      const b = this._getBufferForType(type);
      b[offset] = a3[offset] = v2;
      updated = true;
    }
    return updated;
  }
  /**
   * Updates a given Vector2 uniform.
   *
   * @param {Vector2Uniform} uniform - The Vector2 uniform.
   * @return {boolean} Whether the uniform has been updated or not.
   */
  updateVector2(uniform2) {
    let updated = false;
    const a3 = this.values;
    const v2 = uniform2.getValue();
    const offset = uniform2.offset;
    const type = uniform2.getType();
    if (a3[offset + 0] !== v2.x || a3[offset + 1] !== v2.y) {
      const b = this._getBufferForType(type);
      b[offset + 0] = a3[offset + 0] = v2.x;
      b[offset + 1] = a3[offset + 1] = v2.y;
      updated = true;
    }
    return updated;
  }
  /**
   * Updates a given Vector3 uniform.
   *
   * @param {Vector3Uniform} uniform - The Vector3 uniform.
   * @return {boolean} Whether the uniform has been updated or not.
   */
  updateVector3(uniform2) {
    let updated = false;
    const a3 = this.values;
    const v2 = uniform2.getValue();
    const offset = uniform2.offset;
    const type = uniform2.getType();
    if (a3[offset + 0] !== v2.x || a3[offset + 1] !== v2.y || a3[offset + 2] !== v2.z) {
      const b = this._getBufferForType(type);
      b[offset + 0] = a3[offset + 0] = v2.x;
      b[offset + 1] = a3[offset + 1] = v2.y;
      b[offset + 2] = a3[offset + 2] = v2.z;
      updated = true;
    }
    return updated;
  }
  /**
   * Updates a given Vector4 uniform.
   *
   * @param {Vector4Uniform} uniform - The Vector4 uniform.
   * @return {boolean} Whether the uniform has been updated or not.
   */
  updateVector4(uniform2) {
    let updated = false;
    const a3 = this.values;
    const v2 = uniform2.getValue();
    const offset = uniform2.offset;
    const type = uniform2.getType();
    if (a3[offset + 0] !== v2.x || a3[offset + 1] !== v2.y || a3[offset + 2] !== v2.z || a3[offset + 4] !== v2.w) {
      const b = this._getBufferForType(type);
      b[offset + 0] = a3[offset + 0] = v2.x;
      b[offset + 1] = a3[offset + 1] = v2.y;
      b[offset + 2] = a3[offset + 2] = v2.z;
      b[offset + 3] = a3[offset + 3] = v2.w;
      updated = true;
    }
    return updated;
  }
  /**
   * Updates a given Color uniform.
   *
   * @param {ColorUniform} uniform - The Color uniform.
   * @return {boolean} Whether the uniform has been updated or not.
   */
  updateColor(uniform2) {
    let updated = false;
    const a3 = this.values;
    const c5 = uniform2.getValue();
    const offset = uniform2.offset;
    if (a3[offset + 0] !== c5.r || a3[offset + 1] !== c5.g || a3[offset + 2] !== c5.b) {
      const b = this.buffer;
      b[offset + 0] = a3[offset + 0] = c5.r;
      b[offset + 1] = a3[offset + 1] = c5.g;
      b[offset + 2] = a3[offset + 2] = c5.b;
      updated = true;
    }
    return updated;
  }
  /**
   * Updates a given Matrix3 uniform.
   *
   * @param {Matrix3Uniform} uniform - The Matrix3 uniform.
   * @return {boolean} Whether the uniform has been updated or not.
   */
  updateMatrix3(uniform2) {
    let updated = false;
    const a3 = this.values;
    const e3 = uniform2.getValue().elements;
    const offset = uniform2.offset;
    if (a3[offset + 0] !== e3[0] || a3[offset + 1] !== e3[1] || a3[offset + 2] !== e3[2] || a3[offset + 4] !== e3[3] || a3[offset + 5] !== e3[4] || a3[offset + 6] !== e3[5] || a3[offset + 8] !== e3[6] || a3[offset + 9] !== e3[7] || a3[offset + 10] !== e3[8]) {
      const b = this.buffer;
      b[offset + 0] = a3[offset + 0] = e3[0];
      b[offset + 1] = a3[offset + 1] = e3[1];
      b[offset + 2] = a3[offset + 2] = e3[2];
      b[offset + 4] = a3[offset + 4] = e3[3];
      b[offset + 5] = a3[offset + 5] = e3[4];
      b[offset + 6] = a3[offset + 6] = e3[5];
      b[offset + 8] = a3[offset + 8] = e3[6];
      b[offset + 9] = a3[offset + 9] = e3[7];
      b[offset + 10] = a3[offset + 10] = e3[8];
      updated = true;
    }
    return updated;
  }
  /**
   * Updates a given Matrix4 uniform.
   *
   * @param {Matrix4Uniform} uniform - The Matrix4 uniform.
   * @return {boolean} Whether the uniform has been updated or not.
   */
  updateMatrix4(uniform2) {
    let updated = false;
    const a3 = this.values;
    const e3 = uniform2.getValue().elements;
    const offset = uniform2.offset;
    if (arraysEqual(a3, e3, offset) === false) {
      const b = this.buffer;
      b.set(e3, offset);
      setArray(a3, e3, offset);
      updated = true;
    }
    return updated;
  }
  /**
   * Returns a typed array that matches the given data type.
   *
   * @private
   * @param {string} type - The data type.
   * @return {TypedArray} The typed array.
   */
  _getBufferForType(type) {
    if (type === "int" || type === "ivec2" || type === "ivec3" || type === "ivec4") return new Int32Array(this.buffer.buffer);
    if (type === "uint" || type === "uvec2" || type === "uvec3" || type === "uvec4") return new Uint32Array(this.buffer.buffer);
    return this.buffer;
  }
};
function setArray(a3, b, offset) {
  for (let i2 = 0, l2 = b.length; i2 < l2; i2++) {
    a3[offset + i2] = b[i2];
  }
}
function arraysEqual(a3, b, offset) {
  for (let i2 = 0, l2 = b.length; i2 < l2; i2++) {
    if (a3[offset + i2] !== b[i2]) return false;
  }
  return true;
}
var _id$3 = 0;
var NodeUniformsGroup = class extends UniformsGroup2 {
  /**
   * Constructs a new node-based uniforms group.
   *
   * @param {string} name - The group's name.
   * @param {UniformGroupNode} groupNode - The uniform group node.
   */
  constructor(name, groupNode) {
    super(name);
    this.id = _id$3++;
    this.groupNode = groupNode;
    this.isNodeUniformsGroup = true;
  }
};
var Sampler = class extends Binding {
  /**
   * Constructs a new sampler.
   *
   * @param {string} name - The samplers's name.
   * @param {?Texture} texture - The texture this binding is referring to.
   */
  constructor(name, texture2) {
    super(name);
    this._texture = null;
    this._onTextureDispose = () => {
      this.generation = null;
      this.version = 0;
    };
    this.texture = texture2;
    this.version = texture2 ? texture2.version : 0;
    this.generation = null;
    this.samplerKey = "";
    this.isSampler = true;
  }
  /**
   * Sets the texture of this sampler.
   *
   * @param {Texture} value - The texture to set.
   */
  set texture(value) {
    if (this._texture === value) return;
    if (this._texture) {
      this._texture.removeEventListener("dispose", this._onTextureDispose);
    }
    this._texture = value;
    this.generation = null;
    this.version = 0;
    if (this._texture) {
      this._texture.addEventListener("dispose", this._onTextureDispose);
    }
  }
  /**
   * Gets the texture of this sampler.
   * @return {?Texture} The texture.
   */
  get texture() {
    return this._texture;
  }
  /**
   * Updates the binding.
   *
   * @return {boolean} Whether the texture has been updated and must be
   * uploaded to the GPU.
   */
  update() {
    const { texture: texture2, version } = this;
    if (version !== texture2.version) {
      this.version = texture2.version;
      return true;
    }
    return false;
  }
  clone() {
    const clonedSampler = super.clone();
    clonedSampler._texture = null;
    clonedSampler._onTextureDispose = () => {
      clonedSampler.generation = null;
      clonedSampler.version = 0;
    };
    clonedSampler.texture = this.texture;
    return clonedSampler;
  }
};
var _id$22 = 0;
var SampledTexture = class extends Sampler {
  /**
   * Constructs a new sampled texture.
   *
   * @param {string} name - The sampled texture's name.
   * @param {?Texture} texture - The texture this binding is referring to.
   */
  constructor(name, texture2) {
    super(name, texture2);
    this.id = _id$22++;
    this.store = false;
    this.mipLevel = 0;
    this.isSampledTexture = true;
  }
};
var NodeSampledTexture = class extends SampledTexture {
  /**
   * Constructs a new node-based sampled texture.
   *
   * @param {string} name - The textures's name.
   * @param {TextureNode} textureNode - The texture node.
   * @param {UniformGroupNode} groupNode - The uniform group node.
   * @param {?string} [access=null] - The access type.
   */
  constructor(name, textureNode, groupNode, access = null) {
    super(name, textureNode ? textureNode.value : null);
    this.textureNode = textureNode;
    this.groupNode = groupNode;
    this.access = access;
  }
  /**
   * Updates the binding.
   *
   * @return {boolean} Whether the texture has been updated and must be
   * uploaded to the GPU.
   */
  update() {
    const { textureNode } = this;
    if (this.texture !== textureNode.value) {
      this.texture = textureNode.value;
      return true;
    }
    return super.update();
  }
};
var NodeSampledCubeTexture = class extends NodeSampledTexture {
  /**
   * Constructs a new node-based sampled cube texture.
   *
   * @param {string} name - The textures's name.
   * @param {TextureNode} textureNode - The texture node.
   * @param {UniformGroupNode} groupNode - The uniform group node.
   * @param {?string} [access=null] - The access type.
   */
  constructor(name, textureNode, groupNode, access = null) {
    super(name, textureNode, groupNode, access);
    this.isSampledCubeTexture = true;
  }
};
var NodeSampledTexture3D = class extends NodeSampledTexture {
  /**
   * Constructs a new node-based sampled 3D texture.
   *
   * @param {string} name - The textures's name.
   * @param {TextureNode} textureNode - The texture node.
   * @param {UniformGroupNode} groupNode - The uniform group node.
   * @param {?string} [access=null] - The access type.
   */
  constructor(name, textureNode, groupNode, access = null) {
    super(name, textureNode, groupNode, access);
    this.isSampledTexture3D = true;
  }
};
var glslPolyfills = {
  bitcast_int_uint: new CodeNode(
    /* glsl */
    "uint tsl_bitcast_int_to_uint ( int x ) { return floatBitsToUint( intBitsToFloat ( x ) ); }"
  ),
  bitcast_uint_int: new CodeNode(
    /* glsl */
    "uint tsl_bitcast_uint_to_int ( uint x ) { return floatBitsToInt( uintBitsToFloat ( x ) ); }"
  )
};
var glslMethods = {
  textureDimensions: "textureSize",
  equals: "equal",
  bitcast_float_int: "floatBitsToInt",
  bitcast_int_float: "intBitsToFloat",
  bitcast_uint_float: "uintBitsToFloat",
  bitcast_float_uint: "floatBitsToUint",
  bitcast_uint_int: "tsl_bitcast_uint_to_int",
  bitcast_int_uint: "tsl_bitcast_int_to_uint",
  floatpack_snorm_2x16: "packSnorm2x16",
  floatpack_unorm_2x16: "packUnorm2x16",
  floatpack_float16_2x16: "packHalf2x16",
  floatunpack_snorm_2x16: "unpackSnorm2x16",
  floatunpack_unorm_2x16: "unpackUnorm2x16",
  floatunpack_float16_2x16: "unpackHalf2x16"
};
var precisionLib = {
  low: "lowp",
  medium: "mediump",
  high: "highp"
};
var supports$1 = {
  swizzleAssign: true,
  storageBuffer: false
};
var interpolationTypeMap = {
  perspective: "smooth",
  linear: "noperspective"
};
var interpolationModeMap = {
  "centroid": "centroid"
};
var defaultPrecisions = `
precision highp float;
precision highp int;
precision highp sampler2D;
precision highp sampler3D;
precision highp samplerCube;
precision highp sampler2DArray;

precision highp usampler2D;
precision highp usampler3D;
precision highp usamplerCube;
precision highp usampler2DArray;

precision highp isampler2D;
precision highp isampler3D;
precision highp isamplerCube;
precision highp isampler2DArray;

precision lowp sampler2DShadow;
precision lowp sampler2DArrayShadow;
precision lowp samplerCubeShadow;
`;
var GLSLNodeBuilder = class extends NodeBuilder {
  /**
   * Constructs a new GLSL node builder renderer.
   *
   * @param {Object3D} object - The 3D object.
   * @param {Renderer} renderer - The renderer.
   */
  constructor(object, renderer3) {
    super(object, renderer3, new GLSLNodeParser());
    this.uniformGroups = {};
    this.transforms = [];
    this.extensions = {};
    this.builtins = { vertex: [], fragment: [], compute: [] };
  }
  /**
   * Checks if the given texture requires a manual conversion to the working color space.
   *
   * @param {Texture} texture - The texture to check.
   * @return {boolean} Whether the given texture requires a conversion to working color space or not.
   */
  needsToWorkingColorSpace(texture2) {
    return texture2.isVideoTexture === true && texture2.colorSpace !== NoColorSpace;
  }
  /**
   * Includes the given method name into the current
   * function node.
   *
   * @private
   * @param {string} name - The method name to include.
   * @return {CodeNode} The respective code node.
   */
  _include(name) {
    const codeNode = glslPolyfills[name];
    codeNode.build(this);
    this.addInclude(codeNode);
    return codeNode;
  }
  /**
   * Returns the native shader method name for a given generic name.
   *
   * @param {string} method - The method name to resolve.
   * @return {string} The resolved GLSL method name.
   */
  getMethod(method2) {
    if (glslPolyfills[method2] !== void 0) {
      this._include(method2);
    }
    return glslMethods[method2] || method2;
  }
  /**
   * Returns the bitcast method name for a given input and outputType.
   *
   * @param {string} type - The output type to bitcast to.
   * @param {string} inputType - The input type of the.
   * @return {string} The resolved WGSL bitcast invocation.
   */
  getBitcastMethod(type, inputType) {
    return this.getMethod(`bitcast_${inputType}_${type}`);
  }
  /**
   * Returns the float packing method name for a given numeric encoding.
   *
   * @param {string} encoding - The numeric encoding that describes how the float values are mapped to the integer range.
   * @returns {string} The resolved GLSL float packing method name.
   */
  getFloatPackingMethod(encoding) {
    return this.getMethod(`floatpack_${encoding}_2x16`);
  }
  /**
   * Returns the float unpacking method name for a given numeric encoding.
   *
   * @param {string} encoding - The numeric encoding that describes how the integer values are mapped to the float range.
   * @returns {string} The resolved GLSL float unpacking method name.
   */
  getFloatUnpackingMethod(encoding) {
    return this.getMethod(`floatunpack_${encoding}_2x16`);
  }
  /**
   * Returns the native snippet for a ternary operation.
   *
   * @param {string} condSnippet - The condition determining which expression gets resolved.
   * @param {string} ifSnippet - The expression to resolve to if the condition is true.
   * @param {string} elseSnippet - The expression to resolve to if the condition is false.
   * @return {string} The resolved method name.
   */
  getTernary(condSnippet, ifSnippet, elseSnippet) {
    return `${condSnippet} ? ${ifSnippet} : ${elseSnippet}`;
  }
  /**
   * Returns the output struct name. Not relevant for GLSL.
   *
   * @return {string}
   */
  getOutputStructName() {
    return "";
  }
  /**
   * Builds the given shader node.
   *
   * @param {ShaderNodeInternal} shaderNode - The shader node.
   * @return {string} The GLSL function code.
   */
  buildFunctionCode(shaderNode) {
    const layout = shaderNode.layout;
    const flowData = this.flowShaderNode(shaderNode);
    const parameters = [];
    for (const input of layout.inputs) {
      parameters.push(this.getType(input.type) + " " + input.name);
    }
    const code2 = `${this.getType(layout.type)} ${layout.name}( ${parameters.join(", ")} ) {

	${flowData.vars}

${flowData.code}
	return ${flowData.result};

}`;
    return code2;
  }
  /**
   * Setups the Pixel Buffer Object (PBO) for the given storage
   * buffer node.
   *
   * @param {StorageBufferNode} storageBufferNode - The storage buffer node.
   */
  setupPBO(storageBufferNode) {
    const attribute2 = storageBufferNode.value;
    if (attribute2.pbo === void 0) {
      const originalArray = attribute2.array;
      const numElements = attribute2.count * attribute2.itemSize;
      const { itemSize } = attribute2;
      const isInteger2 = attribute2.array.constructor.name.toLowerCase().includes("int");
      let format3 = isInteger2 ? RedIntegerFormat : RedFormat;
      if (itemSize === 2) {
        format3 = isInteger2 ? RGIntegerFormat : RGFormat;
      } else if (itemSize === 3) {
        format3 = isInteger2 ? RGBIntegerFormat : RGBFormat;
      } else if (itemSize === 4) {
        format3 = isInteger2 ? RGBAIntegerFormat : RGBAFormat;
      }
      const typeMap = {
        Float32Array: FloatType,
        Uint8Array: UnsignedByteType,
        Uint16Array: UnsignedShortType,
        Uint32Array: UnsignedIntType,
        Int8Array: ByteType,
        Int16Array: ShortType,
        Int32Array: IntType,
        Uint8ClampedArray: UnsignedByteType
      };
      const width = Math.pow(2, Math.ceil(Math.log2(Math.sqrt(numElements / itemSize))));
      let height = Math.ceil(numElements / itemSize / width);
      if (width * height * itemSize < numElements) height++;
      const newSize = width * height * itemSize;
      const newArray = new originalArray.constructor(newSize);
      newArray.set(originalArray, 0);
      attribute2.array = newArray;
      const pboTexture = new DataTexture(attribute2.array, width, height, format3, typeMap[attribute2.array.constructor.name] || FloatType);
      pboTexture.needsUpdate = true;
      pboTexture.isPBOTexture = true;
      const pbo = new TextureNode(pboTexture, null, null);
      pbo.setPrecision("high");
      attribute2.pboNode = pbo;
      attribute2.pbo = pbo.value;
      this.getUniformFromNode(attribute2.pboNode, "texture", this.shaderStage, this.context.nodeName);
    }
  }
  /**
   * Returns a GLSL snippet that represents the property name of the given node.
   *
   * @param {Node} node - The node.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The property name.
   */
  getPropertyName(node, shaderStage = this.shaderStage) {
    if (node.isNodeUniform && node.node.isTextureNode !== true && node.node.isBufferNode !== true) {
      return shaderStage.charAt(0) + "_" + node.name;
    }
    return super.getPropertyName(node, shaderStage);
  }
  /**
   * Setups the Pixel Buffer Object (PBO) for the given storage
   * buffer node.
   *
   * @param {StorageArrayElementNode} storageArrayElementNode - The storage array element node.
   * @return {string} The property name.
   */
  generatePBO(storageArrayElementNode) {
    const { node, indexNode } = storageArrayElementNode;
    const attribute2 = node.value;
    if (this.renderer.backend.has(attribute2)) {
      const attributeData = this.renderer.backend.get(attribute2);
      attributeData.pbo = attribute2.pbo;
    }
    const nodeUniform = this.getUniformFromNode(attribute2.pboNode, "texture", this.shaderStage, this.context.nodeName);
    const textureName = this.getPropertyName(nodeUniform);
    this.increaseUsage(indexNode);
    const indexSnippet = indexNode.build(this, "uint");
    const elementNodeData = this.getDataFromNode(storageArrayElementNode);
    let propertyName = elementNodeData.propertyName;
    if (propertyName === void 0) {
      const nodeVar = this.getVarFromNode(storageArrayElementNode);
      propertyName = this.getPropertyName(nodeVar);
      const bufferNodeData = this.getDataFromNode(node);
      let propertySizeName = bufferNodeData.propertySizeName;
      if (propertySizeName === void 0) {
        propertySizeName = propertyName + "Size";
        this.getVarFromNode(node, propertySizeName, "uint");
        this.addLineFlowCode(`${propertySizeName} = uint( textureSize( ${textureName}, 0 ).x )`, storageArrayElementNode);
        bufferNodeData.propertySizeName = propertySizeName;
      }
      const { itemSize } = attribute2;
      const channel = "." + vectorComponents.join("").slice(0, itemSize);
      const uvSnippet = `ivec2(${indexSnippet} % ${propertySizeName}, ${indexSnippet} / ${propertySizeName})`;
      const snippet = this.generateTextureLoad(null, textureName, uvSnippet, "0", null, null);
      let prefix = "vec4";
      if (attribute2.pbo.type === UnsignedIntType) {
        prefix = "uvec4";
      } else if (attribute2.pbo.type === IntType) {
        prefix = "ivec4";
      }
      this.addLineFlowCode(`${propertyName} = ${prefix}(${snippet})${channel}`, storageArrayElementNode);
      elementNodeData.propertyName = propertyName;
    }
    return propertyName;
  }
  /**
   * Generates the GLSL snippet that reads a single texel from a texture without sampling or filtering.
   *
   * @param {?Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvIndexSnippet - A GLSL snippet that represents texture coordinates used for sampling.
   * @param {?string} levelSnippet - A GLSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
   * @param {?string} depthSnippet - A GLSL snippet that represents the 0-based texture array index to sample.
   * @param {?string} offsetSnippet - A GLSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
   * @return {string} The GLSL snippet.
   */
  generateTextureLoad(texture2, textureProperty, uvIndexSnippet, levelSnippet, depthSnippet, offsetSnippet) {
    if (levelSnippet === null) levelSnippet = "0";
    let snippet;
    if (depthSnippet) {
      if (offsetSnippet) {
        snippet = `texelFetchOffset( ${textureProperty}, ivec3( ${uvIndexSnippet}, ${depthSnippet} ), ${levelSnippet}, ${offsetSnippet} )`;
      } else {
        snippet = `texelFetch( ${textureProperty}, ivec3( ${uvIndexSnippet}, ${depthSnippet} ), ${levelSnippet} )`;
      }
    } else {
      if (offsetSnippet) {
        snippet = `texelFetchOffset( ${textureProperty}, ${uvIndexSnippet}, ${levelSnippet}, ${offsetSnippet} )`;
      } else {
        snippet = `texelFetch( ${textureProperty}, ${uvIndexSnippet}, ${levelSnippet} )`;
      }
    }
    if (texture2 !== null && texture2.isDepthTexture) {
      snippet += ".x";
    }
    return snippet;
  }
  /**
   * Generates the GLSL snippet for sampling/loading the given texture.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.
   * @param {?string} depthSnippet -  A GLSL snippet that represents the 0-based texture array index to sample.
   * @param {?string} offsetSnippet - A GLSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
   * @return {string} The GLSL snippet.
   */
  generateTexture(texture2, textureProperty, uvSnippet, depthSnippet, offsetSnippet) {
    if (depthSnippet) uvSnippet = `vec3( ${uvSnippet}, ${depthSnippet} )`;
    if (texture2.isDepthTexture) {
      if (offsetSnippet) return `textureOffset( ${textureProperty}, ${uvSnippet}, ${offsetSnippet} ).x`;
      return `texture( ${textureProperty}, ${uvSnippet} ).x`;
    }
    if (offsetSnippet) return `textureOffset( ${textureProperty}, ${uvSnippet}, ${offsetSnippet} )`;
    return `texture( ${textureProperty}, ${uvSnippet} )`;
  }
  /**
   * Generates the GLSL snippet when sampling textures with explicit mip level.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.
   * @param {string} levelSnippet - A GLSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
   * @param {?string} offsetSnippet - A GLSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
   * @return {string} The GLSL snippet.
   */
  generateTextureLevel(texture2, textureProperty, uvSnippet, levelSnippet, offsetSnippet) {
    if (offsetSnippet) {
      return `textureLodOffset( ${textureProperty}, ${uvSnippet}, ${levelSnippet}, ${offsetSnippet} )`;
    }
    return `textureLod( ${textureProperty}, ${uvSnippet}, ${levelSnippet} )`;
  }
  /**
   * Generates the GLSL snippet when sampling textures with a bias to the mip level.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.
   * @param {string} biasSnippet - A GLSL snippet that represents the bias to apply to the mip level before sampling.
   * @param {?string} offsetSnippet - A GLSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
   * @return {string} The GLSL snippet.
   */
  generateTextureBias(texture2, textureProperty, uvSnippet, biasSnippet, offsetSnippet) {
    if (offsetSnippet) {
      return `textureOffset( ${textureProperty}, ${uvSnippet}, ${offsetSnippet}, ${biasSnippet} )`;
    }
    return `texture( ${textureProperty}, ${uvSnippet}, ${biasSnippet} )`;
  }
  /**
   * Generates the GLSL snippet for sampling/loading the given texture using explicit gradients.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.
   * @param {Array<string>} gradSnippet - An array holding both gradient GLSL snippets.
   * @param {?string} offsetSnippet - A GLSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
   * @return {string} The GLSL snippet.
   */
  generateTextureGrad(texture2, textureProperty, uvSnippet, gradSnippet, offsetSnippet) {
    if (offsetSnippet) {
      return `textureGradOffset( ${textureProperty}, ${uvSnippet}, ${gradSnippet[0]}, ${gradSnippet[1]}, ${offsetSnippet} )`;
    }
    return `textureGrad( ${textureProperty}, ${uvSnippet}, ${gradSnippet[0]}, ${gradSnippet[1]} )`;
  }
  /**
   * Generates the GLSL snippet for sampling a depth texture and comparing the sampled depth values
   * against a reference value.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.
   * @param {string} compareSnippet -  A GLSL snippet that represents the reference value.
   * @param {?string} depthSnippet - A GLSL snippet that represents 0-based texture array index to sample.
   * @param {?string} offsetSnippet - A GLSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The GLSL snippet.
   */
  generateTextureCompare(texture2, textureProperty, uvSnippet, compareSnippet, depthSnippet, offsetSnippet, shaderStage = this.shaderStage) {
    if (shaderStage === "fragment") {
      if (texture2.isCubeTexture) {
        return `texture( ${textureProperty}, vec4( ${uvSnippet}, ${compareSnippet} ) )`;
      }
      if (depthSnippet) {
        if (offsetSnippet) {
          return `textureOffset( ${textureProperty}, vec4( ${uvSnippet}, ${depthSnippet}, ${compareSnippet} ), ${offsetSnippet} )`;
        }
        return `texture( ${textureProperty}, vec4( ${uvSnippet}, ${depthSnippet}, ${compareSnippet} ) )`;
      }
      if (offsetSnippet) {
        return `textureOffset( ${textureProperty}, vec3( ${uvSnippet}, ${compareSnippet} ), ${offsetSnippet} )`;
      }
      return `texture( ${textureProperty}, vec3( ${uvSnippet}, ${compareSnippet} ) )`;
    } else {
      error(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${shaderStage} shader.`);
    }
  }
  /**
   * Returns the variables of the given shader stage as a GLSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The GLSL snippet that defines the variables.
   */
  getVars(shaderStage) {
    const snippets = [];
    const vars = this.vars[shaderStage];
    if (vars !== void 0) {
      for (const variable of vars) {
        snippets.push(`${this.getVar(variable.type, variable.name, variable.count)};`);
      }
    }
    return snippets.join("\n	");
  }
  /**
   * Returns the uniforms of the given shader stage as a GLSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The GLSL snippet that defines the uniforms.
   */
  getUniforms(shaderStage) {
    const uniforms = this.uniforms[shaderStage];
    const bindingSnippets = [];
    const uniformGroups = {};
    for (const uniform2 of uniforms) {
      let snippet = null;
      let group2 = false;
      if (uniform2.type === "texture" || uniform2.type === "texture3D") {
        const texture2 = uniform2.node.value;
        let typePrefix = "";
        if (texture2.isDataTexture === true || texture2.isData3DTexture === true) {
          if (texture2.type === UnsignedIntType) {
            typePrefix = "u";
          } else if (texture2.type === IntType) {
            typePrefix = "i";
          }
        }
        if (uniform2.type === "texture3D" && texture2.isArrayTexture === false) {
          snippet = `${typePrefix}sampler3D ${uniform2.name};`;
        } else if (texture2.compareFunction) {
          if (texture2.isArrayTexture === true) {
            snippet = `sampler2DArrayShadow ${uniform2.name};`;
          } else {
            snippet = `sampler2DShadow ${uniform2.name};`;
          }
        } else if (texture2.isArrayTexture === true || texture2.isDataArrayTexture === true || texture2.isCompressedArrayTexture === true) {
          snippet = `${typePrefix}sampler2DArray ${uniform2.name};`;
        } else {
          snippet = `${typePrefix}sampler2D ${uniform2.name};`;
        }
      } else if (uniform2.type === "cubeTexture") {
        snippet = `samplerCube ${uniform2.name};`;
      } else if (uniform2.type === "cubeDepthTexture") {
        snippet = `samplerCubeShadow ${uniform2.name};`;
      } else if (uniform2.type === "buffer") {
        const bufferNode = uniform2.node;
        const bufferType = this.getType(bufferNode.bufferType);
        const bufferCount = bufferNode.bufferCount;
        const bufferCountSnippet = bufferCount > 0 ? bufferCount : "";
        snippet = `${bufferNode.name} {
	${bufferType} ${uniform2.name}[${bufferCountSnippet}];
};
`;
      } else {
        const vectorType = this.getVectorType(uniform2.type);
        snippet = `${vectorType} ${this.getPropertyName(uniform2, shaderStage)};`;
        group2 = true;
      }
      const precision = uniform2.node.precision;
      if (precision !== null) {
        snippet = precisionLib[precision] + " " + snippet;
      }
      if (group2) {
        snippet = "	" + snippet;
        const groupName = uniform2.groupNode.name;
        const groupSnippets = uniformGroups[groupName] || (uniformGroups[groupName] = []);
        groupSnippets.push(snippet);
      } else {
        snippet = "uniform " + snippet;
        bindingSnippets.push(snippet);
      }
    }
    let output2 = "";
    for (const name in uniformGroups) {
      const groupSnippets = uniformGroups[name];
      output2 += this._getGLSLUniformStruct(shaderStage + "_" + name, groupSnippets.join("\n")) + "\n";
    }
    output2 += bindingSnippets.join("\n");
    return output2;
  }
  /**
   * Returns the type for a given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   * @return {string} The type.
   */
  getTypeFromAttribute(attribute2) {
    let nodeType = super.getTypeFromAttribute(attribute2);
    if (/^[iu]/.test(nodeType) && attribute2.gpuType !== IntType) {
      let dataAttribute = attribute2;
      if (attribute2.isInterleavedBufferAttribute) dataAttribute = attribute2.data;
      const array4 = dataAttribute.array;
      if ((array4 instanceof Uint32Array || array4 instanceof Int32Array) === false) {
        nodeType = nodeType.slice(1);
      }
    }
    return nodeType;
  }
  /**
   * Returns the shader attributes of the given shader stage as a GLSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The GLSL snippet that defines the shader attributes.
   */
  getAttributes(shaderStage) {
    let snippet = "";
    if (shaderStage === "vertex" || shaderStage === "compute") {
      const attributes = this.getAttributesArray();
      let location = 0;
      for (const attribute2 of attributes) {
        snippet += `layout( location = ${location++} ) in ${attribute2.type} ${attribute2.name};
`;
      }
    }
    return snippet;
  }
  /**
   * Returns the members of the given struct type node as a GLSL string.
   *
   * @param {StructTypeNode} struct - The struct type node.
   * @return {string} The GLSL snippet that defines the struct members.
   */
  getStructMembers(struct2) {
    const snippets = [];
    for (const member of struct2.members) {
      snippets.push(`	${member.type} ${member.name};`);
    }
    return snippets.join("\n");
  }
  /**
   * Returns the structs of the given shader stage as a GLSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The GLSL snippet that defines the structs.
   */
  getStructs(shaderStage) {
    const snippets = [];
    const structs = this.structs[shaderStage];
    const outputSnippet = [];
    for (const struct2 of structs) {
      if (struct2.output) {
        for (const member of struct2.members) {
          outputSnippet.push(`layout( location = ${member.index} ) out ${member.type} ${member.name};`);
        }
      } else {
        let snippet = "struct " + struct2.name + " {\n";
        snippet += this.getStructMembers(struct2);
        snippet += "\n};\n";
        snippets.push(snippet);
      }
    }
    if (outputSnippet.length === 0) {
      outputSnippet.push("layout( location = 0 ) out vec4 fragColor;");
    }
    return "\n" + outputSnippet.join("\n") + "\n\n" + snippets.join("\n");
  }
  /**
   * Returns the varyings of the given shader stage as a GLSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The GLSL snippet that defines the varyings.
   */
  getVaryings(shaderStage) {
    let snippet = "";
    const varyings = this.varyings;
    if (shaderStage === "vertex" || shaderStage === "compute") {
      for (const varying2 of varyings) {
        if (shaderStage === "compute") varying2.needsInterpolation = true;
        const type = this.getType(varying2.type);
        if (varying2.needsInterpolation) {
          if (varying2.interpolationType) {
            const interpolationType = interpolationTypeMap[varying2.interpolationType] || varying2.interpolationType;
            const sampling = interpolationModeMap[varying2.interpolationSampling] || "";
            snippet += `${interpolationType} ${sampling} out ${type} ${varying2.name};
`;
          } else {
            const flat = type.includes("int") || type.includes("uv") || type.includes("iv") ? "flat " : "";
            snippet += `${flat}out ${type} ${varying2.name};
`;
          }
        } else {
          snippet += `${type} ${varying2.name};
`;
        }
      }
    } else if (shaderStage === "fragment") {
      for (const varying2 of varyings) {
        if (varying2.needsInterpolation) {
          const type = this.getType(varying2.type);
          if (varying2.interpolationType) {
            const interpolationType = interpolationTypeMap[varying2.interpolationType] || varying2.interpolationType;
            const sampling = interpolationModeMap[varying2.interpolationSampling] || "";
            snippet += `${interpolationType} ${sampling} in ${type} ${varying2.name};
`;
          } else {
            const flat = type.includes("int") || type.includes("uv") || type.includes("iv") ? "flat " : "";
            snippet += `${flat}in ${type} ${varying2.name};
`;
          }
        }
      }
    }
    for (const builtin2 of this.builtins[shaderStage]) {
      snippet += `${builtin2};
`;
    }
    return snippet;
  }
  /**
   * Returns the vertex index builtin.
   *
   * @return {string} The vertex index.
   */
  getVertexIndex() {
    return "uint( gl_VertexID )";
  }
  /**
   * Contextually returns either the vertex stage instance index builtin
   * or the linearized index of an compute invocation within a grid of workgroups.
   *
   * @return {string} The instance index.
   */
  getInstanceIndex() {
    return "uint( gl_InstanceID )";
  }
  /**
   * Returns a builtin representing the index of an invocation within its workgroup.
   *
   * @return {string} The invocation local index.
   */
  getInvocationLocalIndex() {
    const workgroupSize = this.object.workgroupSize;
    const size2 = workgroupSize.reduce((acc, curr) => acc * curr, 1);
    return `uint( gl_InstanceID ) % ${size2}u`;
  }
  /**
   * Returns a builtin representing the size of a subgroup within the current shader.
   */
  getSubgroupSize() {
    error("GLSLNodeBuilder: WebGLBackend does not support the subgroupSize node");
  }
  /**
   * Returns a builtin representing the index of an invocation within its subgroup.
   */
  getInvocationSubgroupIndex() {
    error("GLSLNodeBuilder: WebGLBackend does not support the invocationSubgroupIndex node");
  }
  /**
   * Returns a builtin representing the index of the current invocation's subgroup within its workgroup.
   */
  getSubgroupIndex() {
    error("GLSLNodeBuilder: WebGLBackend does not support the subgroupIndex node");
  }
  /**
   * Returns the draw index builtin.
   *
   * @return {?string} The drawIndex shader string. Returns `null` if `WEBGL_multi_draw` isn't supported by the device.
   */
  getDrawIndex() {
    const extensions = this.renderer.backend.extensions;
    if (extensions.has("WEBGL_multi_draw")) {
      return "uint( gl_DrawID )";
    }
    return null;
  }
  /**
   * Returns the front facing builtin.
   *
   * @return {string} The front facing builtin.
   */
  getFrontFacing() {
    return "gl_FrontFacing";
  }
  /**
   * Returns the frag coord builtin.
   *
   * @return {string} The frag coord builtin.
   */
  getFragCoord() {
    return "gl_FragCoord.xy";
  }
  /**
   * Returns the frag depth builtin.
   *
   * @return {string} The frag depth builtin.
   */
  getFragDepth() {
    return "gl_FragDepth";
  }
  /**
   * Enables the given extension.
   *
   * @param {string} name - The extension name.
   * @param {string} behavior - The extension behavior.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage.
   */
  enableExtension(name, behavior, shaderStage = this.shaderStage) {
    const map6 = this.extensions[shaderStage] || (this.extensions[shaderStage] = /* @__PURE__ */ new Map());
    if (map6.has(name) === false) {
      map6.set(name, {
        name,
        behavior
      });
    }
  }
  /**
   * Returns the enabled extensions of the given shader stage as a GLSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The GLSL snippet that defines the enabled extensions.
   */
  getExtensions(shaderStage) {
    const snippets = [];
    if (shaderStage === "vertex") {
      const ext = this.renderer.backend.extensions;
      const isBatchedMesh = this.object.isBatchedMesh;
      if (isBatchedMesh && ext.has("WEBGL_multi_draw")) {
        this.enableExtension("GL_ANGLE_multi_draw", "require", shaderStage);
      }
    }
    const extensions = this.extensions[shaderStage];
    if (extensions !== void 0) {
      for (const { name, behavior } of extensions.values()) {
        snippets.push(`#extension ${name} : ${behavior}`);
      }
    }
    return snippets.join("\n");
  }
  /**
   * Returns the clip distances builtin.
   *
   * @return {string} The clip distances builtin.
   */
  getClipDistance() {
    return "gl_ClipDistance";
  }
  /**
   * Whether the requested feature is available or not.
   *
   * @param {string} name - The requested feature.
   * @return {boolean} Whether the requested feature is supported or not.
   */
  isAvailable(name) {
    let result2 = supports$1[name];
    if (result2 === void 0) {
      let extensionName;
      result2 = false;
      switch (name) {
        case "float32Filterable":
          extensionName = "OES_texture_float_linear";
          break;
        case "clipDistance":
          extensionName = "WEBGL_clip_cull_distance";
          break;
      }
      if (extensionName !== void 0) {
        const extensions = this.renderer.backend.extensions;
        if (extensions.has(extensionName)) {
          extensions.get(extensionName);
          result2 = true;
        }
      }
      supports$1[name] = result2;
    }
    return result2;
  }
  /**
   * Whether to flip texture data along its vertical axis or not.
   *
   * @return {boolean} Returns always `true` in context of GLSL.
   */
  isFlipY() {
    return true;
  }
  /**
   * Enables hardware clipping.
   *
   * @param {string} planeCount - The clipping plane count.
   */
  enableHardwareClipping(planeCount) {
    this.enableExtension("GL_ANGLE_clip_cull_distance", "require");
    this.builtins["vertex"].push(`out float gl_ClipDistance[ ${planeCount} ]`);
  }
  /**
   * Enables multiview.
   */
  enableMultiview() {
    this.enableExtension("GL_OVR_multiview2", "require", "fragment");
    this.enableExtension("GL_OVR_multiview2", "require", "vertex");
    this.builtins["vertex"].push("layout(num_views = 2) in");
  }
  /**
   * Registers a transform in context of Transform Feedback.
   *
   * @param {string} varyingName - The varying name.
   * @param {AttributeNode} attributeNode - The attribute node.
   */
  registerTransform(varyingName, attributeNode) {
    this.transforms.push({ varyingName, attributeNode });
  }
  /**
   * Returns the transforms of the given shader stage as a GLSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The GLSL snippet that defines the transforms.
   */
  getTransforms() {
    const transforms = this.transforms;
    let snippet = "";
    for (let i2 = 0; i2 < transforms.length; i2++) {
      const transform3 = transforms[i2];
      const attributeName = this.getPropertyName(transform3.attributeNode);
      if (attributeName) snippet += `${transform3.varyingName} = ${attributeName};
	`;
    }
    return snippet;
  }
  /**
   * Returns a GLSL struct based on the given name and variables.
   *
   * @private
   * @param {string} name - The struct name.
   * @param {string} vars - The struct variables.
   * @return {string} The GLSL snippet representing a struct.
   */
  _getGLSLUniformStruct(name, vars) {
    return `
layout( std140 ) uniform ${name} {
${vars}
};`;
  }
  /**
   * Returns a GLSL vertex shader based on the given shader data.
   *
   * @private
   * @param {Object} shaderData - The shader data.
   * @return {string} The vertex shader.
   */
  _getGLSLVertexCode(shaderData) {
    return `#version 300 es

${this.getSignature()}

// extensions
${shaderData.extensions}

// precision
${defaultPrecisions}

// uniforms
${shaderData.uniforms}

// varyings
${shaderData.varyings}

// attributes
${shaderData.attributes}

// codes
${shaderData.codes}

void main() {

	// vars
	${shaderData.vars}

	// transforms
	${shaderData.transforms}

	// flow
	${shaderData.flow}

	gl_PointSize = 1.0;

}
`;
  }
  /**
   * Returns a GLSL fragment shader based on the given shader data.
   *
   * @private
   * @param {Object} shaderData - The shader data.
   * @return {string} The vertex shader.
   */
  _getGLSLFragmentCode(shaderData) {
    return `#version 300 es

${this.getSignature()}

// extensions
${shaderData.extensions}

// precision
${defaultPrecisions}

// structs
${shaderData.structs}

// uniforms
${shaderData.uniforms}

// varyings
${shaderData.varyings}

// codes
${shaderData.codes}

void main() {

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

}
`;
  }
  /**
   * Controls the code build of the shader stages.
   */
  buildCode() {
    const shadersData = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };
    this.sortBindingGroups();
    for (const shaderStage in shadersData) {
      let flow2 = "// code\n\n";
      flow2 += this.flowCode[shaderStage];
      const flowNodes = this.flowNodes[shaderStage];
      const mainNode = flowNodes[flowNodes.length - 1];
      for (const node of flowNodes) {
        const flowSlotData = this.getFlowData(
          node
          /*, shaderStage*/
        );
        const slotName = node.name;
        if (slotName) {
          if (flow2.length > 0) flow2 += "\n";
          flow2 += `	// flow -> ${slotName}
	`;
        }
        flow2 += `${flowSlotData.code}
	`;
        if (node === mainNode && shaderStage !== "compute") {
          flow2 += "// result\n	";
          if (shaderStage === "vertex") {
            flow2 += "gl_Position = ";
            flow2 += `${flowSlotData.result};`;
          } else if (shaderStage === "fragment") {
            if (!node.outputNode.isOutputStructNode) {
              flow2 += "fragColor = ";
              flow2 += `${flowSlotData.result};`;
            }
          }
        }
      }
      const stageData = shadersData[shaderStage];
      stageData.extensions = this.getExtensions(shaderStage);
      stageData.uniforms = this.getUniforms(shaderStage);
      stageData.attributes = this.getAttributes(shaderStage);
      stageData.varyings = this.getVaryings(shaderStage);
      stageData.vars = this.getVars(shaderStage);
      stageData.structs = this.getStructs(shaderStage);
      stageData.codes = this.getCodes(shaderStage);
      stageData.transforms = this.getTransforms(shaderStage);
      stageData.flow = flow2;
    }
    if (this.material !== null) {
      this.vertexShader = this._getGLSLVertexCode(shadersData.vertex);
      this.fragmentShader = this._getGLSLFragmentCode(shadersData.fragment);
    } else {
      this.computeShader = this._getGLSLVertexCode(shadersData.compute);
    }
  }
  /**
   * This method is one of the more important ones since it's responsible
   * for generating a matching binding instance for the given uniform node.
   *
   * These bindings are later used in the renderer to create bind groups
   * and layouts.
   *
   * @param {UniformNode} node - The uniform node.
   * @param {string} type - The node data type.
   * @param {string} shaderStage - The shader stage.
   * @param {?string} [name=null] - An optional uniform name.
   * @return {NodeUniform} The node uniform object.
   */
  getUniformFromNode(node, type, shaderStage, name = null) {
    const uniformNode = super.getUniformFromNode(node, type, shaderStage, name);
    const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);
    let uniformGPU = nodeData.uniformGPU;
    if (uniformGPU === void 0) {
      const group2 = node.groupNode;
      const groupName = group2.name;
      const bindings = this.getBindGroupArray(groupName, shaderStage);
      if (type === "texture") {
        uniformGPU = new NodeSampledTexture(uniformNode.name, uniformNode.node, group2);
        bindings.push(uniformGPU);
      } else if (type === "cubeTexture" || type === "cubeDepthTexture") {
        uniformGPU = new NodeSampledCubeTexture(uniformNode.name, uniformNode.node, group2);
        bindings.push(uniformGPU);
      } else if (type === "texture3D") {
        uniformGPU = new NodeSampledTexture3D(uniformNode.name, uniformNode.node, group2);
        bindings.push(uniformGPU);
      } else if (type === "buffer") {
        uniformNode.name = `buffer${node.id}`;
        const sharedData = this.getSharedDataFromNode(node);
        let buffer2 = sharedData.buffer;
        if (buffer2 === void 0) {
          node.name = `NodeBuffer_${node.id}`;
          buffer2 = new NodeUniformBuffer(node, group2);
          buffer2.name = node.name;
          sharedData.buffer = buffer2;
        }
        bindings.push(buffer2);
        uniformGPU = buffer2;
      } else {
        const uniformsStage = this.uniformGroups[shaderStage] || (this.uniformGroups[shaderStage] = {});
        let uniformsGroup = uniformsStage[groupName];
        if (uniformsGroup === void 0) {
          uniformsGroup = new NodeUniformsGroup(shaderStage + "_" + groupName, group2);
          uniformsStage[groupName] = uniformsGroup;
          bindings.push(uniformsGroup);
        }
        uniformGPU = this.getNodeUniform(uniformNode, type);
        uniformsGroup.addUniform(uniformGPU);
      }
      nodeData.uniformGPU = uniformGPU;
    }
    return uniformNode;
  }
};
var _vector22 = null;
var _color4 = null;
var Backend = class {
  /**
   * Constructs a new backend.
   *
   * @param {Object} parameters - An object holding parameters for the backend.
   */
  constructor(parameters = {}) {
    this.parameters = Object.assign({}, parameters);
    this.data = /* @__PURE__ */ new WeakMap();
    this.renderer = null;
    this.domElement = null;
    this.timestampQueryPool = {
      [TimestampQuery.RENDER]: null,
      [TimestampQuery.COMPUTE]: null
    };
    this.trackTimestamp = parameters.trackTimestamp === true;
  }
  /**
   * Initializes the backend so it is ready for usage. Concrete backends
   * are supposed to implement their rendering context creation and related
   * operations in this method.
   *
   * @async
   * @param {Renderer} renderer - The renderer.
   * @return {Promise} A Promise that resolves when the backend has been initialized.
   */
  async init(renderer3) {
    this.renderer = renderer3;
  }
  /**
   * The coordinate system of the backend.
   *
   * @abstract
   * @type {number}
   * @readonly
   */
  get coordinateSystem() {
  }
  // render context
  /**
   * This method is executed at the beginning of a render call and
   * can be used by the backend to prepare the state for upcoming
   * draw calls.
   *
   * @abstract
   * @param {RenderContext} renderContext - The render context.
   */
  beginRender() {
  }
  /**
   * This method is executed at the end of a render call and
   * can be used by the backend to finalize work after draw
   * calls.
   *
   * @abstract
   * @param {RenderContext} renderContext - The render context.
   */
  finishRender() {
  }
  /**
   * This method is executed at the beginning of a compute call and
   * can be used by the backend to prepare the state for upcoming
   * compute tasks.
   *
   * @abstract
   * @param {Node|Array<Node>} computeGroup - The compute node(s).
   */
  beginCompute() {
  }
  /**
   * This method is executed at the end of a compute call and
   * can be used by the backend to finalize work after compute
   * tasks.
   *
   * @abstract
   * @param {Node|Array<Node>} computeGroup - The compute node(s).
   */
  finishCompute() {
  }
  // render object
  /**
   * Executes a draw command for the given render object.
   *
   * @abstract
   * @param {RenderObject} renderObject - The render object to draw.
   * @param {Info} info - Holds a series of statistical information about the GPU memory and the rendering process.
   */
  draw() {
  }
  // compute node
  /**
   * Executes a compute command for the given compute node.
   *
   * @abstract
   * @param {Node|Array<Node>} computeGroup - The group of compute nodes of a compute call. Can be a single compute node.
   * @param {Node} computeNode - The compute node.
   * @param {Array<BindGroup>} bindings - The bindings.
   * @param {ComputePipeline} computePipeline - The compute pipeline.
   */
  compute() {
  }
  // program
  /**
   * Creates a shader program from the given programmable stage.
   *
   * @abstract
   * @param {ProgrammableStage} program - The programmable stage.
   */
  createProgram() {
  }
  /**
   * Destroys the shader program of the given programmable stage.
   *
   * @abstract
   * @param {ProgrammableStage} program - The programmable stage.
   */
  destroyProgram() {
  }
  // bindings
  /**
   * Creates bindings from the given bind group definition.
   *
   * @abstract
   * @param {BindGroup} bindGroup - The bind group.
   * @param {Array<BindGroup>} bindings - Array of bind groups.
   * @param {number} cacheIndex - The cache index.
   * @param {number} version - The version.
   */
  createBindings() {
  }
  /**
   * Updates the given bind group definition.
   *
   * @abstract
   * @param {BindGroup} bindGroup - The bind group.
   * @param {Array<BindGroup>} bindings - Array of bind groups.
   * @param {number} cacheIndex - The cache index.
   * @param {number} version - The version.
   */
  updateBindings() {
  }
  /**
   * Updates a buffer binding.
   *
   * @abstract
   * @param {Buffer} binding - The buffer binding to update.
   */
  updateBinding() {
  }
  // pipeline
  /**
   * Creates a render pipeline for the given render object.
   *
   * @abstract
   * @param {RenderObject} renderObject - The render object.
   * @param {Array<Promise>} promises - An array of compilation promises which are used in `compileAsync()`.
   */
  createRenderPipeline() {
  }
  /**
   * Creates a compute pipeline for the given compute node.
   *
   * @abstract
   * @param {ComputePipeline} computePipeline - The compute pipeline.
   * @param {Array<BindGroup>} bindings - The bindings.
   */
  createComputePipeline() {
  }
  // cache key
  /**
   * Returns `true` if the render pipeline requires an update.
   *
   * @abstract
   * @param {RenderObject} renderObject - The render object.
   * @return {boolean} Whether the render pipeline requires an update or not.
   */
  needsRenderUpdate() {
  }
  /**
   * Returns a cache key that is used to identify render pipelines.
   *
   * @abstract
   * @param {RenderObject} renderObject - The render object.
   * @return {string} The cache key.
   */
  getRenderCacheKey() {
  }
  // node builder
  /**
   * Returns a node builder for the given render object.
   *
   * @abstract
   * @param {RenderObject} renderObject - The render object.
   * @param {Renderer} renderer - The renderer.
   * @return {NodeBuilder} The node builder.
   */
  createNodeBuilder() {
  }
  // textures
  /**
   * Updates a GPU sampler for the given texture.
   *
   * @abstract
   * @param {Texture} texture - The texture to update the sampler for.
   * @return {string} The current sampler key.
   */
  updateSampler() {
  }
  /**
   * Creates a default texture for the given texture that can be used
   * as a placeholder until the actual texture is ready for usage.
   *
   * @abstract
   * @param {Texture} texture - The texture to create a default texture for.
   */
  createDefaultTexture() {
  }
  /**
   * Defines a texture on the GPU for the given texture object.
   *
   * @abstract
   * @param {Texture} texture - The texture.
   * @param {Object} [options={}] - Optional configuration parameter.
   */
  createTexture() {
  }
  /**
   * Uploads the updated texture data to the GPU.
   *
   * @abstract
   * @param {Texture} texture - The texture.
   * @param {Object} [options={}] - Optional configuration parameter.
   */
  updateTexture() {
  }
  /**
   * Generates mipmaps for the given texture.
   *
   * @abstract
   * @param {Texture} texture - The texture.
   */
  generateMipmaps() {
  }
  /**
   * Destroys the GPU data for the given texture object.
   *
   * @abstract
   * @param {Texture} texture - The texture.
   * @param {boolean} [isDefaultTexture=false] - Whether the texture uses a default GPU texture or not.
   */
  destroyTexture() {
  }
  /**
   * Returns texture data as a typed array.
   *
   * @abstract
   * @async
   * @param {Texture} texture - The texture to copy.
   * @param {number} x - The x coordinate of the copy origin.
   * @param {number} y - The y coordinate of the copy origin.
   * @param {number} width - The width of the copy.
   * @param {number} height - The height of the copy.
   * @param {number} faceIndex - The face index.
   * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.
   */
  async copyTextureToBuffer() {
  }
  /**
   * Copies data of the given source texture to the given destination texture.
   *
   * @abstract
   * @param {Texture} srcTexture - The source texture.
   * @param {Texture} dstTexture - The destination texture.
   * @param {?(Box3|Box2)} [srcRegion=null] - The region of the source texture to copy.
   * @param {?(Vector2|Vector3)} [dstPosition=null] - The destination position of the copy.
   * @param {number} [srcLevel=0] - The source mip level to copy from.
   * @param {number} [dstLevel=0] - The destination mip level to copy to.
   */
  copyTextureToTexture() {
  }
  /**
  * Copies the current bound framebuffer to the given texture.
  *
  * @abstract
  * @param {Texture} texture - The destination texture.
  * @param {RenderContext} renderContext - The render context.
  * @param {Vector4} rectangle - A four dimensional vector defining the origin and dimension of the copy.
  */
  copyFramebufferToTexture() {
  }
  // attributes
  /**
   * Creates the GPU buffer of a shader attribute.
   *
   * @abstract
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  createAttribute() {
  }
  /**
   * Creates the GPU buffer of an indexed shader attribute.
   *
   * @abstract
   * @param {BufferAttribute} attribute - The indexed buffer attribute.
   */
  createIndexAttribute() {
  }
  /**
   * Creates the GPU buffer of a storage attribute.
   *
   * @abstract
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  createStorageAttribute() {
  }
  /**
   * Updates the GPU buffer of a shader attribute.
   *
   * @abstract
   * @param {BufferAttribute} attribute - The buffer attribute to update.
   */
  updateAttribute() {
  }
  /**
   * Destroys the GPU buffer of a shader attribute.
   *
   * @abstract
   * @param {BufferAttribute} attribute - The buffer attribute to destroy.
   */
  destroyAttribute() {
  }
  // canvas
  /**
   * Returns the backend's rendering context.
   *
   * @abstract
   * @return {Object} The rendering context.
   */
  getContext() {
  }
  /**
   * Backends can use this method if they have to run
   * logic when the renderer gets resized.
   *
   * @abstract
   */
  updateSize() {
  }
  /**
   * Updates the viewport with the values from the given render context.
   *
   * @abstract
   * @param {RenderContext} renderContext - The render context.
   */
  updateViewport() {
  }
  // utils
  /**
   * Updates a unique identifier for the given render context that can be used
   * to allocate resources like occlusion queries or timestamp queries.
   *
   * @param {RenderContext|ComputeNode} abstractRenderContext - The render context.
   */
  updateTimeStampUID(abstractRenderContext) {
    const contextData = this.get(abstractRenderContext);
    const frame2 = this.renderer.info.frame;
    let prefix;
    if (abstractRenderContext.isComputeNode === true) {
      prefix = "c:" + this.renderer.info.compute.frameCalls;
    } else {
      prefix = "r:" + this.renderer.info.render.frameCalls;
    }
    contextData.timestampUID = prefix + ":" + abstractRenderContext.id + ":f" + frame2;
  }
  /**
   * Returns a unique identifier for the given render context that can be used
   * to allocate resources like occlusion queries or timestamp queries.
   *
   * @param {RenderContext|ComputeNode} abstractRenderContext - The render context.
   * @return {string} The unique identifier.
   */
  getTimestampUID(abstractRenderContext) {
    return this.get(abstractRenderContext).timestampUID;
  }
  /**
   * Returns all timestamp frames for the given type.
   *
   * @param {string} type - The type of the time stamp.
   * @return {Array<number>} The timestamp frames.
   */
  getTimestampFrames(type) {
    const queryPool = this.timestampQueryPool[type];
    return queryPool ? queryPool.getTimestampFrames() : [];
  }
  /**
   * Returns the query pool for the given uid.
   *
   * @param {string} uid - The unique identifier.
   * @return {TimestampQueryPool} The query pool.
   */
  _getQueryPool(uid) {
    const type = uid.startsWith("c:") ? TimestampQuery.COMPUTE : TimestampQuery.RENDER;
    const queryPool = this.timestampQueryPool[type];
    return queryPool;
  }
  /**
   * Returns the timestamp for the given uid.
   *
   * @param {string} uid - The unique identifier.
   * @return {number} The timestamp.
   */
  getTimestamp(uid) {
    const queryPool = this._getQueryPool(uid);
    return queryPool.getTimestamp(uid);
  }
  /**
   * Returns `true` if a timestamp for the given uid is available.
   *
   * @param {string} uid - The unique identifier.
   * @return {boolean} Whether the timestamp is available or not.
   */
  hasTimestamp(uid) {
    const queryPool = this._getQueryPool(uid);
    return queryPool.hasTimestamp(uid);
  }
  /**
   * Returns `true` if the given 3D object is fully occluded by other
   * 3D objects in the scene. Backends must implement this method by using
   * a Occlusion Query API.
   *
   * @abstract
   * @param {RenderContext} renderContext - The render context.
   * @param {Object3D} object - The 3D object to test.
   * @return {boolean} Whether the 3D object is fully occluded or not.
   */
  isOccluded() {
  }
  /**
   * Resolves the time stamp for the given render context and type.
   *
   * @async
   * @abstract
   * @param {string} [type='render'] - The type of the time stamp.
   * @return {Promise<number>} A Promise that resolves with the time stamp.
   */
  async resolveTimestampsAsync(type = "render") {
    if (!this.trackTimestamp) {
      warnOnce("WebGPURenderer: Timestamp tracking is disabled.");
      return;
    }
    const queryPool = this.timestampQueryPool[type];
    if (!queryPool) {
      return;
    }
    const duration = await queryPool.resolveQueriesAsync();
    this.renderer.info[type].timestamp = duration;
    return duration;
  }
  /**
   * This method performs a readback operation by moving buffer data from
   * a storage buffer attribute from the GPU to the CPU.
   *
   * @async
   * @param {StorageBufferAttribute} attribute - The storage buffer attribute.
   * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.
   */
  async getArrayBufferAsync() {
  }
  /**
   * Checks if the given feature is supported by the backend.
   *
   * @async
   * @abstract
   * @param {string} name - The feature's name.
   * @return {Promise<boolean>} A Promise that resolves with a bool that indicates whether the feature is supported or not.
   */
  async hasFeatureAsync() {
  }
  /**
   * Checks if the given feature is supported  by the backend.
   *
   * @abstract
   * @param {string} name - The feature's name.
   * @return {boolean} Whether the feature is supported or not.
   */
  hasFeature() {
  }
  /**
   * Returns the maximum anisotropy texture filtering value.
   *
   * @abstract
   * @return {number} The maximum anisotropy texture filtering value.
   */
  getMaxAnisotropy() {
  }
  /**
   * Returns the drawing buffer size.
   *
   * @return {Vector2} The drawing buffer size.
   */
  getDrawingBufferSize() {
    _vector22 = _vector22 || new Vector2();
    return this.renderer.getDrawingBufferSize(_vector22);
  }
  /**
   * Defines the scissor test.
   *
   * @abstract
   * @param {boolean} boolean - Whether the scissor test should be enabled or not.
   */
  setScissorTest() {
  }
  /**
   * Returns the clear color and alpha into a single
   * color object.
   *
   * @return {Color4} The clear color.
   */
  getClearColor() {
    const renderer3 = this.renderer;
    _color4 = _color4 || new Color4();
    renderer3.getClearColor(_color4);
    _color4.getRGB(_color4);
    return _color4;
  }
  /**
   * Returns the DOM element. If no DOM element exists, the backend
   * creates a new one.
   *
   * @return {HTMLCanvasElement} The DOM element.
   */
  getDomElement() {
    let domElement = this.domElement;
    if (domElement === null) {
      domElement = this.parameters.canvas !== void 0 ? this.parameters.canvas : createCanvasElement();
      if ("setAttribute" in domElement) domElement.setAttribute("data-engine", `three.js r${REVISION} webgpu`);
      this.domElement = domElement;
    }
    return domElement;
  }
  /**
   * Sets a dictionary for the given object into the
   * internal data structure.
   *
   * @param {Object} object - The object.
   * @param {Object} value - The dictionary to set.
   */
  set(object, value) {
    this.data.set(object, value);
  }
  /**
   * Returns the dictionary for the given object.
   *
   * @param {Object} object - The object.
   * @return {Object} The object's dictionary.
   */
  get(object) {
    let map6 = this.data.get(object);
    if (map6 === void 0) {
      map6 = {};
      this.data.set(object, map6);
    }
    return map6;
  }
  /**
   * Checks if the given object has a dictionary
   * with data defined.
   *
   * @param {Object} object - The object.
   * @return {boolean} Whether a dictionary for the given object as been defined or not.
   */
  has(object) {
    return this.data.has(object);
  }
  /**
   * Deletes an object from the internal data structure.
   *
   * @param {Object} object - The object to delete.
   */
  delete(object) {
    this.data.delete(object);
  }
  /**
   * Delete GPU data associated with a bind group.
   *
   * @abstract
   * @param {BindGroup} bindGroup - The bind group.
   */
  deleteBindGroupData() {
  }
  /**
   * Frees internal resources.
   *
   * @abstract
   */
  dispose() {
  }
};
var _id$1 = 0;
var DualAttributeData = class {
  constructor(attributeData, dualBuffer) {
    this.buffers = [attributeData.bufferGPU, dualBuffer];
    this.type = attributeData.type;
    this.bufferType = attributeData.bufferType;
    this.pbo = attributeData.pbo;
    this.byteLength = attributeData.byteLength;
    this.bytesPerElement = attributeData.BYTES_PER_ELEMENT;
    this.version = attributeData.version;
    this.isInteger = attributeData.isInteger;
    this.activeBufferIndex = 0;
    this.baseId = attributeData.id;
  }
  get id() {
    return `${this.baseId}|${this.activeBufferIndex}`;
  }
  get bufferGPU() {
    return this.buffers[this.activeBufferIndex];
  }
  get transformBuffer() {
    return this.buffers[this.activeBufferIndex ^ 1];
  }
  switchBuffers() {
    this.activeBufferIndex ^= 1;
  }
};
var WebGLAttributeUtils = class {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGLBackend} backend - The WebGL 2 backend.
   */
  constructor(backend) {
    this.backend = backend;
  }
  /**
   * Creates the GPU buffer for the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   * @param {GLenum } bufferType - A flag that indicates the buffer type and thus binding point target.
   */
  createAttribute(attribute2, bufferType) {
    const backend = this.backend;
    const { gl } = backend;
    const array4 = attribute2.array;
    const usage = attribute2.usage || gl.STATIC_DRAW;
    const bufferAttribute2 = attribute2.isInterleavedBufferAttribute ? attribute2.data : attribute2;
    const bufferData = backend.get(bufferAttribute2);
    let bufferGPU = bufferData.bufferGPU;
    if (bufferGPU === void 0) {
      bufferGPU = this._createBuffer(gl, bufferType, array4, usage);
      bufferData.bufferGPU = bufferGPU;
      bufferData.bufferType = bufferType;
      bufferData.version = bufferAttribute2.version;
    }
    let type;
    if (array4 instanceof Float32Array) {
      type = gl.FLOAT;
    } else if (typeof Float16Array !== "undefined" && array4 instanceof Float16Array) {
      type = gl.HALF_FLOAT;
    } else if (array4 instanceof Uint16Array) {
      if (attribute2.isFloat16BufferAttribute) {
        type = gl.HALF_FLOAT;
      } else {
        type = gl.UNSIGNED_SHORT;
      }
    } else if (array4 instanceof Int16Array) {
      type = gl.SHORT;
    } else if (array4 instanceof Uint32Array) {
      type = gl.UNSIGNED_INT;
    } else if (array4 instanceof Int32Array) {
      type = gl.INT;
    } else if (array4 instanceof Int8Array) {
      type = gl.BYTE;
    } else if (array4 instanceof Uint8Array) {
      type = gl.UNSIGNED_BYTE;
    } else if (array4 instanceof Uint8ClampedArray) {
      type = gl.UNSIGNED_BYTE;
    } else {
      throw new Error("THREE.WebGLBackend: Unsupported buffer data format: " + array4);
    }
    let attributeData = {
      bufferGPU,
      bufferType,
      type,
      byteLength: array4.byteLength,
      bytesPerElement: array4.BYTES_PER_ELEMENT,
      version: attribute2.version,
      pbo: attribute2.pbo,
      isInteger: type === gl.INT || type === gl.UNSIGNED_INT || attribute2.gpuType === IntType,
      id: _id$1++
    };
    if (attribute2.isStorageBufferAttribute || attribute2.isStorageInstancedBufferAttribute) {
      const bufferGPUDual = this._createBuffer(gl, bufferType, array4, usage);
      attributeData = new DualAttributeData(attributeData, bufferGPUDual);
    }
    backend.set(attribute2, attributeData);
  }
  /**
   * Updates the GPU buffer of the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  updateAttribute(attribute2) {
    const backend = this.backend;
    const { gl } = backend;
    const array4 = attribute2.array;
    const bufferAttribute2 = attribute2.isInterleavedBufferAttribute ? attribute2.data : attribute2;
    const bufferData = backend.get(bufferAttribute2);
    const bufferType = bufferData.bufferType;
    const updateRanges = attribute2.isInterleavedBufferAttribute ? attribute2.data.updateRanges : attribute2.updateRanges;
    gl.bindBuffer(bufferType, bufferData.bufferGPU);
    if (updateRanges.length === 0) {
      gl.bufferSubData(bufferType, 0, array4);
    } else {
      for (let i2 = 0, l2 = updateRanges.length; i2 < l2; i2++) {
        const range4 = updateRanges[i2];
        gl.bufferSubData(
          bufferType,
          range4.start * array4.BYTES_PER_ELEMENT,
          array4,
          range4.start,
          range4.count
        );
      }
      bufferAttribute2.clearUpdateRanges();
    }
    gl.bindBuffer(bufferType, null);
    bufferData.version = bufferAttribute2.version;
  }
  /**
   * Destroys the GPU buffer of the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  destroyAttribute(attribute2) {
    const backend = this.backend;
    const { gl } = backend;
    if (attribute2.isInterleavedBufferAttribute) {
      backend.delete(attribute2.data);
    }
    const attributeData = backend.get(attribute2);
    gl.deleteBuffer(attributeData.bufferGPU);
    backend.delete(attribute2);
  }
  /**
   * This method performs a readback operation by moving buffer data from
   * a storage buffer attribute from the GPU to the CPU.
   *
   * @async
   * @param {StorageBufferAttribute} attribute - The storage buffer attribute.
   * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.
   */
  async getArrayBufferAsync(attribute2) {
    const backend = this.backend;
    const { gl } = backend;
    const bufferAttribute2 = attribute2.isInterleavedBufferAttribute ? attribute2.data : attribute2;
    const { bufferGPU } = backend.get(bufferAttribute2);
    const array4 = attribute2.array;
    const byteLength = array4.byteLength;
    gl.bindBuffer(gl.COPY_READ_BUFFER, bufferGPU);
    const writeBuffer = gl.createBuffer();
    gl.bindBuffer(gl.COPY_WRITE_BUFFER, writeBuffer);
    gl.bufferData(gl.COPY_WRITE_BUFFER, byteLength, gl.STREAM_READ);
    gl.copyBufferSubData(gl.COPY_READ_BUFFER, gl.COPY_WRITE_BUFFER, 0, 0, byteLength);
    await backend.utils._clientWaitAsync();
    const dstBuffer = new attribute2.array.constructor(array4.length);
    gl.bindBuffer(gl.COPY_WRITE_BUFFER, writeBuffer);
    gl.getBufferSubData(gl.COPY_WRITE_BUFFER, 0, dstBuffer);
    gl.deleteBuffer(writeBuffer);
    gl.bindBuffer(gl.COPY_READ_BUFFER, null);
    gl.bindBuffer(gl.COPY_WRITE_BUFFER, null);
    return dstBuffer.buffer;
  }
  /**
   * Creates a WebGL buffer with the given data.
   *
   * @private
   * @param {WebGL2RenderingContext} gl - The rendering context.
   * @param {GLenum } bufferType - A flag that indicates the buffer type and thus binding point target.
   * @param {TypedArray} array - The array of the buffer attribute.
   * @param {GLenum} usage - The usage.
   * @return {WebGLBuffer} The WebGL buffer.
   */
  _createBuffer(gl, bufferType, array4, usage) {
    const bufferGPU = gl.createBuffer();
    gl.bindBuffer(bufferType, bufferGPU);
    gl.bufferData(bufferType, array4, usage);
    gl.bindBuffer(bufferType, null);
    return bufferGPU;
  }
};
var equationToGL;
var factorToGL;
var WebGLState = class {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGLBackend} backend - The WebGL 2 backend.
   */
  constructor(backend) {
    this.backend = backend;
    this.gl = this.backend.gl;
    this.enabled = {};
    this.currentFlipSided = null;
    this.currentCullFace = null;
    this.currentProgram = null;
    this.currentBlendingEnabled = false;
    this.currentBlending = null;
    this.currentBlendSrc = null;
    this.currentBlendDst = null;
    this.currentBlendSrcAlpha = null;
    this.currentBlendDstAlpha = null;
    this.currentPremultipledAlpha = null;
    this.currentPolygonOffsetFactor = null;
    this.currentPolygonOffsetUnits = null;
    this.currentColorMask = null;
    this.currentDepthFunc = null;
    this.currentDepthMask = null;
    this.currentStencilFunc = null;
    this.currentStencilRef = null;
    this.currentStencilFuncMask = null;
    this.currentStencilFail = null;
    this.currentStencilZFail = null;
    this.currentStencilZPass = null;
    this.currentStencilMask = null;
    this.currentLineWidth = null;
    this.currentClippingPlanes = 0;
    this.currentVAO = null;
    this.currentIndex = null;
    this.currentBoundFramebuffers = {};
    this.currentDrawbuffers = /* @__PURE__ */ new WeakMap();
    this.maxTextures = this.gl.getParameter(this.gl.MAX_TEXTURE_IMAGE_UNITS);
    this.currentTextureSlot = null;
    this.currentBoundTextures = {};
    this.currentBoundBufferBases = {};
    this._init();
  }
  /**
   * Inits the state of the utility.
   *
   * @private
   */
  _init() {
    const gl = this.gl;
    equationToGL = {
      [AddEquation]: gl.FUNC_ADD,
      [SubtractEquation]: gl.FUNC_SUBTRACT,
      [ReverseSubtractEquation]: gl.FUNC_REVERSE_SUBTRACT
    };
    factorToGL = {
      [ZeroFactor]: gl.ZERO,
      [OneFactor]: gl.ONE,
      [SrcColorFactor]: gl.SRC_COLOR,
      [SrcAlphaFactor]: gl.SRC_ALPHA,
      [SrcAlphaSaturateFactor]: gl.SRC_ALPHA_SATURATE,
      [DstColorFactor]: gl.DST_COLOR,
      [DstAlphaFactor]: gl.DST_ALPHA,
      [OneMinusSrcColorFactor]: gl.ONE_MINUS_SRC_COLOR,
      [OneMinusSrcAlphaFactor]: gl.ONE_MINUS_SRC_ALPHA,
      [OneMinusDstColorFactor]: gl.ONE_MINUS_DST_COLOR,
      [OneMinusDstAlphaFactor]: gl.ONE_MINUS_DST_ALPHA
    };
    const scissorParam = gl.getParameter(gl.SCISSOR_BOX);
    const viewportParam = gl.getParameter(gl.VIEWPORT);
    this.currentScissor = new Vector4().fromArray(scissorParam);
    this.currentViewport = new Vector4().fromArray(viewportParam);
    this._tempVec4 = new Vector4();
  }
  /**
   * Enables the given WebGL capability.
   *
   * This method caches the capability state so
   * `gl.enable()` is only called when necessary.
   *
   * @param {GLenum} id - The capability to enable.
   */
  enable(id2) {
    const { enabled } = this;
    if (enabled[id2] !== true) {
      this.gl.enable(id2);
      enabled[id2] = true;
    }
  }
  /**
   * Disables the given WebGL capability.
   *
   * This method caches the capability state so
   * `gl.disable()` is only called when necessary.
   *
   * @param {GLenum} id - The capability to enable.
   */
  disable(id2) {
    const { enabled } = this;
    if (enabled[id2] !== false) {
      this.gl.disable(id2);
      enabled[id2] = false;
    }
  }
  /**
   * Specifies whether polygons are front- or back-facing
   * by setting the winding orientation.
   *
   * This method caches the state so `gl.frontFace()` is only
   * called when necessary.
   *
   * @param {boolean} flipSided - Whether triangles flipped their sides or not.
   */
  setFlipSided(flipSided) {
    if (this.currentFlipSided !== flipSided) {
      const { gl } = this;
      if (flipSided) {
        gl.frontFace(gl.CW);
      } else {
        gl.frontFace(gl.CCW);
      }
      this.currentFlipSided = flipSided;
    }
  }
  /**
   * Specifies whether or not front- and/or back-facing
   * polygons can be culled.
   *
   * This method caches the state so `gl.cullFace()` is only
   * called when necessary.
   *
   * @param {number} cullFace - Defines which polygons are candidates for culling.
   */
  setCullFace(cullFace) {
    const { gl } = this;
    if (cullFace !== CullFaceNone) {
      this.enable(gl.CULL_FACE);
      if (cullFace !== this.currentCullFace) {
        if (cullFace === CullFaceBack) {
          gl.cullFace(gl.BACK);
        } else if (cullFace === CullFaceFront) {
          gl.cullFace(gl.FRONT);
        } else {
          gl.cullFace(gl.FRONT_AND_BACK);
        }
      }
    } else {
      this.disable(gl.CULL_FACE);
    }
    this.currentCullFace = cullFace;
  }
  /**
   * Specifies the width of line primitives.
   *
   * This method caches the state so `gl.lineWidth()` is only
   * called when necessary.
   *
   * @param {number} width - The line width.
   */
  setLineWidth(width) {
    const { currentLineWidth, gl } = this;
    if (width !== currentLineWidth) {
      gl.lineWidth(width);
      this.currentLineWidth = width;
    }
  }
  setMRTBlending(textures) {
    const gl = this.gl;
    const drawBuffersIndexedExt = this.backend.drawBuffersIndexedExt;
    if (!drawBuffersIndexedExt) return;
    for (let i2 = 1; i2 < textures.length; i2++) {
      drawBuffersIndexedExt.blendFuncSeparateiOES(i2, gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);
    }
  }
  /**
   * Defines the blending.
   *
   * This method caches the state so `gl.blendEquation()`, `gl.blendEquationSeparate()`,
   * `gl.blendFunc()` and  `gl.blendFuncSeparate()` are only called when necessary.
   *
   * @param {number} blending - The blending type.
   * @param {number} blendEquation - The blending equation.
   * @param {number} blendSrc - Only relevant for custom blending. The RGB source blending factor.
   * @param {number} blendDst - Only relevant for custom blending. The RGB destination blending factor.
   * @param {number} blendEquationAlpha - Only relevant for custom blending. The blending equation for alpha.
   * @param {number} blendSrcAlpha - Only relevant for custom blending. The alpha source blending factor.
   * @param {number} blendDstAlpha - Only relevant for custom blending. The alpha destination blending factor.
   * @param {boolean} premultipliedAlpha - Whether premultiplied alpha is enabled or not.
   */
  setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
    const { gl } = this;
    if (blending === NoBlending) {
      if (this.currentBlendingEnabled === true) {
        this.disable(gl.BLEND);
        this.currentBlendingEnabled = false;
      }
      return;
    }
    if (this.currentBlendingEnabled === false) {
      this.enable(gl.BLEND);
      this.currentBlendingEnabled = true;
    }
    if (blending !== CustomBlending) {
      if (blending !== this.currentBlending || premultipliedAlpha !== this.currentPremultipledAlpha) {
        if (this.currentBlendEquation !== AddEquation || this.currentBlendEquationAlpha !== AddEquation) {
          gl.blendEquation(gl.FUNC_ADD);
          this.currentBlendEquation = AddEquation;
          this.currentBlendEquationAlpha = AddEquation;
        }
        if (premultipliedAlpha) {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
              break;
            case AdditiveBlending:
              gl.blendFunc(gl.ONE, gl.ONE);
              break;
            case SubtractiveBlending:
              gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);
              break;
            case MultiplyBlending:
              gl.blendFuncSeparate(gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ZERO, gl.ONE);
              break;
            default:
              error("WebGLState: Invalid blending: ", blending);
              break;
          }
        } else {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
              break;
            case AdditiveBlending:
              gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE);
              break;
            case SubtractiveBlending:
              error("WebGLState: SubtractiveBlending requires material.premultipliedAlpha = true");
              break;
            case MultiplyBlending:
              error("WebGLState: MultiplyBlending requires material.premultipliedAlpha = true");
              break;
            default:
              error("WebGLState: Invalid blending: ", blending);
              break;
          }
        }
        this.currentBlendSrc = null;
        this.currentBlendDst = null;
        this.currentBlendSrcAlpha = null;
        this.currentBlendDstAlpha = null;
        this.currentBlending = blending;
        this.currentPremultipledAlpha = premultipliedAlpha;
      }
      return;
    }
    blendEquationAlpha = blendEquationAlpha || blendEquation;
    blendSrcAlpha = blendSrcAlpha || blendSrc;
    blendDstAlpha = blendDstAlpha || blendDst;
    if (blendEquation !== this.currentBlendEquation || blendEquationAlpha !== this.currentBlendEquationAlpha) {
      gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
      this.currentBlendEquation = blendEquation;
      this.currentBlendEquationAlpha = blendEquationAlpha;
    }
    if (blendSrc !== this.currentBlendSrc || blendDst !== this.currentBlendDst || blendSrcAlpha !== this.currentBlendSrcAlpha || blendDstAlpha !== this.currentBlendDstAlpha) {
      gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
      this.currentBlendSrc = blendSrc;
      this.currentBlendDst = blendDst;
      this.currentBlendSrcAlpha = blendSrcAlpha;
      this.currentBlendDstAlpha = blendDstAlpha;
    }
    this.currentBlending = blending;
    this.currentPremultipledAlpha = false;
  }
  /**
   * Specifies whether colors can be written when rendering
   * into a framebuffer or not.
   *
   * This method caches the state so `gl.colorMask()` is only
   * called when necessary.
   *
   * @param {boolean} colorMask - The color mask.
   */
  setColorMask(colorMask) {
    if (this.currentColorMask !== colorMask) {
      this.gl.colorMask(colorMask, colorMask, colorMask, colorMask);
      this.currentColorMask = colorMask;
    }
  }
  /**
   * Specifies whether the depth test is enabled or not.
   *
   * @param {boolean} depthTest - Whether the depth test is enabled or not.
   */
  setDepthTest(depthTest) {
    const { gl } = this;
    if (depthTest) {
      this.enable(gl.DEPTH_TEST);
    } else {
      this.disable(gl.DEPTH_TEST);
    }
  }
  /**
   * Specifies whether depth values can be written when rendering
   * into a framebuffer or not.
   *
   * This method caches the state so `gl.depthMask()` is only
   * called when necessary.
   *
   * @param {boolean} depthMask - The depth mask.
   */
  setDepthMask(depthMask) {
    if (this.currentDepthMask !== depthMask) {
      this.gl.depthMask(depthMask);
      this.currentDepthMask = depthMask;
    }
  }
  /**
   * Specifies the depth compare function.
   *
   * This method caches the state so `gl.depthFunc()` is only
   * called when necessary.
   *
   * @param {number} depthFunc - The depth compare function.
   */
  setDepthFunc(depthFunc) {
    if (this.currentDepthFunc !== depthFunc) {
      const { gl } = this;
      switch (depthFunc) {
        case NeverDepth:
          gl.depthFunc(gl.NEVER);
          break;
        case AlwaysDepth:
          gl.depthFunc(gl.ALWAYS);
          break;
        case LessDepth:
          gl.depthFunc(gl.LESS);
          break;
        case LessEqualDepth:
          gl.depthFunc(gl.LEQUAL);
          break;
        case EqualDepth:
          gl.depthFunc(gl.EQUAL);
          break;
        case GreaterEqualDepth:
          gl.depthFunc(gl.GEQUAL);
          break;
        case GreaterDepth:
          gl.depthFunc(gl.GREATER);
          break;
        case NotEqualDepth:
          gl.depthFunc(gl.NOTEQUAL);
          break;
        default:
          gl.depthFunc(gl.LEQUAL);
      }
      this.currentDepthFunc = depthFunc;
    }
  }
  /**
   * Specifies the scissor box.
   *
   * @param {number} x - The x-coordinate of the lower left corner of the viewport.
   * @param {number} y - The y-coordinate of the lower left corner of the viewport.
   * @param {number} width - The width of the viewport.
   * @param {number} height - The height of the viewport.
   *
   */
  scissor(x3, y3, width, height) {
    const scissor = this._tempVec4.set(x3, y3, width, height);
    if (this.currentScissor.equals(scissor) === false) {
      const { gl } = this;
      gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
      this.currentScissor.copy(scissor);
    }
  }
  /**
   * Specifies the viewport.
   *
   * @param {number} x - The x-coordinate of the lower left corner of the viewport.
   * @param {number} y - The y-coordinate of the lower left corner of the viewport.
   * @param {number} width - The width of the viewport.
   * @param {number} height - The height of the viewport.
   *
   */
  viewport(x3, y3, width, height) {
    const viewport2 = this._tempVec4.set(x3, y3, width, height);
    if (this.currentViewport.equals(viewport2) === false) {
      const { gl } = this;
      gl.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
      this.currentViewport.copy(viewport2);
    }
  }
  /**
   * Defines the scissor test.
   *
   * @param {boolean} boolean - Whether the scissor test should be enabled or not.
   */
  setScissorTest(boolean) {
    const gl = this.gl;
    if (boolean) {
      this.enable(gl.SCISSOR_TEST);
    } else {
      this.disable(gl.SCISSOR_TEST);
    }
  }
  /**
   * Specifies whether the stencil test is enabled or not.
   *
   * @param {boolean} stencilTest - Whether the stencil test is enabled or not.
   */
  setStencilTest(stencilTest) {
    const { gl } = this;
    if (stencilTest) {
      this.enable(gl.STENCIL_TEST);
    } else {
      this.disable(gl.STENCIL_TEST);
    }
  }
  /**
   * Specifies whether stencil values can be written when rendering
   * into a framebuffer or not.
   *
   * This method caches the state so `gl.stencilMask()` is only
   * called when necessary.
   *
   * @param {boolean} stencilMask - The stencil mask.
   */
  setStencilMask(stencilMask) {
    if (this.currentStencilMask !== stencilMask) {
      this.gl.stencilMask(stencilMask);
      this.currentStencilMask = stencilMask;
    }
  }
  /**
   * Specifies whether the stencil test functions.
   *
   * This method caches the state so `gl.stencilFunc()` is only
   * called when necessary.
   *
   * @param {number} stencilFunc - The stencil compare function.
   * @param {number} stencilRef - The reference value for the stencil test.
   * @param {number} stencilMask - A bit-wise mask that is used to AND the reference value and the stored stencil value when the test is done.
   */
  setStencilFunc(stencilFunc, stencilRef, stencilMask) {
    if (this.currentStencilFunc !== stencilFunc || this.currentStencilRef !== stencilRef || this.currentStencilFuncMask !== stencilMask) {
      this.gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
      this.currentStencilFunc = stencilFunc;
      this.currentStencilRef = stencilRef;
      this.currentStencilFuncMask = stencilMask;
    }
  }
  /**
   * Specifies whether the stencil test operation.
   *
   * This method caches the state so `gl.stencilOp()` is only
   * called when necessary.
   *
   * @param {number} stencilFail - The function to use when the stencil test fails.
   * @param {number} stencilZFail - The function to use when the stencil test passes, but the depth test fail.
   * @param {number} stencilZPass - The function to use when both the stencil test and the depth test pass,
   * or when the stencil test passes and there is no depth buffer or depth testing is disabled.
   */
  setStencilOp(stencilFail, stencilZFail, stencilZPass) {
    if (this.currentStencilFail !== stencilFail || this.currentStencilZFail !== stencilZFail || this.currentStencilZPass !== stencilZPass) {
      this.gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
      this.currentStencilFail = stencilFail;
      this.currentStencilZFail = stencilZFail;
      this.currentStencilZPass = stencilZPass;
    }
  }
  /**
   * Configures the WebGL state for the given material.
   *
   * @param {Material} material - The material to configure the state for.
   * @param {number} frontFaceCW - Whether the front faces are counter-clockwise or not.
   * @param {number} hardwareClippingPlanes - The number of hardware clipping planes.
   */
  setMaterial(material, frontFaceCW, hardwareClippingPlanes) {
    const { gl } = this;
    material.side === DoubleSide ? this.disable(gl.CULL_FACE) : this.enable(gl.CULL_FACE);
    let flipSided = material.side === BackSide;
    if (frontFaceCW) flipSided = !flipSided;
    this.setFlipSided(flipSided);
    material.blending === NormalBlending && material.transparent === false ? this.setBlending(NoBlending) : this.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
    this.setDepthFunc(material.depthFunc);
    this.setDepthTest(material.depthTest);
    this.setDepthMask(material.depthWrite);
    this.setColorMask(material.colorWrite);
    const stencilWrite = material.stencilWrite;
    this.setStencilTest(stencilWrite);
    if (stencilWrite) {
      this.setStencilMask(material.stencilWriteMask);
      this.setStencilFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
      this.setStencilOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
    }
    this.setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
    material.alphaToCoverage === true && this.backend.renderer.currentSamples > 0 ? this.enable(gl.SAMPLE_ALPHA_TO_COVERAGE) : this.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
    if (hardwareClippingPlanes > 0) {
      if (this.currentClippingPlanes !== hardwareClippingPlanes) {
        const CLIP_DISTANCE0_WEBGL = 12288;
        for (let i2 = 0; i2 < 8; i2++) {
          if (i2 < hardwareClippingPlanes) {
            this.enable(CLIP_DISTANCE0_WEBGL + i2);
          } else {
            this.disable(CLIP_DISTANCE0_WEBGL + i2);
          }
        }
      }
    }
  }
  /**
   * Specifies the polygon offset.
   *
   * This method caches the state so `gl.polygonOffset()` is only
   * called when necessary.
   *
   * @param {boolean} polygonOffset - Whether polygon offset is enabled or not.
   * @param {number} factor - The scale factor for the variable depth offset for each polygon.
   * @param {number} units - The multiplier by which an implementation-specific value is multiplied with to create a constant depth offset.
   */
  setPolygonOffset(polygonOffset, factor, units) {
    const { gl } = this;
    if (polygonOffset) {
      this.enable(gl.POLYGON_OFFSET_FILL);
      if (this.currentPolygonOffsetFactor !== factor || this.currentPolygonOffsetUnits !== units) {
        gl.polygonOffset(factor, units);
        this.currentPolygonOffsetFactor = factor;
        this.currentPolygonOffsetUnits = units;
      }
    } else {
      this.disable(gl.POLYGON_OFFSET_FILL);
    }
  }
  /**
   * Defines the usage of the given WebGL program.
   *
   * This method caches the state so `gl.useProgram()` is only
   * called when necessary.
   *
   * @param {WebGLProgram} program - The WebGL program to use.
   * @return {boolean} Whether a program change has been executed or not.
   */
  useProgram(program) {
    if (this.currentProgram !== program) {
      this.gl.useProgram(program);
      this.currentProgram = program;
      return true;
    }
    return false;
  }
  /**
   * Sets the vertex state by binding the given VAO and element buffer.
   *
   * @param {WebGLVertexArrayObject} vao - The VAO.
   * @param {?WebGLBuffer} indexBuffer - The index buffer.
   * @return {boolean} Whether a vertex state has been changed or not.
   */
  setVertexState(vao, indexBuffer = null) {
    const gl = this.gl;
    if (this.currentVAO !== vao || this.currentIndex !== indexBuffer) {
      gl.bindVertexArray(vao);
      if (indexBuffer !== null) {
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
      }
      this.currentVAO = vao;
      this.currentIndex = indexBuffer;
      return true;
    }
    return false;
  }
  /**
   * Resets the vertex array state by resetting the VAO and element buffer.
   */
  resetVertexState() {
    const gl = this.gl;
    gl.bindVertexArray(null);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    this.currentVAO = null;
    this.currentIndex = null;
  }
  // framebuffer
  /**
   * Binds the given framebuffer.
   *
   * This method caches the state so `gl.bindFramebuffer()` is only
   * called when necessary.
   *
   * @param {number} target - The binding point (target).
   * @param {WebGLFramebuffer} framebuffer - The WebGL framebuffer to bind.
   * @return {boolean} Whether a bind has been executed or not.
   */
  bindFramebuffer(target, framebuffer) {
    const { gl, currentBoundFramebuffers } = this;
    if (currentBoundFramebuffers[target] !== framebuffer) {
      gl.bindFramebuffer(target, framebuffer);
      currentBoundFramebuffers[target] = framebuffer;
      if (target === gl.DRAW_FRAMEBUFFER) {
        currentBoundFramebuffers[gl.FRAMEBUFFER] = framebuffer;
      }
      if (target === gl.FRAMEBUFFER) {
        currentBoundFramebuffers[gl.DRAW_FRAMEBUFFER] = framebuffer;
      }
      return true;
    }
    return false;
  }
  /**
   * Defines draw buffers to which fragment colors are written into.
   * Configures the MRT setup of custom framebuffers.
   *
   * This method caches the state so `gl.drawBuffers()` is only
   * called when necessary.
   *
   * @param {RenderContext} renderContext - The render context.
   * @param {WebGLFramebuffer} framebuffer - The WebGL framebuffer.
   */
  drawBuffers(renderContext, framebuffer) {
    const { gl } = this;
    let drawBuffers = [];
    let needsUpdate = false;
    if (renderContext.textures !== null) {
      drawBuffers = this.currentDrawbuffers.get(framebuffer);
      if (drawBuffers === void 0) {
        drawBuffers = [];
        this.currentDrawbuffers.set(framebuffer, drawBuffers);
      }
      const textures = renderContext.textures;
      if (drawBuffers.length !== textures.length || drawBuffers[0] !== gl.COLOR_ATTACHMENT0) {
        for (let i2 = 0, il = textures.length; i2 < il; i2++) {
          drawBuffers[i2] = gl.COLOR_ATTACHMENT0 + i2;
        }
        drawBuffers.length = textures.length;
        needsUpdate = true;
      }
    } else {
      if (drawBuffers[0] !== gl.BACK) {
        drawBuffers[0] = gl.BACK;
        needsUpdate = true;
      }
    }
    if (needsUpdate) {
      gl.drawBuffers(drawBuffers);
    }
  }
  // texture
  /**
   * Makes the given texture unit active.
   *
   * This method caches the state so `gl.activeTexture()` is only
   * called when necessary.
   *
   * @param {number} webglSlot - The texture unit to make active.
   */
  activeTexture(webglSlot) {
    const { gl, currentTextureSlot, maxTextures } = this;
    if (webglSlot === void 0) webglSlot = gl.TEXTURE0 + maxTextures - 1;
    if (currentTextureSlot !== webglSlot) {
      gl.activeTexture(webglSlot);
      this.currentTextureSlot = webglSlot;
    }
  }
  /**
   * Binds the given WebGL texture to a target.
   *
   * This method caches the state so `gl.bindTexture()` is only
   * called when necessary.
   *
   * @param {number} webglType - The binding point (target).
   * @param {WebGLTexture} webglTexture - The WebGL texture to bind.
   * @param {number} webglSlot - The texture.
   */
  bindTexture(webglType, webglTexture, webglSlot) {
    const { gl, currentTextureSlot, currentBoundTextures, maxTextures } = this;
    if (webglSlot === void 0) {
      if (currentTextureSlot === null) {
        webglSlot = gl.TEXTURE0 + maxTextures - 1;
      } else {
        webglSlot = currentTextureSlot;
      }
    }
    let boundTexture = currentBoundTextures[webglSlot];
    if (boundTexture === void 0) {
      boundTexture = { type: void 0, texture: void 0 };
      currentBoundTextures[webglSlot] = boundTexture;
    }
    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
      if (currentTextureSlot !== webglSlot) {
        gl.activeTexture(webglSlot);
        this.currentTextureSlot = webglSlot;
      }
      gl.bindTexture(webglType, webglTexture);
      boundTexture.type = webglType;
      boundTexture.texture = webglTexture;
    }
  }
  /**
   * Binds a given WebGL buffer to a given binding point (target) at a given index.
   *
   * This method caches the state so `gl.bindBufferBase()` is only
   * called when necessary.
   *
   * @param {number} target - The target for the bind operation.
   * @param {number} index - The index of the target.
   * @param {WebGLBuffer} buffer - The WebGL buffer.
   * @return {boolean} Whether a bind has been executed or not.
   */
  bindBufferBase(target, index8, buffer2) {
    const { gl } = this;
    const key = `${target}-${index8}`;
    if (this.currentBoundBufferBases[key] !== buffer2) {
      gl.bindBufferBase(target, index8, buffer2);
      this.currentBoundBufferBases[key] = buffer2;
      return true;
    }
    return false;
  }
  /**
   * Unbinds the current bound texture.
   *
   * This method caches the state so `gl.bindTexture()` is only
   * called when necessary.
   */
  unbindTexture() {
    const { gl, currentTextureSlot, currentBoundTextures } = this;
    const boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture !== void 0 && boundTexture.type !== void 0) {
      gl.bindTexture(boundTexture.type, null);
      boundTexture.type = void 0;
      boundTexture.texture = void 0;
    }
  }
};
var WebGLUtils = class {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGLBackend} backend - The WebGL 2 backend.
   */
  constructor(backend) {
    this.backend = backend;
    this.gl = this.backend.gl;
    this.extensions = backend.extensions;
  }
  /**
   * Converts the given three.js constant into a WebGL constant.
   * The method currently supports the conversion of texture formats
   * and types.
   *
   * @param {number} p - The three.js constant.
   * @param {string} [colorSpace=NoColorSpace] - The color space.
   * @return {?number} The corresponding WebGL constant.
   */
  convert(p3, colorSpace = NoColorSpace) {
    const { gl, extensions } = this;
    let extension;
    const transfer = ColorManagement.getTransfer(colorSpace);
    if (p3 === UnsignedByteType) return gl.UNSIGNED_BYTE;
    if (p3 === UnsignedShort4444Type) return gl.UNSIGNED_SHORT_4_4_4_4;
    if (p3 === UnsignedShort5551Type) return gl.UNSIGNED_SHORT_5_5_5_1;
    if (p3 === UnsignedInt5999Type) return gl.UNSIGNED_INT_5_9_9_9_REV;
    if (p3 === UnsignedInt101111Type) return gl.UNSIGNED_INT_10F_11F_11F_REV;
    if (p3 === ByteType) return gl.BYTE;
    if (p3 === ShortType) return gl.SHORT;
    if (p3 === UnsignedShortType) return gl.UNSIGNED_SHORT;
    if (p3 === IntType) return gl.INT;
    if (p3 === UnsignedIntType) return gl.UNSIGNED_INT;
    if (p3 === FloatType) return gl.FLOAT;
    if (p3 === HalfFloatType) {
      return gl.HALF_FLOAT;
    }
    if (p3 === AlphaFormat) return gl.ALPHA;
    if (p3 === RGBFormat) return gl.RGB;
    if (p3 === RGBAFormat) return gl.RGBA;
    if (p3 === DepthFormat) return gl.DEPTH_COMPONENT;
    if (p3 === DepthStencilFormat) return gl.DEPTH_STENCIL;
    if (p3 === RedFormat) return gl.RED;
    if (p3 === RedIntegerFormat) return gl.RED_INTEGER;
    if (p3 === RGFormat) return gl.RG;
    if (p3 === RGIntegerFormat) return gl.RG_INTEGER;
    if (p3 === RGBAIntegerFormat) return gl.RGBA_INTEGER;
    if (p3 === RGB_S3TC_DXT1_Format || p3 === RGBA_S3TC_DXT1_Format || p3 === RGBA_S3TC_DXT3_Format || p3 === RGBA_S3TC_DXT5_Format) {
      if (transfer === SRGBTransfer) {
        extension = extensions.get("WEBGL_compressed_texture_s3tc_srgb");
        if (extension !== null) {
          if (p3 === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (p3 === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (p3 === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (p3 === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else {
          return null;
        }
      } else {
        extension = extensions.get("WEBGL_compressed_texture_s3tc");
        if (extension !== null) {
          if (p3 === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (p3 === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (p3 === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (p3 === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        } else {
          return null;
        }
      }
    }
    if (p3 === RGB_PVRTC_4BPPV1_Format || p3 === RGB_PVRTC_2BPPV1_Format || p3 === RGBA_PVRTC_4BPPV1_Format || p3 === RGBA_PVRTC_2BPPV1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_pvrtc");
      if (extension !== null) {
        if (p3 === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (p3 === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (p3 === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (p3 === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else {
        return null;
      }
    }
    if (p3 === RGB_ETC1_Format || p3 === RGB_ETC2_Format || p3 === RGBA_ETC2_EAC_Format || p3 === R11_EAC_Format || p3 === SIGNED_R11_EAC_Format || p3 === RG11_EAC_Format || p3 === SIGNED_RG11_EAC_Format) {
      extension = extensions.get("WEBGL_compressed_texture_etc");
      if (extension !== null) {
        if (p3 === RGB_ETC1_Format || p3 === RGB_ETC2_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
        if (p3 === RGBA_ETC2_EAC_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;
        if (p3 === R11_EAC_Format) return extension.COMPRESSED_R11_EAC;
        if (p3 === SIGNED_R11_EAC_Format) return extension.COMPRESSED_SIGNED_R11_EAC;
        if (p3 === RG11_EAC_Format) return extension.COMPRESSED_RG11_EAC;
        if (p3 === SIGNED_RG11_EAC_Format) return extension.COMPRESSED_SIGNED_RG11_EAC;
      } else {
        return null;
      }
    }
    if (p3 === RGBA_ASTC_4x4_Format || p3 === RGBA_ASTC_5x4_Format || p3 === RGBA_ASTC_5x5_Format || p3 === RGBA_ASTC_6x5_Format || p3 === RGBA_ASTC_6x6_Format || p3 === RGBA_ASTC_8x5_Format || p3 === RGBA_ASTC_8x6_Format || p3 === RGBA_ASTC_8x8_Format || p3 === RGBA_ASTC_10x5_Format || p3 === RGBA_ASTC_10x6_Format || p3 === RGBA_ASTC_10x8_Format || p3 === RGBA_ASTC_10x10_Format || p3 === RGBA_ASTC_12x10_Format || p3 === RGBA_ASTC_12x12_Format) {
      extension = extensions.get("WEBGL_compressed_texture_astc");
      if (extension !== null) {
        if (p3 === RGBA_ASTC_4x4_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (p3 === RGBA_ASTC_5x4_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (p3 === RGBA_ASTC_5x5_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (p3 === RGBA_ASTC_6x5_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (p3 === RGBA_ASTC_6x6_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (p3 === RGBA_ASTC_8x5_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (p3 === RGBA_ASTC_8x6_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (p3 === RGBA_ASTC_8x8_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (p3 === RGBA_ASTC_10x5_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (p3 === RGBA_ASTC_10x6_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (p3 === RGBA_ASTC_10x8_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (p3 === RGBA_ASTC_10x10_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (p3 === RGBA_ASTC_12x10_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (p3 === RGBA_ASTC_12x12_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else {
        return null;
      }
    }
    if (p3 === RGBA_BPTC_Format) {
      extension = extensions.get("EXT_texture_compression_bptc");
      if (extension !== null) {
        if (p3 === RGBA_BPTC_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;
      } else {
        return null;
      }
    }
    if (p3 === RED_RGTC1_Format || p3 === SIGNED_RED_RGTC1_Format || p3 === RED_GREEN_RGTC2_Format || p3 === SIGNED_RED_GREEN_RGTC2_Format) {
      extension = extensions.get("EXT_texture_compression_rgtc");
      if (extension !== null) {
        if (p3 === RED_RGTC1_Format) return extension.COMPRESSED_RED_RGTC1_EXT;
        if (p3 === SIGNED_RED_RGTC1_Format) return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (p3 === RED_GREEN_RGTC2_Format) return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (p3 === SIGNED_RED_GREEN_RGTC2_Format) return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else {
        return null;
      }
    }
    if (p3 === UnsignedInt248Type) {
      return gl.UNSIGNED_INT_24_8;
    }
    return gl[p3] !== void 0 ? gl[p3] : null;
  }
  /**
   * This method can be used to synchronize the CPU with the GPU by waiting until
   * ongoing GPU commands have been completed.
   *
   * @private
   * @return {Promise} A promise that resolves when all ongoing GPU commands have been completed.
   */
  _clientWaitAsync() {
    const { gl } = this;
    const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
    gl.flush();
    return new Promise((resolve, reject2) => {
      function test() {
        const res = gl.clientWaitSync(sync, gl.SYNC_FLUSH_COMMANDS_BIT, 0);
        if (res === gl.WAIT_FAILED) {
          gl.deleteSync(sync);
          reject2();
          return;
        }
        if (res === gl.TIMEOUT_EXPIRED) {
          requestAnimationFrame(test);
          return;
        }
        gl.deleteSync(sync);
        resolve();
      }
      test();
    });
  }
};
var initialized = false;
var wrappingToGL;
var filterToGL;
var compareToGL;
var WebGLTextureUtils = class {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGLBackend} backend - The WebGL 2 backend.
   */
  constructor(backend) {
    this.backend = backend;
    this.gl = backend.gl;
    this.extensions = backend.extensions;
    this.defaultTextures = {};
    this._srcFramebuffer = null;
    this._dstFramebuffer = null;
    if (initialized === false) {
      this._init();
      initialized = true;
    }
  }
  /**
   * Inits the state of the utility.
   *
   * @private
   */
  _init() {
    const gl = this.gl;
    wrappingToGL = {
      [RepeatWrapping]: gl.REPEAT,
      [ClampToEdgeWrapping]: gl.CLAMP_TO_EDGE,
      [MirroredRepeatWrapping]: gl.MIRRORED_REPEAT
    };
    filterToGL = {
      [NearestFilter]: gl.NEAREST,
      [NearestMipmapNearestFilter]: gl.NEAREST_MIPMAP_NEAREST,
      [NearestMipmapLinearFilter]: gl.NEAREST_MIPMAP_LINEAR,
      [LinearFilter]: gl.LINEAR,
      [LinearMipmapNearestFilter]: gl.LINEAR_MIPMAP_NEAREST,
      [LinearMipmapLinearFilter]: gl.LINEAR_MIPMAP_LINEAR
    };
    compareToGL = {
      [NeverCompare]: gl.NEVER,
      [AlwaysCompare]: gl.ALWAYS,
      [LessCompare]: gl.LESS,
      [LessEqualCompare]: gl.LEQUAL,
      [EqualCompare]: gl.EQUAL,
      [GreaterEqualCompare]: gl.GEQUAL,
      [GreaterCompare]: gl.GREATER,
      [NotEqualCompare]: gl.NOTEQUAL
    };
  }
  /**
   * Returns the native texture type for the given texture.
   *
   * @param {Texture} texture - The texture.
   * @return {GLenum} The native texture type.
   */
  getGLTextureType(texture2) {
    const { gl } = this;
    let glTextureType;
    if (texture2.isCubeTexture === true) {
      glTextureType = gl.TEXTURE_CUBE_MAP;
    } else if (texture2.isArrayTexture === true || texture2.isDataArrayTexture === true || texture2.isCompressedArrayTexture === true) {
      glTextureType = gl.TEXTURE_2D_ARRAY;
    } else if (texture2.isData3DTexture === true) {
      glTextureType = gl.TEXTURE_3D;
    } else {
      glTextureType = gl.TEXTURE_2D;
    }
    return glTextureType;
  }
  /**
   * Returns the native texture type for the given texture.
   *
   * @param {?string} internalFormatName - The internal format name. When `null`, the internal format is derived from the subsequent parameters.
   * @param {GLenum} glFormat - The WebGL format.
   * @param {GLenum} glType - The WebGL type.
   * @param {string} colorSpace - The texture's color space.
   * @param {boolean} [forceLinearTransfer=false] - Whether to force a linear transfer or not.
   * @return {GLenum} The internal format.
   */
  getInternalFormat(internalFormatName, glFormat, glType, colorSpace, forceLinearTransfer = false) {
    const { gl, extensions } = this;
    if (internalFormatName !== null) {
      if (gl[internalFormatName] !== void 0) return gl[internalFormatName];
      warn("WebGLBackend: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
    }
    let internalFormat = glFormat;
    if (glFormat === gl.RED) {
      if (glType === gl.FLOAT) internalFormat = gl.R32F;
      if (glType === gl.HALF_FLOAT) internalFormat = gl.R16F;
      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.R8;
      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.R16;
      if (glType === gl.UNSIGNED_INT) internalFormat = gl.R32UI;
      if (glType === gl.BYTE) internalFormat = gl.R8I;
      if (glType === gl.SHORT) internalFormat = gl.R16I;
      if (glType === gl.INT) internalFormat = gl.R32I;
    }
    if (glFormat === gl.RED_INTEGER) {
      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.R8UI;
      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.R16UI;
      if (glType === gl.UNSIGNED_INT) internalFormat = gl.R32UI;
      if (glType === gl.BYTE) internalFormat = gl.R8I;
      if (glType === gl.SHORT) internalFormat = gl.R16I;
      if (glType === gl.INT) internalFormat = gl.R32I;
    }
    if (glFormat === gl.RG) {
      if (glType === gl.FLOAT) internalFormat = gl.RG32F;
      if (glType === gl.HALF_FLOAT) internalFormat = gl.RG16F;
      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RG8;
      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RG16;
      if (glType === gl.UNSIGNED_INT) internalFormat = gl.RG32UI;
      if (glType === gl.BYTE) internalFormat = gl.RG8I;
      if (glType === gl.SHORT) internalFormat = gl.RG16I;
      if (glType === gl.INT) internalFormat = gl.RG32I;
    }
    if (glFormat === gl.RG_INTEGER) {
      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RG8UI;
      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RG16UI;
      if (glType === gl.UNSIGNED_INT) internalFormat = gl.RG32UI;
      if (glType === gl.BYTE) internalFormat = gl.RG8I;
      if (glType === gl.SHORT) internalFormat = gl.RG16I;
      if (glType === gl.INT) internalFormat = gl.RG32I;
    }
    if (glFormat === gl.RGB) {
      const transfer = forceLinearTransfer ? LinearTransfer : ColorManagement.getTransfer(colorSpace);
      if (glType === gl.FLOAT) internalFormat = gl.RGB32F;
      if (glType === gl.HALF_FLOAT) internalFormat = gl.RGB16F;
      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RGB8;
      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RGB16;
      if (glType === gl.UNSIGNED_INT) internalFormat = gl.RGB32UI;
      if (glType === gl.BYTE) internalFormat = gl.RGB8I;
      if (glType === gl.SHORT) internalFormat = gl.RGB16I;
      if (glType === gl.INT) internalFormat = gl.RGB32I;
      if (glType === gl.UNSIGNED_BYTE) internalFormat = transfer === SRGBTransfer ? gl.SRGB8 : gl.RGB8;
      if (glType === gl.UNSIGNED_SHORT_5_6_5) internalFormat = gl.RGB565;
      if (glType === gl.UNSIGNED_SHORT_5_5_5_1) internalFormat = gl.RGB5_A1;
      if (glType === gl.UNSIGNED_SHORT_4_4_4_4) internalFormat = gl.RGB4;
      if (glType === gl.UNSIGNED_INT_5_9_9_9_REV) internalFormat = gl.RGB9_E5;
      if (glType === gl.UNSIGNED_INT_10F_11F_11F_REV) internalFormat = gl.R11F_G11F_B10F;
    }
    if (glFormat === gl.RGB_INTEGER) {
      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RGB8UI;
      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RGB16UI;
      if (glType === gl.UNSIGNED_INT) internalFormat = gl.RGB32UI;
      if (glType === gl.BYTE) internalFormat = gl.RGB8I;
      if (glType === gl.SHORT) internalFormat = gl.RGB16I;
      if (glType === gl.INT) internalFormat = gl.RGB32I;
    }
    if (glFormat === gl.RGBA) {
      const transfer = forceLinearTransfer ? LinearTransfer : ColorManagement.getTransfer(colorSpace);
      if (glType === gl.FLOAT) internalFormat = gl.RGBA32F;
      if (glType === gl.HALF_FLOAT) internalFormat = gl.RGBA16F;
      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RGBA8;
      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RGBA16;
      if (glType === gl.UNSIGNED_INT) internalFormat = gl.RGBA32UI;
      if (glType === gl.BYTE) internalFormat = gl.RGBA8I;
      if (glType === gl.SHORT) internalFormat = gl.RGBA16I;
      if (glType === gl.INT) internalFormat = gl.RGBA32I;
      if (glType === gl.UNSIGNED_BYTE) internalFormat = transfer === SRGBTransfer ? gl.SRGB8_ALPHA8 : gl.RGBA8;
      if (glType === gl.UNSIGNED_SHORT_4_4_4_4) internalFormat = gl.RGBA4;
      if (glType === gl.UNSIGNED_SHORT_5_5_5_1) internalFormat = gl.RGB5_A1;
    }
    if (glFormat === gl.RGBA_INTEGER) {
      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RGBA8UI;
      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RGBA16UI;
      if (glType === gl.UNSIGNED_INT) internalFormat = gl.RGBA32UI;
      if (glType === gl.BYTE) internalFormat = gl.RGBA8I;
      if (glType === gl.SHORT) internalFormat = gl.RGBA16I;
      if (glType === gl.INT) internalFormat = gl.RGBA32I;
    }
    if (glFormat === gl.DEPTH_COMPONENT) {
      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.DEPTH_COMPONENT16;
      if (glType === gl.UNSIGNED_INT) internalFormat = gl.DEPTH_COMPONENT24;
      if (glType === gl.FLOAT) internalFormat = gl.DEPTH_COMPONENT32F;
    }
    if (glFormat === gl.DEPTH_STENCIL) {
      if (glType === gl.UNSIGNED_INT_24_8) internalFormat = gl.DEPTH24_STENCIL8;
    }
    if (internalFormat === gl.R16F || internalFormat === gl.R32F || internalFormat === gl.RG16F || internalFormat === gl.RG32F || internalFormat === gl.RGBA16F || internalFormat === gl.RGBA32F) {
      extensions.get("EXT_color_buffer_float");
    }
    return internalFormat;
  }
  /**
   * Sets the texture parameters for the given texture.
   *
   * @param {GLenum} textureType - The texture type.
   * @param {Texture} texture - The texture.
   */
  setTextureParameters(textureType, texture2) {
    const { gl, extensions, backend } = this;
    const workingPrimaries = ColorManagement.getPrimaries(ColorManagement.workingColorSpace);
    const texturePrimaries = texture2.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries(texture2.colorSpace);
    const unpackConversion = texture2.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? gl.NONE : gl.BROWSER_DEFAULT_WEBGL;
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, texture2.flipY);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture2.premultiplyAlpha);
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, texture2.unpackAlignment);
    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion);
    gl.texParameteri(textureType, gl.TEXTURE_WRAP_S, wrappingToGL[texture2.wrapS]);
    gl.texParameteri(textureType, gl.TEXTURE_WRAP_T, wrappingToGL[texture2.wrapT]);
    if (textureType === gl.TEXTURE_3D || textureType === gl.TEXTURE_2D_ARRAY) {
      if (!texture2.isArrayTexture) {
        gl.texParameteri(textureType, gl.TEXTURE_WRAP_R, wrappingToGL[texture2.wrapR]);
      }
    }
    gl.texParameteri(textureType, gl.TEXTURE_MAG_FILTER, filterToGL[texture2.magFilter]);
    const hasMipmaps = texture2.mipmaps !== void 0 && texture2.mipmaps.length > 0;
    const minFilter = texture2.minFilter === LinearFilter && hasMipmaps ? LinearMipmapLinearFilter : texture2.minFilter;
    gl.texParameteri(textureType, gl.TEXTURE_MIN_FILTER, filterToGL[minFilter]);
    if (texture2.compareFunction) {
      gl.texParameteri(textureType, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);
      gl.texParameteri(textureType, gl.TEXTURE_COMPARE_FUNC, compareToGL[texture2.compareFunction]);
    }
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      if (texture2.magFilter === NearestFilter) return;
      if (texture2.minFilter !== NearestMipmapLinearFilter && texture2.minFilter !== LinearMipmapLinearFilter) return;
      if (texture2.type === FloatType && extensions.has("OES_texture_float_linear") === false) return;
      if (texture2.anisotropy > 1) {
        const extension = extensions.get("EXT_texture_filter_anisotropic");
        gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture2.anisotropy, backend.getMaxAnisotropy()));
      }
    }
  }
  /**
   * Creates a default texture for the given texture that can be used
   * as a placeholder until the actual texture is ready for usage.
   *
   * @param {Texture} texture - The texture to create a default texture for.
   */
  createDefaultTexture(texture2) {
    const { gl, backend, defaultTextures } = this;
    const glTextureType = this.getGLTextureType(texture2);
    let textureGPU = defaultTextures[glTextureType];
    if (textureGPU === void 0) {
      textureGPU = gl.createTexture();
      backend.state.bindTexture(glTextureType, textureGPU);
      gl.texParameteri(glTextureType, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(glTextureType, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      defaultTextures[glTextureType] = textureGPU;
    }
    backend.set(texture2, {
      textureGPU,
      glTextureType
    });
  }
  /**
   * Defines a texture on the GPU for the given texture object.
   *
   * @param {Texture} texture - The texture.
   * @param {Object} [options={}] - Optional configuration parameter.
   * @return {undefined}
   */
  createTexture(texture2, options) {
    const { gl, backend } = this;
    const { levels, width, height, depth: depth2 } = options;
    const glFormat = backend.utils.convert(texture2.format, texture2.colorSpace);
    const glType = backend.utils.convert(texture2.type);
    const glInternalFormat = this.getInternalFormat(texture2.internalFormat, glFormat, glType, texture2.colorSpace, texture2.isVideoTexture);
    const textureGPU = gl.createTexture();
    const glTextureType = this.getGLTextureType(texture2);
    backend.state.bindTexture(glTextureType, textureGPU);
    this.setTextureParameters(glTextureType, texture2);
    if (texture2.isArrayTexture || texture2.isDataArrayTexture || texture2.isCompressedArrayTexture) {
      gl.texStorage3D(gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, width, height, depth2);
    } else if (texture2.isData3DTexture) {
      gl.texStorage3D(gl.TEXTURE_3D, levels, glInternalFormat, width, height, depth2);
    } else if (!texture2.isVideoTexture) {
      gl.texStorage2D(glTextureType, levels, glInternalFormat, width, height);
    }
    backend.set(texture2, {
      textureGPU,
      glTextureType,
      glFormat,
      glType,
      glInternalFormat
    });
  }
  /**
   * Uploads texture buffer data to the GPU memory.
   *
   * @param {WebGLBuffer} buffer - The buffer data.
   * @param {Texture} texture - The texture,
   */
  copyBufferToTexture(buffer2, texture2) {
    const { gl, backend } = this;
    const { textureGPU, glTextureType, glFormat, glType } = backend.get(texture2);
    const { width, height } = texture2.source.data;
    gl.bindBuffer(gl.PIXEL_UNPACK_BUFFER, buffer2);
    backend.state.bindTexture(glTextureType, textureGPU);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
    gl.texSubImage2D(glTextureType, 0, 0, 0, width, height, glFormat, glType, 0);
    gl.bindBuffer(gl.PIXEL_UNPACK_BUFFER, null);
    backend.state.unbindTexture();
  }
  /**
   * Uploads the updated texture data to the GPU.
   *
   * @param {Texture} texture - The texture.
   * @param {Object} [options={}] - Optional configuration parameter.
   */
  updateTexture(texture2, options) {
    const { gl } = this;
    const { width, height } = options;
    const { textureGPU, glTextureType, glFormat, glType, glInternalFormat } = this.backend.get(texture2);
    if (texture2.isRenderTargetTexture || textureGPU === void 0)
      return;
    this.backend.state.bindTexture(glTextureType, textureGPU);
    this.setTextureParameters(glTextureType, texture2);
    if (texture2.isCompressedTexture) {
      const mipmaps = texture2.mipmaps;
      const image = options.image;
      for (let i2 = 0; i2 < mipmaps.length; i2++) {
        const mipmap = mipmaps[i2];
        if (texture2.isCompressedArrayTexture) {
          if (texture2.format !== gl.RGBA) {
            if (glFormat !== null) {
              gl.compressedTexSubImage3D(gl.TEXTURE_2D_ARRAY, i2, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data);
            } else {
              warn("WebGLBackend: Attempt to load unsupported compressed texture format in .uploadTexture()");
            }
          } else {
            gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, i2, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data);
          }
        } else {
          if (glFormat !== null) {
            gl.compressedTexSubImage2D(gl.TEXTURE_2D, i2, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
          } else {
            warn("WebGLBackend: Unsupported compressed texture format");
          }
        }
      }
    } else if (texture2.isCubeTexture) {
      const images = options.images;
      const mipmaps = texture2.mipmaps;
      for (let i2 = 0; i2 < 6; i2++) {
        const image = getImage(images[i2]);
        gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, 0, 0, 0, width, height, glFormat, glType, image);
        for (let j2 = 0; j2 < mipmaps.length; j2++) {
          const mipmap = mipmaps[j2];
          const image2 = getImage(mipmap.images[i2]);
          gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j2 + 1, 0, 0, image2.width, image2.height, glFormat, glType, image2);
        }
      }
    } else if (texture2.isDataArrayTexture || texture2.isArrayTexture) {
      const image = options.image;
      if (texture2.layerUpdates.size > 0) {
        const layerByteLength = getByteLength(image.width, image.height, texture2.format, texture2.type);
        for (const layerIndex of texture2.layerUpdates) {
          const layerData = image.data.subarray(
            layerIndex * layerByteLength / image.data.BYTES_PER_ELEMENT,
            (layerIndex + 1) * layerByteLength / image.data.BYTES_PER_ELEMENT
          );
          gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, 0, 0, 0, layerIndex, image.width, image.height, 1, glFormat, glType, layerData);
        }
        texture2.clearLayerUpdates();
      } else {
        gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
      }
    } else if (texture2.isData3DTexture) {
      const image = options.image;
      gl.texSubImage3D(gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
    } else if (texture2.isVideoTexture) {
      texture2.update();
      gl.texImage2D(glTextureType, 0, glInternalFormat, glFormat, glType, options.image);
    } else {
      const mipmaps = texture2.mipmaps;
      if (mipmaps.length > 0) {
        for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
          const mipmap = mipmaps[i2];
          const image = getImage(mipmap);
          gl.texSubImage2D(glTextureType, i2, 0, 0, mipmap.width, mipmap.height, glFormat, glType, image);
        }
      } else {
        const image = getImage(options.image);
        gl.texSubImage2D(glTextureType, 0, 0, 0, width, height, glFormat, glType, image);
      }
    }
  }
  /**
   * Generates mipmaps for the given texture.
   *
   * @param {Texture} texture - The texture.
   */
  generateMipmaps(texture2) {
    const { gl, backend } = this;
    const { textureGPU, glTextureType } = backend.get(texture2);
    backend.state.bindTexture(glTextureType, textureGPU);
    gl.generateMipmap(glTextureType);
  }
  /**
   * Deallocates the render buffers of the given render target.
   *
   * @param {RenderTarget} renderTarget - The render target.
   */
  deallocateRenderBuffers(renderTarget) {
    const { gl, backend } = this;
    if (renderTarget) {
      const renderContextData = backend.get(renderTarget);
      renderContextData.renderBufferStorageSetup = void 0;
      if (renderContextData.framebuffers) {
        for (const cacheKey in renderContextData.framebuffers) {
          gl.deleteFramebuffer(renderContextData.framebuffers[cacheKey]);
        }
        delete renderContextData.framebuffers;
      }
      if (renderContextData.depthRenderbuffer) {
        gl.deleteRenderbuffer(renderContextData.depthRenderbuffer);
        delete renderContextData.depthRenderbuffer;
      }
      if (renderContextData.stencilRenderbuffer) {
        gl.deleteRenderbuffer(renderContextData.stencilRenderbuffer);
        delete renderContextData.stencilRenderbuffer;
      }
      if (renderContextData.msaaFrameBuffer) {
        gl.deleteFramebuffer(renderContextData.msaaFrameBuffer);
        delete renderContextData.msaaFrameBuffer;
      }
      if (renderContextData.msaaRenderbuffers) {
        for (let i2 = 0; i2 < renderContextData.msaaRenderbuffers.length; i2++) {
          gl.deleteRenderbuffer(renderContextData.msaaRenderbuffers[i2]);
        }
        delete renderContextData.msaaRenderbuffers;
      }
    }
  }
  /**
   * Destroys the GPU data for the given texture object.
   *
   * @param {Texture} texture - The texture.
   * @param {boolean} [isDefaultTexture=false] - Whether the texture uses a default GPU texture or not.
   */
  destroyTexture(texture2, isDefaultTexture = false) {
    const { gl, backend } = this;
    const { textureGPU, renderTarget } = backend.get(texture2);
    this.deallocateRenderBuffers(renderTarget);
    if (isDefaultTexture === false) {
      gl.deleteTexture(textureGPU);
    }
    backend.delete(texture2);
  }
  /**
   * Copies data of the given source texture to the given destination texture.
   *
   * @param {Texture} srcTexture - The source texture.
   * @param {Texture} dstTexture - The destination texture.
   * @param {?(Box3|Box2)} [srcRegion=null] - The region of the source texture to copy.
   * @param {?(Vector2|Vector3)} [dstPosition=null] - The destination position of the copy.
   * @param {number} [srcLevel=0] - The source mip level to copy from.
   * @param {number} [dstLevel=0] - The destination mip level to copy to.
   */
  copyTextureToTexture(srcTexture, dstTexture, srcRegion = null, dstPosition = null, srcLevel = 0, dstLevel = 0) {
    const { gl, backend } = this;
    const { state } = this.backend;
    const { textureGPU: dstTextureGPU, glTextureType, glType, glFormat } = backend.get(dstTexture);
    state.bindTexture(glTextureType, dstTextureGPU);
    let width, height, depth2, minX, minY, minZ;
    let dstX, dstY, dstZ;
    const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[dstLevel] : srcTexture.image;
    if (srcRegion !== null) {
      width = srcRegion.max.x - srcRegion.min.x;
      height = srcRegion.max.y - srcRegion.min.y;
      depth2 = srcRegion.isBox3 ? srcRegion.max.z - srcRegion.min.z : 1;
      minX = srcRegion.min.x;
      minY = srcRegion.min.y;
      minZ = srcRegion.isBox3 ? srcRegion.min.z : 0;
    } else {
      const levelScale = Math.pow(2, -srcLevel);
      width = Math.floor(image.width * levelScale);
      height = Math.floor(image.height * levelScale);
      if (srcTexture.isDataArrayTexture || srcTexture.isArrayTexture) {
        depth2 = image.depth;
      } else if (srcTexture.isData3DTexture) {
        depth2 = Math.floor(image.depth * levelScale);
      } else {
        depth2 = 1;
      }
      minX = 0;
      minY = 0;
      minZ = 0;
    }
    if (dstPosition !== null) {
      dstX = dstPosition.x;
      dstY = dstPosition.y;
      dstZ = dstPosition.z;
    } else {
      dstX = 0;
      dstY = 0;
      dstZ = 0;
    }
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
    const currentUnpackRowLen = gl.getParameter(gl.UNPACK_ROW_LENGTH);
    const currentUnpackImageHeight = gl.getParameter(gl.UNPACK_IMAGE_HEIGHT);
    const currentUnpackSkipPixels = gl.getParameter(gl.UNPACK_SKIP_PIXELS);
    const currentUnpackSkipRows = gl.getParameter(gl.UNPACK_SKIP_ROWS);
    const currentUnpackSkipImages = gl.getParameter(gl.UNPACK_SKIP_IMAGES);
    gl.pixelStorei(gl.UNPACK_ROW_LENGTH, image.width);
    gl.pixelStorei(gl.UNPACK_IMAGE_HEIGHT, image.height);
    gl.pixelStorei(gl.UNPACK_SKIP_PIXELS, minX);
    gl.pixelStorei(gl.UNPACK_SKIP_ROWS, minY);
    gl.pixelStorei(gl.UNPACK_SKIP_IMAGES, minZ);
    const isSrc3D = srcTexture.isDataArrayTexture || srcTexture.isData3DTexture || dstTexture.isArrayTexture;
    const isDst3D = dstTexture.isDataArrayTexture || dstTexture.isData3DTexture || dstTexture.isArrayTexture;
    if (srcTexture.isDepthTexture) {
      const srcTextureData = backend.get(srcTexture);
      const dstTextureData = backend.get(dstTexture);
      const srcRenderContextData = backend.get(srcTextureData.renderTarget);
      const dstRenderContextData = backend.get(dstTextureData.renderTarget);
      const srcFramebuffer = srcRenderContextData.framebuffers[srcTextureData.cacheKey];
      const dstFramebuffer = dstRenderContextData.framebuffers[dstTextureData.cacheKey];
      state.bindFramebuffer(gl.READ_FRAMEBUFFER, srcFramebuffer);
      state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, dstFramebuffer);
      for (let i2 = 0; i2 < depth2; i2++) {
        if (isSrc3D) {
          gl.framebufferTextureLayer(gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, srcTextureData.textureGPU, srcLevel, minZ + i2);
          gl.framebufferTextureLayer(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, dstTextureGPU, dstLevel, dstZ + i2);
        }
        gl.blitFramebuffer(minX, minY, width, height, dstX, dstY, width, height, gl.DEPTH_BUFFER_BIT, gl.NEAREST);
      }
      state.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
      state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
    } else if (srcLevel !== 0 || srcTexture.isRenderTargetTexture || backend.has(srcTexture)) {
      const srcTextureData = backend.get(srcTexture);
      if (this._srcFramebuffer === null) this._srcFramebuffer = gl.createFramebuffer();
      if (this._dstFramebuffer === null) this._dstFramebuffer = gl.createFramebuffer();
      state.bindFramebuffer(gl.READ_FRAMEBUFFER, this._srcFramebuffer);
      state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this._dstFramebuffer);
      for (let i2 = 0; i2 < depth2; i2++) {
        if (isSrc3D) {
          gl.framebufferTextureLayer(gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, srcTextureData.textureGPU, srcLevel, minZ + i2);
        } else {
          gl.framebufferTexture2D(gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, srcTextureData.textureGPU, srcLevel);
        }
        if (isDst3D) {
          gl.framebufferTextureLayer(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, dstTextureGPU, dstLevel, dstZ + i2);
        } else {
          gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, dstTextureGPU, dstLevel);
        }
        if (srcLevel !== 0) {
          gl.blitFramebuffer(minX, minY, width, height, dstX, dstY, width, height, gl.COLOR_BUFFER_BIT, gl.NEAREST);
        } else if (isDst3D) {
          gl.copyTexSubImage3D(glTextureType, dstLevel, dstX, dstY, dstZ + i2, minX, minY, width, height);
        } else {
          gl.copyTexSubImage2D(glTextureType, dstLevel, dstX, dstY, minX, minY, width, height);
        }
      }
      state.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
      state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
    } else {
      if (isDst3D) {
        if (srcTexture.isDataTexture || srcTexture.isData3DTexture) {
          gl.texSubImage3D(glTextureType, dstLevel, dstX, dstY, dstZ, width, height, depth2, glFormat, glType, image.data);
        } else if (dstTexture.isCompressedArrayTexture) {
          gl.compressedTexSubImage3D(glTextureType, dstLevel, dstX, dstY, dstZ, width, height, depth2, glFormat, image.data);
        } else {
          gl.texSubImage3D(glTextureType, dstLevel, dstX, dstY, dstZ, width, height, depth2, glFormat, glType, image);
        }
      } else {
        if (srcTexture.isDataTexture) {
          gl.texSubImage2D(gl.TEXTURE_2D, dstLevel, dstX, dstY, width, height, glFormat, glType, image.data);
        } else if (srcTexture.isCompressedTexture) {
          gl.compressedTexSubImage2D(gl.TEXTURE_2D, dstLevel, dstX, dstY, image.width, image.height, glFormat, image.data);
        } else {
          gl.texSubImage2D(gl.TEXTURE_2D, dstLevel, dstX, dstY, width, height, glFormat, glType, image);
        }
      }
    }
    gl.pixelStorei(gl.UNPACK_ROW_LENGTH, currentUnpackRowLen);
    gl.pixelStorei(gl.UNPACK_IMAGE_HEIGHT, currentUnpackImageHeight);
    gl.pixelStorei(gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels);
    gl.pixelStorei(gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows);
    gl.pixelStorei(gl.UNPACK_SKIP_IMAGES, currentUnpackSkipImages);
    if (dstLevel === 0 && dstTexture.generateMipmaps) {
      gl.generateMipmap(glTextureType);
    }
    state.unbindTexture();
  }
  /**
   * Copies the current bound framebuffer to the given texture.
   *
   * @param {Texture} texture - The destination texture.
   * @param {RenderContext} renderContext - The render context.
   * @param {Vector4} rectangle - A four dimensional vector defining the origin and dimension of the copy.
   */
  copyFramebufferToTexture(texture2, renderContext, rectangle) {
    const { gl } = this;
    const { state } = this.backend;
    const { textureGPU } = this.backend.get(texture2);
    const { x: x3, y: y3, z: width, w: height } = rectangle;
    const requireDrawFrameBuffer = texture2.isDepthTexture === true || renderContext.renderTarget && renderContext.renderTarget.samples > 0;
    const srcHeight = renderContext.renderTarget ? renderContext.renderTarget.height : this.backend.getDrawingBufferSize().y;
    if (requireDrawFrameBuffer) {
      const partial2 = x3 !== 0 || y3 !== 0;
      let mask;
      let attachment;
      if (texture2.isDepthTexture === true) {
        mask = gl.DEPTH_BUFFER_BIT;
        attachment = gl.DEPTH_ATTACHMENT;
        if (renderContext.stencil) {
          mask |= gl.STENCIL_BUFFER_BIT;
        }
      } else {
        mask = gl.COLOR_BUFFER_BIT;
        attachment = gl.COLOR_ATTACHMENT0;
      }
      if (partial2) {
        const renderTargetContextData = this.backend.get(renderContext.renderTarget);
        const fb = renderTargetContextData.framebuffers[renderContext.getCacheKey()];
        const msaaFrameBuffer = renderTargetContextData.msaaFrameBuffer;
        state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, fb);
        state.bindFramebuffer(gl.READ_FRAMEBUFFER, msaaFrameBuffer);
        const flippedY = srcHeight - y3 - height;
        gl.blitFramebuffer(x3, flippedY, x3 + width, flippedY + height, x3, flippedY, x3 + width, flippedY + height, mask, gl.NEAREST);
        state.bindFramebuffer(gl.READ_FRAMEBUFFER, fb);
        state.bindTexture(gl.TEXTURE_2D, textureGPU);
        gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, x3, flippedY, width, height);
        state.unbindTexture();
      } else {
        const fb = gl.createFramebuffer();
        state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, fb);
        gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, attachment, gl.TEXTURE_2D, textureGPU, 0);
        gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, gl.NEAREST);
        gl.deleteFramebuffer(fb);
      }
    } else {
      state.bindTexture(gl.TEXTURE_2D, textureGPU);
      gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, x3, srcHeight - height - y3, width, height);
      state.unbindTexture();
    }
    if (texture2.generateMipmaps) this.generateMipmaps(texture2);
    this.backend._setFramebuffer(renderContext);
  }
  /**
   * SetupS storage for internal depth/stencil buffers and bind to correct framebuffer.
   *
   * @param {WebGLRenderbuffer} renderbuffer - The render buffer.
   * @param {RenderContext} renderContext - The render context.
   * @param {number} samples - The MSAA sample count.
   * @param {boolean} [useMultisampledRTT=false] - Whether to use WEBGL_multisampled_render_to_texture or not.
   */
  setupRenderBufferStorage(renderbuffer, renderContext, samples, useMultisampledRTT = false) {
    const { gl } = this;
    const renderTarget = renderContext.renderTarget;
    const { depthTexture, depthBuffer, stencilBuffer, width, height } = renderTarget;
    gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
    if (depthBuffer && !stencilBuffer) {
      let glInternalFormat = gl.DEPTH_COMPONENT24;
      if (useMultisampledRTT === true) {
        const multisampledRTTExt = this.extensions.get("WEBGL_multisampled_render_to_texture");
        multisampledRTTExt.renderbufferStorageMultisampleEXT(gl.RENDERBUFFER, renderTarget.samples, glInternalFormat, width, height);
      } else if (samples > 0) {
        if (depthTexture && depthTexture.isDepthTexture) {
          if (depthTexture.type === gl.FLOAT) {
            glInternalFormat = gl.DEPTH_COMPONENT32F;
          }
        }
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, glInternalFormat, width, height);
      } else {
        gl.renderbufferStorage(gl.RENDERBUFFER, glInternalFormat, width, height);
      }
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);
    } else if (depthBuffer && stencilBuffer) {
      if (samples > 0) {
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, gl.DEPTH24_STENCIL8, width, height);
      } else {
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height);
      }
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);
    }
    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
  }
  /**
   * Returns texture data as a typed array.
   *
   * @async
   * @param {Texture} texture - The texture to copy.
   * @param {number} x - The x coordinate of the copy origin.
   * @param {number} y - The y coordinate of the copy origin.
   * @param {number} width - The width of the copy.
   * @param {number} height - The height of the copy.
   * @param {number} faceIndex - The face index.
   * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.
   */
  async copyTextureToBuffer(texture2, x3, y3, width, height, faceIndex) {
    const { backend, gl } = this;
    const { textureGPU, glFormat, glType } = this.backend.get(texture2);
    const fb = gl.createFramebuffer();
    backend.state.bindFramebuffer(gl.READ_FRAMEBUFFER, fb);
    const target = texture2.isCubeTexture ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex : gl.TEXTURE_2D;
    gl.framebufferTexture2D(gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, target, textureGPU, 0);
    const typedArrayType = this._getTypedArrayType(glType);
    const bytesPerTexel = this._getBytesPerTexel(glType, glFormat);
    const elementCount = width * height;
    const byteLength = elementCount * bytesPerTexel;
    const buffer2 = gl.createBuffer();
    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buffer2);
    gl.bufferData(gl.PIXEL_PACK_BUFFER, byteLength, gl.STREAM_READ);
    gl.readPixels(x3, y3, width, height, glFormat, glType, 0);
    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
    await backend.utils._clientWaitAsync();
    const dstBuffer = new typedArrayType(byteLength / typedArrayType.BYTES_PER_ELEMENT);
    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buffer2);
    gl.getBufferSubData(gl.PIXEL_PACK_BUFFER, 0, dstBuffer);
    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
    backend.state.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
    gl.deleteFramebuffer(fb);
    return dstBuffer;
  }
  /**
   * Returns the corresponding typed array type for the given WebGL data type.
   *
   * @private
   * @param {GLenum} glType - The WebGL data type.
   * @return {TypedArray.constructor} The typed array type.
   */
  _getTypedArrayType(glType) {
    const { gl } = this;
    if (glType === gl.UNSIGNED_BYTE) return Uint8Array;
    if (glType === gl.UNSIGNED_SHORT_4_4_4_4) return Uint16Array;
    if (glType === gl.UNSIGNED_SHORT_5_5_5_1) return Uint16Array;
    if (glType === gl.UNSIGNED_SHORT_5_6_5) return Uint16Array;
    if (glType === gl.UNSIGNED_SHORT) return Uint16Array;
    if (glType === gl.UNSIGNED_INT) return Uint32Array;
    if (glType === gl.HALF_FLOAT) return Uint16Array;
    if (glType === gl.FLOAT) return Float32Array;
    throw new Error(`Unsupported WebGL type: ${glType}`);
  }
  /**
   * Returns the bytes-per-texel value for the given WebGL data type and texture format.
   *
   * @private
   * @param {GLenum} glType - The WebGL data type.
   * @param {GLenum} glFormat - The WebGL texture format.
   * @return {number} The bytes-per-texel.
   */
  _getBytesPerTexel(glType, glFormat) {
    const { gl } = this;
    let bytesPerComponent = 0;
    if (glType === gl.UNSIGNED_BYTE) bytesPerComponent = 1;
    if (glType === gl.UNSIGNED_SHORT_4_4_4_4 || glType === gl.UNSIGNED_SHORT_5_5_5_1 || glType === gl.UNSIGNED_SHORT_5_6_5 || glType === gl.UNSIGNED_SHORT || glType === gl.HALF_FLOAT) bytesPerComponent = 2;
    if (glType === gl.UNSIGNED_INT || glType === gl.FLOAT) bytesPerComponent = 4;
    if (glFormat === gl.RGBA) return bytesPerComponent * 4;
    if (glFormat === gl.RGB) return bytesPerComponent * 3;
    if (glFormat === gl.ALPHA) return bytesPerComponent;
  }
  /**
   * Frees the internal resources.
   */
  dispose() {
    const { gl } = this;
    if (this._srcFramebuffer !== null) gl.deleteFramebuffer(this._srcFramebuffer);
    if (this._dstFramebuffer !== null) gl.deleteFramebuffer(this._dstFramebuffer);
  }
};
function getImage(source) {
  if (source.isDataTexture) {
    return source.image.data;
  } else if (typeof HTMLImageElement !== "undefined" && source instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && source instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && source instanceof ImageBitmap || typeof OffscreenCanvas !== "undefined" && source instanceof OffscreenCanvas) {
    return source;
  }
  return source.data;
}
var WebGLExtensions = class {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGLBackend} backend - The WebGL 2 backend.
   */
  constructor(backend) {
    this.backend = backend;
    this.gl = this.backend.gl;
    this.availableExtensions = this.gl.getSupportedExtensions();
    this.extensions = {};
  }
  /**
   * Returns the extension object for the given extension name.
   *
   * @param {string} name - The extension name.
   * @return {Object} The extension object.
   */
  get(name) {
    let extension = this.extensions[name];
    if (extension === void 0) {
      extension = this.gl.getExtension(name);
      this.extensions[name] = extension;
    }
    return extension;
  }
  /**
   * Returns `true` if the requested extension is available.
   *
   * @param {string} name - The extension name.
   * @return {boolean} Whether the given extension is available or not.
   */
  has(name) {
    return this.availableExtensions.includes(name);
  }
};
var WebGLCapabilities = class {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGLBackend} backend - The WebGL 2 backend.
   */
  constructor(backend) {
    this.backend = backend;
    this.maxAnisotropy = null;
  }
  /**
   * Returns the maximum anisotropy texture filtering value. This value
   * depends on the device and is reported by the `EXT_texture_filter_anisotropic`
   * WebGL extension.
   *
   * @return {number} The maximum anisotropy texture filtering value.
   */
  getMaxAnisotropy() {
    if (this.maxAnisotropy !== null) return this.maxAnisotropy;
    const gl = this.backend.gl;
    const extensions = this.backend.extensions;
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      const extension = extensions.get("EXT_texture_filter_anisotropic");
      this.maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else {
      this.maxAnisotropy = 0;
    }
    return this.maxAnisotropy;
  }
};
var GLFeatureName = {
  "WEBGL_multi_draw": "WEBGL_multi_draw",
  "WEBGL_compressed_texture_astc": "texture-compression-astc",
  "WEBGL_compressed_texture_etc": "texture-compression-etc2",
  "WEBGL_compressed_texture_etc1": "texture-compression-etc1",
  "WEBGL_compressed_texture_pvrtc": "texture-compression-pvrtc",
  "WEBGL_compressed_texture_s3tc": "texture-compression-s3tc",
  "EXT_texture_compression_bptc": "texture-compression-bc",
  "EXT_disjoint_timer_query_webgl2": "timestamp-query",
  "OVR_multiview2": "OVR_multiview2"
};
var WebGLBufferRenderer = class {
  constructor(backend) {
    this.gl = backend.gl;
    this.extensions = backend.extensions;
    this.info = backend.renderer.info;
    this.mode = null;
    this.index = 0;
    this.type = null;
    this.object = null;
  }
  render(start2, count2) {
    const { gl, mode: mode2, object, type, info, index: index8 } = this;
    if (index8 !== 0) {
      gl.drawElements(mode2, count2, type, start2);
    } else {
      gl.drawArrays(mode2, start2, count2);
    }
    info.update(object, count2, 1);
  }
  renderInstances(start2, count2, primcount) {
    const { gl, mode: mode2, type, index: index8, object, info } = this;
    if (primcount === 0) return;
    if (index8 !== 0) {
      gl.drawElementsInstanced(mode2, count2, type, start2, primcount);
    } else {
      gl.drawArraysInstanced(mode2, start2, count2, primcount);
    }
    info.update(object, count2, primcount);
  }
  renderMultiDraw(starts, counts, drawCount) {
    const { extensions, mode: mode2, object, info } = this;
    if (drawCount === 0) return;
    const extension = extensions.get("WEBGL_multi_draw");
    if (extension === null) {
      for (let i2 = 0; i2 < drawCount; i2++) {
        this.render(starts[i2], counts[i2]);
      }
    } else {
      if (this.index !== 0) {
        extension.multiDrawElementsWEBGL(mode2, counts, 0, this.type, starts, 0, drawCount);
      } else {
        extension.multiDrawArraysWEBGL(mode2, starts, 0, counts, 0, drawCount);
      }
      let elementCount = 0;
      for (let i2 = 0; i2 < drawCount; i2++) {
        elementCount += counts[i2];
      }
      info.update(object, elementCount, 1);
    }
  }
  renderMultiDrawInstances(starts, counts, drawCount, primcount) {
    const { extensions, mode: mode2, object, info } = this;
    if (drawCount === 0) return;
    const extension = extensions.get("WEBGL_multi_draw");
    if (extension === null) {
      for (let i2 = 0; i2 < drawCount; i2++) {
        this.renderInstances(starts[i2], counts[i2], primcount[i2]);
      }
    } else {
      if (this.index !== 0) {
        extension.multiDrawElementsInstancedWEBGL(mode2, counts, 0, this.type, starts, 0, primcount, 0, drawCount);
      } else {
        extension.multiDrawArraysInstancedWEBGL(mode2, starts, 0, counts, 0, primcount, 0, drawCount);
      }
      let elementCount = 0;
      for (let i2 = 0; i2 < drawCount; i2++) {
        elementCount += counts[i2] * primcount[i2];
      }
      info.update(object, elementCount, 1);
    }
  }
  //
};
var TimestampQueryPool = class {
  /**
   * Creates a new timestamp query pool.
   *
   * @param {number} [maxQueries=256] - Maximum number of queries this pool can hold.
   */
  constructor(maxQueries = 256) {
    this.trackTimestamp = true;
    this.maxQueries = maxQueries;
    this.currentQueryIndex = 0;
    this.queryOffsets = /* @__PURE__ */ new Map();
    this.isDisposed = false;
    this.lastValue = 0;
    this.frames = [];
    this.pendingResolve = false;
    this.timestamps = /* @__PURE__ */ new Map();
  }
  /**
   * Returns all timestamp frames.
   *
   * @return {Array<number>} The timestamp frames.
   */
  getTimestampFrames() {
    return this.frames;
  }
  /**
   * Returns the timestamp for a given render context.
   *
   * @param {string} uid - A unique identifier for the render context.
   * @return {?number} The timestamp, or undefined if not available.
   */
  getTimestamp(uid) {
    let timestamp = this.timestamps.get(uid);
    if (timestamp === void 0) {
      warn(`TimestampQueryPool: No timestamp available for uid ${uid}.`);
      timestamp = 0;
    }
    return timestamp;
  }
  /**
   * Returns whether a timestamp is available for a given render context.
   *
   * @param {string} uid - A unique identifier for the render context.
   * @return {boolean} True if a timestamp is available, false otherwise.
   */
  hasTimestamp(uid) {
    return this.timestamps.has(uid);
  }
  /**
   * Allocate queries for a specific uid.
   *
   * @abstract
   * @param {string} uid - A unique identifier for the render context.
   * @param {number} frameId - The current frame identifier.
   * @returns {?number}
   */
  allocateQueriesForContext() {
  }
  /**
   * Resolve all timestamps and return data (or process them).
   *
   * @abstract
   * @async
   * @returns {Promise<number>|number} The resolved timestamp value.
   */
  async resolveQueriesAsync() {
  }
  /**
   * Dispose of the query pool.
   *
   * @abstract
   */
  dispose() {
  }
};
var WebGLTimestampQueryPool = class extends TimestampQueryPool {
  /**
   * Creates a new WebGL timestamp query pool.
   *
   * @param {WebGLRenderingContext|WebGL2RenderingContext} gl - The WebGL context.
   * @param {string} type - The type identifier for this query pool.
   * @param {number} [maxQueries=2048] - Maximum number of queries this pool can hold.
   */
  constructor(gl, type, maxQueries = 2048) {
    super(maxQueries);
    this.gl = gl;
    this.type = type;
    this.ext = gl.getExtension("EXT_disjoint_timer_query_webgl2") || gl.getExtension("EXT_disjoint_timer_query");
    if (!this.ext) {
      warn("EXT_disjoint_timer_query not supported; timestamps will be disabled.");
      this.trackTimestamp = false;
      return;
    }
    this.queries = [];
    for (let i2 = 0; i2 < this.maxQueries; i2++) {
      this.queries.push(gl.createQuery());
    }
    this.activeQuery = null;
    this.queryStates = /* @__PURE__ */ new Map();
  }
  /**
   * Allocates a pair of queries for a given render context.
   *
   * @param {string} uid - A unique identifier for the render context.
   * @returns {?number} The base offset for the allocated queries, or null if allocation failed.
   */
  allocateQueriesForContext(uid) {
    if (!this.trackTimestamp) return null;
    if (this.currentQueryIndex + 2 > this.maxQueries) {
      warnOnce(`WebGPUTimestampQueryPool [${this.type}]: Maximum number of queries exceeded, when using trackTimestamp it is necessary to resolves the queries via renderer.resolveTimestampsAsync( THREE.TimestampQuery.${this.type.toUpperCase()} ).`);
      return null;
    }
    const baseOffset = this.currentQueryIndex;
    this.currentQueryIndex += 2;
    this.queryStates.set(baseOffset, "inactive");
    this.queryOffsets.set(uid, baseOffset);
    return baseOffset;
  }
  /**
   * Begins a timestamp query for the specified render context.
   *
   * @param {string} uid - A unique identifier for the render context.
   */
  beginQuery(uid) {
    if (!this.trackTimestamp || this.isDisposed) {
      return;
    }
    const baseOffset = this.queryOffsets.get(uid);
    if (baseOffset == null) {
      return;
    }
    if (this.activeQuery !== null) {
      return;
    }
    const query = this.queries[baseOffset];
    if (!query) {
      return;
    }
    try {
      if (this.queryStates.get(baseOffset) === "inactive") {
        this.gl.beginQuery(this.ext.TIME_ELAPSED_EXT, query);
        this.activeQuery = baseOffset;
        this.queryStates.set(baseOffset, "started");
      }
    } catch (e3) {
      error("Error in beginQuery:", e3);
      this.activeQuery = null;
      this.queryStates.set(baseOffset, "inactive");
    }
  }
  /**
   * Ends the active timestamp query for the specified render context.
   *
   * @param {string} uid - A unique identifier for the render context.
   */
  endQuery(uid) {
    if (!this.trackTimestamp || this.isDisposed) {
      return;
    }
    const baseOffset = this.queryOffsets.get(uid);
    if (baseOffset == null) {
      return;
    }
    if (this.activeQuery !== baseOffset) {
      return;
    }
    try {
      this.gl.endQuery(this.ext.TIME_ELAPSED_EXT);
      this.queryStates.set(baseOffset, "ended");
      this.activeQuery = null;
    } catch (e3) {
      error("Error in endQuery:", e3);
      this.queryStates.set(baseOffset, "inactive");
      this.activeQuery = null;
    }
  }
  /**
   * Asynchronously resolves all completed queries and returns the total duration.
   *
   * @async
   * @returns {Promise<number>} The total duration in milliseconds, or the last valid value if resolution fails.
   */
  async resolveQueriesAsync() {
    if (!this.trackTimestamp || this.pendingResolve) {
      return this.lastValue;
    }
    this.pendingResolve = true;
    try {
      const resolvePromises = /* @__PURE__ */ new Map();
      for (const [uid, baseOffset] of this.queryOffsets) {
        const state = this.queryStates.get(baseOffset);
        if (state === "ended") {
          const query = this.queries[baseOffset];
          resolvePromises.set(uid, this.resolveQuery(query));
        }
      }
      if (resolvePromises.size === 0) {
        return this.lastValue;
      }
      const framesDuration = {};
      const frames = [];
      for (const [uid, promise] of resolvePromises) {
        const match = uid.match(/^(.*):f(\d+)$/);
        const frame2 = parseInt(match[2]);
        if (frames.includes(frame2) === false) {
          frames.push(frame2);
        }
        if (framesDuration[frame2] === void 0) framesDuration[frame2] = 0;
        const duration = await promise;
        this.timestamps.set(uid, duration);
        framesDuration[frame2] += duration;
      }
      const totalDuration = framesDuration[frames[frames.length - 1]];
      this.lastValue = totalDuration;
      this.frames = frames;
      this.currentQueryIndex = 0;
      this.queryOffsets.clear();
      this.queryStates.clear();
      this.activeQuery = null;
      return totalDuration;
    } catch (e3) {
      error("Error resolving queries:", e3);
      return this.lastValue;
    } finally {
      this.pendingResolve = false;
    }
  }
  /**
   * Resolves a single query, checking for completion and disjoint operation.
   *
   * @async
   * @param {WebGLQuery} query - The query object to resolve.
   * @returns {Promise<number>} The elapsed time in milliseconds.
   */
  async resolveQuery(query) {
    return new Promise((resolve) => {
      if (this.isDisposed) {
        resolve(this.lastValue);
        return;
      }
      let timeoutId;
      let isResolved = false;
      const cleanup = () => {
        if (timeoutId) {
          clearTimeout(timeoutId);
          timeoutId = null;
        }
      };
      const finalizeResolution = (value) => {
        if (!isResolved) {
          isResolved = true;
          cleanup();
          resolve(value);
        }
      };
      const checkQuery = () => {
        if (this.isDisposed) {
          finalizeResolution(this.lastValue);
          return;
        }
        try {
          const disjoint2 = this.gl.getParameter(this.ext.GPU_DISJOINT_EXT);
          if (disjoint2) {
            finalizeResolution(this.lastValue);
            return;
          }
          const available = this.gl.getQueryParameter(query, this.gl.QUERY_RESULT_AVAILABLE);
          if (!available) {
            timeoutId = setTimeout(checkQuery, 1);
            return;
          }
          const elapsed = this.gl.getQueryParameter(query, this.gl.QUERY_RESULT);
          resolve(Number(elapsed) / 1e6);
        } catch (e3) {
          error("Error checking query:", e3);
          resolve(this.lastValue);
        }
      };
      checkQuery();
    });
  }
  /**
   * Releases all resources held by this query pool.
   * This includes deleting all query objects and clearing internal state.
   */
  dispose() {
    if (this.isDisposed) {
      return;
    }
    this.isDisposed = true;
    if (!this.trackTimestamp) return;
    for (const query of this.queries) {
      this.gl.deleteQuery(query);
    }
    this.queries = [];
    this.queryStates.clear();
    this.queryOffsets.clear();
    this.lastValue = 0;
    this.activeQuery = null;
  }
};
var WebGLBackend = class extends Backend {
  /**
   * WebGLBackend options.
   *
   * @typedef {Object} WebGLBackend~Options
   * @property {boolean} [logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.
   * @property {boolean} [alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.
   * @property {boolean} [depth=true] - Whether the default framebuffer should have a depth buffer or not.
   * @property {boolean} [stencil=false] - Whether the default framebuffer should have a stencil buffer or not.
   * @property {boolean} [antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.
   * @property {number} [samples=0] - When `antialias` is `true`, `4` samples are used by default. Set this parameter to any other integer value than 0 to overwrite the default.
   * @property {boolean} [forceWebGL=false] - If set to `true`, the renderer uses a WebGL 2 backend no matter if WebGPU is supported or not.
   * @property {WebGL2RenderingContext} [context=undefined] - A WebGL 2 rendering context.
   */
  /**
   * Constructs a new WebGPU backend.
   *
   * @param {WebGLBackend~Options} [parameters] - The configuration parameter.
   */
  constructor(parameters = {}) {
    super(parameters);
    this.isWebGLBackend = true;
    this.attributeUtils = null;
    this.extensions = null;
    this.capabilities = null;
    this.textureUtils = null;
    this.bufferRenderer = null;
    this.gl = null;
    this.state = null;
    this.utils = null;
    this.vaoCache = {};
    this.transformFeedbackCache = {};
    this.discard = false;
    this.disjoint = null;
    this.parallel = null;
    this._currentContext = null;
    this._knownBindings = /* @__PURE__ */ new WeakSet();
    this._supportsInvalidateFramebuffer = typeof navigator === "undefined" ? false : /OculusBrowser/g.test(navigator.userAgent);
    this._xrFramebuffer = null;
  }
  /**
   * Initializes the backend so it is ready for usage.
   *
   * @param {Renderer} renderer - The renderer.
   */
  init(renderer3) {
    super.init(renderer3);
    const parameters = this.parameters;
    const contextAttributes = {
      antialias: renderer3.currentSamples > 0,
      alpha: true,
      // always true for performance reasons
      depth: renderer3.depth,
      stencil: renderer3.stencil
    };
    const glContext = parameters.context !== void 0 ? parameters.context : renderer3.domElement.getContext("webgl2", contextAttributes);
    function onContextLost(event) {
      event.preventDefault();
      const contextLossInfo = {
        api: "WebGL",
        message: event.statusMessage || "Unknown reason",
        reason: null,
        originalEvent: event
      };
      renderer3.onDeviceLost(contextLossInfo);
    }
    this._onContextLost = onContextLost;
    renderer3.domElement.addEventListener("webglcontextlost", onContextLost, false);
    this.gl = glContext;
    this.extensions = new WebGLExtensions(this);
    this.capabilities = new WebGLCapabilities(this);
    this.attributeUtils = new WebGLAttributeUtils(this);
    this.textureUtils = new WebGLTextureUtils(this);
    this.bufferRenderer = new WebGLBufferRenderer(this);
    this.state = new WebGLState(this);
    this.utils = new WebGLUtils(this);
    this.extensions.get("EXT_color_buffer_float");
    this.extensions.get("WEBGL_clip_cull_distance");
    this.extensions.get("OES_texture_float_linear");
    this.extensions.get("EXT_color_buffer_half_float");
    this.extensions.get("WEBGL_multisampled_render_to_texture");
    this.extensions.get("WEBGL_render_shared_exponent");
    this.extensions.get("WEBGL_multi_draw");
    this.extensions.get("OVR_multiview2");
    this.disjoint = this.extensions.get("EXT_disjoint_timer_query_webgl2");
    this.parallel = this.extensions.get("KHR_parallel_shader_compile");
    this.drawBuffersIndexedExt = this.extensions.get("OES_draw_buffers_indexed");
  }
  /**
   * The coordinate system of the backend.
   *
   * @type {number}
   * @readonly
   */
  get coordinateSystem() {
    return WebGLCoordinateSystem;
  }
  /**
   * This method performs a readback operation by moving buffer data from
   * a storage buffer attribute from the GPU to the CPU.
   *
   * @async
   * @param {StorageBufferAttribute} attribute - The storage buffer attribute.
   * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.
   */
  async getArrayBufferAsync(attribute2) {
    return await this.attributeUtils.getArrayBufferAsync(attribute2);
  }
  /**
   * Ensures the backend is XR compatible.
   *
   * @async
   * @return {Promise} A Promise that resolve when the renderer is XR compatible.
   */
  async makeXRCompatible() {
    const attributes = this.gl.getContextAttributes();
    if (attributes.xrCompatible !== true) {
      await this.gl.makeXRCompatible();
    }
  }
  /**
   * Sets the XR rendering destination.
   *
   * @param {WebGLFramebuffer} xrFramebuffer - The XR framebuffer.
   */
  setXRTarget(xrFramebuffer) {
    this._xrFramebuffer = xrFramebuffer;
  }
  /**
   * Configures the given XR render target with external textures.
   *
   * This method is only relevant when using the WebXR Layers API.
   *
   * @param {XRRenderTarget} renderTarget - The XR render target.
   * @param {WebGLTexture} colorTexture - A native color texture.
   * @param {?WebGLTexture} [depthTexture=null] - A native depth texture.
   */
  setXRRenderTargetTextures(renderTarget, colorTexture, depthTexture = null) {
    const gl = this.gl;
    this.set(renderTarget.texture, { textureGPU: colorTexture, glInternalFormat: gl.RGBA8 });
    if (depthTexture !== null) {
      const glInternalFormat = renderTarget.stencilBuffer ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;
      this.set(renderTarget.depthTexture, { textureGPU: depthTexture, glInternalFormat });
      if (this.extensions.has("WEBGL_multisampled_render_to_texture") === true && renderTarget._autoAllocateDepthBuffer === true && renderTarget.multiview === false) {
        warn("WebGLBackend: Render-to-texture extension was disabled because an external texture was provided");
      }
      renderTarget._autoAllocateDepthBuffer = false;
    }
  }
  /**
   * Inits a time stamp query for the given render context.
   *
   * @param {string} type - The type of the timestamp query.
   * @param {string} uid - A unique identifier for the timestamp query.
   */
  initTimestampQuery(type, uid) {
    if (!this.disjoint || !this.trackTimestamp) return;
    if (!this.timestampQueryPool[type]) {
      this.timestampQueryPool[type] = new WebGLTimestampQueryPool(this.gl, type, 2048);
    }
    const timestampQueryPool = this.timestampQueryPool[type];
    const baseOffset = timestampQueryPool.allocateQueriesForContext(uid);
    if (baseOffset !== null) {
      timestampQueryPool.beginQuery(uid);
    }
  }
  // timestamp utils
  /**
   * Prepares the timestamp buffer.
   *
   * @param {string} type - The type of the timestamp query.
   * @param {string} uid - A unique identifier for the timestamp query.
   */
  prepareTimestampBuffer(type, uid) {
    if (!this.disjoint || !this.trackTimestamp) return;
    const timestampQueryPool = this.timestampQueryPool[type];
    timestampQueryPool.endQuery(uid);
  }
  /**
   * Returns the backend's rendering context.
   *
   * @return {WebGL2RenderingContext} The rendering context.
   */
  getContext() {
    return this.gl;
  }
  /**
   * This method is executed at the beginning of a render call and prepares
   * the WebGL state for upcoming render calls
   *
   * @param {RenderContext} renderContext - The render context.
   */
  beginRender(renderContext) {
    const { state } = this;
    const renderContextData = this.get(renderContext);
    if (renderContext.viewport) {
      this.updateViewport(renderContext);
    } else {
      const { width, height } = this.getDrawingBufferSize();
      state.viewport(0, 0, width, height);
    }
    if (renderContext.scissor) {
      const { x: x3, y: y3, width, height } = renderContext.scissorValue;
      state.scissor(x3, renderContext.height - height - y3, width, height);
    }
    this.initTimestampQuery(TimestampQuery.RENDER, this.getTimestampUID(renderContext));
    renderContextData.previousContext = this._currentContext;
    this._currentContext = renderContext;
    this._setFramebuffer(renderContext);
    this.clear(renderContext.clearColor, renderContext.clearDepth, renderContext.clearStencil, renderContext, false);
    const occlusionQueryCount = renderContext.occlusionQueryCount;
    if (occlusionQueryCount > 0) {
      renderContextData.currentOcclusionQueries = renderContextData.occlusionQueries;
      renderContextData.currentOcclusionQueryObjects = renderContextData.occlusionQueryObjects;
      renderContextData.lastOcclusionObject = null;
      renderContextData.occlusionQueries = new Array(occlusionQueryCount);
      renderContextData.occlusionQueryObjects = new Array(occlusionQueryCount);
      renderContextData.occlusionQueryIndex = 0;
    }
  }
  /**
   * This method is executed at the end of a render call and finalizes work
   * after draw calls.
   *
   * @param {RenderContext} renderContext - The render context.
   */
  finishRender(renderContext) {
    const { gl, state } = this;
    const renderContextData = this.get(renderContext);
    const previousContext = renderContextData.previousContext;
    state.resetVertexState();
    const occlusionQueryCount = renderContext.occlusionQueryCount;
    if (occlusionQueryCount > 0) {
      if (occlusionQueryCount > renderContextData.occlusionQueryIndex) {
        gl.endQuery(gl.ANY_SAMPLES_PASSED);
      }
      this.resolveOccludedAsync(renderContext);
    }
    const textures = renderContext.textures;
    if (textures !== null) {
      for (let i2 = 0; i2 < textures.length; i2++) {
        const texture2 = textures[i2];
        if (texture2.generateMipmaps) {
          this.generateMipmaps(texture2);
        }
      }
    }
    this._currentContext = previousContext;
    this._resolveRenderTarget(renderContext);
    if (previousContext !== null) {
      this._setFramebuffer(previousContext);
      if (previousContext.viewport) {
        this.updateViewport(previousContext);
      } else {
        const { width, height } = this.getDrawingBufferSize();
        state.viewport(0, 0, width, height);
      }
    }
    this.prepareTimestampBuffer(TimestampQuery.RENDER, this.getTimestampUID(renderContext));
  }
  /**
   * This method processes the result of occlusion queries and writes it
   * into render context data.
   *
   * @async
   * @param {RenderContext} renderContext - The render context.
   */
  resolveOccludedAsync(renderContext) {
    const renderContextData = this.get(renderContext);
    const { currentOcclusionQueries, currentOcclusionQueryObjects } = renderContextData;
    if (currentOcclusionQueries && currentOcclusionQueryObjects) {
      const occluded = /* @__PURE__ */ new WeakSet();
      const { gl } = this;
      renderContextData.currentOcclusionQueryObjects = null;
      renderContextData.currentOcclusionQueries = null;
      const check = () => {
        let completed = 0;
        for (let i2 = 0; i2 < currentOcclusionQueries.length; i2++) {
          const query = currentOcclusionQueries[i2];
          if (query === null) continue;
          if (gl.getQueryParameter(query, gl.QUERY_RESULT_AVAILABLE)) {
            if (gl.getQueryParameter(query, gl.QUERY_RESULT) === 0) occluded.add(currentOcclusionQueryObjects[i2]);
            currentOcclusionQueries[i2] = null;
            gl.deleteQuery(query);
            completed++;
          }
        }
        if (completed < currentOcclusionQueries.length) {
          requestAnimationFrame(check);
        } else {
          renderContextData.occluded = occluded;
        }
      };
      check();
    }
  }
  /**
   * Returns `true` if the given 3D object is fully occluded by other
   * 3D objects in the scene.
   *
   * @param {RenderContext} renderContext - The render context.
   * @param {Object3D} object - The 3D object to test.
   * @return {boolean} Whether the 3D object is fully occluded or not.
   */
  isOccluded(renderContext, object) {
    const renderContextData = this.get(renderContext);
    return renderContextData.occluded && renderContextData.occluded.has(object);
  }
  /**
   * Updates the viewport with the values from the given render context.
   *
   * @param {RenderContext} renderContext - The render context.
   */
  updateViewport(renderContext) {
    const { state } = this;
    const { x: x3, y: y3, width, height } = renderContext.viewportValue;
    state.viewport(x3, renderContext.height - height - y3, width, height);
  }
  /**
   * Defines the scissor test.
   *
   * @param {boolean} boolean - Whether the scissor test should be enabled or not.
   */
  setScissorTest(boolean) {
    const state = this.state;
    state.setScissorTest(boolean);
  }
  /**
   * Returns the clear color and alpha into a single
   * color object.
   *
   * @return {Color4} The clear color.
   */
  getClearColor() {
    const clearColor = super.getClearColor();
    clearColor.r *= clearColor.a;
    clearColor.g *= clearColor.a;
    clearColor.b *= clearColor.a;
    return clearColor;
  }
  /**
   * Performs a clear operation.
   *
   * @param {boolean} color - Whether the color buffer should be cleared or not.
   * @param {boolean} depth - Whether the depth buffer should be cleared or not.
   * @param {boolean} stencil - Whether the stencil buffer should be cleared or not.
   * @param {?Object} [descriptor=null] - The render context of the current set render target.
   * @param {boolean} [setFrameBuffer=true] - Controls whether the intermediate framebuffer should be set or not.
   * @param {boolean} [resolveRenderTarget=true] - Controls whether an active render target should be resolved
   * or not. Only relevant for explicit clears.
   */
  clear(color3, depth2, stencil, descriptor = null, setFrameBuffer = true, resolveRenderTarget = true) {
    const { gl, renderer: renderer3 } = this;
    if (descriptor === null) {
      const clearColor = this.getClearColor();
      descriptor = {
        textures: null,
        clearColorValue: clearColor
      };
    }
    let clear = 0;
    if (color3) clear |= gl.COLOR_BUFFER_BIT;
    if (depth2) clear |= gl.DEPTH_BUFFER_BIT;
    if (stencil) clear |= gl.STENCIL_BUFFER_BIT;
    if (clear !== 0) {
      let clearColor;
      if (descriptor.clearColorValue) {
        clearColor = descriptor.clearColorValue;
      } else {
        clearColor = this.getClearColor();
      }
      const clearDepth = renderer3.getClearDepth();
      const clearStencil = renderer3.getClearStencil();
      if (depth2) this.state.setDepthMask(true);
      if (descriptor.textures === null) {
        gl.clearColor(clearColor.r, clearColor.g, clearColor.b, clearColor.a);
        gl.clear(clear);
      } else {
        if (setFrameBuffer) this._setFramebuffer(descriptor);
        if (color3) {
          for (let i2 = 0; i2 < descriptor.textures.length; i2++) {
            if (i2 === 0) {
              gl.clearBufferfv(gl.COLOR, i2, [clearColor.r, clearColor.g, clearColor.b, clearColor.a]);
            } else {
              gl.clearBufferfv(gl.COLOR, i2, [0, 0, 0, 1]);
            }
          }
        }
        if (depth2 && stencil) {
          gl.clearBufferfi(gl.DEPTH_STENCIL, 0, clearDepth, clearStencil);
        } else if (depth2) {
          gl.clearBufferfv(gl.DEPTH, 0, [clearDepth]);
        } else if (stencil) {
          gl.clearBufferiv(gl.STENCIL, 0, [clearStencil]);
        }
        if (setFrameBuffer && resolveRenderTarget) this._resolveRenderTarget(descriptor);
      }
    }
  }
  /**
   * This method is executed at the beginning of a compute call and
   * prepares the state for upcoming compute tasks.
   *
   * @param {Node|Array<Node>} computeGroup - The compute node(s).
   */
  beginCompute(computeGroup) {
    const { state, gl } = this;
    state.bindFramebuffer(gl.FRAMEBUFFER, null);
    this.initTimestampQuery(TimestampQuery.COMPUTE, this.getTimestampUID(computeGroup));
  }
  /**
   * Executes a compute command for the given compute node.
   *
   * @param {Node|Array<Node>} computeGroup - The group of compute nodes of a compute call. Can be a single compute node.
   * @param {Node} computeNode - The compute node.
   * @param {Array<BindGroup>} bindings - The bindings.
   * @param {ComputePipeline} pipeline - The compute pipeline.
   * @param {?number} [count=null] - The count of compute invocations. If `null`, the count is determined by the compute node.
   */
  compute(computeGroup, computeNode, bindings, pipeline, count2 = null) {
    const { state, gl } = this;
    if (this.discard === false) {
      state.enable(gl.RASTERIZER_DISCARD);
      this.discard = true;
    }
    const { programGPU, transformBuffers, attributes } = this.get(pipeline);
    const vaoKey = this._getVaoKey(attributes);
    const vaoGPU = this.vaoCache[vaoKey];
    if (vaoGPU === void 0) {
      this.vaoCache[vaoKey] = this._createVao(attributes);
    } else {
      state.setVertexState(vaoGPU);
    }
    state.useProgram(programGPU);
    this._bindUniforms(bindings);
    const transformFeedbackGPU = this._getTransformFeedback(transformBuffers);
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, transformFeedbackGPU);
    gl.beginTransformFeedback(gl.POINTS);
    count2 = count2 !== null ? count2 : computeNode.count;
    if (Array.isArray(count2)) {
      warnOnce("WebGLBackend.compute(): The count parameter must be a single number, not an array.");
      count2 = count2[0];
    } else if (count2 && typeof count2 === "object" && count2.isIndirectStorageBufferAttribute) {
      warnOnce("WebGLBackend.compute(): The count parameter must be a single number, not IndirectStorageBufferAttribute");
      count2 = computeNode.count;
    }
    if (attributes[0].isStorageInstancedBufferAttribute) {
      gl.drawArraysInstanced(gl.POINTS, 0, 1, count2);
    } else {
      gl.drawArrays(gl.POINTS, 0, count2);
    }
    gl.endTransformFeedback();
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
    for (let i2 = 0; i2 < transformBuffers.length; i2++) {
      const dualAttributeData = transformBuffers[i2];
      if (dualAttributeData.pbo && this.has(dualAttributeData.pbo)) {
        this.textureUtils.copyBufferToTexture(dualAttributeData.transformBuffer, dualAttributeData.pbo);
      }
      dualAttributeData.switchBuffers();
    }
  }
  /**
   * This method is executed at the end of a compute call and
   * finalizes work after compute tasks.
   *
   * @param {Node|Array<Node>} computeGroup - The compute node(s).
   */
  finishCompute(computeGroup) {
    const { state, gl } = this;
    this.discard = false;
    state.disable(gl.RASTERIZER_DISCARD);
    this.prepareTimestampBuffer(TimestampQuery.COMPUTE, this.getTimestampUID(computeGroup));
    if (this._currentContext) {
      this._setFramebuffer(this._currentContext);
    }
  }
  /**
   * Internal to determine if the current render target is a render target array with depth 2D array texture.
   *
   * @param {RenderContext} renderContext - The render context.
   * @return {boolean} Whether the render target is a render target array with depth 2D array texture.
   *
   * @private
   */
  _isRenderCameraDepthArray(renderContext) {
    return renderContext.depthTexture && renderContext.depthTexture.isArrayTexture && renderContext.camera.isArrayCamera;
  }
  /**
   * Executes a draw command for the given render object.
   *
   * @param {RenderObject} renderObject - The render object to draw.
   * @param {Info} info - Holds a series of statistical information about the GPU memory and the rendering process.
   */
  draw(renderObject) {
    const { object, pipeline, material, context: context2, hardwareClippingPlanes } = renderObject;
    const { programGPU } = this.get(pipeline);
    const { gl, state } = this;
    const contextData = this.get(context2);
    const drawParams = renderObject.getDrawParameters();
    if (drawParams === null) return;
    this._bindUniforms(renderObject.getBindings());
    const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
    state.setMaterial(material, frontFaceCW, hardwareClippingPlanes);
    if (context2.textures !== null && context2.textures.length > 1) {
      state.setMRTBlending(context2.textures);
    }
    state.useProgram(programGPU);
    const attributes = renderObject.getAttributes();
    const attributesData = this.get(attributes);
    let vaoGPU = attributesData.vaoGPU;
    if (vaoGPU === void 0) {
      const vaoKey = this._getVaoKey(attributes);
      vaoGPU = this.vaoCache[vaoKey];
      if (vaoGPU === void 0) {
        vaoGPU = this._createVao(attributes);
        this.vaoCache[vaoKey] = vaoGPU;
        attributesData.vaoGPU = vaoGPU;
      }
    }
    const index8 = renderObject.getIndex();
    const indexGPU = index8 !== null ? this.get(index8).bufferGPU : null;
    state.setVertexState(vaoGPU, indexGPU);
    const lastObject = contextData.lastOcclusionObject;
    if (lastObject !== object && lastObject !== void 0) {
      if (lastObject !== null && lastObject.occlusionTest === true) {
        gl.endQuery(gl.ANY_SAMPLES_PASSED);
        contextData.occlusionQueryIndex++;
      }
      if (object.occlusionTest === true) {
        const query = gl.createQuery();
        gl.beginQuery(gl.ANY_SAMPLES_PASSED, query);
        contextData.occlusionQueries[contextData.occlusionQueryIndex] = query;
        contextData.occlusionQueryObjects[contextData.occlusionQueryIndex] = object;
      }
      contextData.lastOcclusionObject = object;
    }
    const renderer3 = this.bufferRenderer;
    if (object.isPoints) renderer3.mode = gl.POINTS;
    else if (object.isLineSegments) renderer3.mode = gl.LINES;
    else if (object.isLine) renderer3.mode = gl.LINE_STRIP;
    else if (object.isLineLoop) renderer3.mode = gl.LINE_LOOP;
    else {
      if (material.wireframe === true) {
        state.setLineWidth(material.wireframeLinewidth * this.renderer.getPixelRatio());
        renderer3.mode = gl.LINES;
      } else {
        renderer3.mode = gl.TRIANGLES;
      }
    }
    const { vertexCount, instanceCount } = drawParams;
    let { firstVertex } = drawParams;
    renderer3.object = object;
    if (index8 !== null) {
      firstVertex *= index8.array.BYTES_PER_ELEMENT;
      const indexData = this.get(index8);
      renderer3.index = index8.count;
      renderer3.type = indexData.type;
    } else {
      renderer3.index = 0;
    }
    const draw = () => {
      if (object.isBatchedMesh) {
        if (object._multiDrawInstances !== null) {
          warnOnce("WebGLBackend: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection.");
          renderer3.renderMultiDrawInstances(object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount, object._multiDrawInstances);
        } else if (!this.hasFeature("WEBGL_multi_draw")) {
          warnOnce("WebGLBackend: WEBGL_multi_draw not supported.");
        } else {
          renderer3.renderMultiDraw(object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount);
        }
      } else if (instanceCount > 1) {
        renderer3.renderInstances(firstVertex, vertexCount, instanceCount);
      } else {
        renderer3.render(firstVertex, vertexCount);
      }
    };
    if (renderObject.camera.isArrayCamera === true && renderObject.camera.cameras.length > 0 && renderObject.camera.isMultiViewCamera === false) {
      const cameraData = this.get(renderObject.camera);
      const cameras = renderObject.camera.cameras;
      const cameraIndex2 = renderObject.getBindingGroup("cameraIndex").bindings[0];
      if (cameraData.indexesGPU === void 0 || cameraData.indexesGPU.length !== cameras.length) {
        const data = new Uint32Array([0, 0, 0, 0]);
        const indexesGPU = [];
        for (let i2 = 0, len = cameras.length; i2 < len; i2++) {
          const bufferGPU = gl.createBuffer();
          data[0] = i2;
          gl.bindBuffer(gl.UNIFORM_BUFFER, bufferGPU);
          gl.bufferData(gl.UNIFORM_BUFFER, data, gl.STATIC_DRAW);
          indexesGPU.push(bufferGPU);
        }
        cameraData.indexesGPU = indexesGPU;
      }
      const cameraIndexData = this.get(cameraIndex2);
      const pixelRatio = this.renderer.getPixelRatio();
      const renderTarget = this._currentContext.renderTarget;
      const isRenderCameraDepthArray = this._isRenderCameraDepthArray(this._currentContext);
      const prevActiveCubeFace = this._currentContext.activeCubeFace;
      if (isRenderCameraDepthArray) {
        const textureData = this.get(renderTarget.depthTexture);
        if (textureData.clearedRenderId !== this.renderer._nodes.nodeFrame.renderId) {
          textureData.clearedRenderId = this.renderer._nodes.nodeFrame.renderId;
          const { stencilBuffer } = renderTarget;
          for (let i2 = 0, len = cameras.length; i2 < len; i2++) {
            this.renderer._activeCubeFace = i2;
            this._currentContext.activeCubeFace = i2;
            this._setFramebuffer(this._currentContext);
            this.clear(false, true, stencilBuffer, this._currentContext, false, false);
          }
          this.renderer._activeCubeFace = prevActiveCubeFace;
          this._currentContext.activeCubeFace = prevActiveCubeFace;
        }
      }
      for (let i2 = 0, len = cameras.length; i2 < len; i2++) {
        const subCamera = cameras[i2];
        if (object.layers.test(subCamera.layers)) {
          if (isRenderCameraDepthArray) {
            this.renderer._activeCubeFace = i2;
            this._currentContext.activeCubeFace = i2;
            this._setFramebuffer(this._currentContext);
          }
          const vp = subCamera.viewport;
          if (vp !== void 0) {
            const x3 = vp.x * pixelRatio;
            const y3 = vp.y * pixelRatio;
            const width = vp.width * pixelRatio;
            const height = vp.height * pixelRatio;
            state.viewport(
              Math.floor(x3),
              Math.floor(renderObject.context.height - height - y3),
              Math.floor(width),
              Math.floor(height)
            );
          }
          state.bindBufferBase(gl.UNIFORM_BUFFER, cameraIndexData.index, cameraData.indexesGPU[i2]);
          draw();
        }
        this._currentContext.activeCubeFace = prevActiveCubeFace;
        this.renderer._activeCubeFace = prevActiveCubeFace;
      }
    } else {
      draw();
    }
  }
  /**
   * Explain why always null is returned.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {boolean} Whether the render pipeline requires an update or not.
   */
  needsRenderUpdate() {
    return false;
  }
  /**
   * Explain why no cache key is computed.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {string} The cache key.
   */
  getRenderCacheKey() {
    return "";
  }
  // textures
  /**
   * Creates a default texture for the given texture that can be used
   * as a placeholder until the actual texture is ready for usage.
   *
   * @param {Texture} texture - The texture to create a default texture for.
   */
  createDefaultTexture(texture2) {
    this.textureUtils.createDefaultTexture(texture2);
  }
  /**
   * Defines a texture on the GPU for the given texture object.
   *
   * @param {Texture} texture - The texture.
   * @param {Object} [options={}] - Optional configuration parameter.
   */
  createTexture(texture2, options) {
    this.textureUtils.createTexture(texture2, options);
  }
  /**
   * Uploads the updated texture data to the GPU.
   *
   * @param {Texture} texture - The texture.
   * @param {Object} [options={}] - Optional configuration parameter.
   */
  updateTexture(texture2, options) {
    this.textureUtils.updateTexture(texture2, options);
  }
  /**
   * Generates mipmaps for the given texture.
   *
   * @param {Texture} texture - The texture.
   */
  generateMipmaps(texture2) {
    this.textureUtils.generateMipmaps(texture2);
  }
  /**
   * Destroys the GPU data for the given texture object.
   *
   * @param {Texture} texture - The texture.
   * @param {boolean} [isDefaultTexture=false] - Whether the texture uses a default GPU texture or not.
   */
  destroyTexture(texture2, isDefaultTexture = false) {
    this.textureUtils.destroyTexture(texture2, isDefaultTexture);
  }
  /**
   * Returns texture data as a typed array.
   *
   * @async
   * @param {Texture} texture - The texture to copy.
   * @param {number} x - The x coordinate of the copy origin.
   * @param {number} y - The y coordinate of the copy origin.
   * @param {number} width - The width of the copy.
   * @param {number} height - The height of the copy.
   * @param {number} faceIndex - The face index.
   * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.
   */
  async copyTextureToBuffer(texture2, x3, y3, width, height, faceIndex) {
    return this.textureUtils.copyTextureToBuffer(texture2, x3, y3, width, height, faceIndex);
  }
  /**
   * This method does nothing since WebGL 2 has no concept of samplers.
   *
   * @param {Texture} texture - The texture to update the sampler for.
   * @return {string} The current sampler key.
   */
  updateSampler() {
    return "";
  }
  // node builder
  /**
   * Returns a node builder for the given render object.
   *
   * @param {RenderObject} object - The render object.
   * @param {Renderer} renderer - The renderer.
   * @return {GLSLNodeBuilder} The node builder.
   */
  createNodeBuilder(object, renderer3) {
    return new GLSLNodeBuilder(object, renderer3);
  }
  // program
  /**
   * Creates a shader program from the given programmable stage.
   *
   * @param {ProgrammableStage} program - The programmable stage.
   */
  createProgram(program) {
    const gl = this.gl;
    const { stage, code: code2 } = program;
    const shader = stage === "fragment" ? gl.createShader(gl.FRAGMENT_SHADER) : gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(shader, code2);
    gl.compileShader(shader);
    this.set(program, {
      shaderGPU: shader
    });
  }
  /**
   * Destroys the shader program of the given programmable stage.
   *
   * @param {ProgrammableStage} program - The programmable stage.
   */
  destroyProgram(program) {
    this.delete(program);
  }
  /**
   * Creates a render pipeline for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @param {Array<Promise>} promises - An array of compilation promises which are used in `compileAsync()`.
   */
  createRenderPipeline(renderObject, promises) {
    const gl = this.gl;
    const pipeline = renderObject.pipeline;
    const { fragmentProgram, vertexProgram } = pipeline;
    const programGPU = gl.createProgram();
    const fragmentShader = this.get(fragmentProgram).shaderGPU;
    const vertexShader = this.get(vertexProgram).shaderGPU;
    gl.attachShader(programGPU, fragmentShader);
    gl.attachShader(programGPU, vertexShader);
    gl.linkProgram(programGPU);
    this.set(pipeline, {
      programGPU,
      fragmentShader,
      vertexShader
    });
    if (promises !== null && this.parallel) {
      const p3 = new Promise((resolve) => {
        const parallel = this.parallel;
        const checkStatus = () => {
          if (gl.getProgramParameter(programGPU, parallel.COMPLETION_STATUS_KHR)) {
            this._completeCompile(renderObject, pipeline);
            resolve();
          } else {
            requestAnimationFrame(checkStatus);
          }
        };
        checkStatus();
      });
      promises.push(p3);
      return;
    }
    this._completeCompile(renderObject, pipeline);
  }
  /**
   * Formats the source code of error messages.
   *
   * @private
   * @param {string} string - The code.
   * @param {number} errorLine - The error line.
   * @return {string} The formatted code.
   */
  _handleSource(string2, errorLine) {
    const lines = string2.split("\n");
    const lines2 = [];
    const from = Math.max(errorLine - 6, 0);
    const to = Math.min(errorLine + 6, lines.length);
    for (let i2 = from; i2 < to; i2++) {
      const line = i2 + 1;
      lines2.push(`${line === errorLine ? ">" : " "} ${line}: ${lines[i2]}`);
    }
    return lines2.join("\n");
  }
  /**
   * Gets the shader compilation errors from the info log.
   *
   * @private
   * @param {WebGL2RenderingContext} gl - The rendering context.
   * @param {WebGLShader} shader - The WebGL shader object.
   * @param {string} type - The shader type.
   * @return {string} The shader errors.
   */
  _getShaderErrors(gl, shader, type) {
    const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
    const shaderInfoLog = gl.getShaderInfoLog(shader) || "";
    const errors = shaderInfoLog.trim();
    if (status && errors === "") return "";
    const errorMatches = /ERROR: 0:(\d+)/.exec(errors);
    if (errorMatches) {
      const errorLine = parseInt(errorMatches[1]);
      return type.toUpperCase() + "\n\n" + errors + "\n\n" + this._handleSource(gl.getShaderSource(shader), errorLine);
    } else {
      return errors;
    }
  }
  /**
   * Logs shader compilation errors.
   *
   * @private
   * @param {WebGLProgram} programGPU - The WebGL program.
   * @param {WebGLShader} glFragmentShader - The fragment shader as a native WebGL shader object.
   * @param {WebGLShader} glVertexShader - The vertex shader as a native WebGL shader object.
   */
  _logProgramError(programGPU, glFragmentShader, glVertexShader) {
    if (this.renderer.debug.checkShaderErrors) {
      const gl = this.gl;
      const programInfoLog = gl.getProgramInfoLog(programGPU) || "";
      const programLog = programInfoLog.trim();
      if (gl.getProgramParameter(programGPU, gl.LINK_STATUS) === false) {
        if (typeof this.renderer.debug.onShaderError === "function") {
          this.renderer.debug.onShaderError(gl, programGPU, glVertexShader, glFragmentShader);
        } else {
          const vertexErrors = this._getShaderErrors(gl, glVertexShader, "vertex");
          const fragmentErrors = this._getShaderErrors(gl, glFragmentShader, "fragment");
          error(
            "THREE.WebGLProgram: Shader Error " + gl.getError() + " - VALIDATE_STATUS " + gl.getProgramParameter(programGPU, gl.VALIDATE_STATUS) + "\n\nProgram Info Log: " + programLog + "\n" + vertexErrors + "\n" + fragmentErrors
          );
        }
      } else if (programLog !== "") {
        warn("WebGLProgram: Program Info Log:", programLog);
      }
    }
  }
  /**
   * Completes the shader program setup for the given render object.
   *
   * @private
   * @param {RenderObject} renderObject - The render object.
   * @param {RenderPipeline} pipeline - The render pipeline.
   */
  _completeCompile(renderObject, pipeline) {
    const { state, gl } = this;
    const pipelineData = this.get(pipeline);
    const { programGPU, fragmentShader, vertexShader } = pipelineData;
    if (gl.getProgramParameter(programGPU, gl.LINK_STATUS) === false) {
      this._logProgramError(programGPU, fragmentShader, vertexShader);
    }
    state.useProgram(programGPU);
    const bindings = renderObject.getBindings();
    this._setupBindings(bindings, programGPU);
    this.set(pipeline, {
      programGPU
    });
  }
  /**
   * Creates a compute pipeline for the given compute node.
   *
   * @param {ComputePipeline} computePipeline - The compute pipeline.
   * @param {Array<BindGroup>} bindings - The bindings.
   */
  createComputePipeline(computePipeline, bindings) {
    const { state, gl } = this;
    const fragmentProgram = {
      stage: "fragment",
      code: "#version 300 es\nprecision highp float;\nvoid main() {}"
    };
    this.createProgram(fragmentProgram);
    const { computeProgram } = computePipeline;
    const programGPU = gl.createProgram();
    const fragmentShader = this.get(fragmentProgram).shaderGPU;
    const vertexShader = this.get(computeProgram).shaderGPU;
    const transforms = computeProgram.transforms;
    const transformVaryingNames = [];
    const transformAttributeNodes = [];
    for (let i2 = 0; i2 < transforms.length; i2++) {
      const transform3 = transforms[i2];
      transformVaryingNames.push(transform3.varyingName);
      transformAttributeNodes.push(transform3.attributeNode);
    }
    gl.attachShader(programGPU, fragmentShader);
    gl.attachShader(programGPU, vertexShader);
    gl.transformFeedbackVaryings(
      programGPU,
      transformVaryingNames,
      gl.SEPARATE_ATTRIBS
    );
    gl.linkProgram(programGPU);
    if (gl.getProgramParameter(programGPU, gl.LINK_STATUS) === false) {
      this._logProgramError(programGPU, fragmentShader, vertexShader);
    }
    state.useProgram(programGPU);
    this._setupBindings(bindings, programGPU);
    const attributeNodes = computeProgram.attributes;
    const attributes = [];
    const transformBuffers = [];
    for (let i2 = 0; i2 < attributeNodes.length; i2++) {
      const attribute2 = attributeNodes[i2].node.attribute;
      attributes.push(attribute2);
      if (!this.has(attribute2)) this.attributeUtils.createAttribute(attribute2, gl.ARRAY_BUFFER);
    }
    for (let i2 = 0; i2 < transformAttributeNodes.length; i2++) {
      const attribute2 = transformAttributeNodes[i2].attribute;
      if (!this.has(attribute2)) this.attributeUtils.createAttribute(attribute2, gl.ARRAY_BUFFER);
      const attributeData = this.get(attribute2);
      transformBuffers.push(attributeData);
    }
    this.set(computePipeline, {
      programGPU,
      transformBuffers,
      attributes
    });
  }
  /**
   * Creates bindings from the given bind group definition.
   *
   * @param {BindGroup} bindGroup - The bind group.
   * @param {Array<BindGroup>} bindings - Array of bind groups.
   * @param {number} cacheIndex - The cache index.
   * @param {number} version - The version.
   */
  createBindings(bindGroup, bindings) {
    if (this._knownBindings.has(bindings) === false) {
      this._knownBindings.add(bindings);
      let uniformBuffers = 0;
      let textures = 0;
      for (const bindGroup2 of bindings) {
        this.set(bindGroup2, {
          textures,
          uniformBuffers
        });
        for (const binding of bindGroup2.bindings) {
          if (binding.isUniformBuffer) uniformBuffers++;
          if (binding.isSampledTexture) textures++;
        }
      }
    }
    this.updateBindings(bindGroup, bindings);
  }
  /**
   * Updates the given bind group definition.
   *
   * @param {BindGroup} bindGroup - The bind group.
   * @param {Array<BindGroup>} bindings - Array of bind groups.
   * @param {number} cacheIndex - The cache index.
   * @param {number} version - The version.
   */
  updateBindings(bindGroup) {
    const { gl } = this;
    const bindGroupData = this.get(bindGroup);
    let i2 = bindGroupData.uniformBuffers;
    let t5 = bindGroupData.textures;
    for (const binding of bindGroup.bindings) {
      const map6 = this.get(binding);
      if (binding.isUniformsGroup || binding.isUniformBuffer) {
        const array4 = binding.buffer;
        let { bufferGPU } = this.get(array4);
        if (bufferGPU === void 0) {
          bufferGPU = gl.createBuffer();
          gl.bindBuffer(gl.UNIFORM_BUFFER, bufferGPU);
          gl.bufferData(gl.UNIFORM_BUFFER, array4.byteLength, gl.DYNAMIC_DRAW);
          this.set(array4, { bufferGPU });
        } else {
          gl.bindBuffer(gl.UNIFORM_BUFFER, bufferGPU);
        }
        const updateRanges = binding.updateRanges;
        gl.bindBuffer(gl.UNIFORM_BUFFER, bufferGPU);
        if (updateRanges.length === 0) {
          gl.bufferData(gl.UNIFORM_BUFFER, array4, gl.DYNAMIC_DRAW);
        } else {
          const isTyped = isTypedArray(array4);
          const byteOffsetFactor = isTyped ? 1 : array4.BYTES_PER_ELEMENT;
          for (let i3 = 0, l2 = updateRanges.length; i3 < l2; i3++) {
            const range4 = updateRanges[i3];
            const dataOffset = range4.start * byteOffsetFactor;
            const size2 = range4.count * byteOffsetFactor;
            const bufferOffset = dataOffset * (isTyped ? array4.BYTES_PER_ELEMENT : 1);
            gl.bufferSubData(gl.UNIFORM_BUFFER, bufferOffset, array4, dataOffset, size2);
          }
        }
        map6.index = i2++;
        map6.bufferGPU = bufferGPU;
        this.set(binding, map6);
      } else if (binding.isSampledTexture) {
        const { textureGPU, glTextureType } = this.get(binding.texture);
        map6.index = t5++;
        map6.textureGPU = textureGPU;
        map6.glTextureType = glTextureType;
        this.set(binding, map6);
      }
    }
  }
  /**
   * Updates a buffer binding.
   *
   *  @param {Buffer} binding - The buffer binding to update.
   */
  updateBinding(binding) {
    const gl = this.gl;
    if (binding.isUniformsGroup || binding.isUniformBuffer) {
      const bindingData = this.get(binding);
      const bufferGPU = bindingData.bufferGPU;
      const array4 = binding.buffer;
      const updateRanges = binding.updateRanges;
      gl.bindBuffer(gl.UNIFORM_BUFFER, bufferGPU);
      if (updateRanges.length === 0) {
        gl.bufferData(gl.UNIFORM_BUFFER, array4, gl.DYNAMIC_DRAW);
      } else {
        const isTyped = isTypedArray(array4);
        const byteOffsetFactor = isTyped ? 1 : array4.BYTES_PER_ELEMENT;
        for (let i2 = 0, l2 = updateRanges.length; i2 < l2; i2++) {
          const range4 = updateRanges[i2];
          const dataOffset = range4.start * byteOffsetFactor;
          const size2 = range4.count * byteOffsetFactor;
          const bufferOffset = dataOffset * (isTyped ? array4.BYTES_PER_ELEMENT : 1);
          gl.bufferSubData(gl.UNIFORM_BUFFER, bufferOffset, array4, dataOffset, size2);
        }
      }
    }
  }
  // attributes
  /**
   * Creates the GPU buffer of an indexed shader attribute.
   *
   * @param {BufferAttribute} attribute - The indexed buffer attribute.
   */
  createIndexAttribute(attribute2) {
    const gl = this.gl;
    this.attributeUtils.createAttribute(attribute2, gl.ELEMENT_ARRAY_BUFFER);
  }
  /**
   * Creates the GPU buffer of a shader attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  createAttribute(attribute2) {
    if (this.has(attribute2)) return;
    const gl = this.gl;
    this.attributeUtils.createAttribute(attribute2, gl.ARRAY_BUFFER);
  }
  /**
   * Creates the GPU buffer of a storage attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  createStorageAttribute(attribute2) {
    if (this.has(attribute2)) return;
    const gl = this.gl;
    this.attributeUtils.createAttribute(attribute2, gl.ARRAY_BUFFER);
  }
  /**
   * Updates the GPU buffer of a shader attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute to update.
   */
  updateAttribute(attribute2) {
    this.attributeUtils.updateAttribute(attribute2);
  }
  /**
   * Destroys the GPU buffer of a shader attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute to destroy.
   */
  destroyAttribute(attribute2) {
    this.attributeUtils.destroyAttribute(attribute2);
  }
  /**
   * Checks if the given feature is supported  by the backend.
   *
   * @param {string} name - The feature's name.
   * @return {boolean} Whether the feature is supported or not.
   */
  hasFeature(name) {
    const keysMatching = Object.keys(GLFeatureName).filter((key) => GLFeatureName[key] === name);
    const extensions = this.extensions;
    for (let i2 = 0; i2 < keysMatching.length; i2++) {
      if (extensions.has(keysMatching[i2])) return true;
    }
    return false;
  }
  /**
   * Returns the maximum anisotropy texture filtering value.
   *
   * @return {number} The maximum anisotropy texture filtering value.
   */
  getMaxAnisotropy() {
    return this.capabilities.getMaxAnisotropy();
  }
  /**
   * Copies data of the given source texture to the given destination texture.
   *
   * @param {Texture} srcTexture - The source texture.
   * @param {Texture} dstTexture - The destination texture.
   * @param {?(Box3|Box2)} [srcRegion=null] - The region of the source texture to copy.
   * @param {?(Vector2|Vector3)} [dstPosition=null] - The destination position of the copy.
   * @param {number} [srcLevel=0] - The source mip level to copy from.
   * @param {number} [dstLevel=0] - The destination mip level to copy to.
   */
  copyTextureToTexture(srcTexture, dstTexture, srcRegion = null, dstPosition = null, srcLevel = 0, dstLevel = 0) {
    this.textureUtils.copyTextureToTexture(srcTexture, dstTexture, srcRegion, dstPosition, srcLevel, dstLevel);
  }
  /**
   * Copies the current bound framebuffer to the given texture.
   *
   * @param {Texture} texture - The destination texture.
   * @param {RenderContext} renderContext - The render context.
   * @param {Vector4} rectangle - A four dimensional vector defining the origin and dimension of the copy.
   */
  copyFramebufferToTexture(texture2, renderContext, rectangle) {
    this.textureUtils.copyFramebufferToTexture(texture2, renderContext, rectangle);
  }
  /**
   * Configures the active framebuffer from the given render context.
   *
   * @private
   * @param {RenderContext} descriptor - The render context.
   */
  _setFramebuffer(descriptor) {
    const { gl, state } = this;
    let currentFrameBuffer = null;
    if (descriptor.textures !== null) {
      const renderTarget = descriptor.renderTarget;
      const renderTargetContextData = this.get(renderTarget);
      const { samples, depthBuffer, stencilBuffer } = renderTarget;
      const isCube = renderTarget.isWebGLCubeRenderTarget === true;
      const isRenderTarget3D = renderTarget.isRenderTarget3D === true;
      const isRenderTargetArray = renderTarget.depth > 1;
      const isXRRenderTarget = renderTarget.isXRRenderTarget === true;
      const _hasExternalTextures = isXRRenderTarget === true && renderTarget._hasExternalTextures === true;
      let msaaFb = renderTargetContextData.msaaFrameBuffer;
      let depthRenderbuffer = renderTargetContextData.depthRenderbuffer;
      const multisampledRTTExt = this.extensions.get("WEBGL_multisampled_render_to_texture");
      const multiviewExt = this.extensions.get("OVR_multiview2");
      const useMultisampledRTT = this._useMultisampledExtension(renderTarget);
      const cacheKey = getCacheKey(descriptor);
      let fb;
      if (isCube) {
        renderTargetContextData.cubeFramebuffers || (renderTargetContextData.cubeFramebuffers = {});
        fb = renderTargetContextData.cubeFramebuffers[cacheKey];
      } else if (isXRRenderTarget && _hasExternalTextures === false) {
        fb = this._xrFramebuffer;
      } else {
        renderTargetContextData.framebuffers || (renderTargetContextData.framebuffers = {});
        fb = renderTargetContextData.framebuffers[cacheKey];
      }
      if (fb === void 0) {
        fb = gl.createFramebuffer();
        state.bindFramebuffer(gl.FRAMEBUFFER, fb);
        const textures = descriptor.textures;
        const depthInvalidationArray = [];
        if (isCube) {
          renderTargetContextData.cubeFramebuffers[cacheKey] = fb;
          const { textureGPU } = this.get(textures[0]);
          const cubeFace = this.renderer._activeCubeFace;
          const mipLevel = this.renderer._activeMipmapLevel;
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + cubeFace, textureGPU, mipLevel);
        } else {
          renderTargetContextData.framebuffers[cacheKey] = fb;
          for (let i2 = 0; i2 < textures.length; i2++) {
            const texture2 = textures[i2];
            const textureData = this.get(texture2);
            textureData.renderTarget = descriptor.renderTarget;
            textureData.cacheKey = cacheKey;
            const attachment = gl.COLOR_ATTACHMENT0 + i2;
            if (renderTarget.multiview) {
              multiviewExt.framebufferTextureMultisampleMultiviewOVR(gl.FRAMEBUFFER, attachment, textureData.textureGPU, 0, samples, 0, 2);
            } else if (isRenderTarget3D || isRenderTargetArray) {
              const layer = this.renderer._activeCubeFace;
              const mipLevel = this.renderer._activeMipmapLevel;
              gl.framebufferTextureLayer(gl.FRAMEBUFFER, attachment, textureData.textureGPU, mipLevel, layer);
            } else {
              if (useMultisampledRTT) {
                multisampledRTTExt.framebufferTexture2DMultisampleEXT(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, textureData.textureGPU, 0, samples);
              } else {
                const mipLevel = this.renderer._activeMipmapLevel;
                gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, textureData.textureGPU, mipLevel);
              }
            }
          }
        }
        const depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
        if (renderTarget._autoAllocateDepthBuffer === true) {
          const renderbuffer = gl.createRenderbuffer();
          this.textureUtils.setupRenderBufferStorage(renderbuffer, descriptor, 0, useMultisampledRTT);
          renderTargetContextData.xrDepthRenderbuffer = renderbuffer;
          depthInvalidationArray.push(stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT);
          gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
          gl.framebufferRenderbuffer(gl.FRAMEBUFFER, depthStyle, gl.RENDERBUFFER, renderbuffer);
        } else {
          if (descriptor.depthTexture !== null) {
            depthInvalidationArray.push(stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT);
            const textureData = this.get(descriptor.depthTexture);
            textureData.renderTarget = descriptor.renderTarget;
            textureData.cacheKey = cacheKey;
            if (renderTarget.multiview) {
              multiviewExt.framebufferTextureMultisampleMultiviewOVR(gl.FRAMEBUFFER, depthStyle, textureData.textureGPU, 0, samples, 0, 2);
            } else if (_hasExternalTextures && useMultisampledRTT) {
              multisampledRTTExt.framebufferTexture2DMultisampleEXT(gl.FRAMEBUFFER, depthStyle, gl.TEXTURE_2D, textureData.textureGPU, 0, samples);
            } else {
              if (descriptor.depthTexture.isArrayTexture) {
                const layer = this.renderer._activeCubeFace;
                gl.framebufferTextureLayer(gl.FRAMEBUFFER, depthStyle, textureData.textureGPU, 0, layer);
              } else if (descriptor.depthTexture.isCubeTexture) {
                const cubeFace = this.renderer._activeCubeFace;
                gl.framebufferTexture2D(gl.FRAMEBUFFER, depthStyle, gl.TEXTURE_CUBE_MAP_POSITIVE_X + cubeFace, textureData.textureGPU, 0);
              } else {
                gl.framebufferTexture2D(gl.FRAMEBUFFER, depthStyle, gl.TEXTURE_2D, textureData.textureGPU, 0);
              }
            }
          }
        }
        renderTargetContextData.depthInvalidationArray = depthInvalidationArray;
      } else {
        const isRenderCameraDepthArray = this._isRenderCameraDepthArray(descriptor);
        if (isRenderCameraDepthArray) {
          state.bindFramebuffer(gl.FRAMEBUFFER, fb);
          const layer = this.renderer._activeCubeFace;
          const depthData = this.get(descriptor.depthTexture);
          const depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
          gl.framebufferTextureLayer(
            gl.FRAMEBUFFER,
            depthStyle,
            depthData.textureGPU,
            0,
            layer
          );
        }
        if ((isXRRenderTarget || useMultisampledRTT || renderTarget.multiview) && renderTarget._isOpaqueFramebuffer !== true) {
          state.bindFramebuffer(gl.FRAMEBUFFER, fb);
          const textureData = this.get(descriptor.textures[0]);
          if (renderTarget.multiview) {
            multiviewExt.framebufferTextureMultisampleMultiviewOVR(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, textureData.textureGPU, 0, samples, 0, 2);
          } else if (useMultisampledRTT) {
            multisampledRTTExt.framebufferTexture2DMultisampleEXT(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, textureData.textureGPU, 0, samples);
          } else {
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, textureData.textureGPU, 0);
          }
          const depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
          if (renderTarget._autoAllocateDepthBuffer === true) {
            const renderbuffer = renderTargetContextData.xrDepthRenderbuffer;
            gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, depthStyle, gl.RENDERBUFFER, renderbuffer);
          } else {
            const textureData2 = this.get(descriptor.depthTexture);
            if (renderTarget.multiview) {
              multiviewExt.framebufferTextureMultisampleMultiviewOVR(gl.FRAMEBUFFER, depthStyle, textureData2.textureGPU, 0, samples, 0, 2);
            } else if (useMultisampledRTT) {
              multisampledRTTExt.framebufferTexture2DMultisampleEXT(gl.FRAMEBUFFER, depthStyle, gl.TEXTURE_2D, textureData2.textureGPU, 0, samples);
            } else {
              gl.framebufferTexture2D(gl.FRAMEBUFFER, depthStyle, gl.TEXTURE_2D, textureData2.textureGPU, 0);
            }
          }
        }
      }
      if (samples > 0 && useMultisampledRTT === false && !renderTarget.multiview) {
        if (msaaFb === void 0) {
          const invalidationArray = [];
          msaaFb = gl.createFramebuffer();
          state.bindFramebuffer(gl.FRAMEBUFFER, msaaFb);
          const msaaRenderbuffers = [];
          const textures = descriptor.textures;
          for (let i2 = 0; i2 < textures.length; i2++) {
            msaaRenderbuffers[i2] = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, msaaRenderbuffers[i2]);
            invalidationArray.push(gl.COLOR_ATTACHMENT0 + i2);
            const texture2 = descriptor.textures[i2];
            const textureData = this.get(texture2);
            gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, textureData.glInternalFormat, descriptor.width, descriptor.height);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i2, gl.RENDERBUFFER, msaaRenderbuffers[i2]);
          }
          gl.bindRenderbuffer(gl.RENDERBUFFER, null);
          renderTargetContextData.msaaFrameBuffer = msaaFb;
          renderTargetContextData.msaaRenderbuffers = msaaRenderbuffers;
          if (depthBuffer && depthRenderbuffer === void 0) {
            depthRenderbuffer = gl.createRenderbuffer();
            this.textureUtils.setupRenderBufferStorage(depthRenderbuffer, descriptor, samples);
            renderTargetContextData.depthRenderbuffer = depthRenderbuffer;
            const depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
            invalidationArray.push(depthStyle);
          }
          renderTargetContextData.invalidationArray = invalidationArray;
        }
        currentFrameBuffer = renderTargetContextData.msaaFrameBuffer;
      } else {
        currentFrameBuffer = fb;
      }
      state.drawBuffers(descriptor, fb);
    }
    state.bindFramebuffer(gl.FRAMEBUFFER, currentFrameBuffer);
  }
  /**
   * Computes the VAO key for the given index and attributes.
   *
   * @private
   * @param {Array<BufferAttribute>} attributes - An array of buffer attributes.
   * @return {string} The VAO key.
   */
  _getVaoKey(attributes) {
    let key = "";
    for (let i2 = 0; i2 < attributes.length; i2++) {
      const attributeData = this.get(attributes[i2]);
      key += ":" + attributeData.id;
    }
    return key;
  }
  /**
   * Creates a VAO from the index and attributes.
   *
   * @private
   * @param {Array<BufferAttribute>} attributes - An array of buffer attributes.
   * @return {Object} The VAO data.
   */
  _createVao(attributes) {
    const { gl } = this;
    const vaoGPU = gl.createVertexArray();
    gl.bindVertexArray(vaoGPU);
    for (let i2 = 0; i2 < attributes.length; i2++) {
      const attribute2 = attributes[i2];
      const attributeData = this.get(attribute2);
      gl.bindBuffer(gl.ARRAY_BUFFER, attributeData.bufferGPU);
      gl.enableVertexAttribArray(i2);
      let stride, offset;
      if (attribute2.isInterleavedBufferAttribute === true) {
        stride = attribute2.data.stride * attributeData.bytesPerElement;
        offset = attribute2.offset * attributeData.bytesPerElement;
      } else {
        stride = 0;
        offset = 0;
      }
      if (attributeData.isInteger) {
        gl.vertexAttribIPointer(i2, attribute2.itemSize, attributeData.type, stride, offset);
      } else {
        gl.vertexAttribPointer(i2, attribute2.itemSize, attributeData.type, attribute2.normalized, stride, offset);
      }
      if (attribute2.isInstancedBufferAttribute && !attribute2.isInterleavedBufferAttribute) {
        gl.vertexAttribDivisor(i2, attribute2.meshPerAttribute);
      } else if (attribute2.isInterleavedBufferAttribute && attribute2.data.isInstancedInterleavedBuffer) {
        gl.vertexAttribDivisor(i2, attribute2.data.meshPerAttribute);
      }
    }
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    return vaoGPU;
  }
  /**
   * Creates a transform feedback from the given transform buffers.
   *
   * @private
   * @param {Array<DualAttributeData>} transformBuffers - The transform buffers.
   * @return {WebGLTransformFeedback} The transform feedback.
   */
  _getTransformFeedback(transformBuffers) {
    let key = "";
    for (let i2 = 0; i2 < transformBuffers.length; i2++) {
      key += ":" + transformBuffers[i2].id;
    }
    let transformFeedbackGPU = this.transformFeedbackCache[key];
    if (transformFeedbackGPU !== void 0) {
      return transformFeedbackGPU;
    }
    const { gl } = this;
    transformFeedbackGPU = gl.createTransformFeedback();
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, transformFeedbackGPU);
    for (let i2 = 0; i2 < transformBuffers.length; i2++) {
      const attributeData = transformBuffers[i2];
      gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, i2, attributeData.transformBuffer);
    }
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
    this.transformFeedbackCache[key] = transformFeedbackGPU;
    return transformFeedbackGPU;
  }
  /**
   * Setups the given bindings.
   *
   * @private
   * @param {Array<BindGroup>} bindings - The bindings.
   * @param {WebGLProgram} programGPU - The WebGL program.
   */
  _setupBindings(bindings, programGPU) {
    const gl = this.gl;
    for (const bindGroup of bindings) {
      for (const binding of bindGroup.bindings) {
        const bindingData = this.get(binding);
        const index8 = bindingData.index;
        if (binding.isUniformsGroup || binding.isUniformBuffer) {
          const location = gl.getUniformBlockIndex(programGPU, binding.name);
          gl.uniformBlockBinding(programGPU, location, index8);
        } else if (binding.isSampledTexture) {
          const location = gl.getUniformLocation(programGPU, binding.name);
          gl.uniform1i(location, index8);
        }
      }
    }
  }
  /**
   * Binds the given uniforms.
   *
   * @private
   * @param {Array<BindGroup>} bindings - The bindings.
   */
  _bindUniforms(bindings) {
    const { gl, state } = this;
    for (const bindGroup of bindings) {
      for (const binding of bindGroup.bindings) {
        const bindingData = this.get(binding);
        const index8 = bindingData.index;
        if (binding.isUniformsGroup || binding.isUniformBuffer) {
          state.bindBufferBase(gl.UNIFORM_BUFFER, index8, bindingData.bufferGPU);
        } else if (binding.isSampledTexture) {
          state.bindTexture(bindingData.glTextureType, bindingData.textureGPU, gl.TEXTURE0 + index8);
        }
      }
    }
  }
  /**
   * The method ensures multisampled render targets are resolved.
   *
   * @private
   * @param {RenderContext} renderContext - The render context.
   */
  _resolveRenderTarget(renderContext) {
    const { gl, state } = this;
    const renderTarget = renderContext.renderTarget;
    if (renderContext.textures !== null && renderTarget) {
      const renderTargetContextData = this.get(renderTarget);
      if (renderTarget.samples > 0 && this._useMultisampledExtension(renderTarget) === false) {
        const fb = renderTargetContextData.framebuffers[renderContext.getCacheKey()];
        let mask = gl.COLOR_BUFFER_BIT;
        if (renderTarget.resolveDepthBuffer) {
          if (renderTarget.depthBuffer) mask |= gl.DEPTH_BUFFER_BIT;
          if (renderTarget.stencilBuffer && renderTarget.resolveStencilBuffer) mask |= gl.STENCIL_BUFFER_BIT;
        }
        const msaaFrameBuffer = renderTargetContextData.msaaFrameBuffer;
        const msaaRenderbuffers = renderTargetContextData.msaaRenderbuffers;
        const textures = renderContext.textures;
        const isMRT = textures.length > 1;
        state.bindFramebuffer(gl.READ_FRAMEBUFFER, msaaFrameBuffer);
        state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, fb);
        if (isMRT) {
          for (let i2 = 0; i2 < textures.length; i2++) {
            gl.framebufferRenderbuffer(gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i2, gl.RENDERBUFFER, null);
            gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i2, gl.TEXTURE_2D, null, 0);
          }
        }
        for (let i2 = 0; i2 < textures.length; i2++) {
          if (isMRT) {
            const { textureGPU } = this.get(textures[i2]);
            gl.framebufferRenderbuffer(gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, msaaRenderbuffers[i2]);
            gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, textureGPU, 0);
          }
          if (renderContext.scissor) {
            const { x: x3, y: y3, width, height } = renderContext.scissorValue;
            const viewY = renderContext.height - height - y3;
            gl.blitFramebuffer(x3, viewY, x3 + width, viewY + height, x3, viewY, x3 + width, viewY + height, mask, gl.NEAREST);
          } else {
            gl.blitFramebuffer(0, 0, renderContext.width, renderContext.height, 0, 0, renderContext.width, renderContext.height, mask, gl.NEAREST);
          }
        }
        if (isMRT) {
          for (let i2 = 0; i2 < textures.length; i2++) {
            const { textureGPU } = this.get(textures[i2]);
            gl.framebufferRenderbuffer(gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i2, gl.RENDERBUFFER, msaaRenderbuffers[i2]);
            gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i2, gl.TEXTURE_2D, textureGPU, 0);
          }
        }
        if (this._supportsInvalidateFramebuffer === true) {
          gl.invalidateFramebuffer(gl.READ_FRAMEBUFFER, renderTargetContextData.invalidationArray);
        }
      } else if (renderTarget.resolveDepthBuffer === false && renderTargetContextData.framebuffers) {
        const fb = renderTargetContextData.framebuffers[renderContext.getCacheKey()];
        state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, fb);
        gl.invalidateFramebuffer(gl.DRAW_FRAMEBUFFER, renderTargetContextData.depthInvalidationArray);
      }
    }
  }
  /**
   * Returns `true` if the `WEBGL_multisampled_render_to_texture` extension
   * should be used when MSAA is enabled.
   *
   * @private
   * @param {RenderTarget} renderTarget - The render target that should be multisampled.
   * @return {boolean} Whether to use the `WEBGL_multisampled_render_to_texture` extension for MSAA or not.
   */
  _useMultisampledExtension(renderTarget) {
    if (renderTarget.multiview === true) {
      return true;
    }
    return renderTarget.samples > 0 && this.extensions.has("WEBGL_multisampled_render_to_texture") === true && renderTarget._autoAllocateDepthBuffer !== false;
  }
  /**
   * Frees internal resources.
   */
  dispose() {
    if (this.textureUtils !== null) this.textureUtils.dispose();
    const extension = this.extensions.get("WEBGL_lose_context");
    if (extension) extension.loseContext();
    this.renderer.domElement.removeEventListener("webglcontextlost", this._onContextLost);
  }
};
var GPUPrimitiveTopology = {
  PointList: "point-list",
  LineList: "line-list",
  LineStrip: "line-strip",
  TriangleList: "triangle-list",
  TriangleStrip: "triangle-strip"
};
var GPUShaderStage = typeof self !== "undefined" ? self.GPUShaderStage : { VERTEX: 1, FRAGMENT: 2, COMPUTE: 4 };
var GPUCompareFunction = {
  Never: "never",
  Less: "less",
  Equal: "equal",
  LessEqual: "less-equal",
  Greater: "greater",
  NotEqual: "not-equal",
  GreaterEqual: "greater-equal",
  Always: "always"
};
var GPUStoreOp = {
  Store: "store"
};
var GPULoadOp = {
  Load: "load",
  Clear: "clear"
};
var GPUFrontFace = {
  CCW: "ccw",
  CW: "cw"
};
var GPUCullMode = {
  None: "none",
  Back: "back"
};
var GPUIndexFormat = {
  Uint16: "uint16",
  Uint32: "uint32"
};
var GPUTextureFormat = {
  // 8-bit formats
  R8Unorm: "r8unorm",
  R8Snorm: "r8snorm",
  R8Uint: "r8uint",
  R8Sint: "r8sint",
  // 16-bit formats
  R16Uint: "r16uint",
  R16Sint: "r16sint",
  R16Float: "r16float",
  RG8Unorm: "rg8unorm",
  RG8Snorm: "rg8snorm",
  RG8Uint: "rg8uint",
  RG8Sint: "rg8sint",
  // 32-bit formats
  R32Uint: "r32uint",
  R32Sint: "r32sint",
  R32Float: "r32float",
  RG16Uint: "rg16uint",
  RG16Sint: "rg16sint",
  RG16Float: "rg16float",
  RGBA8Unorm: "rgba8unorm",
  RGBA8UnormSRGB: "rgba8unorm-srgb",
  RGBA8Snorm: "rgba8snorm",
  RGBA8Uint: "rgba8uint",
  RGBA8Sint: "rgba8sint",
  BGRA8Unorm: "bgra8unorm",
  BGRA8UnormSRGB: "bgra8unorm-srgb",
  // Packed 32-bit formats
  RGB9E5UFloat: "rgb9e5ufloat",
  RGB10A2Unorm: "rgb10a2unorm",
  RG11B10UFloat: "rg11b10ufloat",
  // 64-bit formats
  RG32Uint: "rg32uint",
  RG32Sint: "rg32sint",
  RG32Float: "rg32float",
  RGBA16Uint: "rgba16uint",
  RGBA16Sint: "rgba16sint",
  RGBA16Float: "rgba16float",
  // 128-bit formats
  RGBA32Uint: "rgba32uint",
  RGBA32Sint: "rgba32sint",
  RGBA32Float: "rgba32float",
  Depth16Unorm: "depth16unorm",
  Depth24Plus: "depth24plus",
  Depth24PlusStencil8: "depth24plus-stencil8",
  Depth32Float: "depth32float",
  // 'depth32float-stencil8' extension
  Depth32FloatStencil8: "depth32float-stencil8",
  // BC compressed formats usable if 'texture-compression-bc' is both
  // supported by the device/user agent and enabled in requestDevice.
  BC1RGBAUnorm: "bc1-rgba-unorm",
  BC1RGBAUnormSRGB: "bc1-rgba-unorm-srgb",
  BC2RGBAUnorm: "bc2-rgba-unorm",
  BC2RGBAUnormSRGB: "bc2-rgba-unorm-srgb",
  BC3RGBAUnorm: "bc3-rgba-unorm",
  BC3RGBAUnormSRGB: "bc3-rgba-unorm-srgb",
  BC4RUnorm: "bc4-r-unorm",
  BC4RSnorm: "bc4-r-snorm",
  BC5RGUnorm: "bc5-rg-unorm",
  BC5RGSnorm: "bc5-rg-snorm",
  BC6HRGBUFloat: "bc6h-rgb-ufloat",
  BC6HRGBFloat: "bc6h-rgb-float",
  BC7RGBAUnorm: "bc7-rgba-unorm",
  BC7RGBAUnormSRGB: "bc7-rgba-unorm-srgb",
  // ETC2 compressed formats usable if 'texture-compression-etc2' is both
  // supported by the device/user agent and enabled in requestDevice.
  ETC2RGB8Unorm: "etc2-rgb8unorm",
  ETC2RGB8UnormSRGB: "etc2-rgb8unorm-srgb",
  ETC2RGB8A1Unorm: "etc2-rgb8a1unorm",
  ETC2RGB8A1UnormSRGB: "etc2-rgb8a1unorm-srgb",
  ETC2RGBA8Unorm: "etc2-rgba8unorm",
  ETC2RGBA8UnormSRGB: "etc2-rgba8unorm-srgb",
  EACR11Unorm: "eac-r11unorm",
  EACR11Snorm: "eac-r11snorm",
  EACRG11Unorm: "eac-rg11unorm",
  EACRG11Snorm: "eac-rg11snorm",
  // ASTC compressed formats usable if 'texture-compression-astc' is both
  // supported by the device/user agent and enabled in requestDevice.
  ASTC4x4Unorm: "astc-4x4-unorm",
  ASTC4x4UnormSRGB: "astc-4x4-unorm-srgb",
  ASTC5x4Unorm: "astc-5x4-unorm",
  ASTC5x4UnormSRGB: "astc-5x4-unorm-srgb",
  ASTC5x5Unorm: "astc-5x5-unorm",
  ASTC5x5UnormSRGB: "astc-5x5-unorm-srgb",
  ASTC6x5Unorm: "astc-6x5-unorm",
  ASTC6x5UnormSRGB: "astc-6x5-unorm-srgb",
  ASTC6x6Unorm: "astc-6x6-unorm",
  ASTC6x6UnormSRGB: "astc-6x6-unorm-srgb",
  ASTC8x5Unorm: "astc-8x5-unorm",
  ASTC8x5UnormSRGB: "astc-8x5-unorm-srgb",
  ASTC8x6Unorm: "astc-8x6-unorm",
  ASTC8x6UnormSRGB: "astc-8x6-unorm-srgb",
  ASTC8x8Unorm: "astc-8x8-unorm",
  ASTC8x8UnormSRGB: "astc-8x8-unorm-srgb",
  ASTC10x5Unorm: "astc-10x5-unorm",
  ASTC10x5UnormSRGB: "astc-10x5-unorm-srgb",
  ASTC10x6Unorm: "astc-10x6-unorm",
  ASTC10x6UnormSRGB: "astc-10x6-unorm-srgb",
  ASTC10x8Unorm: "astc-10x8-unorm",
  ASTC10x8UnormSRGB: "astc-10x8-unorm-srgb",
  ASTC10x10Unorm: "astc-10x10-unorm",
  ASTC10x10UnormSRGB: "astc-10x10-unorm-srgb",
  ASTC12x10Unorm: "astc-12x10-unorm",
  ASTC12x10UnormSRGB: "astc-12x10-unorm-srgb",
  ASTC12x12Unorm: "astc-12x12-unorm",
  ASTC12x12UnormSRGB: "astc-12x12-unorm-srgb"
};
var GPUAddressMode = {
  ClampToEdge: "clamp-to-edge",
  Repeat: "repeat",
  MirrorRepeat: "mirror-repeat"
};
var GPUFilterMode = {
  Linear: "linear",
  Nearest: "nearest"
};
var GPUBlendFactor = {
  Zero: "zero",
  One: "one",
  Src: "src",
  OneMinusSrc: "one-minus-src",
  SrcAlpha: "src-alpha",
  OneMinusSrcAlpha: "one-minus-src-alpha",
  Dst: "dst",
  OneMinusDst: "one-minus-dst",
  DstAlpha: "dst-alpha",
  OneMinusDstAlpha: "one-minus-dst-alpha",
  SrcAlphaSaturated: "src-alpha-saturated",
  Constant: "constant",
  OneMinusConstant: "one-minus-constant"
};
var GPUBlendOperation = {
  Add: "add",
  Subtract: "subtract",
  ReverseSubtract: "reverse-subtract",
  Min: "min",
  Max: "max"
};
var GPUColorWriteFlags = {
  None: 0,
  All: 15
};
var GPUStencilOperation = {
  Keep: "keep",
  Zero: "zero",
  Replace: "replace",
  Invert: "invert",
  IncrementClamp: "increment-clamp",
  DecrementClamp: "decrement-clamp",
  IncrementWrap: "increment-wrap",
  DecrementWrap: "decrement-wrap"
};
var GPUBufferBindingType = {
  Storage: "storage",
  ReadOnlyStorage: "read-only-storage"
};
var GPUStorageTextureAccess = {
  WriteOnly: "write-only",
  ReadOnly: "read-only",
  ReadWrite: "read-write"
};
var GPUSamplerBindingType = {
  NonFiltering: "non-filtering",
  Comparison: "comparison"
};
var GPUTextureSampleType = {
  Float: "float",
  UnfilterableFloat: "unfilterable-float",
  Depth: "depth",
  SInt: "sint",
  UInt: "uint"
};
var GPUTextureDimension = {
  TwoD: "2d",
  ThreeD: "3d"
};
var GPUTextureViewDimension = {
  TwoD: "2d",
  TwoDArray: "2d-array",
  Cube: "cube",
  ThreeD: "3d"
};
var GPUTextureAspect = {
  All: "all"
};
var GPUInputStepMode = {
  Vertex: "vertex",
  Instance: "instance"
};
var GPUFeatureName = {
  CoreFeaturesAndLimits: "core-features-and-limits",
  DepthClipControl: "depth-clip-control",
  Depth32FloatStencil8: "depth32float-stencil8",
  TextureCompressionBC: "texture-compression-bc",
  TextureCompressionBCSliced3D: "texture-compression-bc-sliced-3d",
  TextureCompressionETC2: "texture-compression-etc2",
  TextureCompressionASTC: "texture-compression-astc",
  TextureCompressionASTCSliced3D: "texture-compression-astc-sliced-3d",
  TimestampQuery: "timestamp-query",
  IndirectFirstInstance: "indirect-first-instance",
  ShaderF16: "shader-f16",
  RG11B10UFloat: "rg11b10ufloat-renderable",
  BGRA8UNormStorage: "bgra8unorm-storage",
  Float32Filterable: "float32-filterable",
  Float32Blendable: "float32-blendable",
  ClipDistances: "clip-distances",
  DualSourceBlending: "dual-source-blending",
  Subgroups: "subgroups",
  TextureFormatsTier1: "texture-formats-tier1",
  TextureFormatsTier2: "texture-formats-tier2"
};
var GPUFeatureMap = {
  "texture-compression-s3tc": "texture-compression-bc",
  "texture-compression-etc1": "texture-compression-etc2"
};
var NodeSampler = class extends Sampler {
  /**
   * Constructs a new node-based sampler.
   *
   * @param {string} name - The samplers's name.
   * @param {TextureNode} textureNode - The texture node.
   * @param {UniformGroupNode} groupNode - The uniform group node.
   */
  constructor(name, textureNode, groupNode) {
    super(name, textureNode ? textureNode.value : null);
    this.textureNode = textureNode;
    this.groupNode = groupNode;
  }
  /**
   * Updates the texture value of this sampler.
   *
   * @return {boolean} Whether the sampler needs an update or not.
   */
  update() {
    const { textureNode } = this;
    if (this.texture !== textureNode.value) {
      this.texture = textureNode.value;
      return true;
    }
    return super.update();
  }
};
var StorageBuffer = class extends Buffer {
  /**
   * Constructs a new uniform buffer.
   *
   * @param {string} name - The buffer's name.
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  constructor(name, attribute2) {
    super(name, attribute2 ? attribute2.array : null);
    this.attribute = attribute2;
    this.isStorageBuffer = true;
  }
};
var _id2 = 0;
var NodeStorageBuffer = class extends StorageBuffer {
  /**
   * Constructs a new node-based storage buffer.
   *
   * @param {StorageBufferNode} nodeUniform - The storage buffer node.
   * @param {UniformGroupNode} groupNode - The uniform group node.
   */
  constructor(nodeUniform, groupNode) {
    super("StorageBuffer_" + _id2++, nodeUniform ? nodeUniform.value : null);
    this.nodeUniform = nodeUniform;
    this.access = nodeUniform ? nodeUniform.access : NodeAccess.READ_WRITE;
    this.groupNode = groupNode;
  }
  /**
   * The storage buffer.
   *
   * @type {BufferAttribute}
   */
  get buffer() {
    return this.nodeUniform.value;
  }
};
var WebGPUTexturePassUtils = class extends DataMap {
  /**
   * Constructs a new utility object.
   *
   * @param {GPUDevice} device - The WebGPU device.
   */
  constructor(device) {
    super();
    this.device = device;
    const mipmapVertexSource = `
struct VarysStruct {
	@builtin( position ) Position: vec4<f32>,
	@location( 0 ) vTex : vec2<f32>
};

@vertex
fn main( @builtin( vertex_index ) vertexIndex : u32 ) -> VarysStruct {

	var Varys : VarysStruct;

	var pos = array< vec2<f32>, 4 >(
		vec2<f32>( -1.0,  1.0 ),
		vec2<f32>(  1.0,  1.0 ),
		vec2<f32>( -1.0, -1.0 ),
		vec2<f32>(  1.0, -1.0 )
	);

	var tex = array< vec2<f32>, 4 >(
		vec2<f32>( 0.0, 0.0 ),
		vec2<f32>( 1.0, 0.0 ),
		vec2<f32>( 0.0, 1.0 ),
		vec2<f32>( 1.0, 1.0 )
	);

	Varys.vTex = tex[ vertexIndex ];
	Varys.Position = vec4<f32>( pos[ vertexIndex ], 0.0, 1.0 );

	return Varys;

}
`;
    const mipmapFragmentSource = `
@group( 0 ) @binding( 0 )
var imgSampler : sampler;

@group( 0 ) @binding( 1 )
var img : texture_2d<f32>;

@fragment
fn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {

	return textureSample( img, imgSampler, vTex );

}
`;
    const flipYFragmentSource = `
@group( 0 ) @binding( 0 )
var imgSampler : sampler;

@group( 0 ) @binding( 1 )
var img : texture_2d<f32>;

@fragment
fn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {

	return textureSample( img, imgSampler, vec2( vTex.x, 1.0 - vTex.y ) );

}
`;
    this.mipmapSampler = device.createSampler({ minFilter: GPUFilterMode.Linear });
    this.flipYSampler = device.createSampler({ minFilter: GPUFilterMode.Nearest });
    this.transferPipelines = {};
    this.flipYPipelines = {};
    this.mipmapVertexShaderModule = device.createShaderModule({
      label: "mipmapVertex",
      code: mipmapVertexSource
    });
    this.mipmapFragmentShaderModule = device.createShaderModule({
      label: "mipmapFragment",
      code: mipmapFragmentSource
    });
    this.flipYFragmentShaderModule = device.createShaderModule({
      label: "flipYFragment",
      code: flipYFragmentSource
    });
  }
  /**
   * Returns a render pipeline for the internal copy render pass. The pass
   * requires a unique render pipeline for each texture format.
   *
   * @param {string} format - The GPU texture format
   * @return {GPURenderPipeline} The GPU render pipeline.
   */
  getTransferPipeline(format3) {
    let pipeline = this.transferPipelines[format3];
    if (pipeline === void 0) {
      pipeline = this.device.createRenderPipeline({
        label: `mipmap-${format3}`,
        vertex: {
          module: this.mipmapVertexShaderModule,
          entryPoint: "main"
        },
        fragment: {
          module: this.mipmapFragmentShaderModule,
          entryPoint: "main",
          targets: [{ format: format3 }]
        },
        primitive: {
          topology: GPUPrimitiveTopology.TriangleStrip,
          stripIndexFormat: GPUIndexFormat.Uint32
        },
        layout: "auto"
      });
      this.transferPipelines[format3] = pipeline;
    }
    return pipeline;
  }
  /**
   * Returns a render pipeline for the flipY render pass. The pass
   * requires a unique render pipeline for each texture format.
   *
   * @param {string} format - The GPU texture format
   * @return {GPURenderPipeline} The GPU render pipeline.
   */
  getFlipYPipeline(format3) {
    let pipeline = this.flipYPipelines[format3];
    if (pipeline === void 0) {
      pipeline = this.device.createRenderPipeline({
        label: `flipY-${format3}`,
        vertex: {
          module: this.mipmapVertexShaderModule,
          entryPoint: "main"
        },
        fragment: {
          module: this.flipYFragmentShaderModule,
          entryPoint: "main",
          targets: [{ format: format3 }]
        },
        primitive: {
          topology: GPUPrimitiveTopology.TriangleStrip,
          stripIndexFormat: GPUIndexFormat.Uint32
        },
        layout: "auto"
      });
      this.flipYPipelines[format3] = pipeline;
    }
    return pipeline;
  }
  /**
   * Flip the contents of the given GPU texture along its vertical axis.
   *
   * @param {GPUTexture} textureGPU - The GPU texture object.
   * @param {Object} textureGPUDescriptor - The texture descriptor.
   * @param {number} [baseArrayLayer=0] - The index of the first array layer accessible to the texture view.
   */
  flipY(textureGPU, textureGPUDescriptor, baseArrayLayer = 0) {
    const format3 = textureGPUDescriptor.format;
    const { width, height } = textureGPUDescriptor.size;
    const transferPipeline = this.getTransferPipeline(format3);
    const flipYPipeline = this.getFlipYPipeline(format3);
    const tempTexture = this.device.createTexture({
      size: { width, height, depthOrArrayLayers: 1 },
      format: format3,
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
    });
    const srcView = textureGPU.createView({
      baseMipLevel: 0,
      mipLevelCount: 1,
      dimension: GPUTextureViewDimension.TwoD,
      baseArrayLayer
    });
    const dstView = tempTexture.createView({
      baseMipLevel: 0,
      mipLevelCount: 1,
      dimension: GPUTextureViewDimension.TwoD,
      baseArrayLayer: 0
    });
    const commandEncoder = this.device.createCommandEncoder({});
    const pass2 = (pipeline, sourceView, destinationView) => {
      const bindGroupLayout = pipeline.getBindGroupLayout(0);
      const bindGroup = this.device.createBindGroup({
        layout: bindGroupLayout,
        entries: [{
          binding: 0,
          resource: this.flipYSampler
        }, {
          binding: 1,
          resource: sourceView
        }]
      });
      const passEncoder = commandEncoder.beginRenderPass({
        colorAttachments: [{
          view: destinationView,
          loadOp: GPULoadOp.Clear,
          storeOp: GPUStoreOp.Store,
          clearValue: [0, 0, 0, 0]
        }]
      });
      passEncoder.setPipeline(pipeline);
      passEncoder.setBindGroup(0, bindGroup);
      passEncoder.draw(4, 1, 0, 0);
      passEncoder.end();
    };
    pass2(transferPipeline, srcView, dstView);
    pass2(flipYPipeline, dstView, srcView);
    this.device.queue.submit([commandEncoder.finish()]);
    tempTexture.destroy();
  }
  /**
   * Generates mipmaps for the given GPU texture.
   *
   * @param {GPUTexture} textureGPU - The GPU texture object.
   * @param {Object} textureGPUDescriptor - The texture descriptor.
   * @param {number} [baseArrayLayer=0] - The index of the first array layer accessible to the texture view.
   * @param {?GPUCommandEncoder} [encoder=null] - An optional command encoder used to generate mipmaps.
   */
  generateMipmaps(textureGPU, textureGPUDescriptor, baseArrayLayer = 0, encoder = null) {
    const textureData = this.get(textureGPU);
    if (textureData.layers === void 0) {
      textureData.layers = [];
    }
    const passes = textureData.layers[baseArrayLayer] || this._mipmapCreateBundles(textureGPU, textureGPUDescriptor, baseArrayLayer);
    const commandEncoder = encoder || this.device.createCommandEncoder({ label: "mipmapEncoder" });
    this._mipmapRunBundles(commandEncoder, passes);
    if (encoder === null) this.device.queue.submit([commandEncoder.finish()]);
    textureData.layers[baseArrayLayer] = passes;
  }
  /**
   * Since multiple copy render passes are required to generate mipmaps, the passes
   * are managed as render bundles to improve performance.
   *
   * @param {GPUTexture} textureGPU - The GPU texture object.
   * @param {Object} textureGPUDescriptor - The texture descriptor.
   * @param {number} baseArrayLayer - The index of the first array layer accessible to the texture view.
   * @return {Array<Object>} An array of render bundles.
   */
  _mipmapCreateBundles(textureGPU, textureGPUDescriptor, baseArrayLayer) {
    const pipeline = this.getTransferPipeline(textureGPUDescriptor.format);
    const bindGroupLayout = pipeline.getBindGroupLayout(0);
    let srcView = textureGPU.createView({
      baseMipLevel: 0,
      mipLevelCount: 1,
      dimension: GPUTextureViewDimension.TwoD,
      baseArrayLayer
    });
    const passes = [];
    for (let i2 = 1; i2 < textureGPUDescriptor.mipLevelCount; i2++) {
      const bindGroup = this.device.createBindGroup({
        layout: bindGroupLayout,
        entries: [{
          binding: 0,
          resource: this.mipmapSampler
        }, {
          binding: 1,
          resource: srcView
        }]
      });
      const dstView = textureGPU.createView({
        baseMipLevel: i2,
        mipLevelCount: 1,
        dimension: GPUTextureViewDimension.TwoD,
        baseArrayLayer
      });
      const passDescriptor = {
        colorAttachments: [{
          view: dstView,
          loadOp: GPULoadOp.Clear,
          storeOp: GPUStoreOp.Store,
          clearValue: [0, 0, 0, 0]
        }]
      };
      const passEncoder = this.device.createRenderBundleEncoder({
        colorFormats: [textureGPUDescriptor.format]
      });
      passEncoder.setPipeline(pipeline);
      passEncoder.setBindGroup(0, bindGroup);
      passEncoder.draw(4, 1, 0, 0);
      passes.push({
        renderBundles: [passEncoder.finish()],
        passDescriptor
      });
      srcView = dstView;
    }
    return passes;
  }
  /**
   * Executes the render bundles.
   *
   * @param {GPUCommandEncoder} commandEncoder - The GPU command encoder.
   * @param {Array<Object>} passes - An array of render bundles.
   */
  _mipmapRunBundles(commandEncoder, passes) {
    const levels = passes.length;
    for (let i2 = 0; i2 < levels; i2++) {
      const pass2 = passes[i2];
      const passEncoder = commandEncoder.beginRenderPass(pass2.passDescriptor);
      passEncoder.executeBundles(pass2.renderBundles);
      passEncoder.end();
    }
  }
};
var _compareToWebGPU = {
  [NeverCompare]: "never",
  [LessCompare]: "less",
  [EqualCompare]: "equal",
  [LessEqualCompare]: "less-equal",
  [GreaterCompare]: "greater",
  [GreaterEqualCompare]: "greater-equal",
  [AlwaysCompare]: "always",
  [NotEqualCompare]: "not-equal"
};
var _flipMap = [0, 1, 3, 2, 4, 5];
var WebGPUTextureUtils = class {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGPUBackend} backend - The WebGPU backend.
   */
  constructor(backend) {
    this.backend = backend;
    this._passUtils = null;
    this.defaultTexture = {};
    this.defaultCubeTexture = {};
    this.defaultVideoFrame = null;
    this._samplerCache = /* @__PURE__ */ new Map();
  }
  /**
   * Creates a GPU sampler for the given texture.
   *
   * @param {Texture} texture - The texture to create the sampler for.
   * @return {string} The current sampler key.
   */
  updateSampler(texture2) {
    const backend = this.backend;
    const samplerKey = texture2.minFilter + "-" + texture2.magFilter + "-" + texture2.wrapS + "-" + texture2.wrapT + "-" + (texture2.wrapR || "0") + "-" + texture2.anisotropy + "-" + (texture2.compareFunction || 0);
    let samplerData = this._samplerCache.get(samplerKey);
    if (samplerData === void 0) {
      const samplerDescriptorGPU = {
        addressModeU: this._convertAddressMode(texture2.wrapS),
        addressModeV: this._convertAddressMode(texture2.wrapT),
        addressModeW: this._convertAddressMode(texture2.wrapR),
        magFilter: this._convertFilterMode(texture2.magFilter),
        minFilter: this._convertFilterMode(texture2.minFilter),
        mipmapFilter: this._convertFilterMode(texture2.minFilter),
        maxAnisotropy: 1
      };
      if (samplerDescriptorGPU.magFilter === GPUFilterMode.Linear && samplerDescriptorGPU.minFilter === GPUFilterMode.Linear && samplerDescriptorGPU.mipmapFilter === GPUFilterMode.Linear) {
        samplerDescriptorGPU.maxAnisotropy = texture2.anisotropy;
      }
      if (texture2.isDepthTexture && texture2.compareFunction !== null) {
        samplerDescriptorGPU.compare = _compareToWebGPU[texture2.compareFunction];
      }
      const sampler2 = backend.device.createSampler(samplerDescriptorGPU);
      samplerData = { sampler: sampler2, usedTimes: 0 };
      this._samplerCache.set(samplerKey, samplerData);
    }
    const textureData = backend.get(texture2);
    if (textureData.sampler !== samplerData.sampler) {
      if (textureData.sampler !== void 0) {
        const oldSamplerData = this._samplerCache.get(textureData.samplerKey);
        oldSamplerData.usedTimes--;
        if (oldSamplerData.usedTimes === 0) {
          this._samplerCache.delete(textureData.samplerKey);
        }
      }
      textureData.samplerKey = samplerKey;
      textureData.sampler = samplerData.sampler;
      samplerData.usedTimes++;
    }
    return samplerKey;
  }
  /**
   * Creates a default texture for the given texture that can be used
   * as a placeholder until the actual texture is ready for usage.
   *
   * @param {Texture} texture - The texture to create a default texture for.
   */
  createDefaultTexture(texture2) {
    let textureGPU;
    const format3 = getFormat2(texture2);
    if (texture2.isCubeTexture) {
      textureGPU = this._getDefaultCubeTextureGPU(format3);
    } else {
      textureGPU = this._getDefaultTextureGPU(format3);
    }
    this.backend.get(texture2).texture = textureGPU;
  }
  /**
   * Defines a texture on the GPU for the given texture object.
   *
   * @param {Texture} texture - The texture.
   * @param {Object} [options={}] - Optional configuration parameter.
   */
  createTexture(texture2, options = {}) {
    const backend = this.backend;
    const textureData = backend.get(texture2);
    if (textureData.initialized) {
      throw new Error("WebGPUTextureUtils: Texture already initialized.");
    }
    if (texture2.isExternalTexture) {
      textureData.texture = texture2.sourceTexture;
      textureData.initialized = true;
      return;
    }
    if (options.needsMipmaps === void 0) options.needsMipmaps = false;
    if (options.levels === void 0) options.levels = 1;
    if (options.depth === void 0) options.depth = 1;
    const { width, height, depth: depth2, levels } = options;
    if (texture2.isFramebufferTexture) {
      if (options.renderTarget) {
        options.format = this.backend.utils.getCurrentColorFormat(options.renderTarget);
      } else {
        options.format = this.backend.utils.getPreferredCanvasFormat();
      }
    }
    const dimension = this._getDimension(texture2);
    const format3 = texture2.internalFormat || options.format || getFormat2(texture2, backend.device);
    textureData.format = format3;
    const { samples, primarySamples, isMSAA } = backend.utils.getTextureSampleData(texture2);
    let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC;
    if (texture2.isStorageTexture === true) {
      usage |= GPUTextureUsage.STORAGE_BINDING;
    }
    if (texture2.isCompressedTexture !== true && texture2.isCompressedArrayTexture !== true && format3 !== GPUTextureFormat.RGB9E5UFloat) {
      usage |= GPUTextureUsage.RENDER_ATTACHMENT;
    }
    const textureDescriptorGPU = {
      label: texture2.name,
      size: {
        width,
        height,
        depthOrArrayLayers: depth2
      },
      mipLevelCount: levels,
      sampleCount: primarySamples,
      dimension,
      format: format3,
      usage
    };
    if (format3 === void 0) {
      warn("WebGPURenderer: Texture format not supported.");
      this.createDefaultTexture(texture2);
      return;
    }
    if (texture2.isCubeTexture) {
      textureDescriptorGPU.textureBindingViewDimension = GPUTextureViewDimension.Cube;
    }
    textureData.texture = backend.device.createTexture(textureDescriptorGPU);
    if (isMSAA) {
      const msaaTextureDescriptorGPU = Object.assign({}, textureDescriptorGPU);
      msaaTextureDescriptorGPU.label = msaaTextureDescriptorGPU.label + "-msaa";
      msaaTextureDescriptorGPU.sampleCount = samples;
      msaaTextureDescriptorGPU.mipLevelCount = 1;
      textureData.msaaTexture = backend.device.createTexture(msaaTextureDescriptorGPU);
    }
    textureData.initialized = true;
    textureData.textureDescriptorGPU = textureDescriptorGPU;
  }
  /**
   * Destroys the GPU data for the given texture object.
   *
   * @param {Texture} texture - The texture.
   * @param {boolean} [isDefaultTexture=false] - Whether the texture uses a default GPU texture or not.
   */
  destroyTexture(texture2, isDefaultTexture = false) {
    const backend = this.backend;
    const textureData = backend.get(texture2);
    if (textureData.texture !== void 0 && isDefaultTexture === false) textureData.texture.destroy();
    if (textureData.msaaTexture !== void 0) textureData.msaaTexture.destroy();
    backend.delete(texture2);
  }
  /**
   * Generates mipmaps for the given texture.
   *
   * @param {Texture} texture - The texture.
   * @param {?GPUCommandEncoder} [encoder=null] - An optional command encoder used to generate mipmaps.
   */
  generateMipmaps(texture2, encoder = null) {
    const textureData = this.backend.get(texture2);
    if (texture2.isCubeTexture) {
      for (let i2 = 0; i2 < 6; i2++) {
        this._generateMipmaps(textureData.texture, textureData.textureDescriptorGPU, i2, encoder);
      }
    } else {
      const depth2 = texture2.image.depth || 1;
      for (let i2 = 0; i2 < depth2; i2++) {
        this._generateMipmaps(textureData.texture, textureData.textureDescriptorGPU, i2, encoder);
      }
    }
  }
  /**
   * Returns the color buffer representing the color
   * attachment of the default framebuffer.
   *
   * @return {GPUTexture} The color buffer.
   */
  getColorBuffer() {
    const backend = this.backend;
    const canvasTarget = backend.renderer.getCanvasTarget();
    const { width, height } = backend.getDrawingBufferSize();
    const samples = backend.renderer.currentSamples;
    const colorTexture = canvasTarget.colorTexture;
    const colorTextureData = backend.get(colorTexture);
    if (colorTexture.width === width && colorTexture.height === height && colorTexture.samples === samples) {
      return colorTextureData.texture;
    }
    let colorBuffer = colorTextureData.texture;
    if (colorBuffer) colorBuffer.destroy();
    colorBuffer = backend.device.createTexture({
      label: "colorBuffer",
      size: {
        width,
        height,
        depthOrArrayLayers: 1
      },
      sampleCount: backend.utils.getSampleCount(backend.renderer.currentSamples),
      format: backend.utils.getPreferredCanvasFormat(),
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC
    });
    colorTexture.source.width = width;
    colorTexture.source.height = height;
    colorTexture.samples = samples;
    colorTextureData.texture = colorBuffer;
    return colorBuffer;
  }
  /**
   * Returns the depth buffer representing the depth
   * attachment of the default framebuffer.
   *
   * @param {boolean} [depth=true] - Whether depth is enabled or not.
   * @param {boolean} [stencil=false] -  Whether stencil is enabled or not.
   * @return {GPUTexture} The depth buffer.
   */
  getDepthBuffer(depth2 = true, stencil = false) {
    const backend = this.backend;
    const canvasTarget = backend.renderer.getCanvasTarget();
    const { width, height } = backend.getDrawingBufferSize();
    const samples = backend.renderer.currentSamples;
    const depthTexture = canvasTarget.depthTexture;
    if (depthTexture.width === width && depthTexture.height === height && depthTexture.samples === samples && depthTexture.depth === depth2 && depthTexture.stencil === stencil) {
      return backend.get(depthTexture).texture;
    }
    const depthTextureGPU = backend.get(depthTexture).texture;
    let format3, type;
    if (stencil) {
      format3 = DepthStencilFormat;
      type = UnsignedInt248Type;
    } else if (depth2) {
      format3 = DepthFormat;
      type = UnsignedIntType;
    }
    if (depthTextureGPU !== void 0) {
      if (depthTexture.image.width === width && depthTexture.image.height === height && depthTexture.format === format3 && depthTexture.type === type && depthTexture.samples === samples) {
        return depthTextureGPU;
      }
      this.destroyTexture(depthTexture);
    }
    depthTexture.name = "depthBuffer";
    depthTexture.format = format3;
    depthTexture.type = type;
    depthTexture.image.width = width;
    depthTexture.image.height = height;
    depthTexture.samples = samples;
    this.createTexture(depthTexture, { width, height });
    return backend.get(depthTexture).texture;
  }
  /**
   * Uploads the updated texture data to the GPU.
   *
   * @param {Texture} texture - The texture.
   * @param {Object} [options={}] - Optional configuration parameter.
   */
  updateTexture(texture2, options) {
    const textureData = this.backend.get(texture2);
    const mipmaps = texture2.mipmaps;
    const { textureDescriptorGPU } = textureData;
    if (texture2.isRenderTargetTexture || textureDescriptorGPU === void 0)
      return;
    if (texture2.isDataTexture) {
      if (mipmaps.length > 0) {
        for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
          const mipmap = mipmaps[i2];
          this._copyBufferToTexture(mipmap, textureData.texture, textureDescriptorGPU, 0, texture2.flipY, 0, i2);
        }
      } else {
        this._copyBufferToTexture(options.image, textureData.texture, textureDescriptorGPU, 0, texture2.flipY);
      }
    } else if (texture2.isArrayTexture || texture2.isDataArrayTexture || texture2.isData3DTexture) {
      for (let i2 = 0; i2 < options.image.depth; i2++) {
        this._copyBufferToTexture(options.image, textureData.texture, textureDescriptorGPU, i2, texture2.flipY, i2);
      }
    } else if (texture2.isCompressedTexture || texture2.isCompressedArrayTexture) {
      this._copyCompressedBufferToTexture(texture2.mipmaps, textureData.texture, textureDescriptorGPU);
    } else if (texture2.isCubeTexture) {
      this._copyCubeMapToTexture(texture2, textureData.texture, textureDescriptorGPU);
    } else {
      if (mipmaps.length > 0) {
        for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
          const mipmap = mipmaps[i2];
          this._copyImageToTexture(mipmap, textureData.texture, textureDescriptorGPU, 0, texture2.flipY, texture2.premultiplyAlpha, i2);
        }
      } else {
        this._copyImageToTexture(options.image, textureData.texture, textureDescriptorGPU, 0, texture2.flipY, texture2.premultiplyAlpha);
      }
    }
    textureData.version = texture2.version;
  }
  /**
   * Returns texture data as a typed array.
   *
   * @async
   * @param {Texture} texture - The texture to copy.
   * @param {number} x - The x coordinate of the copy origin.
   * @param {number} y - The y coordinate of the copy origin.
   * @param {number} width - The width of the copy.
   * @param {number} height - The height of the copy.
   * @param {number} faceIndex - The face index.
   * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.
   */
  async copyTextureToBuffer(texture2, x3, y3, width, height, faceIndex) {
    const device = this.backend.device;
    const textureData = this.backend.get(texture2);
    const textureGPU = textureData.texture;
    const format3 = textureData.textureDescriptorGPU.format;
    const bytesPerTexel = this._getBytesPerTexel(format3);
    let bytesPerRow = width * bytesPerTexel;
    bytesPerRow = Math.ceil(bytesPerRow / 256) * 256;
    const readBuffer = device.createBuffer(
      {
        size: (height - 1) * bytesPerRow + width * bytesPerTexel,
        // see https://github.com/mrdoob/three.js/issues/31658#issuecomment-3229442010
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
      }
    );
    const encoder = device.createCommandEncoder();
    encoder.copyTextureToBuffer(
      {
        texture: textureGPU,
        origin: { x: x3, y: y3, z: faceIndex }
      },
      {
        buffer: readBuffer,
        bytesPerRow
      },
      {
        width,
        height
      }
    );
    const typedArrayType = this._getTypedArrayType(format3);
    device.queue.submit([encoder.finish()]);
    await readBuffer.mapAsync(GPUMapMode.READ);
    const buffer2 = readBuffer.getMappedRange();
    return new typedArrayType(buffer2);
  }
  /**
   * Frees all internal resources.
   */
  dispose() {
    this._samplerCache.clear();
  }
  /**
   * Returns the default GPU texture for the given format.
   *
   * @private
   * @param {string} format - The GPU format.
   * @return {GPUTexture} The GPU texture.
   */
  _getDefaultTextureGPU(format3) {
    let defaultTexture = this.defaultTexture[format3];
    if (defaultTexture === void 0) {
      const texture2 = new Texture();
      texture2.minFilter = NearestFilter;
      texture2.magFilter = NearestFilter;
      this.createTexture(texture2, { width: 1, height: 1, format: format3 });
      this.defaultTexture[format3] = defaultTexture = texture2;
    }
    return this.backend.get(defaultTexture).texture;
  }
  /**
   * Returns the default GPU cube texture for the given format.
   *
   * @private
   * @param {string} format - The GPU format.
   * @return {GPUTexture} The GPU texture.
   */
  _getDefaultCubeTextureGPU(format3) {
    let defaultCubeTexture = this.defaultCubeTexture[format3];
    if (defaultCubeTexture === void 0) {
      const texture2 = new CubeTexture();
      texture2.minFilter = NearestFilter;
      texture2.magFilter = NearestFilter;
      this.createTexture(texture2, { width: 1, height: 1, depth: 6 });
      this.defaultCubeTexture[format3] = defaultCubeTexture = texture2;
    }
    return this.backend.get(defaultCubeTexture).texture;
  }
  /**
   * Uploads cube texture image data to the GPU memory.
   *
   * @private
   * @param {CubeTexture} texture - The cube texture.
   * @param {GPUTexture} textureGPU - The GPU texture.
   * @param {Object} textureDescriptorGPU - The GPU texture descriptor.
   */
  _copyCubeMapToTexture(texture2, textureGPU, textureDescriptorGPU) {
    const images = texture2.images;
    const mipmaps = texture2.mipmaps;
    for (let i2 = 0; i2 < 6; i2++) {
      const image = images[i2];
      const flipIndex = texture2.flipY === true ? _flipMap[i2] : i2;
      if (image.isDataTexture) {
        this._copyBufferToTexture(image.image, textureGPU, textureDescriptorGPU, flipIndex, texture2.flipY);
      } else {
        this._copyImageToTexture(image, textureGPU, textureDescriptorGPU, flipIndex, texture2.flipY, texture2.premultiplyAlpha);
      }
      for (let j2 = 0; j2 < mipmaps.length; j2++) {
        const mipmap = mipmaps[j2];
        const image2 = mipmap.images[i2];
        if (image2.isDataTexture) {
          this._copyBufferToTexture(image2.image, textureGPU, textureDescriptorGPU, flipIndex, texture2.flipY, 0, j2 + 1);
        } else {
          this._copyImageToTexture(image2, textureGPU, textureDescriptorGPU, flipIndex, texture2.flipY, texture2.premultiplyAlpha, j2 + 1);
        }
      }
    }
  }
  /**
   * Uploads texture image data to the GPU memory.
   *
   * @private
   * @param {HTMLImageElement|ImageBitmap|HTMLCanvasElement} image - The image data.
   * @param {GPUTexture} textureGPU - The GPU texture.
   * @param {Object} textureDescriptorGPU - The GPU texture descriptor.
   * @param {number} originDepth - The origin depth.
   * @param {boolean} flipY - Whether to flip texture data along their vertical axis or not.
   * @param {boolean} premultiplyAlpha - Whether the texture should have its RGB channels premultiplied by the alpha channel or not.
   * @param {number} [mipLevel=0] - The mip level where the data should be copied to.
   */
  _copyImageToTexture(image, textureGPU, textureDescriptorGPU, originDepth, flipY, premultiplyAlpha2, mipLevel = 0) {
    const device = this.backend.device;
    const width = mipLevel > 0 ? image.width : textureDescriptorGPU.size.width;
    const height = mipLevel > 0 ? image.height : textureDescriptorGPU.size.height;
    try {
      device.queue.copyExternalImageToTexture(
        {
          source: image,
          flipY
        },
        {
          texture: textureGPU,
          mipLevel,
          origin: { x: 0, y: 0, z: originDepth },
          premultipliedAlpha: premultiplyAlpha2
        },
        {
          width,
          height,
          depthOrArrayLayers: 1
        }
      );
    } catch (_2) {
    }
  }
  /**
   * Returns the pass utils singleton.
   *
   * @private
   * @return {WebGPUTexturePassUtils} The utils instance.
   */
  _getPassUtils() {
    let passUtils = this._passUtils;
    if (passUtils === null) {
      this._passUtils = passUtils = new WebGPUTexturePassUtils(this.backend.device);
    }
    return passUtils;
  }
  /**
   * Generates mipmaps for the given GPU texture.
   *
   * @private
   * @param {GPUTexture} textureGPU - The GPU texture object.
   * @param {Object} textureDescriptorGPU - The texture descriptor.
   * @param {number} [baseArrayLayer=0] - The index of the first array layer accessible to the texture view.
   * @param {?GPUCommandEncoder} [encoder=null] - An optional command encoder used to generate mipmaps.
   */
  _generateMipmaps(textureGPU, textureDescriptorGPU, baseArrayLayer = 0, encoder = null) {
    this._getPassUtils().generateMipmaps(textureGPU, textureDescriptorGPU, baseArrayLayer, encoder);
  }
  /**
   * Flip the contents of the given GPU texture along its vertical axis.
   *
   * @private
   * @param {GPUTexture} textureGPU - The GPU texture object.
   * @param {Object} textureDescriptorGPU - The texture descriptor.
   * @param {number} [originDepth=0] - The origin depth.
   */
  _flipY(textureGPU, textureDescriptorGPU, originDepth = 0) {
    this._getPassUtils().flipY(textureGPU, textureDescriptorGPU, originDepth);
  }
  /**
   * Uploads texture buffer data to the GPU memory.
   *
   * @private
   * @param {Object} image - An object defining the image buffer data.
   * @param {GPUTexture} textureGPU - The GPU texture.
   * @param {Object} textureDescriptorGPU - The GPU texture descriptor.
   * @param {number} originDepth - The origin depth.
   * @param {boolean} flipY - Whether to flip texture data along their vertical axis or not.
   * @param {number} [depth=0] - The depth offset when copying array or 3D texture data.
   * @param {number} [mipLevel=0] - The mip level where the data should be copied to.
   */
  _copyBufferToTexture(image, textureGPU, textureDescriptorGPU, originDepth, flipY, depth2 = 0, mipLevel = 0) {
    const device = this.backend.device;
    const data = image.data;
    const bytesPerTexel = this._getBytesPerTexel(textureDescriptorGPU.format);
    const bytesPerRow = image.width * bytesPerTexel;
    device.queue.writeTexture(
      {
        texture: textureGPU,
        mipLevel,
        origin: { x: 0, y: 0, z: originDepth }
      },
      data,
      {
        offset: image.width * image.height * bytesPerTexel * depth2,
        bytesPerRow
      },
      {
        width: image.width,
        height: image.height,
        depthOrArrayLayers: 1
      }
    );
    if (flipY === true) {
      this._flipY(textureGPU, textureDescriptorGPU, originDepth);
    }
  }
  /**
   * Uploads compressed texture data to the GPU memory.
   *
   * @private
   * @param {Array<Object>} mipmaps - An array with mipmap data.
   * @param {GPUTexture} textureGPU - The GPU texture.
   * @param {Object} textureDescriptorGPU - The GPU texture descriptor.
   */
  _copyCompressedBufferToTexture(mipmaps, textureGPU, textureDescriptorGPU) {
    const device = this.backend.device;
    const blockData = this._getBlockData(textureDescriptorGPU.format);
    const isArrayTexture = textureDescriptorGPU.size.depthOrArrayLayers > 1;
    for (let i2 = 0; i2 < mipmaps.length; i2++) {
      const mipmap = mipmaps[i2];
      const width = mipmap.width;
      const height = mipmap.height;
      const depth2 = isArrayTexture ? textureDescriptorGPU.size.depthOrArrayLayers : 1;
      const bytesPerRow = Math.ceil(width / blockData.width) * blockData.byteLength;
      const bytesPerImage = bytesPerRow * Math.ceil(height / blockData.height);
      for (let j2 = 0; j2 < depth2; j2++) {
        device.queue.writeTexture(
          {
            texture: textureGPU,
            mipLevel: i2,
            origin: { x: 0, y: 0, z: j2 }
          },
          mipmap.data,
          {
            offset: j2 * bytesPerImage,
            bytesPerRow,
            rowsPerImage: Math.ceil(height / blockData.height)
          },
          {
            width: Math.ceil(width / blockData.width) * blockData.width,
            height: Math.ceil(height / blockData.height) * blockData.height,
            depthOrArrayLayers: 1
          }
        );
      }
    }
  }
  /**
   * This method is only relevant for compressed texture formats. It returns a block
   * data descriptor for the given GPU compressed texture format.
   *
   * @private
   * @param {string} format - The GPU compressed texture format.
   * @return {Object} The block data descriptor.
   */
  _getBlockData(format3) {
    if (format3 === GPUTextureFormat.BC1RGBAUnorm || format3 === GPUTextureFormat.BC1RGBAUnormSRGB) return { byteLength: 8, width: 4, height: 4 };
    if (format3 === GPUTextureFormat.BC2RGBAUnorm || format3 === GPUTextureFormat.BC2RGBAUnormSRGB) return { byteLength: 16, width: 4, height: 4 };
    if (format3 === GPUTextureFormat.BC3RGBAUnorm || format3 === GPUTextureFormat.BC3RGBAUnormSRGB) return { byteLength: 16, width: 4, height: 4 };
    if (format3 === GPUTextureFormat.BC4RUnorm || format3 === GPUTextureFormat.BC4RSnorm) return { byteLength: 8, width: 4, height: 4 };
    if (format3 === GPUTextureFormat.BC5RGUnorm || format3 === GPUTextureFormat.BC5RGSnorm) return { byteLength: 16, width: 4, height: 4 };
    if (format3 === GPUTextureFormat.BC6HRGBUFloat || format3 === GPUTextureFormat.BC6HRGBFloat) return { byteLength: 16, width: 4, height: 4 };
    if (format3 === GPUTextureFormat.BC7RGBAUnorm || format3 === GPUTextureFormat.BC7RGBAUnormSRGB) return { byteLength: 16, width: 4, height: 4 };
    if (format3 === GPUTextureFormat.ETC2RGB8Unorm || format3 === GPUTextureFormat.ETC2RGB8UnormSRGB) return { byteLength: 8, width: 4, height: 4 };
    if (format3 === GPUTextureFormat.ETC2RGB8A1Unorm || format3 === GPUTextureFormat.ETC2RGB8A1UnormSRGB) return { byteLength: 8, width: 4, height: 4 };
    if (format3 === GPUTextureFormat.ETC2RGBA8Unorm || format3 === GPUTextureFormat.ETC2RGBA8UnormSRGB) return { byteLength: 16, width: 4, height: 4 };
    if (format3 === GPUTextureFormat.EACR11Unorm) return { byteLength: 8, width: 4, height: 4 };
    if (format3 === GPUTextureFormat.EACR11Snorm) return { byteLength: 8, width: 4, height: 4 };
    if (format3 === GPUTextureFormat.EACRG11Unorm) return { byteLength: 16, width: 4, height: 4 };
    if (format3 === GPUTextureFormat.EACRG11Snorm) return { byteLength: 16, width: 4, height: 4 };
    if (format3 === GPUTextureFormat.ASTC4x4Unorm || format3 === GPUTextureFormat.ASTC4x4UnormSRGB) return { byteLength: 16, width: 4, height: 4 };
    if (format3 === GPUTextureFormat.ASTC5x4Unorm || format3 === GPUTextureFormat.ASTC5x4UnormSRGB) return { byteLength: 16, width: 5, height: 4 };
    if (format3 === GPUTextureFormat.ASTC5x5Unorm || format3 === GPUTextureFormat.ASTC5x5UnormSRGB) return { byteLength: 16, width: 5, height: 5 };
    if (format3 === GPUTextureFormat.ASTC6x5Unorm || format3 === GPUTextureFormat.ASTC6x5UnormSRGB) return { byteLength: 16, width: 6, height: 5 };
    if (format3 === GPUTextureFormat.ASTC6x6Unorm || format3 === GPUTextureFormat.ASTC6x6UnormSRGB) return { byteLength: 16, width: 6, height: 6 };
    if (format3 === GPUTextureFormat.ASTC8x5Unorm || format3 === GPUTextureFormat.ASTC8x5UnormSRGB) return { byteLength: 16, width: 8, height: 5 };
    if (format3 === GPUTextureFormat.ASTC8x6Unorm || format3 === GPUTextureFormat.ASTC8x6UnormSRGB) return { byteLength: 16, width: 8, height: 6 };
    if (format3 === GPUTextureFormat.ASTC8x8Unorm || format3 === GPUTextureFormat.ASTC8x8UnormSRGB) return { byteLength: 16, width: 8, height: 8 };
    if (format3 === GPUTextureFormat.ASTC10x5Unorm || format3 === GPUTextureFormat.ASTC10x5UnormSRGB) return { byteLength: 16, width: 10, height: 5 };
    if (format3 === GPUTextureFormat.ASTC10x6Unorm || format3 === GPUTextureFormat.ASTC10x6UnormSRGB) return { byteLength: 16, width: 10, height: 6 };
    if (format3 === GPUTextureFormat.ASTC10x8Unorm || format3 === GPUTextureFormat.ASTC10x8UnormSRGB) return { byteLength: 16, width: 10, height: 8 };
    if (format3 === GPUTextureFormat.ASTC10x10Unorm || format3 === GPUTextureFormat.ASTC10x10UnormSRGB) return { byteLength: 16, width: 10, height: 10 };
    if (format3 === GPUTextureFormat.ASTC12x10Unorm || format3 === GPUTextureFormat.ASTC12x10UnormSRGB) return { byteLength: 16, width: 12, height: 10 };
    if (format3 === GPUTextureFormat.ASTC12x12Unorm || format3 === GPUTextureFormat.ASTC12x12UnormSRGB) return { byteLength: 16, width: 12, height: 12 };
  }
  /**
   * Converts the three.js uv wrapping constants to GPU address mode constants.
   *
   * @private
   * @param {number} value - The three.js constant defining a uv wrapping mode.
   * @return {string} The GPU address mode.
   */
  _convertAddressMode(value) {
    let addressMode = GPUAddressMode.ClampToEdge;
    if (value === RepeatWrapping) {
      addressMode = GPUAddressMode.Repeat;
    } else if (value === MirroredRepeatWrapping) {
      addressMode = GPUAddressMode.MirrorRepeat;
    }
    return addressMode;
  }
  /**
   * Converts the three.js filter constants to GPU filter constants.
   *
   * @private
   * @param {number} value - The three.js constant defining a filter mode.
   * @return {string} The GPU filter mode.
   */
  _convertFilterMode(value) {
    let filterMode = GPUFilterMode.Linear;
    if (value === NearestFilter || value === NearestMipmapNearestFilter || value === NearestMipmapLinearFilter) {
      filterMode = GPUFilterMode.Nearest;
    }
    return filterMode;
  }
  /**
   * Returns the bytes-per-texel value for the given GPU texture format.
   *
   * @private
   * @param {string} format - The GPU texture format.
   * @return {number} The bytes-per-texel.
   */
  _getBytesPerTexel(format3) {
    if (format3 === GPUTextureFormat.R8Unorm || format3 === GPUTextureFormat.R8Snorm || format3 === GPUTextureFormat.R8Uint || format3 === GPUTextureFormat.R8Sint) return 1;
    if (format3 === GPUTextureFormat.R16Uint || format3 === GPUTextureFormat.R16Sint || format3 === GPUTextureFormat.R16Float || format3 === GPUTextureFormat.RG8Unorm || format3 === GPUTextureFormat.RG8Snorm || format3 === GPUTextureFormat.RG8Uint || format3 === GPUTextureFormat.RG8Sint) return 2;
    if (format3 === GPUTextureFormat.R32Uint || format3 === GPUTextureFormat.R32Sint || format3 === GPUTextureFormat.R32Float || format3 === GPUTextureFormat.RG16Uint || format3 === GPUTextureFormat.RG16Sint || format3 === GPUTextureFormat.RG16Float || format3 === GPUTextureFormat.RGBA8Unorm || format3 === GPUTextureFormat.RGBA8UnormSRGB || format3 === GPUTextureFormat.RGBA8Snorm || format3 === GPUTextureFormat.RGBA8Uint || format3 === GPUTextureFormat.RGBA8Sint || format3 === GPUTextureFormat.BGRA8Unorm || format3 === GPUTextureFormat.BGRA8UnormSRGB || // Packed 32-bit formats
    format3 === GPUTextureFormat.RGB9E5UFloat || format3 === GPUTextureFormat.RGB10A2Unorm || format3 === GPUTextureFormat.RG11B10UFloat || format3 === GPUTextureFormat.Depth32Float || format3 === GPUTextureFormat.Depth24Plus || format3 === GPUTextureFormat.Depth24PlusStencil8 || format3 === GPUTextureFormat.Depth32FloatStencil8) return 4;
    if (format3 === GPUTextureFormat.RG32Uint || format3 === GPUTextureFormat.RG32Sint || format3 === GPUTextureFormat.RG32Float || format3 === GPUTextureFormat.RGBA16Uint || format3 === GPUTextureFormat.RGBA16Sint || format3 === GPUTextureFormat.RGBA16Float) return 8;
    if (format3 === GPUTextureFormat.RGBA32Uint || format3 === GPUTextureFormat.RGBA32Sint || format3 === GPUTextureFormat.RGBA32Float) return 16;
  }
  /**
   * Returns the corresponding typed array type for the given GPU texture format.
   *
   * @private
   * @param {string} format - The GPU texture format.
   * @return {TypedArray.constructor} The typed array type.
   */
  _getTypedArrayType(format3) {
    if (format3 === GPUTextureFormat.R8Uint) return Uint8Array;
    if (format3 === GPUTextureFormat.R8Sint) return Int8Array;
    if (format3 === GPUTextureFormat.R8Unorm) return Uint8Array;
    if (format3 === GPUTextureFormat.R8Snorm) return Int8Array;
    if (format3 === GPUTextureFormat.RG8Uint) return Uint8Array;
    if (format3 === GPUTextureFormat.RG8Sint) return Int8Array;
    if (format3 === GPUTextureFormat.RG8Unorm) return Uint8Array;
    if (format3 === GPUTextureFormat.RG8Snorm) return Int8Array;
    if (format3 === GPUTextureFormat.RGBA8Uint) return Uint8Array;
    if (format3 === GPUTextureFormat.RGBA8Sint) return Int8Array;
    if (format3 === GPUTextureFormat.RGBA8Unorm || format3 === GPUTextureFormat.RGBA8UnormSRGB) return Uint8Array;
    if (format3 === GPUTextureFormat.RGBA8Snorm) return Int8Array;
    if (format3 === GPUTextureFormat.R16Uint) return Uint16Array;
    if (format3 === GPUTextureFormat.R16Sint) return Int16Array;
    if (format3 === GPUTextureFormat.RG16Uint) return Uint16Array;
    if (format3 === GPUTextureFormat.RG16Sint) return Int16Array;
    if (format3 === GPUTextureFormat.RGBA16Uint) return Uint16Array;
    if (format3 === GPUTextureFormat.RGBA16Sint) return Int16Array;
    if (format3 === GPUTextureFormat.R16Float) return Uint16Array;
    if (format3 === GPUTextureFormat.RG16Float) return Uint16Array;
    if (format3 === GPUTextureFormat.RGBA16Float) return Uint16Array;
    if (format3 === GPUTextureFormat.R32Uint) return Uint32Array;
    if (format3 === GPUTextureFormat.R32Sint) return Int32Array;
    if (format3 === GPUTextureFormat.R32Float) return Float32Array;
    if (format3 === GPUTextureFormat.RG32Uint) return Uint32Array;
    if (format3 === GPUTextureFormat.RG32Sint) return Int32Array;
    if (format3 === GPUTextureFormat.RG32Float) return Float32Array;
    if (format3 === GPUTextureFormat.RGBA32Uint) return Uint32Array;
    if (format3 === GPUTextureFormat.RGBA32Sint) return Int32Array;
    if (format3 === GPUTextureFormat.RGBA32Float) return Float32Array;
    if (format3 === GPUTextureFormat.BGRA8Unorm || format3 === GPUTextureFormat.BGRA8UnormSRGB) return Uint8Array;
    if (format3 === GPUTextureFormat.RGB10A2Unorm) return Uint32Array;
    if (format3 === GPUTextureFormat.RGB9E5UFloat) return Uint32Array;
    if (format3 === GPUTextureFormat.RG11B10UFloat) return Uint32Array;
    if (format3 === GPUTextureFormat.Depth32Float) return Float32Array;
    if (format3 === GPUTextureFormat.Depth24Plus) return Uint32Array;
    if (format3 === GPUTextureFormat.Depth24PlusStencil8) return Uint32Array;
    if (format3 === GPUTextureFormat.Depth32FloatStencil8) return Float32Array;
  }
  /**
   * Returns the GPU dimensions for the given texture.
   *
   * @private
   * @param {Texture} texture - The texture.
   * @return {string} The GPU dimension.
   */
  _getDimension(texture2) {
    let dimension;
    if (texture2.is3DTexture || texture2.isData3DTexture) {
      dimension = GPUTextureDimension.ThreeD;
    } else {
      dimension = GPUTextureDimension.TwoD;
    }
    return dimension;
  }
};
function getFormat2(texture2, device = null) {
  const format3 = texture2.format;
  const type = texture2.type;
  const colorSpace = texture2.colorSpace;
  const transfer = ColorManagement.getTransfer(colorSpace);
  let formatGPU;
  if (texture2.isCompressedTexture === true || texture2.isCompressedArrayTexture === true) {
    switch (format3) {
      case RGB_S3TC_DXT1_Format:
      case RGBA_S3TC_DXT1_Format:
        formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.BC1RGBAUnormSRGB : GPUTextureFormat.BC1RGBAUnorm;
        break;
      case RGBA_S3TC_DXT3_Format:
        formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.BC2RGBAUnormSRGB : GPUTextureFormat.BC2RGBAUnorm;
        break;
      case RGBA_S3TC_DXT5_Format:
        formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.BC3RGBAUnormSRGB : GPUTextureFormat.BC3RGBAUnorm;
        break;
      case RED_RGTC1_Format:
        formatGPU = GPUTextureFormat.BC4RUnorm;
        break;
      case SIGNED_RED_RGTC1_Format:
        formatGPU = GPUTextureFormat.BC4RSnorm;
        break;
      case RED_GREEN_RGTC2_Format:
        formatGPU = GPUTextureFormat.BC5RGUnorm;
        break;
      case SIGNED_RED_GREEN_RGTC2_Format:
        formatGPU = GPUTextureFormat.BC5RGSnorm;
        break;
      case RGBA_BPTC_Format:
        formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.BC7RGBAUnormSRGB : GPUTextureFormat.BC7RGBAUnorm;
        break;
      case RGB_ETC2_Format:
      case RGB_ETC1_Format:
        formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.ETC2RGB8UnormSRGB : GPUTextureFormat.ETC2RGB8Unorm;
        break;
      case RGBA_ETC2_EAC_Format:
        formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.ETC2RGBA8UnormSRGB : GPUTextureFormat.ETC2RGBA8Unorm;
        break;
      case R11_EAC_Format:
        formatGPU = GPUTextureFormat.EACR11Unorm;
        break;
      case SIGNED_R11_EAC_Format:
        formatGPU = GPUTextureFormat.EACR11Snorm;
        break;
      case RG11_EAC_Format:
        formatGPU = GPUTextureFormat.EACRG11Unorm;
        break;
      case SIGNED_RG11_EAC_Format:
        formatGPU = GPUTextureFormat.EACRG11Snorm;
        break;
      case RGBA_ASTC_4x4_Format:
        formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.ASTC4x4UnormSRGB : GPUTextureFormat.ASTC4x4Unorm;
        break;
      case RGBA_ASTC_5x4_Format:
        formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.ASTC5x4UnormSRGB : GPUTextureFormat.ASTC5x4Unorm;
        break;
      case RGBA_ASTC_5x5_Format:
        formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.ASTC5x5UnormSRGB : GPUTextureFormat.ASTC5x5Unorm;
        break;
      case RGBA_ASTC_6x5_Format:
        formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.ASTC6x5UnormSRGB : GPUTextureFormat.ASTC6x5Unorm;
        break;
      case RGBA_ASTC_6x6_Format:
        formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.ASTC6x6UnormSRGB : GPUTextureFormat.ASTC6x6Unorm;
        break;
      case RGBA_ASTC_8x5_Format:
        formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.ASTC8x5UnormSRGB : GPUTextureFormat.ASTC8x5Unorm;
        break;
      case RGBA_ASTC_8x6_Format:
        formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.ASTC8x6UnormSRGB : GPUTextureFormat.ASTC8x6Unorm;
        break;
      case RGBA_ASTC_8x8_Format:
        formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.ASTC8x8UnormSRGB : GPUTextureFormat.ASTC8x8Unorm;
        break;
      case RGBA_ASTC_10x5_Format:
        formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.ASTC10x5UnormSRGB : GPUTextureFormat.ASTC10x5Unorm;
        break;
      case RGBA_ASTC_10x6_Format:
        formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.ASTC10x6UnormSRGB : GPUTextureFormat.ASTC10x6Unorm;
        break;
      case RGBA_ASTC_10x8_Format:
        formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.ASTC10x8UnormSRGB : GPUTextureFormat.ASTC10x8Unorm;
        break;
      case RGBA_ASTC_10x10_Format:
        formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.ASTC10x10UnormSRGB : GPUTextureFormat.ASTC10x10Unorm;
        break;
      case RGBA_ASTC_12x10_Format:
        formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.ASTC12x10UnormSRGB : GPUTextureFormat.ASTC12x10Unorm;
        break;
      case RGBA_ASTC_12x12_Format:
        formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.ASTC12x12UnormSRGB : GPUTextureFormat.ASTC12x12Unorm;
        break;
      case RGBAFormat:
        formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.RGBA8UnormSRGB : GPUTextureFormat.RGBA8Unorm;
        break;
      default:
        error("WebGPURenderer: Unsupported texture format.", format3);
    }
  } else {
    switch (format3) {
      case RGBAFormat:
        switch (type) {
          case ByteType:
            formatGPU = GPUTextureFormat.RGBA8Snorm;
            break;
          case ShortType:
            formatGPU = GPUTextureFormat.RGBA16Sint;
            break;
          case UnsignedShortType:
            formatGPU = GPUTextureFormat.RGBA16Uint;
            break;
          case UnsignedIntType:
            formatGPU = GPUTextureFormat.RGBA32Uint;
            break;
          case IntType:
            formatGPU = GPUTextureFormat.RGBA32Sint;
            break;
          case UnsignedByteType:
            formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.RGBA8UnormSRGB : GPUTextureFormat.RGBA8Unorm;
            break;
          case HalfFloatType:
            formatGPU = GPUTextureFormat.RGBA16Float;
            break;
          case FloatType:
            formatGPU = GPUTextureFormat.RGBA32Float;
            break;
          default:
            error("WebGPURenderer: Unsupported texture type with RGBAFormat.", type);
        }
        break;
      case RGBFormat:
        switch (type) {
          case UnsignedInt5999Type:
            formatGPU = GPUTextureFormat.RGB9E5UFloat;
            break;
          case UnsignedInt101111Type:
            formatGPU = GPUTextureFormat.RG11B10UFloat;
            break;
          default:
            error("WebGPURenderer: Unsupported texture type with RGBFormat.", type);
        }
        break;
      case RedFormat:
        switch (type) {
          case ByteType:
            formatGPU = GPUTextureFormat.R8Snorm;
            break;
          case ShortType:
            formatGPU = GPUTextureFormat.R16Sint;
            break;
          case UnsignedShortType:
            formatGPU = GPUTextureFormat.R16Uint;
            break;
          case UnsignedIntType:
            formatGPU = GPUTextureFormat.R32Uint;
            break;
          case IntType:
            formatGPU = GPUTextureFormat.R32Sint;
            break;
          case UnsignedByteType:
            formatGPU = GPUTextureFormat.R8Unorm;
            break;
          case HalfFloatType:
            formatGPU = GPUTextureFormat.R16Float;
            break;
          case FloatType:
            formatGPU = GPUTextureFormat.R32Float;
            break;
          default:
            error("WebGPURenderer: Unsupported texture type with RedFormat.", type);
        }
        break;
      case RGFormat:
        switch (type) {
          case ByteType:
            formatGPU = GPUTextureFormat.RG8Snorm;
            break;
          case ShortType:
            formatGPU = GPUTextureFormat.RG16Sint;
            break;
          case UnsignedShortType:
            formatGPU = GPUTextureFormat.RG16Uint;
            break;
          case UnsignedIntType:
            formatGPU = GPUTextureFormat.RG32Uint;
            break;
          case IntType:
            formatGPU = GPUTextureFormat.RG32Sint;
            break;
          case UnsignedByteType:
            formatGPU = GPUTextureFormat.RG8Unorm;
            break;
          case HalfFloatType:
            formatGPU = GPUTextureFormat.RG16Float;
            break;
          case FloatType:
            formatGPU = GPUTextureFormat.RG32Float;
            break;
          default:
            error("WebGPURenderer: Unsupported texture type with RGFormat.", type);
        }
        break;
      case DepthFormat:
        switch (type) {
          case UnsignedShortType:
            formatGPU = GPUTextureFormat.Depth16Unorm;
            break;
          case UnsignedIntType:
            formatGPU = GPUTextureFormat.Depth24Plus;
            break;
          case FloatType:
            formatGPU = GPUTextureFormat.Depth32Float;
            break;
          default:
            error("WebGPURenderer: Unsupported texture type with DepthFormat.", type);
        }
        break;
      case DepthStencilFormat:
        switch (type) {
          case UnsignedInt248Type:
            formatGPU = GPUTextureFormat.Depth24PlusStencil8;
            break;
          case FloatType:
            if (device && device.features.has(GPUFeatureName.Depth32FloatStencil8) === false) {
              error('WebGPURenderer: Depth textures with DepthStencilFormat + FloatType can only be used with the "depth32float-stencil8" GPU feature.');
            }
            formatGPU = GPUTextureFormat.Depth32FloatStencil8;
            break;
          default:
            error("WebGPURenderer: Unsupported texture type with DepthStencilFormat.", type);
        }
        break;
      case RedIntegerFormat:
        switch (type) {
          case IntType:
            formatGPU = GPUTextureFormat.R32Sint;
            break;
          case UnsignedIntType:
            formatGPU = GPUTextureFormat.R32Uint;
            break;
          default:
            error("WebGPURenderer: Unsupported texture type with RedIntegerFormat.", type);
        }
        break;
      case RGIntegerFormat:
        switch (type) {
          case IntType:
            formatGPU = GPUTextureFormat.RG32Sint;
            break;
          case UnsignedIntType:
            formatGPU = GPUTextureFormat.RG32Uint;
            break;
          default:
            error("WebGPURenderer: Unsupported texture type with RGIntegerFormat.", type);
        }
        break;
      case RGBAIntegerFormat:
        switch (type) {
          case IntType:
            formatGPU = GPUTextureFormat.RGBA32Sint;
            break;
          case UnsignedIntType:
            formatGPU = GPUTextureFormat.RGBA32Uint;
            break;
          default:
            error("WebGPURenderer: Unsupported texture type with RGBAIntegerFormat.", type);
        }
        break;
      default:
        error("WebGPURenderer: Unsupported texture format.", format3);
    }
  }
  return formatGPU;
}
var declarationRegexp = /^[fn]*\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)\s*[\-\>]*\s*([a-z_0-9]+(?:<[\s\S]+?>)?)/i;
var propertiesRegexp = /([a-z_0-9]+)\s*:\s*([a-z_0-9]+(?:<[\s\S]+?>)?)/ig;
var wgslTypeLib$1 = {
  "f32": "float",
  "i32": "int",
  "u32": "uint",
  "bool": "bool",
  "vec2<f32>": "vec2",
  "vec2<i32>": "ivec2",
  "vec2<u32>": "uvec2",
  "vec2<bool>": "bvec2",
  "vec2f": "vec2",
  "vec2i": "ivec2",
  "vec2u": "uvec2",
  "vec2b": "bvec2",
  "vec3<f32>": "vec3",
  "vec3<i32>": "ivec3",
  "vec3<u32>": "uvec3",
  "vec3<bool>": "bvec3",
  "vec3f": "vec3",
  "vec3i": "ivec3",
  "vec3u": "uvec3",
  "vec3b": "bvec3",
  "vec4<f32>": "vec4",
  "vec4<i32>": "ivec4",
  "vec4<u32>": "uvec4",
  "vec4<bool>": "bvec4",
  "vec4f": "vec4",
  "vec4i": "ivec4",
  "vec4u": "uvec4",
  "vec4b": "bvec4",
  "mat2x2<f32>": "mat2",
  "mat2x2f": "mat2",
  "mat3x3<f32>": "mat3",
  "mat3x3f": "mat3",
  "mat4x4<f32>": "mat4",
  "mat4x4f": "mat4",
  "sampler": "sampler",
  "texture_1d": "texture",
  "texture_2d": "texture",
  "texture_2d_array": "texture",
  "texture_multisampled_2d": "cubeTexture",
  "texture_depth_2d": "depthTexture",
  "texture_depth_2d_array": "depthTexture",
  "texture_depth_multisampled_2d": "depthTexture",
  "texture_depth_cube": "depthTexture",
  "texture_depth_cube_array": "depthTexture",
  "texture_3d": "texture3D",
  "texture_cube": "cubeTexture",
  "texture_cube_array": "cubeTexture",
  "texture_storage_1d": "storageTexture",
  "texture_storage_2d": "storageTexture",
  "texture_storage_2d_array": "storageTexture",
  "texture_storage_3d": "storageTexture"
};
var parse = (source) => {
  source = source.trim();
  const declaration = source.match(declarationRegexp);
  if (declaration !== null && declaration.length === 4) {
    const inputsCode = declaration[2];
    const propsMatches = [];
    let match = null;
    while ((match = propertiesRegexp.exec(inputsCode)) !== null) {
      propsMatches.push({ name: match[1], type: match[2] });
    }
    const inputs = [];
    for (let i2 = 0; i2 < propsMatches.length; i2++) {
      const { name: name2, type: type2 } = propsMatches[i2];
      let resolvedType = type2;
      if (resolvedType.startsWith("ptr")) {
        resolvedType = "pointer";
      } else {
        if (resolvedType.startsWith("texture")) {
          resolvedType = type2.split("<")[0];
        }
        resolvedType = wgslTypeLib$1[resolvedType];
      }
      inputs.push(new NodeFunctionInput(resolvedType, name2));
    }
    const blockCode = source.substring(declaration[0].length);
    const outputType = declaration[3] || "void";
    const name = declaration[1] !== void 0 ? declaration[1] : "";
    const type = wgslTypeLib$1[outputType] || outputType;
    return {
      type,
      inputs,
      name,
      inputsCode,
      blockCode,
      outputType
    };
  } else {
    throw new Error("FunctionNode: Function is not a WGSL code.");
  }
};
var WGSLNodeFunction = class extends NodeFunction {
  /**
   * Constructs a new WGSL node function.
   *
   * @param {string} source - The WGSL source.
   */
  constructor(source) {
    const { type, inputs, name, inputsCode, blockCode, outputType } = parse(source);
    super(type, inputs, name);
    this.inputsCode = inputsCode;
    this.blockCode = blockCode;
    this.outputType = outputType;
  }
  /**
   * This method returns the WGSL code of the node function.
   *
   * @param {string} [name=this.name] - The function's name.
   * @return {string} The shader code.
   */
  getCode(name = this.name) {
    const outputType = this.outputType !== "void" ? "-> " + this.outputType : "";
    return `fn ${name} ( ${this.inputsCode.trim()} ) ${outputType}` + this.blockCode;
  }
};
var WGSLNodeParser = class extends NodeParser {
  /**
   * The method parses the given WGSL code an returns a node function.
   *
   * @param {string} source - The WGSL code.
   * @return {WGSLNodeFunction} A node function.
   */
  parseFunction(source) {
    return new WGSLNodeFunction(source);
  }
};
var accessNames = {
  [NodeAccess.READ_ONLY]: "read",
  [NodeAccess.WRITE_ONLY]: "write",
  [NodeAccess.READ_WRITE]: "read_write"
};
var wrapNames = {
  [RepeatWrapping]: "repeat",
  [ClampToEdgeWrapping]: "clamp",
  [MirroredRepeatWrapping]: "mirror"
};
var gpuShaderStageLib = {
  "vertex": GPUShaderStage.VERTEX,
  "fragment": GPUShaderStage.FRAGMENT,
  "compute": GPUShaderStage.COMPUTE
};
var supports = {
  instance: true,
  swizzleAssign: false,
  storageBuffer: true
};
var wgslFnOpLib = {
  "^^": "tsl_xor"
};
var wgslTypeLib = {
  float: "f32",
  int: "i32",
  uint: "u32",
  bool: "bool",
  color: "vec3<f32>",
  vec2: "vec2<f32>",
  ivec2: "vec2<i32>",
  uvec2: "vec2<u32>",
  bvec2: "vec2<bool>",
  vec3: "vec3<f32>",
  ivec3: "vec3<i32>",
  uvec3: "vec3<u32>",
  bvec3: "vec3<bool>",
  vec4: "vec4<f32>",
  ivec4: "vec4<i32>",
  uvec4: "vec4<u32>",
  bvec4: "vec4<bool>",
  mat2: "mat2x2<f32>",
  mat3: "mat3x3<f32>",
  mat4: "mat4x4<f32>"
};
var wgslCodeCache = {};
var wgslPolyfill = {
  tsl_xor: new CodeNode("fn tsl_xor( a : bool, b : bool ) -> bool { return ( a || b ) && !( a && b ); }"),
  mod_float: new CodeNode("fn tsl_mod_float( x : f32, y : f32 ) -> f32 { return x - y * floor( x / y ); }"),
  mod_vec2: new CodeNode("fn tsl_mod_vec2( x : vec2f, y : vec2f ) -> vec2f { return x - y * floor( x / y ); }"),
  mod_vec3: new CodeNode("fn tsl_mod_vec3( x : vec3f, y : vec3f ) -> vec3f { return x - y * floor( x / y ); }"),
  mod_vec4: new CodeNode("fn tsl_mod_vec4( x : vec4f, y : vec4f ) -> vec4f { return x - y * floor( x / y ); }"),
  equals_bool: new CodeNode("fn tsl_equals_bool( a : bool, b : bool ) -> bool { return a == b; }"),
  equals_bvec2: new CodeNode("fn tsl_equals_bvec2( a : vec2f, b : vec2f ) -> vec2<bool> { return vec2<bool>( a.x == b.x, a.y == b.y ); }"),
  equals_bvec3: new CodeNode("fn tsl_equals_bvec3( a : vec3f, b : vec3f ) -> vec3<bool> { return vec3<bool>( a.x == b.x, a.y == b.y, a.z == b.z ); }"),
  equals_bvec4: new CodeNode("fn tsl_equals_bvec4( a : vec4f, b : vec4f ) -> vec4<bool> { return vec4<bool>( a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w ); }"),
  repeatWrapping_float: new CodeNode("fn tsl_repeatWrapping_float( coord: f32 ) -> f32 { return fract( coord ); }"),
  mirrorWrapping_float: new CodeNode("fn tsl_mirrorWrapping_float( coord: f32 ) -> f32 { let mirrored = fract( coord * 0.5 ) * 2.0; return 1.0 - abs( 1.0 - mirrored ); }"),
  clampWrapping_float: new CodeNode("fn tsl_clampWrapping_float( coord: f32 ) -> f32 { return clamp( coord, 0.0, 1.0 ); }"),
  biquadraticTexture: new CodeNode(
    /* wgsl */
    `
fn tsl_biquadraticTexture( map : texture_2d<f32>, coord : vec2f, iRes : vec2u, level : u32 ) -> vec4f {

	let res = vec2f( iRes );

	let uvScaled = coord * res;
	let uvWrapping = ( ( uvScaled % res ) + res ) % res;

	// https://www.shadertoy.com/view/WtyXRy

	let uv = uvWrapping - 0.5;
	let iuv = floor( uv );
	let f = fract( uv );

	let rg1 = textureLoad( map, vec2u( iuv + vec2( 0.5, 0.5 ) ) % iRes, level );
	let rg2 = textureLoad( map, vec2u( iuv + vec2( 1.5, 0.5 ) ) % iRes, level );
	let rg3 = textureLoad( map, vec2u( iuv + vec2( 0.5, 1.5 ) ) % iRes, level );
	let rg4 = textureLoad( map, vec2u( iuv + vec2( 1.5, 1.5 ) ) % iRes, level );

	return mix( mix( rg1, rg2, f.x ), mix( rg3, rg4, f.x ), f.y );

}
`
  )
};
var wgslMethods = {
  dFdx: "dpdx",
  dFdy: "- dpdy",
  mod_float: "tsl_mod_float",
  mod_vec2: "tsl_mod_vec2",
  mod_vec3: "tsl_mod_vec3",
  mod_vec4: "tsl_mod_vec4",
  equals_bool: "tsl_equals_bool",
  equals_bvec2: "tsl_equals_bvec2",
  equals_bvec3: "tsl_equals_bvec3",
  equals_bvec4: "tsl_equals_bvec4",
  inversesqrt: "inverseSqrt",
  bitcast: "bitcast<f32>",
  floatpack_snorm_2x16: "pack2x16snorm",
  floatpack_unorm_2x16: "pack2x16unorm",
  floatpack_float16_2x16: "pack2x16float",
  floatunpack_snorm_2x16: "unpack2x16snorm",
  floatunpack_unorm_2x16: "unpack2x16unorm",
  floatunpack_float16_2x16: "unpack2x16float"
};
var diagnostics = "";
if ((typeof navigator !== "undefined" && /Firefox|Deno/g.test(navigator.userAgent)) !== true) {
  diagnostics += "diagnostic( off, derivative_uniformity );\n";
}
var WGSLNodeBuilder = class extends NodeBuilder {
  /**
   * Constructs a new WGSL node builder renderer.
   *
   * @param {Object3D} object - The 3D object.
   * @param {Renderer} renderer - The renderer.
   */
  constructor(object, renderer3) {
    super(object, renderer3, new WGSLNodeParser());
    this.uniformGroups = {};
    this.builtins = {};
    this.directives = {};
    this.scopedArrays = /* @__PURE__ */ new Map();
  }
  /**
   * Generates the WGSL snippet for sampled textures.
   *
   * @private
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
   * @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The WGSL snippet.
   */
  _generateTextureSample(texture2, textureProperty, uvSnippet, depthSnippet, offsetSnippet, shaderStage = this.shaderStage) {
    if (shaderStage === "fragment") {
      if (depthSnippet) {
        if (offsetSnippet) {
          return `textureSample( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${depthSnippet}, ${offsetSnippet} )`;
        }
        return `textureSample( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${depthSnippet} )`;
      } else {
        if (offsetSnippet) {
          return `textureSample( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${offsetSnippet} )`;
        }
        return `textureSample( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet} )`;
      }
    } else {
      return this.generateTextureSampleLevel(texture2, textureProperty, uvSnippet, "0", depthSnippet);
    }
  }
  /**
   * Generates the WGSL snippet when sampling textures with explicit mip level.
   *
   * @private
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {string} levelSnippet - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
   * @param {string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
   * @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
   * @return {string} The WGSL snippet.
   */
  generateTextureSampleLevel(texture2, textureProperty, uvSnippet, levelSnippet, depthSnippet, offsetSnippet) {
    if (this.isUnfilterable(texture2) === false) {
      if (offsetSnippet) {
        return `textureSampleLevel( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${levelSnippet}, ${offsetSnippet} )`;
      }
      return `textureSampleLevel( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${levelSnippet} )`;
    } else if (this.isFilteredTexture(texture2)) {
      return this.generateFilteredTexture(texture2, textureProperty, uvSnippet, offsetSnippet, levelSnippet);
    } else {
      return this.generateTextureLod(texture2, textureProperty, uvSnippet, depthSnippet, offsetSnippet, levelSnippet);
    }
  }
  /**
   * Generates a wrap function used in context of textures.
   *
   * @param {Texture} texture - The texture to generate the function for.
   * @return {string} The name of the generated function.
   */
  generateWrapFunction(texture2) {
    const functionName = `tsl_coord_${wrapNames[texture2.wrapS]}S_${wrapNames[texture2.wrapT]}_${texture2.is3DTexture || texture2.isData3DTexture ? "3d" : "2d"}T`;
    let nodeCode = wgslCodeCache[functionName];
    if (nodeCode === void 0) {
      const includes2 = [];
      const coordType = texture2.is3DTexture || texture2.isData3DTexture ? "vec3f" : "vec2f";
      let code2 = `fn ${functionName}( coord : ${coordType} ) -> ${coordType} {

	return ${coordType}(
`;
      const addWrapSnippet = (wrap2, axis) => {
        if (wrap2 === RepeatWrapping) {
          includes2.push(wgslPolyfill.repeatWrapping_float);
          code2 += `		tsl_repeatWrapping_float( coord.${axis} )`;
        } else if (wrap2 === ClampToEdgeWrapping) {
          includes2.push(wgslPolyfill.clampWrapping_float);
          code2 += `		tsl_clampWrapping_float( coord.${axis} )`;
        } else if (wrap2 === MirroredRepeatWrapping) {
          includes2.push(wgslPolyfill.mirrorWrapping_float);
          code2 += `		tsl_mirrorWrapping_float( coord.${axis} )`;
        } else {
          code2 += `		coord.${axis}`;
          warn(`WebGPURenderer: Unsupported texture wrap type "${wrap2}" for vertex shader.`);
        }
      };
      addWrapSnippet(texture2.wrapS, "x");
      code2 += ",\n";
      addWrapSnippet(texture2.wrapT, "y");
      if (texture2.is3DTexture || texture2.isData3DTexture) {
        code2 += ",\n";
        addWrapSnippet(texture2.wrapR, "z");
      }
      code2 += "\n	);\n\n}\n";
      wgslCodeCache[functionName] = nodeCode = new CodeNode(code2, includes2);
    }
    nodeCode.build(this);
    return functionName;
  }
  /**
   * Generates the array declaration string.
   *
   * @param {string} type - The type.
   * @param {?number} [count] - The count.
   * @return {string} The generated value as a shader string.
   */
  generateArrayDeclaration(type, count2) {
    return `array< ${this.getType(type)}, ${count2} >`;
  }
  /**
   * Generates a WGSL variable that holds the texture dimension of the given texture.
   * It also returns information about the number of layers (elements) of an arrayed
   * texture as well as the cube face count of cube textures.
   *
   * @param {Texture} texture - The texture to generate the function for.
   * @param {string} textureProperty - The name of the video texture uniform in the shader.
   * @param {string} levelSnippet - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
   * @return {string} The name of the dimension variable.
   */
  generateTextureDimension(texture2, textureProperty, levelSnippet) {
    const textureData = this.getDataFromNode(texture2, this.shaderStage, this.globalCache);
    if (textureData.dimensionsSnippet === void 0) textureData.dimensionsSnippet = {};
    let textureDimensionNode = textureData.dimensionsSnippet[levelSnippet];
    if (textureData.dimensionsSnippet[levelSnippet] === void 0) {
      let textureDimensionsParams;
      let dimensionType;
      const { primarySamples } = this.renderer.backend.utils.getTextureSampleData(texture2);
      const isMultisampled = primarySamples > 1;
      if (texture2.is3DTexture || texture2.isData3DTexture) {
        dimensionType = "vec3<u32>";
      } else {
        dimensionType = "vec2<u32>";
      }
      if (isMultisampled || texture2.isStorageTexture) {
        textureDimensionsParams = textureProperty;
      } else {
        textureDimensionsParams = `${textureProperty}${levelSnippet ? `, u32( ${levelSnippet} )` : ""}`;
      }
      textureDimensionNode = new VarNode(new ExpressionNode(`textureDimensions( ${textureDimensionsParams} )`, dimensionType));
      textureData.dimensionsSnippet[levelSnippet] = textureDimensionNode;
      if (texture2.isArrayTexture || texture2.isDataArrayTexture || texture2.is3DTexture || texture2.isData3DTexture) {
        textureData.arrayLayerCount = new VarNode(
          new ExpressionNode(
            `textureNumLayers(${textureProperty})`,
            "u32"
          )
        );
      }
      if (texture2.isTextureCube) {
        textureData.cubeFaceCount = new VarNode(
          new ExpressionNode("6u", "u32")
        );
      }
    }
    return textureDimensionNode.build(this);
  }
  /**
   * Generates the WGSL snippet for a manual filtered texture.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
   * @param {string} [levelSnippet='0u'] - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
   * @return {string} The WGSL snippet.
   */
  generateFilteredTexture(texture2, textureProperty, uvSnippet, offsetSnippet, levelSnippet = "0u") {
    this._include("biquadraticTexture");
    const wrapFunction = this.generateWrapFunction(texture2);
    const textureDimension = this.generateTextureDimension(texture2, textureProperty, levelSnippet);
    if (offsetSnippet) {
      uvSnippet = `${uvSnippet} + vec2<f32>(${offsetSnippet}) / ${textureDimension}`;
    }
    return `tsl_biquadraticTexture( ${textureProperty}, ${wrapFunction}( ${uvSnippet} ), ${textureDimension}, u32( ${levelSnippet} ) )`;
  }
  /**
   * Generates the WGSL snippet for a texture lookup with explicit level-of-detail.
   * Since it's a lookup, no sampling or filtering is applied.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
   * @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
   * @param {string} [levelSnippet='0u'] - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
   * @return {string} The WGSL snippet.
   */
  generateTextureLod(texture2, textureProperty, uvSnippet, depthSnippet, offsetSnippet, levelSnippet = "0u") {
    const wrapFunction = this.generateWrapFunction(texture2);
    const textureDimension = this.generateTextureDimension(texture2, textureProperty, levelSnippet);
    const vecType = texture2.is3DTexture || texture2.isData3DTexture ? "vec3" : "vec2";
    if (offsetSnippet) {
      uvSnippet = `${uvSnippet} + ${vecType}<f32>(${offsetSnippet}) / ${vecType}<f32>( ${textureDimension} )`;
    }
    const coordSnippet = `${vecType}<u32>( ${wrapFunction}( ${uvSnippet} ) * ${vecType}<f32>( ${textureDimension} ) )`;
    return this.generateTextureLoad(texture2, textureProperty, coordSnippet, levelSnippet, depthSnippet, null);
  }
  /**
   * Generates the WGSL snippet that reads a single texel from a texture without sampling or filtering.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvIndexSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {?string} levelSnippet - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
   * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
   * @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
   * @return {string} The WGSL snippet.
   */
  generateTextureLoad(texture2, textureProperty, uvIndexSnippet, levelSnippet, depthSnippet, offsetSnippet) {
    if (levelSnippet === null) levelSnippet = "0u";
    if (offsetSnippet) {
      uvIndexSnippet = `${uvIndexSnippet} + ${offsetSnippet}`;
    }
    let snippet;
    if (depthSnippet) {
      snippet = `textureLoad( ${textureProperty}, ${uvIndexSnippet}, ${depthSnippet}, u32( ${levelSnippet} ) )`;
    } else {
      snippet = `textureLoad( ${textureProperty}, ${uvIndexSnippet}, u32( ${levelSnippet} ) )`;
      if (this.renderer.backend.compatibilityMode && texture2.isDepthTexture) {
        snippet += ".x";
      }
    }
    return snippet;
  }
  /**
   * Generates the WGSL snippet that writes a single texel to a texture.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvIndexSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
   * @param {string} valueSnippet - A WGSL snippet that represent the new texel value.
   * @return {string} The WGSL snippet.
   */
  generateTextureStore(texture2, textureProperty, uvIndexSnippet, depthSnippet, valueSnippet) {
    let snippet;
    if (depthSnippet) {
      snippet = `textureStore( ${textureProperty}, ${uvIndexSnippet}, ${depthSnippet}, ${valueSnippet} )`;
    } else {
      snippet = `textureStore( ${textureProperty}, ${uvIndexSnippet}, ${valueSnippet} )`;
    }
    return snippet;
  }
  /**
   * Returns `true` if the sampled values of the given texture should be compared against a reference value.
   *
   * @param {Texture} texture - The texture.
   * @return {boolean} Whether the sampled values of the given texture should be compared against a reference value or not.
   */
  isSampleCompare(texture2) {
    return texture2.isDepthTexture === true && texture2.compareFunction !== null;
  }
  /**
   * Returns `true` if the given texture is unfilterable.
   *
   * @param {Texture} texture - The texture.
   * @return {boolean} Whether the given texture is unfilterable or not.
   */
  isUnfilterable(texture2) {
    return this.getComponentTypeFromTexture(texture2) !== "float" || !this.isAvailable("float32Filterable") && texture2.isDataTexture === true && texture2.type === FloatType || this.isSampleCompare(texture2) === false && texture2.minFilter === NearestFilter && texture2.magFilter === NearestFilter || this.renderer.backend.utils.getTextureSampleData(texture2).primarySamples > 1;
  }
  /**
   * Generates the WGSL snippet for sampling/loading the given texture.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
   * @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The WGSL snippet.
   */
  generateTexture(texture2, textureProperty, uvSnippet, depthSnippet, offsetSnippet, shaderStage = this.shaderStage) {
    let snippet = null;
    if (this.isUnfilterable(texture2)) {
      snippet = this.generateTextureLod(texture2, textureProperty, uvSnippet, depthSnippet, offsetSnippet, "0", shaderStage);
    } else {
      snippet = this._generateTextureSample(texture2, textureProperty, uvSnippet, depthSnippet, offsetSnippet, shaderStage);
    }
    return snippet;
  }
  /**
   * Generates the WGSL snippet for sampling/loading the given texture using explicit gradients.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {Array<string>} gradSnippet - An array holding both gradient WGSL snippets.
   * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
   * @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The WGSL snippet.
   */
  generateTextureGrad(texture2, textureProperty, uvSnippet, gradSnippet, depthSnippet, offsetSnippet, shaderStage = this.shaderStage) {
    if (shaderStage === "fragment") {
      if (offsetSnippet) {
        return `textureSampleGrad( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet},  ${gradSnippet[0]}, ${gradSnippet[1]}, ${offsetSnippet} )`;
      }
      return `textureSampleGrad( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet},  ${gradSnippet[0]}, ${gradSnippet[1]} )`;
    } else {
      error(`WebGPURenderer: THREE.TextureNode.gradient() does not support ${shaderStage} shader.`);
    }
  }
  /**
   * Generates the WGSL snippet for sampling a depth texture and comparing the sampled depth values
   * against a reference value.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {string} compareSnippet -  A WGSL snippet that represents the reference value.
   * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
   * @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The WGSL snippet.
   */
  generateTextureCompare(texture2, textureProperty, uvSnippet, compareSnippet, depthSnippet, offsetSnippet, shaderStage = this.shaderStage) {
    if (shaderStage === "fragment") {
      if (texture2.isDepthTexture === true && texture2.isArrayTexture === true) {
        if (offsetSnippet) {
          return `textureSampleCompare( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${depthSnippet}, ${compareSnippet}, ${offsetSnippet} )`;
        }
        return `textureSampleCompare( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${depthSnippet}, ${compareSnippet} )`;
      }
      if (offsetSnippet) {
        return `textureSampleCompare( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${compareSnippet}, ${offsetSnippet} )`;
      }
      return `textureSampleCompare( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${compareSnippet} )`;
    } else {
      error(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${shaderStage} shader.`);
    }
  }
  /**
   * Generates the WGSL snippet when sampling textures with explicit mip level.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {string} levelSnippet - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
   * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
   * @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The WGSL snippet.
   */
  generateTextureLevel(texture2, textureProperty, uvSnippet, levelSnippet, depthSnippet, offsetSnippet) {
    if (this.isUnfilterable(texture2) === false) {
      if (offsetSnippet) {
        return `textureSampleLevel( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${levelSnippet}, ${offsetSnippet} )`;
      }
      return `textureSampleLevel( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${levelSnippet} )`;
    } else if (this.isFilteredTexture(texture2)) {
      return this.generateFilteredTexture(texture2, textureProperty, uvSnippet, offsetSnippet, levelSnippet);
    } else {
      return this.generateTextureLod(texture2, textureProperty, uvSnippet, depthSnippet, offsetSnippet, levelSnippet);
    }
  }
  /**
   * Generates the WGSL snippet when sampling textures with a bias to the mip level.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {string} biasSnippet - A WGSL snippet that represents the bias to apply to the mip level before sampling.
   * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
   * @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The WGSL snippet.
   */
  generateTextureBias(texture2, textureProperty, uvSnippet, biasSnippet, depthSnippet, offsetSnippet, shaderStage = this.shaderStage) {
    if (shaderStage === "fragment") {
      if (offsetSnippet) {
        return `textureSampleBias( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${biasSnippet}, ${offsetSnippet} )`;
      }
      return `textureSampleBias( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${biasSnippet} )`;
    } else {
      error(`WebGPURenderer: THREE.TextureNode.biasNode does not support ${shaderStage} shader.`);
    }
  }
  /**
   * Returns a WGSL snippet that represents the property name of the given node.
   *
   * @param {Node} node - The node.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The property name.
   */
  getPropertyName(node, shaderStage = this.shaderStage) {
    if (node.isNodeVarying === true && node.needsInterpolation === true) {
      if (shaderStage === "vertex") {
        return `varyings.${node.name}`;
      }
    } else if (node.isNodeUniform === true) {
      const name = node.name;
      const type = node.type;
      if (type === "texture" || type === "cubeTexture" || type === "cubeDepthTexture" || type === "storageTexture" || type === "texture3D") {
        return name;
      } else if (type === "buffer" || type === "storageBuffer" || type === "indirectStorageBuffer") {
        if (this.isCustomStruct(node)) {
          return name;
        }
        return name + ".value";
      } else {
        return node.groupNode.name + "." + name;
      }
    }
    return super.getPropertyName(node);
  }
  /**
   * Returns the output struct name.
   *
   * @return {string} The name of the output struct.
   */
  getOutputStructName() {
    return "output";
  }
  /**
   * Returns the native shader operator name for a given generic name.
   *
   * @param {string} op - The operator name to resolve.
   * @return {?string} The resolved operator name.
   */
  getFunctionOperator(op) {
    const fnOp = wgslFnOpLib[op];
    if (fnOp !== void 0) {
      this._include(fnOp);
      return fnOp;
    }
    return null;
  }
  /**
   * Returns the node access for the given node and shader stage.
   *
   * @param {StorageTextureNode|StorageBufferNode} node - The storage node.
   * @param {string} shaderStage - The shader stage.
   * @return {string} The node access.
   */
  getNodeAccess(node, shaderStage) {
    if (shaderStage !== "compute") {
      if (node.isAtomic === true) {
        warn("WebGPURenderer: Atomic operations are only supported in compute shaders.");
        return NodeAccess.READ_WRITE;
      }
      return NodeAccess.READ_ONLY;
    }
    return node.access;
  }
  /**
   * Returns A WGSL snippet representing the storage access.
   *
   * @param {StorageTextureNode|StorageBufferNode} node - The storage node.
   * @param {string} shaderStage - The shader stage.
   * @return {string} The WGSL snippet representing the storage access.
   */
  getStorageAccess(node, shaderStage) {
    return accessNames[this.getNodeAccess(node, shaderStage)];
  }
  /**
   * This method is one of the more important ones since it's responsible
   * for generating a matching binding instance for the given uniform node.
   *
   * These bindings are later used in the renderer to create bind groups
   * and layouts.
   *
   * @param {UniformNode} node - The uniform node.
   * @param {string} type - The node data type.
   * @param {string} shaderStage - The shader stage.
   * @param {?string} [name=null] - An optional uniform name.
   * @return {NodeUniform} The node uniform object.
   */
  getUniformFromNode(node, type, shaderStage, name = null) {
    const uniformNode = super.getUniformFromNode(node, type, shaderStage, name);
    const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);
    if (nodeData.uniformGPU === void 0) {
      let uniformGPU;
      const group2 = node.groupNode;
      const groupName = group2.name;
      const bindings = this.getBindGroupArray(groupName, shaderStage);
      if (type === "texture" || type === "cubeTexture" || type === "cubeDepthTexture" || type === "storageTexture" || type === "texture3D") {
        let texture2 = null;
        const access = this.getNodeAccess(node, shaderStage);
        if (type === "texture" || type === "storageTexture") {
          if (node.value.is3DTexture === true) {
            texture2 = new NodeSampledTexture3D(uniformNode.name, uniformNode.node, group2, access);
          } else {
            texture2 = new NodeSampledTexture(uniformNode.name, uniformNode.node, group2, access);
          }
        } else if (type === "cubeTexture" || type === "cubeDepthTexture") {
          texture2 = new NodeSampledCubeTexture(uniformNode.name, uniformNode.node, group2, access);
        } else if (type === "texture3D") {
          texture2 = new NodeSampledTexture3D(uniformNode.name, uniformNode.node, group2, access);
        }
        texture2.store = node.isStorageTextureNode === true;
        texture2.mipLevel = texture2.store ? node.mipLevel : 0;
        texture2.setVisibility(gpuShaderStageLib[shaderStage]);
        if (this.isUnfilterable(node.value) === false && texture2.store === false) {
          const sampler2 = new NodeSampler(`${uniformNode.name}_sampler`, uniformNode.node, group2);
          sampler2.setVisibility(gpuShaderStageLib[shaderStage]);
          bindings.push(sampler2, texture2);
          uniformGPU = [sampler2, texture2];
        } else {
          bindings.push(texture2);
          uniformGPU = [texture2];
        }
      } else if (type === "buffer" || type === "storageBuffer" || type === "indirectStorageBuffer") {
        const sharedData = this.getSharedDataFromNode(node);
        let buffer2 = sharedData.buffer;
        if (buffer2 === void 0) {
          const bufferClass = type === "buffer" ? NodeUniformBuffer : NodeStorageBuffer;
          buffer2 = new bufferClass(node, group2);
          sharedData.buffer = buffer2;
        }
        buffer2.setVisibility(buffer2.getVisibility() | gpuShaderStageLib[shaderStage]);
        bindings.push(buffer2);
        uniformGPU = buffer2;
        uniformNode.name = name ? name : "NodeBuffer_" + uniformNode.id;
      } else {
        const uniformsStage = this.uniformGroups[shaderStage] || (this.uniformGroups[shaderStage] = {});
        let uniformsGroup = uniformsStage[groupName];
        if (uniformsGroup === void 0) {
          uniformsGroup = new NodeUniformsGroup(groupName, group2);
          uniformsGroup.setVisibility(gpuShaderStageLib[shaderStage]);
          uniformsStage[groupName] = uniformsGroup;
          bindings.push(uniformsGroup);
        }
        uniformGPU = this.getNodeUniform(uniformNode, type);
        uniformsGroup.addUniform(uniformGPU);
      }
      nodeData.uniformGPU = uniformGPU;
    }
    return uniformNode;
  }
  /**
   * This method should be used whenever builtins are required in nodes.
   * The internal builtins data structure will make sure builtins are
   * defined in the WGSL source.
   *
   * @param {string} name - The builtin name.
   * @param {string} property - The property name.
   * @param {string} type - The node data type.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The property name.
   */
  getBuiltin(name, property3, type, shaderStage = this.shaderStage) {
    const map6 = this.builtins[shaderStage] || (this.builtins[shaderStage] = /* @__PURE__ */ new Map());
    if (map6.has(name) === false) {
      map6.set(name, {
        name,
        property: property3,
        type
      });
    }
    return property3;
  }
  /**
   * Returns `true` if the given builtin is defined in the given shader stage.
   *
   * @param {string} name - The builtin name.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {boolean} Whether the given builtin is defined in the given shader stage or not.
   */
  hasBuiltin(name, shaderStage = this.shaderStage) {
    return this.builtins[shaderStage] !== void 0 && this.builtins[shaderStage].has(name);
  }
  /**
   * Returns the vertex index builtin.
   *
   * @return {string} The vertex index.
   */
  getVertexIndex() {
    if (this.shaderStage === "vertex") {
      return this.getBuiltin("vertex_index", "vertexIndex", "u32", "attribute");
    }
    return "vertexIndex";
  }
  /**
   * Builds the given shader node.
   *
   * @param {ShaderNodeInternal} shaderNode - The shader node.
   * @return {string} The WGSL function code.
   */
  buildFunctionCode(shaderNode) {
    const layout = shaderNode.layout;
    const flowData = this.flowShaderNode(shaderNode);
    const parameters = [];
    for (const input of layout.inputs) {
      parameters.push(input.name + " : " + this.getType(input.type));
    }
    let code2 = `fn ${layout.name}( ${parameters.join(", ")} ) -> ${this.getType(layout.type)} {
${flowData.vars}
${flowData.code}
`;
    if (flowData.result) {
      code2 += `	return ${flowData.result};
`;
    }
    code2 += "\n}\n";
    return code2;
  }
  /**
   * Contextually returns either the vertex stage instance index builtin
   * or the linearized index of an compute invocation within a grid of workgroups.
   *
   * @return {string} The instance index.
   */
  getInstanceIndex() {
    if (this.shaderStage === "vertex") {
      return this.getBuiltin("instance_index", "instanceIndex", "u32", "attribute");
    }
    return "instanceIndex";
  }
  /**
   * Returns a builtin representing the index of a compute invocation within the scope of a workgroup load.
   *
   * @return {string} The invocation local index.
   */
  getInvocationLocalIndex() {
    return this.getBuiltin("local_invocation_index", "invocationLocalIndex", "u32", "attribute");
  }
  /**
   * Returns a builtin representing the size of a subgroup within the current shader.
   *
   * @return {string} The subgroup size.
   */
  getSubgroupSize() {
    this.enableSubGroups();
    return this.getBuiltin("subgroup_size", "subgroupSize", "u32", "attribute");
  }
  /**
   * Returns a builtin representing the index of a compute invocation within the scope of a subgroup.
   *
   * @return {string} The invocation subgroup index.
   */
  getInvocationSubgroupIndex() {
    this.enableSubGroups();
    return this.getBuiltin("subgroup_invocation_id", "invocationSubgroupIndex", "u32", "attribute");
  }
  /**
   * Returns a builtin representing the index of a compute invocation's subgroup within its workgroup.
   *
   * @return {string} The subgroup index.
   */
  getSubgroupIndex() {
    this.enableSubGroups();
    return this.getBuiltin("subgroup_id", "subgroupIndex", "u32", "attribute");
  }
  /**
   * Overwritten as a NOP since this method is intended for the WebGL 2 backend.
   *
   * @return {null} Null.
   */
  getDrawIndex() {
    return null;
  }
  /**
   * Returns the front facing builtin.
   *
   * @return {string} The front facing builtin.
   */
  getFrontFacing() {
    return this.getBuiltin("front_facing", "isFront", "bool");
  }
  /**
   * Returns the frag coord builtin.
   *
   * @return {string} The frag coord builtin.
   */
  getFragCoord() {
    return this.getBuiltin("position", "fragCoord", "vec4<f32>") + ".xy";
  }
  /**
   * Returns the frag depth builtin.
   *
   * @return {string} The frag depth builtin.
   */
  getFragDepth() {
    return "output." + this.getBuiltin("frag_depth", "depth", "f32", "output");
  }
  /**
   * Returns the clip distances builtin.
   *
   * @return {string} The clip distances builtin.
   */
  getClipDistance() {
    return "varyings.hw_clip_distances";
  }
  /**
   * Whether to flip texture data along its vertical axis or not.
   *
   * @return {boolean} Returns always `false` in context of WGSL.
   */
  isFlipY() {
    return false;
  }
  /**
   * Enables the given directive for the given shader stage.
   *
   * @param {string} name - The directive name.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage to enable the directive for.
   */
  enableDirective(name, shaderStage = this.shaderStage) {
    const stage = this.directives[shaderStage] || (this.directives[shaderStage] = /* @__PURE__ */ new Set());
    stage.add(name);
  }
  /**
   * Returns the directives of the given shader stage as a WGSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} A WGSL snippet that enables the directives of the given stage.
   */
  getDirectives(shaderStage) {
    const snippets = [];
    const directives = this.directives[shaderStage];
    if (directives !== void 0) {
      for (const directive of directives) {
        snippets.push(`enable ${directive};`);
      }
    }
    return snippets.join("\n");
  }
  /**
   * Enables the 'subgroups' directive.
   */
  enableSubGroups() {
    this.enableDirective("subgroups");
  }
  /**
   * Enables the 'subgroups-f16' directive.
   */
  enableSubgroupsF16() {
    this.enableDirective("subgroups-f16");
  }
  /**
   * Enables the 'clip_distances' directive.
   */
  enableClipDistances() {
    this.enableDirective("clip_distances");
  }
  /**
   * Enables the 'f16' directive.
   */
  enableShaderF16() {
    this.enableDirective("f16");
  }
  /**
   * Enables the 'dual_source_blending' directive.
   */
  enableDualSourceBlending() {
    this.enableDirective("dual_source_blending");
  }
  /**
   * Enables hardware clipping.
   *
   * @param {string} planeCount - The clipping plane count.
   */
  enableHardwareClipping(planeCount) {
    this.enableClipDistances();
    this.getBuiltin("clip_distances", "hw_clip_distances", `array<f32, ${planeCount} >`, "vertex");
  }
  /**
   * Returns the builtins of the given shader stage as a WGSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} A WGSL snippet that represents the builtins of the given stage.
   */
  getBuiltins(shaderStage) {
    const snippets = [];
    const builtins = this.builtins[shaderStage];
    if (builtins !== void 0) {
      for (const { name, property: property3, type } of builtins.values()) {
        snippets.push(`@builtin( ${name} ) ${property3} : ${type}`);
      }
    }
    return snippets.join(",\n	");
  }
  /**
   * This method should be used when a new scoped buffer is used in context of
   * compute shaders. It adds the array to the internal data structure which is
   * later used to generate the respective WGSL.
   *
   * @param {string} name - The array name.
   * @param {string} scope - The scope.
   * @param {string} bufferType - The buffer type.
   * @param {string} bufferCount - The buffer count.
   * @return {string} The array name.
   */
  getScopedArray(name, scope, bufferType, bufferCount) {
    if (this.scopedArrays.has(name) === false) {
      this.scopedArrays.set(name, {
        name,
        scope,
        bufferType,
        bufferCount
      });
    }
    return name;
  }
  /**
   * Returns the scoped arrays of the given shader stage as a WGSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string|undefined} The WGSL snippet that defines the scoped arrays.
   * Returns `undefined` when used in the vertex or fragment stage.
   */
  getScopedArrays(shaderStage) {
    if (shaderStage !== "compute") {
      return;
    }
    const snippets = [];
    for (const { name, scope, bufferType, bufferCount } of this.scopedArrays.values()) {
      const type = this.getType(bufferType);
      snippets.push(`var<${scope}> ${name}: array< ${type}, ${bufferCount} >;`);
    }
    return snippets.join("\n");
  }
  /**
   * Returns the shader attributes of the given shader stage as a WGSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The WGSL snippet that defines the shader attributes.
   */
  getAttributes(shaderStage) {
    const snippets = [];
    if (shaderStage === "compute") {
      this.getBuiltin("global_invocation_id", "globalId", "vec3<u32>", "attribute");
      this.getBuiltin("workgroup_id", "workgroupId", "vec3<u32>", "attribute");
      this.getBuiltin("local_invocation_id", "localId", "vec3<u32>", "attribute");
      this.getBuiltin("num_workgroups", "numWorkgroups", "vec3<u32>", "attribute");
      if (this.renderer.hasFeature("subgroups")) {
        this.enableDirective("subgroups", shaderStage);
        this.getBuiltin("subgroup_size", "subgroupSize", "u32", "attribute");
      }
    }
    if (shaderStage === "vertex" || shaderStage === "compute") {
      const builtins = this.getBuiltins("attribute");
      if (builtins) snippets.push(builtins);
      const attributes = this.getAttributesArray();
      for (let index8 = 0, length2 = attributes.length; index8 < length2; index8++) {
        const attribute2 = attributes[index8];
        const name = attribute2.name;
        const type = this.getType(attribute2.type);
        snippets.push(`@location( ${index8} ) ${name} : ${type}`);
      }
    }
    return snippets.join(",\n	");
  }
  /**
   * Returns the members of the given struct type node as a WGSL string.
   *
   * @param {StructTypeNode} struct - The struct type node.
   * @return {string} The WGSL snippet that defines the struct members.
   */
  getStructMembers(struct2) {
    const snippets = [];
    for (const member of struct2.members) {
      const prefix = struct2.output ? "@location( " + member.index + " ) " : "";
      let type = this.getType(member.type);
      if (member.atomic) {
        type = "atomic< " + type + " >";
      }
      snippets.push(`	${prefix + member.name} : ${type}`);
    }
    if (struct2.output) {
      snippets.push(`	${this.getBuiltins("output")}`);
    }
    return snippets.join(",\n");
  }
  /**
   * Returns the structs of the given shader stage as a WGSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The WGSL snippet that defines the structs.
   */
  getStructs(shaderStage) {
    let result2 = "";
    const structs = this.structs[shaderStage];
    if (structs.length > 0) {
      const snippets = [];
      for (const struct2 of structs) {
        let snippet = `struct ${struct2.name} {
`;
        snippet += this.getStructMembers(struct2);
        snippet += "\n};";
        snippets.push(snippet);
      }
      result2 = "\n" + snippets.join("\n\n") + "\n";
    }
    return result2;
  }
  /**
   * Returns a WGSL string representing a variable.
   *
   * @param {string} type - The variable's type.
   * @param {string} name - The variable's name.
   * @param {?number} [count=null] - The array length.
   * @return {string} The WGSL snippet that defines a variable.
   */
  getVar(type, name, count2 = null) {
    let snippet = `var ${name} : `;
    if (count2 !== null) {
      snippet += this.generateArrayDeclaration(type, count2);
    } else {
      snippet += this.getType(type);
    }
    return snippet;
  }
  /**
   * Returns the variables of the given shader stage as a WGSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The WGSL snippet that defines the variables.
   */
  getVars(shaderStage) {
    const snippets = [];
    const vars = this.vars[shaderStage];
    if (vars !== void 0) {
      for (const variable of vars) {
        snippets.push(`	${this.getVar(variable.type, variable.name, variable.count)};`);
      }
    }
    return `
${snippets.join("\n")}
`;
  }
  /**
   * Returns the varyings of the given shader stage as a WGSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The WGSL snippet that defines the varyings.
   */
  getVaryings(shaderStage) {
    const snippets = [];
    if (shaderStage === "vertex") {
      this.getBuiltin("position", "Vertex", "vec4<f32>", "vertex");
    }
    if (shaderStage === "vertex" || shaderStage === "fragment") {
      const varyings = this.varyings;
      const vars = this.vars[shaderStage];
      for (let index8 = 0; index8 < varyings.length; index8++) {
        const varying2 = varyings[index8];
        if (varying2.needsInterpolation) {
          let attributesSnippet = `@location( ${index8} )`;
          if (varying2.interpolationType) {
            const samplingSnippet = varying2.interpolationSampling !== null ? `, ${varying2.interpolationSampling} )` : " )";
            attributesSnippet += ` @interpolate( ${varying2.interpolationType}${samplingSnippet}`;
          } else if (/^(int|uint|ivec|uvec)/.test(varying2.type)) {
            attributesSnippet += ` @interpolate( ${this.renderer.backend.compatibilityMode ? "flat, either" : "flat"} )`;
          }
          snippets.push(`${attributesSnippet} ${varying2.name} : ${this.getType(varying2.type)}`);
        } else if (shaderStage === "vertex" && vars.includes(varying2) === false) {
          vars.push(varying2);
        }
      }
    }
    const builtins = this.getBuiltins(shaderStage);
    if (builtins) snippets.push(builtins);
    const code2 = snippets.join(",\n	");
    return shaderStage === "vertex" ? this._getWGSLStruct("VaryingsStruct", "	" + code2) : code2;
  }
  isCustomStruct(nodeUniform) {
    const attribute2 = nodeUniform.value;
    const bufferNode = nodeUniform.node;
    const isAttributeStructType = (attribute2.isBufferAttribute || attribute2.isInstancedBufferAttribute) && bufferNode.structTypeNode !== null;
    const isStructArray = bufferNode.value && bufferNode.value.array && (typeof bufferNode.value.itemSize === "number" && bufferNode.value.array.length > bufferNode.value.itemSize);
    return isAttributeStructType && !isStructArray;
  }
  /**
   * Returns the uniforms of the given shader stage as a WGSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The WGSL snippet that defines the uniforms.
   */
  getUniforms(shaderStage) {
    const uniforms = this.uniforms[shaderStage];
    const bindingSnippets = [];
    const bufferSnippets = [];
    const structSnippets = [];
    const uniformGroups = {};
    for (const uniform2 of uniforms) {
      const groupName = uniform2.groupNode.name;
      const uniformIndexes = this.bindingsIndexes[groupName];
      if (uniform2.type === "texture" || uniform2.type === "cubeTexture" || uniform2.type === "cubeDepthTexture" || uniform2.type === "storageTexture" || uniform2.type === "texture3D") {
        const texture2 = uniform2.node.value;
        if (this.isUnfilterable(texture2) === false && uniform2.node.isStorageTextureNode !== true) {
          if (this.isSampleCompare(texture2)) {
            bindingSnippets.push(`@binding( ${uniformIndexes.binding++} ) @group( ${uniformIndexes.group} ) var ${uniform2.name}_sampler : sampler_comparison;`);
          } else {
            bindingSnippets.push(`@binding( ${uniformIndexes.binding++} ) @group( ${uniformIndexes.group} ) var ${uniform2.name}_sampler : sampler;`);
          }
        }
        let textureType;
        let multisampled = "";
        const { primarySamples } = this.renderer.backend.utils.getTextureSampleData(texture2);
        if (primarySamples > 1) {
          multisampled = "_multisampled";
        }
        if (texture2.isCubeTexture === true && texture2.isDepthTexture === true) {
          textureType = "texture_depth_cube";
        } else if (texture2.isCubeTexture === true) {
          textureType = "texture_cube<f32>";
        } else if (texture2.isDepthTexture === true) {
          if (this.renderer.backend.compatibilityMode && texture2.compareFunction === null) {
            textureType = `texture${multisampled}_2d<f32>`;
          } else {
            textureType = `texture_depth${multisampled}_2d${texture2.isArrayTexture === true ? "_array" : ""}`;
          }
        } else if (uniform2.node.isStorageTextureNode === true) {
          const format3 = getFormat2(texture2);
          const access = this.getStorageAccess(uniform2.node, shaderStage);
          const is3D = uniform2.node.value.is3DTexture;
          const isArrayTexture = uniform2.node.value.isArrayTexture;
          const dimension = is3D ? "3d" : `2d${isArrayTexture ? "_array" : ""}`;
          textureType = `texture_storage_${dimension}<${format3}, ${access}>`;
        } else if (texture2.isArrayTexture === true || texture2.isDataArrayTexture === true || texture2.isCompressedArrayTexture === true) {
          textureType = "texture_2d_array<f32>";
        } else if (texture2.is3DTexture === true || texture2.isData3DTexture === true) {
          textureType = "texture_3d<f32>";
        } else {
          const componentPrefix = this.getComponentTypeFromTexture(texture2).charAt(0);
          textureType = `texture${multisampled}_2d<${componentPrefix}32>`;
        }
        bindingSnippets.push(`@binding( ${uniformIndexes.binding++} ) @group( ${uniformIndexes.group} ) var ${uniform2.name} : ${textureType};`);
      } else if (uniform2.type === "buffer" || uniform2.type === "storageBuffer" || uniform2.type === "indirectStorageBuffer") {
        const bufferNode = uniform2.node;
        const bufferType = this.getType(bufferNode.getNodeType(this));
        const bufferCount = bufferNode.bufferCount;
        const bufferCountSnippet = bufferCount > 0 && uniform2.type === "buffer" ? ", " + bufferCount : "";
        const bufferAccessMode = bufferNode.isStorageBufferNode ? `storage, ${this.getStorageAccess(bufferNode, shaderStage)}` : "uniform";
        if (this.isCustomStruct(uniform2)) {
          bufferSnippets.push(`@binding( ${uniformIndexes.binding++} ) @group( ${uniformIndexes.group} ) var<${bufferAccessMode}> ${uniform2.name} : ${bufferType};`);
        } else {
          const bufferTypeSnippet = bufferNode.isAtomic ? `atomic<${bufferType}>` : `${bufferType}`;
          const bufferSnippet = `	value : array< ${bufferTypeSnippet}${bufferCountSnippet} >`;
          bufferSnippets.push(this._getWGSLStructBinding(uniform2.name, bufferSnippet, bufferAccessMode, uniformIndexes.binding++, uniformIndexes.group));
        }
      } else {
        const vectorType = this.getType(this.getVectorType(uniform2.type));
        const groupName2 = uniform2.groupNode.name;
        const group2 = uniformGroups[groupName2] || (uniformGroups[groupName2] = {
          index: uniformIndexes.binding++,
          id: uniformIndexes.group,
          snippets: []
        });
        group2.snippets.push(`	${uniform2.name} : ${vectorType}`);
      }
    }
    for (const name in uniformGroups) {
      const group2 = uniformGroups[name];
      structSnippets.push(this._getWGSLStructBinding(name, group2.snippets.join(",\n"), "uniform", group2.index, group2.id));
    }
    const code2 = [...bindingSnippets, ...bufferSnippets, ...structSnippets].join("\n");
    return code2;
  }
  /**
   * Controls the code build of the shader stages.
   */
  buildCode() {
    const shadersData = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };
    this.sortBindingGroups();
    for (const shaderStage in shadersData) {
      this.shaderStage = shaderStage;
      const stageData = shadersData[shaderStage];
      stageData.uniforms = this.getUniforms(shaderStage);
      stageData.attributes = this.getAttributes(shaderStage);
      stageData.varyings = this.getVaryings(shaderStage);
      stageData.structs = this.getStructs(shaderStage);
      stageData.vars = this.getVars(shaderStage);
      stageData.codes = this.getCodes(shaderStage);
      stageData.directives = this.getDirectives(shaderStage);
      stageData.scopedArrays = this.getScopedArrays(shaderStage);
      let flow2 = "// code\n\n";
      flow2 += this.flowCode[shaderStage];
      const flowNodes = this.flowNodes[shaderStage];
      const mainNode = flowNodes[flowNodes.length - 1];
      const outputNode = mainNode.outputNode;
      const isOutputStruct = outputNode !== void 0 && outputNode.isOutputStructNode === true;
      for (const node of flowNodes) {
        const flowSlotData = this.getFlowData(
          node
          /*, shaderStage*/
        );
        const slotName = node.name;
        if (slotName) {
          if (flow2.length > 0) flow2 += "\n";
          flow2 += `	// flow -> ${slotName}
`;
        }
        flow2 += `${flowSlotData.code}
	`;
        if (node === mainNode && shaderStage !== "compute") {
          flow2 += "// result\n\n	";
          if (shaderStage === "vertex") {
            flow2 += `varyings.Vertex = ${flowSlotData.result};`;
          } else if (shaderStage === "fragment") {
            if (isOutputStruct) {
              stageData.returnType = outputNode.getNodeType(this);
              stageData.structs += "var<private> output : " + stageData.returnType + ";";
              flow2 += `return ${flowSlotData.result};`;
            } else {
              let structSnippet = "	@location(0) color: vec4<f32>";
              const builtins = this.getBuiltins("output");
              if (builtins) structSnippet += ",\n	" + builtins;
              stageData.returnType = "OutputStruct";
              stageData.structs += this._getWGSLStruct("OutputStruct", structSnippet);
              stageData.structs += "\nvar<private> output : OutputStruct;";
              flow2 += `output.color = ${flowSlotData.result};

	return output;`;
            }
          }
        }
      }
      stageData.flow = flow2;
    }
    this.shaderStage = null;
    if (this.material !== null) {
      this.vertexShader = this._getWGSLVertexCode(shadersData.vertex);
      this.fragmentShader = this._getWGSLFragmentCode(shadersData.fragment);
    } else {
      const workgroupSize = this.object.workgroupSize;
      this.computeShader = this._getWGSLComputeCode(shadersData.compute, workgroupSize);
    }
  }
  /**
   * Returns the native shader method name for a given generic name.
   *
   * @param {string} method - The method name to resolve.
   * @param {?string} [output=null] - An optional output.
   * @return {string} The resolved WGSL method name.
   */
  getMethod(method2, output2 = null) {
    let wgslMethod;
    if (output2 !== null) {
      wgslMethod = this._getWGSLMethod(method2 + "_" + output2);
    }
    if (wgslMethod === void 0) {
      wgslMethod = this._getWGSLMethod(method2);
    }
    return wgslMethod || method2;
  }
  /**
   * Returns the bitcast method name for a given input and outputType.
   *
   * @param {string} type - The output type to bitcast to.
   * @return {string} The resolved WGSL bitcast invocation.
   */
  getBitcastMethod(type) {
    const dataType = this.getType(type);
    return `bitcast<${dataType}>`;
  }
  /**
   * Returns the float packing method name for a given numeric encoding.
   *
   * @param {string} encoding - The numeric encoding that describes how the float values are mapped to the integer range.
   * @returns {string} The resolve WGSL float packing method name.
   */
  getFloatPackingMethod(encoding) {
    return this.getMethod(`floatpack_${encoding}_2x16`);
  }
  /**
   * Returns the float unpacking method name for a given numeric encoding.
   *
   * @param {string} encoding - The numeric encoding that describes how the integer values are mapped to the float range.
   * @returns {string} The resolve WGSL float unpacking method name.
   */
  getFloatUnpackingMethod(encoding) {
    return this.getMethod(`floatunpack_${encoding}_2x16`);
  }
  /**
   * Returns the native snippet for a ternary operation.
   *
   * @param {string} condSnippet - The condition determining which expression gets resolved.
   * @param {string} ifSnippet - The expression to resolve to if the condition is true.
   * @param {string} elseSnippet - The expression to resolve to if the condition is false.
   * @return {string} The resolved method name.
   */
  getTernary(condSnippet, ifSnippet, elseSnippet) {
    return `select( ${elseSnippet}, ${ifSnippet}, ${condSnippet} )`;
  }
  /**
   * Returns the WGSL type of the given node data type.
   *
   * @param {string} type - The node data type.
   * @return {string} The WGSL type.
   */
  getType(type) {
    return wgslTypeLib[type] || type;
  }
  /**
   * Whether the requested feature is available or not.
   *
   * @param {string} name - The requested feature.
   * @return {boolean} Whether the requested feature is supported or not.
   */
  isAvailable(name) {
    let result2 = supports[name];
    if (result2 === void 0) {
      if (name === "float32Filterable") {
        result2 = this.renderer.hasFeature("float32-filterable");
      } else if (name === "clipDistance") {
        result2 = this.renderer.hasFeature("clip-distances");
      }
      supports[name] = result2;
    }
    return result2;
  }
  /**
   * Returns the native shader method name for a given generic name.
   *
   * @private
   * @param {string} method - The method name to resolve.
   * @return {string} The resolved WGSL method name.
   */
  _getWGSLMethod(method2) {
    if (wgslPolyfill[method2] !== void 0) {
      this._include(method2);
    }
    return wgslMethods[method2];
  }
  /**
   * Includes the given method name into the current
   * function node.
   *
   * @private
   * @param {string} name - The method name to include.
   * @return {CodeNode} The respective code node.
   */
  _include(name) {
    const codeNode = wgslPolyfill[name];
    codeNode.build(this);
    this.addInclude(codeNode);
    return codeNode;
  }
  /**
   * Returns a WGSL vertex shader based on the given shader data.
   *
   * @private
   * @param {Object} shaderData - The shader data.
   * @return {string} The vertex shader.
   */
  _getWGSLVertexCode(shaderData) {
    return `${this.getSignature()}
// directives
${shaderData.directives}

// structs
${shaderData.structs}

// uniforms
${shaderData.uniforms}

// varyings
${shaderData.varyings}
var<private> varyings : VaryingsStruct;

// codes
${shaderData.codes}

@vertex
fn main( ${shaderData.attributes} ) -> VaryingsStruct {

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

	return varyings;

}
`;
  }
  /**
   * Returns a WGSL fragment shader based on the given shader data.
   *
   * @private
   * @param {Object} shaderData - The shader data.
   * @return {string} The vertex shader.
   */
  _getWGSLFragmentCode(shaderData) {
    return `${this.getSignature()}
// global
${diagnostics}

// structs
${shaderData.structs}

// uniforms
${shaderData.uniforms}

// codes
${shaderData.codes}

@fragment
fn main( ${shaderData.varyings} ) -> ${shaderData.returnType} {

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

}
`;
  }
  /**
   * Returns a WGSL compute shader based on the given shader data.
   *
   * @private
   * @param {Object} shaderData - The shader data.
   * @param {string} workgroupSize - The workgroup size.
   * @return {string} The vertex shader.
   */
  _getWGSLComputeCode(shaderData, workgroupSize) {
    const [workgroupSizeX, workgroupSizeY, workgroupSizeZ] = workgroupSize;
    return `${this.getSignature()}
// directives
${shaderData.directives}

// system
var<private> instanceIndex : u32;

// locals
${shaderData.scopedArrays}

// structs
${shaderData.structs}

// uniforms
${shaderData.uniforms}

// codes
${shaderData.codes}

@compute @workgroup_size( ${workgroupSizeX}, ${workgroupSizeY}, ${workgroupSizeZ} )
fn main( ${shaderData.attributes} ) {

	// system
	instanceIndex = globalId.x
		+ globalId.y * ( ${workgroupSizeX} * numWorkgroups.x )
		+ globalId.z * ( ${workgroupSizeX} * numWorkgroups.x ) * ( ${workgroupSizeY} * numWorkgroups.y );

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

}
`;
  }
  /**
   * Returns a WGSL struct based on the given name and variables.
   *
   * @private
   * @param {string} name - The struct name.
   * @param {string} vars - The struct variables.
   * @return {string} The WGSL snippet representing a struct.
   */
  _getWGSLStruct(name, vars) {
    return `
struct ${name} {
${vars}
};`;
  }
  /**
   * Returns a WGSL struct binding.
   *
   * @private
   * @param {string} name - The struct name.
   * @param {string} vars - The struct variables.
   * @param {string} access - The access.
   * @param {number} [binding=0] - The binding index.
   * @param {number} [group=0] - The group index.
   * @return {string} The WGSL snippet representing a struct binding.
   */
  _getWGSLStructBinding(name, vars, access, binding = 0, group2 = 0) {
    const structName = name + "Struct";
    const structSnippet = this._getWGSLStruct(structName, vars);
    return `${structSnippet}
@binding( ${binding} ) @group( ${group2} )
var<${access}> ${name} : ${structName};`;
  }
};
var WebGPUUtils = class {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGPUBackend} backend - The WebGPU backend.
   */
  constructor(backend) {
    this.backend = backend;
  }
  /**
   * Returns the depth/stencil GPU format for the given render context.
   *
   * @param {RenderContext} renderContext - The render context.
   * @return {string} The depth/stencil GPU texture format.
   */
  getCurrentDepthStencilFormat(renderContext) {
    let format3;
    if (renderContext.depthTexture !== null) {
      format3 = this.getTextureFormatGPU(renderContext.depthTexture);
    } else if (renderContext.depth && renderContext.stencil) {
      format3 = GPUTextureFormat.Depth24PlusStencil8;
    } else if (renderContext.depth) {
      format3 = GPUTextureFormat.Depth24Plus;
    }
    return format3;
  }
  /**
   * Returns the GPU format for the given texture.
   *
   * @param {Texture} texture - The texture.
   * @return {string} The GPU texture format.
   */
  getTextureFormatGPU(texture2) {
    return this.backend.get(texture2).format;
  }
  /**
   * Returns an object that defines the multi-sampling state of the given texture.
   *
   * @param {Texture} texture - The texture.
   * @return {Object} The multi-sampling state.
   */
  getTextureSampleData(texture2) {
    let samples;
    if (texture2.isFramebufferTexture) {
      samples = 1;
    } else if (texture2.isDepthTexture && !texture2.renderTarget) {
      const renderer3 = this.backend.renderer;
      const renderTarget = renderer3.getRenderTarget();
      samples = renderTarget ? renderTarget.samples : renderer3.currentSamples;
    } else if (texture2.renderTarget) {
      samples = texture2.renderTarget.samples;
    }
    samples = samples || 1;
    const isMSAA = samples > 1 && texture2.renderTarget !== null && (texture2.isDepthTexture !== true && texture2.isFramebufferTexture !== true);
    const primarySamples = isMSAA ? 1 : samples;
    return { samples, primarySamples, isMSAA };
  }
  /**
   * Returns the default color attachment's GPU format of the current render context.
   *
   * @param {RenderContext} renderContext - The render context.
   * @return {string} The GPU texture format of the default color attachment.
   */
  getCurrentColorFormat(renderContext) {
    let format3;
    if (renderContext.textures !== null) {
      format3 = this.getTextureFormatGPU(renderContext.textures[0]);
    } else {
      format3 = this.getPreferredCanvasFormat();
    }
    return format3;
  }
  /**
   * Returns the GPU formats of all color attachments of the current render context.
   *
   * @param {RenderContext} renderContext - The render context.
   * @return {Array<string>} The GPU texture formats of all color attachments.
   */
  getCurrentColorFormats(renderContext) {
    if (renderContext.textures !== null) {
      return renderContext.textures.map((t5) => this.getTextureFormatGPU(t5));
    } else {
      return [this.getPreferredCanvasFormat()];
    }
  }
  /**
   * Returns the output color space of the current render context.
   *
   * @param {RenderContext} renderContext - The render context.
   * @return {string} The output color space.
   */
  getCurrentColorSpace(renderContext) {
    if (renderContext.textures !== null) {
      return renderContext.textures[0].colorSpace;
    }
    return this.backend.renderer.outputColorSpace;
  }
  /**
   * Returns GPU primitive topology for the given object and material.
   *
   * @param {Object3D} object - The 3D object.
   * @param {Material} material - The material.
   * @return {string} The GPU primitive topology.
   */
  getPrimitiveTopology(object, material) {
    if (object.isPoints) return GPUPrimitiveTopology.PointList;
    else if (object.isLineSegments || object.isMesh && material.wireframe === true) return GPUPrimitiveTopology.LineList;
    else if (object.isLine) return GPUPrimitiveTopology.LineStrip;
    else if (object.isMesh) return GPUPrimitiveTopology.TriangleList;
  }
  /**
   * Returns a modified sample count from the given sample count value.
   *
   * That is required since WebGPU only supports either 1 or 4.
   *
   * @param {number} sampleCount - The input sample count.
   * @return {number} The (potentially updated) output sample count.
   */
  getSampleCount(sampleCount) {
    return sampleCount >= 4 ? 4 : 1;
  }
  /**
   * Returns the sample count of the given render context.
   *
   * @param {RenderContext} renderContext - The render context.
   * @return {number} The sample count.
   */
  getSampleCountRenderContext(renderContext) {
    if (renderContext.textures !== null) {
      return this.getSampleCount(renderContext.sampleCount);
    }
    return this.getSampleCount(this.backend.renderer.currentSamples);
  }
  /**
   * Returns the preferred canvas format.
   *
   * There is a separate method for this so it's possible to
   * honor edge cases for specific devices.
   *
   * @return {string} The GPU texture format of the canvas.
   */
  getPreferredCanvasFormat() {
    const parameters = this.backend.parameters;
    const bufferType = parameters.outputType;
    if (bufferType === void 0) {
      return navigator.gpu.getPreferredCanvasFormat();
    } else if (bufferType === UnsignedByteType) {
      return GPUTextureFormat.BGRA8Unorm;
    } else if (bufferType === HalfFloatType) {
      return GPUTextureFormat.RGBA16Float;
    } else {
      throw new Error("Unsupported output buffer type.");
    }
  }
};
var typedArraysToVertexFormatPrefix = /* @__PURE__ */ new Map([
  [Int8Array, ["sint8", "snorm8"]],
  [Uint8Array, ["uint8", "unorm8"]],
  [Int16Array, ["sint16", "snorm16"]],
  [Uint16Array, ["uint16", "unorm16"]],
  [Int32Array, ["sint32", "snorm32"]],
  [Uint32Array, ["uint32", "unorm32"]],
  [Float32Array, ["float32"]]
]);
if (typeof Float16Array !== "undefined") {
  typedArraysToVertexFormatPrefix.set(Float16Array, ["float16"]);
}
var typedAttributeToVertexFormatPrefix = /* @__PURE__ */ new Map([
  [Float16BufferAttribute, ["float16"]]
]);
var typeArraysToVertexFormatPrefixForItemSize1 = /* @__PURE__ */ new Map([
  [Int32Array, "sint32"],
  [Int16Array, "sint32"],
  // patch for INT16
  [Uint32Array, "uint32"],
  [Uint16Array, "uint32"],
  // patch for UINT16
  [Float32Array, "float32"]
]);
var WebGPUAttributeUtils = class {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGPUBackend} backend - The WebGPU backend.
   */
  constructor(backend) {
    this.backend = backend;
  }
  /**
   * Creates the GPU buffer for the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   * @param {GPUBufferUsage} usage - A flag that indicates how the buffer may be used after its creation.
   */
  createAttribute(attribute2, usage) {
    const bufferAttribute2 = this._getBufferAttribute(attribute2);
    const backend = this.backend;
    const bufferData = backend.get(bufferAttribute2);
    let buffer2 = bufferData.buffer;
    if (buffer2 === void 0) {
      const device = backend.device;
      let array4 = bufferAttribute2.array;
      if (attribute2.normalized === false) {
        if (array4.constructor === Int16Array || array4.constructor === Int8Array) {
          array4 = new Int32Array(array4);
        } else if (array4.constructor === Uint16Array || array4.constructor === Uint8Array) {
          array4 = new Uint32Array(array4);
          if (usage & GPUBufferUsage.INDEX) {
            for (let i2 = 0; i2 < array4.length; i2++) {
              if (array4[i2] === 65535) array4[i2] = 4294967295;
            }
          }
        }
      }
      bufferAttribute2.array = array4;
      if ((bufferAttribute2.isStorageBufferAttribute || bufferAttribute2.isStorageInstancedBufferAttribute) && bufferAttribute2.itemSize === 3) {
        array4 = new array4.constructor(bufferAttribute2.count * 4);
        for (let i2 = 0; i2 < bufferAttribute2.count; i2++) {
          array4.set(bufferAttribute2.array.subarray(i2 * 3, i2 * 3 + 3), i2 * 4);
        }
        bufferAttribute2.itemSize = 4;
        bufferAttribute2.array = array4;
        bufferData._force3to4BytesAlignment = true;
      }
      const byteLength = array4.byteLength;
      const size2 = byteLength + (4 - byteLength % 4) % 4;
      buffer2 = device.createBuffer({
        label: bufferAttribute2.name,
        size: size2,
        usage,
        mappedAtCreation: true
      });
      new array4.constructor(buffer2.getMappedRange()).set(array4);
      buffer2.unmap();
      bufferData.buffer = buffer2;
    }
  }
  /**
   * Updates the GPU buffer of the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  updateAttribute(attribute2) {
    const bufferAttribute2 = this._getBufferAttribute(attribute2);
    const backend = this.backend;
    const device = backend.device;
    const bufferData = backend.get(bufferAttribute2);
    const buffer2 = backend.get(bufferAttribute2).buffer;
    let array4 = bufferAttribute2.array;
    if (bufferData._force3to4BytesAlignment === true) {
      array4 = new array4.constructor(bufferAttribute2.count * 4);
      for (let i2 = 0; i2 < bufferAttribute2.count; i2++) {
        array4.set(bufferAttribute2.array.subarray(i2 * 3, i2 * 3 + 3), i2 * 4);
      }
      bufferAttribute2.array = array4;
    }
    const updateRanges = bufferAttribute2.updateRanges;
    if (updateRanges.length === 0) {
      device.queue.writeBuffer(
        buffer2,
        0,
        array4,
        0
      );
    } else {
      const isTyped = isTypedArray(array4);
      const byteOffsetFactor = isTyped ? 1 : array4.BYTES_PER_ELEMENT;
      for (let i2 = 0, l2 = updateRanges.length; i2 < l2; i2++) {
        const range4 = updateRanges[i2];
        let dataOffset, size2;
        if (bufferData._force3to4BytesAlignment === true) {
          const vertexStart = Math.floor(range4.start / 3);
          const vertexCount = Math.ceil(range4.count / 3);
          dataOffset = vertexStart * 4 * byteOffsetFactor;
          size2 = vertexCount * 4 * byteOffsetFactor;
        } else {
          dataOffset = range4.start * byteOffsetFactor;
          size2 = range4.count * byteOffsetFactor;
        }
        const bufferOffset = dataOffset * (isTyped ? array4.BYTES_PER_ELEMENT : 1);
        device.queue.writeBuffer(
          buffer2,
          bufferOffset,
          array4,
          dataOffset,
          size2
        );
      }
      bufferAttribute2.clearUpdateRanges();
    }
  }
  /**
   * This method creates the vertex buffer layout data which are
   * require when creating a render pipeline for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {Array<Object>} An array holding objects which describe the vertex buffer layout.
   */
  createShaderVertexBuffers(renderObject) {
    const attributes = renderObject.getAttributes();
    const vertexBuffers = /* @__PURE__ */ new Map();
    for (let slot = 0; slot < attributes.length; slot++) {
      const geometryAttribute = attributes[slot];
      const bytesPerElement = geometryAttribute.array.BYTES_PER_ELEMENT;
      const bufferAttribute2 = this._getBufferAttribute(geometryAttribute);
      let vertexBufferLayout = vertexBuffers.get(bufferAttribute2);
      if (vertexBufferLayout === void 0) {
        let arrayStride, stepMode;
        if (geometryAttribute.isInterleavedBufferAttribute === true) {
          arrayStride = geometryAttribute.data.stride * bytesPerElement;
          stepMode = geometryAttribute.data.isInstancedInterleavedBuffer ? GPUInputStepMode.Instance : GPUInputStepMode.Vertex;
        } else {
          arrayStride = geometryAttribute.itemSize * bytesPerElement;
          stepMode = geometryAttribute.isInstancedBufferAttribute ? GPUInputStepMode.Instance : GPUInputStepMode.Vertex;
        }
        if (geometryAttribute.normalized === false && (geometryAttribute.array.constructor === Int16Array || geometryAttribute.array.constructor === Uint16Array)) {
          arrayStride = 4;
        }
        vertexBufferLayout = {
          arrayStride,
          attributes: [],
          stepMode
        };
        vertexBuffers.set(bufferAttribute2, vertexBufferLayout);
      }
      const format3 = this._getVertexFormat(geometryAttribute);
      const offset = geometryAttribute.isInterleavedBufferAttribute === true ? geometryAttribute.offset * bytesPerElement : 0;
      vertexBufferLayout.attributes.push({
        shaderLocation: slot,
        offset,
        format: format3
      });
    }
    return Array.from(vertexBuffers.values());
  }
  /**
   * Destroys the GPU buffer of the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  destroyAttribute(attribute2) {
    const backend = this.backend;
    const data = backend.get(this._getBufferAttribute(attribute2));
    data.buffer.destroy();
    backend.delete(attribute2);
  }
  /**
   * This method performs a readback operation by moving buffer data from
   * a storage buffer attribute from the GPU to the CPU.
   *
   * @async
   * @param {StorageBufferAttribute} attribute - The storage buffer attribute.
   * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.
   */
  async getArrayBufferAsync(attribute2) {
    const backend = this.backend;
    const device = backend.device;
    const data = backend.get(this._getBufferAttribute(attribute2));
    const bufferGPU = data.buffer;
    const size2 = bufferGPU.size;
    const readBufferGPU = device.createBuffer({
      label: `${attribute2.name}_readback`,
      size: size2,
      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
    });
    const cmdEncoder = device.createCommandEncoder({
      label: `readback_encoder_${attribute2.name}`
    });
    cmdEncoder.copyBufferToBuffer(
      bufferGPU,
      0,
      readBufferGPU,
      0,
      size2
    );
    const gpuCommands = cmdEncoder.finish();
    device.queue.submit([gpuCommands]);
    await readBufferGPU.mapAsync(GPUMapMode.READ);
    const arrayBuffer2 = readBufferGPU.getMappedRange();
    const dstBuffer = new attribute2.array.constructor(arrayBuffer2.slice(0));
    readBufferGPU.unmap();
    return dstBuffer.buffer;
  }
  /**
   * Returns the vertex format of the given buffer attribute.
   *
   * @private
   * @param {BufferAttribute} geometryAttribute - The buffer attribute.
   * @return {string|undefined} The vertex format (e.g. 'float32x3').
   */
  _getVertexFormat(geometryAttribute) {
    const { itemSize, normalized } = geometryAttribute;
    const ArrayType = geometryAttribute.array.constructor;
    const AttributeType2 = geometryAttribute.constructor;
    let format3;
    if (itemSize === 1) {
      format3 = typeArraysToVertexFormatPrefixForItemSize1.get(ArrayType);
    } else {
      const prefixOptions = typedAttributeToVertexFormatPrefix.get(AttributeType2) || typedArraysToVertexFormatPrefix.get(ArrayType);
      const prefix = prefixOptions[normalized ? 1 : 0];
      if (prefix) {
        const bytesPerUnit = ArrayType.BYTES_PER_ELEMENT * itemSize;
        const paddedBytesPerUnit = Math.floor((bytesPerUnit + 3) / 4) * 4;
        const paddedItemSize = paddedBytesPerUnit / ArrayType.BYTES_PER_ELEMENT;
        if (paddedItemSize % 1) {
          throw new Error("THREE.WebGPUAttributeUtils: Bad vertex format item size.");
        }
        format3 = `${prefix}x${paddedItemSize}`;
      }
    }
    if (!format3) {
      error("WebGPUAttributeUtils: Vertex format not supported yet.");
    }
    return format3;
  }
  /**
   * Utility method for handling interleaved buffer attributes correctly.
   * To process them, their `InterleavedBuffer` is returned.
   *
   * @private
   * @param {BufferAttribute} attribute - The attribute.
   * @return {BufferAttribute|InterleavedBuffer}
   */
  _getBufferAttribute(attribute2) {
    if (attribute2.isInterleavedBufferAttribute) attribute2 = attribute2.data;
    return attribute2;
  }
};
var BindGroupLayout = class {
  /**
   * Constructs a new layout.
   *
   * @param {GPUBindGroupLayout} layoutGPU - A GPU Bind Group Layout.
   */
  constructor(layoutGPU) {
    this.layoutGPU = layoutGPU;
    this.usedTimes = 0;
  }
};
var WebGPUBindingUtils = class {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGPUBackend} backend - The WebGPU backend.
   */
  constructor(backend) {
    this.backend = backend;
    this._bindGroupLayoutCache = /* @__PURE__ */ new Map();
  }
  /**
   * Creates a GPU bind group layout for the given bind group.
   *
   * @param {BindGroup} bindGroup - The bind group.
   * @return {GPUBindGroupLayout} The GPU bind group layout.
   */
  createBindingsLayout(bindGroup) {
    const backend = this.backend;
    const device = backend.device;
    const bindingsData = backend.get(bindGroup);
    if (bindingsData.layout) {
      return bindingsData.layout.layoutGPU;
    }
    const entries = this._createLayoutEntries(bindGroup);
    const bindGroupLayoutKey = JSON.stringify(entries);
    let bindGroupLayout = this._bindGroupLayoutCache.get(bindGroupLayoutKey);
    if (bindGroupLayout === void 0) {
      bindGroupLayout = new BindGroupLayout(device.createBindGroupLayout({ entries }));
      this._bindGroupLayoutCache.set(bindGroupLayoutKey, bindGroupLayout);
    }
    bindGroupLayout.usedTimes++;
    bindingsData.layout = bindGroupLayout;
    bindingsData.layoutKey = bindGroupLayoutKey;
    return bindGroupLayout.layoutGPU;
  }
  /**
   * Creates bindings from the given bind group definition.
   *
   * @param {BindGroup} bindGroup - The bind group.
   * @param {Array<BindGroup>} bindings - Array of bind groups.
   * @param {number} cacheIndex - The cache index.
   * @param {number} version - The version.
   */
  createBindings(bindGroup, bindings, cacheIndex, version = 0) {
    const { backend } = this;
    const bindingsData = backend.get(bindGroup);
    const bindLayoutGPU = this.createBindingsLayout(bindGroup);
    let bindGroupGPU;
    if (cacheIndex > 0) {
      if (bindingsData.groups === void 0) {
        bindingsData.groups = [];
        bindingsData.versions = [];
      }
      if (bindingsData.versions[cacheIndex] === version) {
        bindGroupGPU = bindingsData.groups[cacheIndex];
      }
    }
    if (bindGroupGPU === void 0) {
      bindGroupGPU = this.createBindGroup(bindGroup, bindLayoutGPU);
      if (cacheIndex > 0) {
        bindingsData.groups[cacheIndex] = bindGroupGPU;
        bindingsData.versions[cacheIndex] = version;
      }
    }
    bindingsData.group = bindGroupGPU;
  }
  /**
   * Updates a buffer binding.
   *
   *  @param {Buffer} binding - The buffer binding to update.
   */
  updateBinding(binding) {
    const backend = this.backend;
    const device = backend.device;
    const array4 = binding.buffer;
    const buffer2 = backend.get(binding).buffer;
    const updateRanges = binding.updateRanges;
    if (updateRanges.length === 0) {
      device.queue.writeBuffer(
        buffer2,
        0,
        array4,
        0
      );
    } else {
      const isTyped = isTypedArray(array4);
      const byteOffsetFactor = isTyped ? 1 : array4.BYTES_PER_ELEMENT;
      for (let i2 = 0, l2 = updateRanges.length; i2 < l2; i2++) {
        const range4 = updateRanges[i2];
        const dataOffset = range4.start * byteOffsetFactor;
        const size2 = range4.count * byteOffsetFactor;
        const bufferOffset = dataOffset * (isTyped ? array4.BYTES_PER_ELEMENT : 1);
        device.queue.writeBuffer(
          buffer2,
          bufferOffset,
          array4,
          dataOffset,
          size2
        );
      }
      binding.clearUpdateRanges();
    }
  }
  /**
   * Creates a GPU bind group for the camera index.
   *
   * @param {Uint32Array} data - The index data.
   * @param {GPUBindGroupLayout} layoutGPU - The GPU bind group layout.
   * @return {GPUBindGroup} The GPU bind group.
   */
  createBindGroupIndex(data, layoutGPU) {
    const backend = this.backend;
    const device = backend.device;
    const usage = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;
    const index8 = data[0];
    const buffer2 = device.createBuffer({
      label: "bindingCameraIndex_" + index8,
      size: 16,
      // uint(4) * 4
      usage
    });
    device.queue.writeBuffer(buffer2, 0, data, 0);
    const entries = [{ binding: 0, resource: { buffer: buffer2 } }];
    return device.createBindGroup({
      label: "bindGroupCameraIndex_" + index8,
      layout: layoutGPU,
      entries
    });
  }
  /**
   * Creates a GPU bind group for the given bind group and GPU layout.
   *
   * @param {BindGroup} bindGroup - The bind group.
   * @param {GPUBindGroupLayout} layoutGPU - The GPU bind group layout.
   * @return {GPUBindGroup} The GPU bind group.
   */
  createBindGroup(bindGroup, layoutGPU) {
    const backend = this.backend;
    const device = backend.device;
    let bindingPoint = 0;
    const entriesGPU = [];
    for (const binding of bindGroup.bindings) {
      if (binding.isUniformBuffer) {
        const bindingData = backend.get(binding);
        if (bindingData.buffer === void 0) {
          const byteLength = binding.byteLength;
          const usage = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;
          const visibilities = [];
          if (binding.visibility & GPUShaderStage.VERTEX) {
            visibilities.push("vertex");
          }
          if (binding.visibility & GPUShaderStage.FRAGMENT) {
            visibilities.push("fragment");
          }
          if (binding.visibility & GPUShaderStage.COMPUTE) {
            visibilities.push("compute");
          }
          const bufferVisibility = `(${visibilities.join(",")})`;
          const bufferGPU = device.createBuffer({
            label: `bindingBuffer${binding.id}_${binding.name}_${bufferVisibility}`,
            size: byteLength,
            usage
          });
          bindingData.buffer = bufferGPU;
        }
        entriesGPU.push({ binding: bindingPoint, resource: { buffer: bindingData.buffer } });
      } else if (binding.isStorageBuffer) {
        const bindingData = backend.get(binding);
        if (bindingData.buffer === void 0) {
          const attribute2 = binding.attribute;
          bindingData.buffer = backend.get(attribute2).buffer;
        }
        entriesGPU.push({ binding: bindingPoint, resource: { buffer: bindingData.buffer } });
      } else if (binding.isSampledTexture) {
        const textureData = backend.get(binding.texture);
        let resourceGPU;
        if (textureData.externalTexture !== void 0) {
          resourceGPU = device.importExternalTexture({ source: textureData.externalTexture });
        } else {
          const mipLevelCount = binding.store ? 1 : textureData.texture.mipLevelCount;
          const baseMipLevel = binding.store ? binding.mipLevel : 0;
          let propertyName = `view-${textureData.texture.width}-${textureData.texture.height}`;
          if (textureData.texture.depthOrArrayLayers > 1) {
            propertyName += `-${textureData.texture.depthOrArrayLayers}`;
          }
          propertyName += `-${mipLevelCount}-${baseMipLevel}`;
          resourceGPU = textureData[propertyName];
          if (resourceGPU === void 0) {
            const aspectGPU = GPUTextureAspect.All;
            let dimensionViewGPU;
            if (binding.isSampledCubeTexture) {
              dimensionViewGPU = GPUTextureViewDimension.Cube;
            } else if (binding.isSampledTexture3D) {
              dimensionViewGPU = GPUTextureViewDimension.ThreeD;
            } else if (binding.texture.isArrayTexture || binding.texture.isDataArrayTexture || binding.texture.isCompressedArrayTexture) {
              dimensionViewGPU = GPUTextureViewDimension.TwoDArray;
            } else {
              dimensionViewGPU = GPUTextureViewDimension.TwoD;
            }
            resourceGPU = textureData[propertyName] = textureData.texture.createView({ aspect: aspectGPU, dimension: dimensionViewGPU, mipLevelCount, baseMipLevel });
          }
        }
        entriesGPU.push({ binding: bindingPoint, resource: resourceGPU });
      } else if (binding.isSampler) {
        const textureGPU = backend.get(binding.texture);
        entriesGPU.push({ binding: bindingPoint, resource: textureGPU.sampler });
      }
      bindingPoint++;
    }
    return device.createBindGroup({
      label: "bindGroup_" + bindGroup.name,
      layout: layoutGPU,
      entries: entriesGPU
    });
  }
  /**
   * Creates a GPU bind group layout entries for the given bind group.
   *
   * @private
   * @param {BindGroup} bindGroup - The bind group.
   * @return {Array<GPUBindGroupLayoutEntry>} The GPU bind group layout entries.
   */
  _createLayoutEntries(bindGroup) {
    const entries = [];
    let index8 = 0;
    for (const binding of bindGroup.bindings) {
      const backend = this.backend;
      const bindingGPU = {
        binding: index8,
        visibility: binding.visibility
      };
      if (binding.isUniformBuffer || binding.isStorageBuffer) {
        const buffer2 = {};
        if (binding.isStorageBuffer) {
          if (binding.visibility & GPUShaderStage.COMPUTE) {
            if (binding.access === NodeAccess.READ_WRITE || binding.access === NodeAccess.WRITE_ONLY) {
              buffer2.type = GPUBufferBindingType.Storage;
            } else {
              buffer2.type = GPUBufferBindingType.ReadOnlyStorage;
            }
          } else {
            buffer2.type = GPUBufferBindingType.ReadOnlyStorage;
          }
        }
        bindingGPU.buffer = buffer2;
      } else if (binding.isSampledTexture && binding.store) {
        const storageTexture2 = {};
        storageTexture2.format = this.backend.get(binding.texture).texture.format;
        const access = binding.access;
        if (access === NodeAccess.READ_WRITE) {
          storageTexture2.access = GPUStorageTextureAccess.ReadWrite;
        } else if (access === NodeAccess.WRITE_ONLY) {
          storageTexture2.access = GPUStorageTextureAccess.WriteOnly;
        } else {
          storageTexture2.access = GPUStorageTextureAccess.ReadOnly;
        }
        if (binding.texture.isArrayTexture) {
          storageTexture2.viewDimension = GPUTextureViewDimension.TwoDArray;
        } else if (binding.texture.is3DTexture) {
          storageTexture2.viewDimension = GPUTextureViewDimension.ThreeD;
        }
        bindingGPU.storageTexture = storageTexture2;
      } else if (binding.isSampledTexture) {
        const texture2 = {};
        const { primarySamples } = backend.utils.getTextureSampleData(binding.texture);
        if (primarySamples > 1) {
          texture2.multisampled = true;
          if (!binding.texture.isDepthTexture) {
            texture2.sampleType = GPUTextureSampleType.UnfilterableFloat;
          }
        }
        if (binding.texture.isDepthTexture) {
          if (backend.compatibilityMode && binding.texture.compareFunction === null) {
            texture2.sampleType = GPUTextureSampleType.UnfilterableFloat;
          } else {
            texture2.sampleType = GPUTextureSampleType.Depth;
          }
        } else if (binding.texture.isDataTexture || binding.texture.isDataArrayTexture || binding.texture.isData3DTexture) {
          const type = binding.texture.type;
          if (type === IntType) {
            texture2.sampleType = GPUTextureSampleType.SInt;
          } else if (type === UnsignedIntType) {
            texture2.sampleType = GPUTextureSampleType.UInt;
          } else if (type === FloatType) {
            if (this.backend.hasFeature("float32-filterable")) {
              texture2.sampleType = GPUTextureSampleType.Float;
            } else {
              texture2.sampleType = GPUTextureSampleType.UnfilterableFloat;
            }
          }
        }
        if (binding.isSampledCubeTexture) {
          texture2.viewDimension = GPUTextureViewDimension.Cube;
        } else if (binding.texture.isArrayTexture || binding.texture.isDataArrayTexture || binding.texture.isCompressedArrayTexture) {
          texture2.viewDimension = GPUTextureViewDimension.TwoDArray;
        } else if (binding.isSampledTexture3D) {
          texture2.viewDimension = GPUTextureViewDimension.ThreeD;
        }
        bindingGPU.texture = texture2;
      } else if (binding.isSampler) {
        const sampler2 = {};
        if (binding.texture.isDepthTexture) {
          if (binding.texture.compareFunction !== null) {
            sampler2.type = GPUSamplerBindingType.Comparison;
          } else if (backend.compatibilityMode) {
            sampler2.type = GPUSamplerBindingType.NonFiltering;
          }
        }
        bindingGPU.sampler = sampler2;
      } else {
        error(`WebGPUBindingUtils: Unsupported binding "${binding}".`);
      }
      entries.push(bindingGPU);
      index8++;
    }
    return entries;
  }
  /**
   * Delete the data associated with a bind group.
   *
   * @param {BindGroup} bindGroup - The bind group.
   */
  deleteBindGroupData(bindGroup) {
    const { backend } = this;
    const bindingsData = backend.get(bindGroup);
    if (bindingsData.layout) {
      bindingsData.layout.usedTimes--;
      if (bindingsData.layout.usedTimes === 0) {
        this._bindGroupLayoutCache.delete(bindingsData.layoutKey);
      }
      bindingsData.layout = void 0;
      bindingsData.layoutKey = void 0;
    }
  }
  /**
   * Frees internal resources.
   */
  dispose() {
    this._bindGroupLayoutCache.clear();
  }
};
var WebGPUPipelineUtils = class {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGPUBackend} backend - The WebGPU backend.
   */
  constructor(backend) {
    this.backend = backend;
    this._activePipelines = /* @__PURE__ */ new WeakMap();
  }
  /**
   * Sets the given pipeline for the given pass. The method makes sure to only set the
   * pipeline when necessary.
   *
   * @param {(GPURenderPassEncoder|GPUComputePassEncoder)} pass - The pass encoder.
   * @param {(GPURenderPipeline|GPUComputePipeline)} pipeline - The pipeline.
   */
  setPipeline(pass2, pipeline) {
    const currentPipeline = this._activePipelines.get(pass2);
    if (currentPipeline !== pipeline) {
      pass2.setPipeline(pipeline);
      this._activePipelines.set(pass2, pipeline);
    }
  }
  /**
   * Returns the sample count derived from the given render context.
   *
   * @private
   * @param {RenderContext} renderContext - The render context.
   * @return {number} The sample count.
   */
  _getSampleCount(renderContext) {
    return this.backend.utils.getSampleCountRenderContext(renderContext);
  }
  /**
   * Creates a render pipeline for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @param {Array<Promise>} promises - An array of compilation promises which are used in `compileAsync()`.
   */
  createRenderPipeline(renderObject, promises) {
    const { object, material, geometry, pipeline } = renderObject;
    const { vertexProgram, fragmentProgram } = pipeline;
    const backend = this.backend;
    const device = backend.device;
    const utils2 = backend.utils;
    const pipelineData = backend.get(pipeline);
    const bindGroupLayouts = [];
    for (const bindGroup of renderObject.getBindings()) {
      const bindingsData = backend.get(bindGroup);
      const { layoutGPU } = bindingsData.layout;
      bindGroupLayouts.push(layoutGPU);
    }
    const vertexBuffers = backend.attributeUtils.createShaderVertexBuffers(renderObject);
    let blending;
    if (material.blending !== NoBlending && (material.blending !== NormalBlending || material.transparent !== false)) {
      blending = this._getBlending(material);
    }
    let stencilFront = {};
    if (material.stencilWrite === true) {
      stencilFront = {
        compare: this._getStencilCompare(material),
        failOp: this._getStencilOperation(material.stencilFail),
        depthFailOp: this._getStencilOperation(material.stencilZFail),
        passOp: this._getStencilOperation(material.stencilZPass)
      };
    }
    const colorWriteMask = this._getColorWriteMask(material);
    const targets = [];
    if (renderObject.context.textures !== null) {
      const textures = renderObject.context.textures;
      for (let i2 = 0; i2 < textures.length; i2++) {
        const colorFormat = utils2.getTextureFormatGPU(textures[i2]);
        if (i2 === 0) {
          targets.push({
            format: colorFormat,
            blend: blending,
            writeMask: colorWriteMask
          });
        } else {
          targets.push({
            format: colorFormat,
            writeMask: colorWriteMask
          });
        }
      }
    } else {
      const colorFormat = utils2.getCurrentColorFormat(renderObject.context);
      targets.push({
        format: colorFormat,
        blend: blending,
        writeMask: colorWriteMask
      });
    }
    const vertexModule = backend.get(vertexProgram).module;
    const fragmentModule = backend.get(fragmentProgram).module;
    const primitiveState = this._getPrimitiveState(object, geometry, material);
    const depthCompare = this._getDepthCompare(material);
    const depthStencilFormat = utils2.getCurrentDepthStencilFormat(renderObject.context);
    const sampleCount = this._getSampleCount(renderObject.context);
    const pipelineDescriptor = {
      label: `renderPipeline_${material.name || material.type}_${material.id}`,
      vertex: Object.assign({}, vertexModule, { buffers: vertexBuffers }),
      fragment: Object.assign({}, fragmentModule, { targets }),
      primitive: primitiveState,
      multisample: {
        count: sampleCount,
        alphaToCoverageEnabled: material.alphaToCoverage && sampleCount > 1
      },
      layout: device.createPipelineLayout({
        bindGroupLayouts
      })
    };
    const depthStencil = {};
    const renderDepth = renderObject.context.depth;
    const renderStencil = renderObject.context.stencil;
    if (renderDepth === true || renderStencil === true) {
      if (renderDepth === true) {
        depthStencil.format = depthStencilFormat;
        depthStencil.depthWriteEnabled = material.depthWrite;
        depthStencil.depthCompare = depthCompare;
      }
      if (renderStencil === true) {
        depthStencil.stencilFront = stencilFront;
        depthStencil.stencilBack = {};
        depthStencil.stencilReadMask = material.stencilFuncMask;
        depthStencil.stencilWriteMask = material.stencilWriteMask;
      }
      if (material.polygonOffset === true) {
        depthStencil.depthBias = material.polygonOffsetUnits;
        depthStencil.depthBiasSlopeScale = material.polygonOffsetFactor;
        depthStencil.depthBiasClamp = 0;
      }
      pipelineDescriptor.depthStencil = depthStencil;
    }
    device.pushErrorScope("validation");
    if (promises === null) {
      pipelineData.pipeline = device.createRenderPipeline(pipelineDescriptor);
      device.popErrorScope().then((err2) => {
        if (err2 !== null) {
          pipelineData.error = true;
          error(err2.message);
        }
      });
    } else {
      const p3 = new Promise(async (resolve) => {
        try {
          pipelineData.pipeline = await device.createRenderPipelineAsync(pipelineDescriptor);
        } catch (err2) {
        }
        const errorScope = await device.popErrorScope();
        if (errorScope !== null) {
          pipelineData.error = true;
          error(errorScope.message);
        }
        resolve();
      });
      promises.push(p3);
    }
  }
  /**
   * Creates GPU render bundle encoder for the given render context.
   *
   * @param {RenderContext} renderContext - The render context.
   * @param {?string} [label='renderBundleEncoder'] - The label.
   * @return {GPURenderBundleEncoder} The GPU render bundle encoder.
   */
  createBundleEncoder(renderContext, label2 = "renderBundleEncoder") {
    const backend = this.backend;
    const { utils: utils2, device } = backend;
    const depthStencilFormat = utils2.getCurrentDepthStencilFormat(renderContext);
    const colorFormats = utils2.getCurrentColorFormats(renderContext);
    const sampleCount = this._getSampleCount(renderContext);
    const descriptor = {
      label: label2,
      colorFormats,
      depthStencilFormat,
      sampleCount
    };
    return device.createRenderBundleEncoder(descriptor);
  }
  /**
   * Creates a compute pipeline for the given compute node.
   *
   * @param {ComputePipeline} pipeline - The compute pipeline.
   * @param {Array<BindGroup>} bindings - The bindings.
   */
  createComputePipeline(pipeline, bindings) {
    const backend = this.backend;
    const device = backend.device;
    const computeProgram = backend.get(pipeline.computeProgram).module;
    const pipelineGPU = backend.get(pipeline);
    const bindGroupLayouts = [];
    for (const bindingsGroup of bindings) {
      const bindingsData = backend.get(bindingsGroup);
      const { layoutGPU } = bindingsData.layout;
      bindGroupLayouts.push(layoutGPU);
    }
    pipelineGPU.pipeline = device.createComputePipeline({
      compute: computeProgram,
      layout: device.createPipelineLayout({
        bindGroupLayouts
      })
    });
  }
  /**
   * Returns the blending state as a descriptor object required
   * for the pipeline creation.
   *
   * @private
   * @param {Material} material - The material.
   * @return {Object} The blending state.
   */
  _getBlending(material) {
    let color3, alpha;
    const blending = material.blending;
    const blendSrc = material.blendSrc;
    const blendDst = material.blendDst;
    const blendEquation = material.blendEquation;
    if (blending === CustomBlending) {
      const blendSrcAlpha = material.blendSrcAlpha !== null ? material.blendSrcAlpha : blendSrc;
      const blendDstAlpha = material.blendDstAlpha !== null ? material.blendDstAlpha : blendDst;
      const blendEquationAlpha = material.blendEquationAlpha !== null ? material.blendEquationAlpha : blendEquation;
      color3 = {
        srcFactor: this._getBlendFactor(blendSrc),
        dstFactor: this._getBlendFactor(blendDst),
        operation: this._getBlendOperation(blendEquation)
      };
      alpha = {
        srcFactor: this._getBlendFactor(blendSrcAlpha),
        dstFactor: this._getBlendFactor(blendDstAlpha),
        operation: this._getBlendOperation(blendEquationAlpha)
      };
    } else {
      const premultipliedAlpha = material.premultipliedAlpha;
      const setBlend = (srcRGB, dstRGB, srcAlpha, dstAlpha) => {
        color3 = {
          srcFactor: srcRGB,
          dstFactor: dstRGB,
          operation: GPUBlendOperation.Add
        };
        alpha = {
          srcFactor: srcAlpha,
          dstFactor: dstAlpha,
          operation: GPUBlendOperation.Add
        };
      };
      if (premultipliedAlpha) {
        switch (blending) {
          case NormalBlending:
            setBlend(GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha, GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha);
            break;
          case AdditiveBlending:
            setBlend(GPUBlendFactor.One, GPUBlendFactor.One, GPUBlendFactor.One, GPUBlendFactor.One);
            break;
          case SubtractiveBlending:
            setBlend(GPUBlendFactor.Zero, GPUBlendFactor.OneMinusSrc, GPUBlendFactor.Zero, GPUBlendFactor.One);
            break;
          case MultiplyBlending:
            setBlend(GPUBlendFactor.Dst, GPUBlendFactor.OneMinusSrcAlpha, GPUBlendFactor.Zero, GPUBlendFactor.One);
            break;
        }
      } else {
        switch (blending) {
          case NormalBlending:
            setBlend(GPUBlendFactor.SrcAlpha, GPUBlendFactor.OneMinusSrcAlpha, GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha);
            break;
          case AdditiveBlending:
            setBlend(GPUBlendFactor.SrcAlpha, GPUBlendFactor.One, GPUBlendFactor.One, GPUBlendFactor.One);
            break;
          case SubtractiveBlending:
            error("WebGPURenderer: SubtractiveBlending requires material.premultipliedAlpha = true");
            break;
          case MultiplyBlending:
            error("WebGPURenderer: MultiplyBlending requires material.premultipliedAlpha = true");
            break;
        }
      }
    }
    if (color3 !== void 0 && alpha !== void 0) {
      return { color: color3, alpha };
    } else {
      error("WebGPURenderer: Invalid blending: ", blending);
    }
  }
  /**
   * Returns the GPU blend factor which is required for the pipeline creation.
   *
   * @private
   * @param {number} blend - The blend factor as a three.js constant.
   * @return {string} The GPU blend factor.
   */
  _getBlendFactor(blend) {
    let blendFactor;
    switch (blend) {
      case ZeroFactor:
        blendFactor = GPUBlendFactor.Zero;
        break;
      case OneFactor:
        blendFactor = GPUBlendFactor.One;
        break;
      case SrcColorFactor:
        blendFactor = GPUBlendFactor.Src;
        break;
      case OneMinusSrcColorFactor:
        blendFactor = GPUBlendFactor.OneMinusSrc;
        break;
      case SrcAlphaFactor:
        blendFactor = GPUBlendFactor.SrcAlpha;
        break;
      case OneMinusSrcAlphaFactor:
        blendFactor = GPUBlendFactor.OneMinusSrcAlpha;
        break;
      case DstColorFactor:
        blendFactor = GPUBlendFactor.Dst;
        break;
      case OneMinusDstColorFactor:
        blendFactor = GPUBlendFactor.OneMinusDst;
        break;
      case DstAlphaFactor:
        blendFactor = GPUBlendFactor.DstAlpha;
        break;
      case OneMinusDstAlphaFactor:
        blendFactor = GPUBlendFactor.OneMinusDstAlpha;
        break;
      case SrcAlphaSaturateFactor:
        blendFactor = GPUBlendFactor.SrcAlphaSaturated;
        break;
      case BlendColorFactor:
        blendFactor = GPUBlendFactor.Constant;
        break;
      case OneMinusBlendColorFactor:
        blendFactor = GPUBlendFactor.OneMinusConstant;
        break;
      default:
        error("WebGPURenderer: Blend factor not supported.", blend);
    }
    return blendFactor;
  }
  /**
   * Returns the GPU stencil compare function which is required for the pipeline creation.
   *
   * @private
   * @param {Material} material - The material.
   * @return {string} The GPU stencil compare function.
   */
  _getStencilCompare(material) {
    let stencilCompare;
    const stencilFunc = material.stencilFunc;
    switch (stencilFunc) {
      case NeverStencilFunc:
        stencilCompare = GPUCompareFunction.Never;
        break;
      case AlwaysStencilFunc:
        stencilCompare = GPUCompareFunction.Always;
        break;
      case LessStencilFunc:
        stencilCompare = GPUCompareFunction.Less;
        break;
      case LessEqualStencilFunc:
        stencilCompare = GPUCompareFunction.LessEqual;
        break;
      case EqualStencilFunc:
        stencilCompare = GPUCompareFunction.Equal;
        break;
      case GreaterEqualStencilFunc:
        stencilCompare = GPUCompareFunction.GreaterEqual;
        break;
      case GreaterStencilFunc:
        stencilCompare = GPUCompareFunction.Greater;
        break;
      case NotEqualStencilFunc:
        stencilCompare = GPUCompareFunction.NotEqual;
        break;
      default:
        error("WebGPURenderer: Invalid stencil function.", stencilFunc);
    }
    return stencilCompare;
  }
  /**
   * Returns the GPU stencil operation which is required for the pipeline creation.
   *
   * @private
   * @param {number} op - A three.js constant defining the stencil operation.
   * @return {string} The GPU stencil operation.
   */
  _getStencilOperation(op) {
    let stencilOperation;
    switch (op) {
      case KeepStencilOp:
        stencilOperation = GPUStencilOperation.Keep;
        break;
      case ZeroStencilOp:
        stencilOperation = GPUStencilOperation.Zero;
        break;
      case ReplaceStencilOp:
        stencilOperation = GPUStencilOperation.Replace;
        break;
      case InvertStencilOp:
        stencilOperation = GPUStencilOperation.Invert;
        break;
      case IncrementStencilOp:
        stencilOperation = GPUStencilOperation.IncrementClamp;
        break;
      case DecrementStencilOp:
        stencilOperation = GPUStencilOperation.DecrementClamp;
        break;
      case IncrementWrapStencilOp:
        stencilOperation = GPUStencilOperation.IncrementWrap;
        break;
      case DecrementWrapStencilOp:
        stencilOperation = GPUStencilOperation.DecrementWrap;
        break;
      default:
        error("WebGPURenderer: Invalid stencil operation.", stencilOperation);
    }
    return stencilOperation;
  }
  /**
   * Returns the GPU blend operation which is required for the pipeline creation.
   *
   * @private
   * @param {number} blendEquation - A three.js constant defining the blend equation.
   * @return {string} The GPU blend operation.
   */
  _getBlendOperation(blendEquation) {
    let blendOperation;
    switch (blendEquation) {
      case AddEquation:
        blendOperation = GPUBlendOperation.Add;
        break;
      case SubtractEquation:
        blendOperation = GPUBlendOperation.Subtract;
        break;
      case ReverseSubtractEquation:
        blendOperation = GPUBlendOperation.ReverseSubtract;
        break;
      case MinEquation:
        blendOperation = GPUBlendOperation.Min;
        break;
      case MaxEquation:
        blendOperation = GPUBlendOperation.Max;
        break;
      default:
        error("WebGPUPipelineUtils: Blend equation not supported.", blendEquation);
    }
    return blendOperation;
  }
  /**
   * Returns the primitive state as a descriptor object required
   * for the pipeline creation.
   *
   * @private
   * @param {Object3D} object - The 3D object.
   * @param {BufferGeometry} geometry - The geometry.
   * @param {Material} material - The material.
   * @return {Object} The primitive state.
   */
  _getPrimitiveState(object, geometry, material) {
    const descriptor = {};
    const utils2 = this.backend.utils;
    descriptor.topology = utils2.getPrimitiveTopology(object, material);
    if (geometry.index !== null && object.isLine === true && object.isLineSegments !== true) {
      descriptor.stripIndexFormat = geometry.index.array instanceof Uint16Array ? GPUIndexFormat.Uint16 : GPUIndexFormat.Uint32;
    }
    let flipSided = material.side === BackSide;
    if (object.isMesh && object.matrixWorld.determinant() < 0) flipSided = !flipSided;
    descriptor.frontFace = flipSided === true ? GPUFrontFace.CW : GPUFrontFace.CCW;
    descriptor.cullMode = material.side === DoubleSide ? GPUCullMode.None : GPUCullMode.Back;
    return descriptor;
  }
  /**
   * Returns the GPU color write mask which is required for the pipeline creation.
   *
   * @private
   * @param {Material} material - The material.
   * @return {number} The GPU color write mask.
   */
  _getColorWriteMask(material) {
    return material.colorWrite === true ? GPUColorWriteFlags.All : GPUColorWriteFlags.None;
  }
  /**
   * Returns the GPU depth compare function which is required for the pipeline creation.
   *
   * @private
   * @param {Material} material - The material.
   * @return {string} The GPU depth compare function.
   */
  _getDepthCompare(material) {
    let depthCompare;
    if (material.depthTest === false) {
      depthCompare = GPUCompareFunction.Always;
    } else {
      const depthFunc = material.depthFunc;
      switch (depthFunc) {
        case NeverDepth:
          depthCompare = GPUCompareFunction.Never;
          break;
        case AlwaysDepth:
          depthCompare = GPUCompareFunction.Always;
          break;
        case LessDepth:
          depthCompare = GPUCompareFunction.Less;
          break;
        case LessEqualDepth:
          depthCompare = GPUCompareFunction.LessEqual;
          break;
        case EqualDepth:
          depthCompare = GPUCompareFunction.Equal;
          break;
        case GreaterEqualDepth:
          depthCompare = GPUCompareFunction.GreaterEqual;
          break;
        case GreaterDepth:
          depthCompare = GPUCompareFunction.Greater;
          break;
        case NotEqualDepth:
          depthCompare = GPUCompareFunction.NotEqual;
          break;
        default:
          error("WebGPUPipelineUtils: Invalid depth function.", depthFunc);
      }
    }
    return depthCompare;
  }
};
var WebGPUTimestampQueryPool = class extends TimestampQueryPool {
  /**
   * Creates a new WebGPU timestamp query pool.
   *
   * @param {GPUDevice} device - The WebGPU device to create queries on.
   * @param {string} type - The type identifier for this query pool.
   * @param {number} [maxQueries=2048] - Maximum number of queries this pool can hold.
   */
  constructor(device, type, maxQueries = 2048) {
    super(maxQueries);
    this.device = device;
    this.type = type;
    this.querySet = this.device.createQuerySet({
      type: "timestamp",
      count: this.maxQueries,
      label: `queryset_global_timestamp_${type}`
    });
    const bufferSize = this.maxQueries * 8;
    this.resolveBuffer = this.device.createBuffer({
      label: `buffer_timestamp_resolve_${type}`,
      size: bufferSize,
      usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC
    });
    this.resultBuffer = this.device.createBuffer({
      label: `buffer_timestamp_result_${type}`,
      size: bufferSize,
      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
    });
  }
  /**
   * Allocates a pair of queries for a given render context.
   *
   * @param {string} uid - A unique identifier for the render context.
   * @returns {?number} The base offset for the allocated queries, or null if allocation failed.
   */
  allocateQueriesForContext(uid) {
    if (!this.trackTimestamp || this.isDisposed) return null;
    if (this.currentQueryIndex + 2 > this.maxQueries) {
      warnOnce(`WebGPUTimestampQueryPool [${this.type}]: Maximum number of queries exceeded, when using trackTimestamp it is necessary to resolves the queries via renderer.resolveTimestampsAsync( THREE.TimestampQuery.${this.type.toUpperCase()} ).`);
      return null;
    }
    const baseOffset = this.currentQueryIndex;
    this.currentQueryIndex += 2;
    this.queryOffsets.set(uid, baseOffset);
    return baseOffset;
  }
  /**
   * Asynchronously resolves all pending queries and returns the total duration.
   * If there's already a pending resolve operation, returns that promise instead.
   *
   * @async
   * @returns {Promise<number>} The total duration in milliseconds, or the last valid value if resolution fails.
   */
  async resolveQueriesAsync() {
    if (!this.trackTimestamp || this.currentQueryIndex === 0 || this.isDisposed) {
      return this.lastValue;
    }
    if (this.pendingResolve) {
      return this.pendingResolve;
    }
    this.pendingResolve = this._resolveQueries();
    try {
      const result2 = await this.pendingResolve;
      return result2;
    } finally {
      this.pendingResolve = null;
    }
  }
  /**
   * Internal method to resolve queries and calculate total duration.
   *
   * @async
   * @private
   * @returns {Promise<number>} The total duration in milliseconds.
   */
  async _resolveQueries() {
    if (this.isDisposed) {
      return this.lastValue;
    }
    try {
      if (this.resultBuffer.mapState !== "unmapped") {
        return this.lastValue;
      }
      const currentOffsets = new Map(this.queryOffsets);
      const queryCount = this.currentQueryIndex;
      const bytesUsed = queryCount * 8;
      this.currentQueryIndex = 0;
      this.queryOffsets.clear();
      const commandEncoder = this.device.createCommandEncoder();
      commandEncoder.resolveQuerySet(
        this.querySet,
        0,
        queryCount,
        this.resolveBuffer,
        0
      );
      commandEncoder.copyBufferToBuffer(
        this.resolveBuffer,
        0,
        this.resultBuffer,
        0,
        bytesUsed
      );
      const commandBuffer = commandEncoder.finish();
      this.device.queue.submit([commandBuffer]);
      if (this.resultBuffer.mapState !== "unmapped") {
        return this.lastValue;
      }
      await this.resultBuffer.mapAsync(GPUMapMode.READ, 0, bytesUsed);
      if (this.isDisposed) {
        if (this.resultBuffer.mapState === "mapped") {
          this.resultBuffer.unmap();
        }
        return this.lastValue;
      }
      const times2 = new BigUint64Array(this.resultBuffer.getMappedRange(0, bytesUsed));
      const framesDuration = {};
      const frames = [];
      for (const [uid, baseOffset] of currentOffsets) {
        const match = uid.match(/^(.*):f(\d+)$/);
        const frame2 = parseInt(match[2]);
        if (frames.includes(frame2) === false) {
          frames.push(frame2);
        }
        if (framesDuration[frame2] === void 0) framesDuration[frame2] = 0;
        const startTime = times2[baseOffset];
        const endTime = times2[baseOffset + 1];
        const duration = Number(endTime - startTime) / 1e6;
        this.timestamps.set(uid, duration);
        framesDuration[frame2] += duration;
      }
      const totalDuration = framesDuration[frames[frames.length - 1]];
      this.resultBuffer.unmap();
      this.lastValue = totalDuration;
      this.frames = frames;
      return totalDuration;
    } catch (e3) {
      error("Error resolving queries:", e3);
      if (this.resultBuffer.mapState === "mapped") {
        this.resultBuffer.unmap();
      }
      return this.lastValue;
    }
  }
  /**
   * Dispose of the query pool.
   *
   * @async
   * @returns {Promise} A Promise that resolves when the dispose has been executed.
   */
  async dispose() {
    if (this.isDisposed) {
      return;
    }
    this.isDisposed = true;
    if (this.pendingResolve) {
      try {
        await this.pendingResolve;
      } catch (e3) {
        error("Error waiting for pending resolve:", e3);
      }
    }
    if (this.resultBuffer && this.resultBuffer.mapState === "mapped") {
      try {
        this.resultBuffer.unmap();
      } catch (e3) {
        error("Error unmapping buffer:", e3);
      }
    }
    if (this.querySet) {
      this.querySet.destroy();
      this.querySet = null;
    }
    if (this.resolveBuffer) {
      this.resolveBuffer.destroy();
      this.resolveBuffer = null;
    }
    if (this.resultBuffer) {
      this.resultBuffer.destroy();
      this.resultBuffer = null;
    }
    this.queryOffsets.clear();
    this.pendingResolve = null;
  }
};
var WebGPUBackend = class extends Backend {
  /**
   * WebGPUBackend options.
   *
   * @typedef {Object} WebGPUBackend~Options
   * @property {boolean} [logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.
   * @property {boolean} [alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.
   * @property {boolean} [compatibilityMode=false] - Whether the backend should be in compatibility mode or not.
   * @property {boolean} [depth=true] - Whether the default framebuffer should have a depth buffer or not.
   * @property {boolean} [stencil=false] - Whether the default framebuffer should have a stencil buffer or not.
   * @property {boolean} [antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.
   * @property {number} [samples=0] - When `antialias` is `true`, `4` samples are used by default. Set this parameter to any other integer value than 0 to overwrite the default.
   * @property {boolean} [forceWebGL=false] - If set to `true`, the renderer uses a WebGL 2 backend no matter if WebGPU is supported or not.
   * @property {boolean} [trackTimestamp=false] - Whether to track timestamps with a Timestamp Query API or not.
   * @property {string} [powerPreference=undefined] - The power preference.
   * @property {Object} [requiredLimits=undefined] - Specifies the limits that are required by the device request. The request will fail if the adapter cannot provide these limits.
   * @property {GPUDevice} [device=undefined] - If there is an existing GPU device on app level, it can be passed to the renderer as a parameter.
   * @property {number} [outputType=undefined] - Texture type for output to canvas. By default, device's preferred format is used; other formats may incur overhead.
   */
  /**
   * Constructs a new WebGPU backend.
   *
   * @param {WebGPUBackend~Options} [parameters] - The configuration parameter.
   */
  constructor(parameters = {}) {
    super(parameters);
    this.isWebGPUBackend = true;
    this.parameters.alpha = parameters.alpha === void 0 ? true : parameters.alpha;
    this.parameters.compatibilityMode = parameters.compatibilityMode === void 0 ? false : parameters.compatibilityMode;
    this.parameters.requiredLimits = parameters.requiredLimits === void 0 ? {} : parameters.requiredLimits;
    this.compatibilityMode = this.parameters.compatibilityMode;
    this.device = null;
    this.defaultRenderPassdescriptor = null;
    this.utils = new WebGPUUtils(this);
    this.attributeUtils = new WebGPUAttributeUtils(this);
    this.bindingUtils = new WebGPUBindingUtils(this);
    this.pipelineUtils = new WebGPUPipelineUtils(this);
    this.textureUtils = new WebGPUTextureUtils(this);
    this.occludedResolveCache = /* @__PURE__ */ new Map();
  }
  /**
   * Initializes the backend so it is ready for usage.
   *
   * @async
   * @param {Renderer} renderer - The renderer.
   * @return {Promise} A Promise that resolves when the backend has been initialized.
   */
  async init(renderer3) {
    await super.init(renderer3);
    const parameters = this.parameters;
    let device;
    if (parameters.device === void 0) {
      const adapterOptions = {
        powerPreference: parameters.powerPreference,
        featureLevel: parameters.compatibilityMode ? "compatibility" : void 0
      };
      const adapter = typeof navigator !== "undefined" ? await navigator.gpu.requestAdapter(adapterOptions) : null;
      if (adapter === null) {
        throw new Error("WebGPUBackend: Unable to create WebGPU adapter.");
      }
      const features = Object.values(GPUFeatureName);
      const supportedFeatures = [];
      for (const name of features) {
        if (adapter.features.has(name)) {
          supportedFeatures.push(name);
        }
      }
      const deviceDescriptor = {
        requiredFeatures: supportedFeatures,
        requiredLimits: parameters.requiredLimits
      };
      device = await adapter.requestDevice(deviceDescriptor);
    } else {
      device = parameters.device;
    }
    device.lost.then((info) => {
      if (info.reason === "destroyed") return;
      const deviceLossInfo = {
        api: "WebGPU",
        message: info.message || "Unknown reason",
        reason: info.reason || null,
        originalEvent: info
      };
      renderer3.onDeviceLost(deviceLossInfo);
    });
    this.device = device;
    this.trackTimestamp = this.trackTimestamp && this.hasFeature(GPUFeatureName.TimestampQuery);
    this.updateSize();
  }
  /**
   * A reference to the context.
   *
   * @type {?GPUCanvasContext}
   * @default null
   */
  get context() {
    const canvasTarget = this.renderer.getCanvasTarget();
    const canvasData = this.get(canvasTarget);
    let context2 = canvasData.context;
    if (context2 === void 0) {
      const parameters = this.parameters;
      if (canvasTarget.isDefaultCanvasTarget === true && parameters.context !== void 0) {
        context2 = parameters.context;
      } else {
        context2 = canvasTarget.domElement.getContext("webgpu");
      }
      if ("setAttribute" in canvasTarget.domElement) canvasTarget.domElement.setAttribute("data-engine", `three.js r${REVISION} webgpu`);
      const alphaMode = parameters.alpha ? "premultiplied" : "opaque";
      const toneMappingMode = parameters.outputType === HalfFloatType ? "extended" : "standard";
      context2.configure({
        device: this.device,
        format: this.utils.getPreferredCanvasFormat(),
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
        alphaMode,
        toneMapping: {
          mode: toneMappingMode
        }
      });
      canvasData.context = context2;
    }
    return context2;
  }
  /**
   * The coordinate system of the backend.
   *
   * @type {number}
   * @readonly
   */
  get coordinateSystem() {
    return WebGPUCoordinateSystem;
  }
  /**
   * This method performs a readback operation by moving buffer data from
   * a storage buffer attribute from the GPU to the CPU.
   *
   * @async
   * @param {StorageBufferAttribute} attribute - The storage buffer attribute.
   * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.
   */
  async getArrayBufferAsync(attribute2) {
    return await this.attributeUtils.getArrayBufferAsync(attribute2);
  }
  /**
   * Returns the backend's rendering context.
   *
   * @return {GPUCanvasContext} The rendering context.
   */
  getContext() {
    return this.context;
  }
  /**
   * Returns the default render pass descriptor.
   *
   * In WebGPU, the default framebuffer must be configured
   * like custom framebuffers so the backend needs a render
   * pass descriptor even when rendering directly to screen.
   *
   * @private
   * @return {Object} The render pass descriptor.
   */
  _getDefaultRenderPassDescriptor() {
    const renderer3 = this.renderer;
    const canvasTarget = renderer3.getCanvasTarget();
    const canvasData = this.get(canvasTarget);
    const samples = renderer3.currentSamples;
    let descriptor = canvasData.descriptor;
    if (descriptor === void 0 || canvasData.samples !== samples) {
      descriptor = {
        colorAttachments: [{
          view: null
        }]
      };
      if (renderer3.depth === true || renderer3.stencil === true) {
        descriptor.depthStencilAttachment = {
          view: this.textureUtils.getDepthBuffer(renderer3.depth, renderer3.stencil).createView()
        };
      }
      const colorAttachment2 = descriptor.colorAttachments[0];
      if (samples > 0) {
        colorAttachment2.view = this.textureUtils.getColorBuffer().createView();
      } else {
        colorAttachment2.resolveTarget = void 0;
      }
      canvasData.descriptor = descriptor;
      canvasData.samples = samples;
    }
    const colorAttachment = descriptor.colorAttachments[0];
    if (samples > 0) {
      colorAttachment.resolveTarget = this.context.getCurrentTexture().createView();
    } else {
      colorAttachment.view = this.context.getCurrentTexture().createView();
    }
    return descriptor;
  }
  /**
   * Internal to determine if the current render target is a render target array with depth 2D array texture.
   *
   * @param {RenderContext} renderContext - The render context.
   * @return {boolean} Whether the render target is a render target array with depth 2D array texture.
   *
   * @private
   */
  _isRenderCameraDepthArray(renderContext) {
    return renderContext.depthTexture && renderContext.depthTexture.image.depth > 1 && renderContext.camera.isArrayCamera;
  }
  /**
   * Returns the render pass descriptor for the given render context.
   *
   * @private
   * @param {RenderContext} renderContext - The render context.
   * @param {Object} colorAttachmentsConfig - Configuration object for the color attachments.
   * @return {Object} The render pass descriptor.
   */
  _getRenderPassDescriptor(renderContext, colorAttachmentsConfig = {}) {
    const renderTarget = renderContext.renderTarget;
    const renderTargetData = this.get(renderTarget);
    let descriptors = renderTargetData.descriptors;
    if (descriptors === void 0 || renderTargetData.width !== renderTarget.width || renderTargetData.height !== renderTarget.height || renderTargetData.samples !== renderTarget.samples) {
      descriptors = {};
      renderTargetData.descriptors = descriptors;
    }
    const cacheKey = renderContext.getCacheKey();
    let descriptorBase = descriptors[cacheKey];
    if (descriptorBase === void 0) {
      const textures = renderContext.textures;
      const textureViews = [];
      let sliceIndex;
      const isRenderCameraDepthArray = this._isRenderCameraDepthArray(renderContext);
      for (let i2 = 0; i2 < textures.length; i2++) {
        const textureData = this.get(textures[i2]);
        const viewDescriptor = {
          label: `colorAttachment_${i2}`,
          baseMipLevel: renderContext.activeMipmapLevel,
          mipLevelCount: 1,
          baseArrayLayer: renderContext.activeCubeFace,
          arrayLayerCount: 1,
          dimension: GPUTextureViewDimension.TwoD
        };
        if (renderTarget.isRenderTarget3D) {
          sliceIndex = renderContext.activeCubeFace;
          viewDescriptor.baseArrayLayer = 0;
          viewDescriptor.dimension = GPUTextureViewDimension.ThreeD;
          viewDescriptor.depthOrArrayLayers = textures[i2].image.depth;
        } else if (renderTarget.isRenderTarget && textures[i2].image.depth > 1) {
          if (isRenderCameraDepthArray === true) {
            const cameras = renderContext.camera.cameras;
            for (let layer = 0; layer < cameras.length; layer++) {
              const layerViewDescriptor = {
                ...viewDescriptor,
                baseArrayLayer: layer,
                arrayLayerCount: 1,
                dimension: GPUTextureViewDimension.TwoD
              };
              const textureView = textureData.texture.createView(layerViewDescriptor);
              textureViews.push({
                view: textureView,
                resolveTarget: void 0,
                depthSlice: void 0
              });
            }
          } else {
            viewDescriptor.dimension = GPUTextureViewDimension.TwoDArray;
            viewDescriptor.depthOrArrayLayers = textures[i2].image.depth;
          }
        }
        if (isRenderCameraDepthArray !== true) {
          const textureView = textureData.texture.createView(viewDescriptor);
          let view, resolveTarget;
          if (textureData.msaaTexture !== void 0) {
            view = textureData.msaaTexture.createView();
            resolveTarget = textureView;
          } else {
            view = textureView;
            resolveTarget = void 0;
          }
          textureViews.push({
            view,
            resolveTarget,
            depthSlice: sliceIndex
          });
        }
      }
      descriptorBase = { textureViews };
      if (renderContext.depth) {
        const depthTextureData = this.get(renderContext.depthTexture);
        const options = {};
        if (renderContext.depthTexture.isArrayTexture || renderContext.depthTexture.isCubeTexture) {
          options.dimension = GPUTextureViewDimension.TwoD;
          options.arrayLayerCount = 1;
          options.baseArrayLayer = renderContext.activeCubeFace;
        }
        descriptorBase.depthStencilView = depthTextureData.texture.createView(options);
      }
      descriptors[cacheKey] = descriptorBase;
      renderTargetData.width = renderTarget.width;
      renderTargetData.height = renderTarget.height;
      renderTargetData.samples = renderTarget.samples;
      renderTargetData.activeMipmapLevel = renderContext.activeMipmapLevel;
      renderTargetData.activeCubeFace = renderContext.activeCubeFace;
    }
    const descriptor = {
      colorAttachments: []
    };
    for (let i2 = 0; i2 < descriptorBase.textureViews.length; i2++) {
      const viewInfo = descriptorBase.textureViews[i2];
      let clearValue = { r: 0, g: 0, b: 0, a: 1 };
      if (i2 === 0 && colorAttachmentsConfig.clearValue) {
        clearValue = colorAttachmentsConfig.clearValue;
      }
      descriptor.colorAttachments.push({
        view: viewInfo.view,
        depthSlice: viewInfo.depthSlice,
        resolveTarget: viewInfo.resolveTarget,
        loadOp: colorAttachmentsConfig.loadOp || GPULoadOp.Load,
        storeOp: colorAttachmentsConfig.storeOp || GPUStoreOp.Store,
        clearValue
      });
    }
    if (descriptorBase.depthStencilView) {
      descriptor.depthStencilAttachment = {
        view: descriptorBase.depthStencilView
      };
    }
    return descriptor;
  }
  /**
   * This method is executed at the beginning of a render call and prepares
   * the WebGPU state for upcoming render calls
   *
   * @param {RenderContext} renderContext - The render context.
   */
  beginRender(renderContext) {
    const renderContextData = this.get(renderContext);
    const device = this.device;
    const occlusionQueryCount = renderContext.occlusionQueryCount;
    let occlusionQuerySet;
    if (occlusionQueryCount > 0) {
      if (renderContextData.currentOcclusionQuerySet) renderContextData.currentOcclusionQuerySet.destroy();
      if (renderContextData.currentOcclusionQueryBuffer) renderContextData.currentOcclusionQueryBuffer.destroy();
      renderContextData.currentOcclusionQuerySet = renderContextData.occlusionQuerySet;
      renderContextData.currentOcclusionQueryBuffer = renderContextData.occlusionQueryBuffer;
      renderContextData.currentOcclusionQueryObjects = renderContextData.occlusionQueryObjects;
      occlusionQuerySet = device.createQuerySet({ type: "occlusion", count: occlusionQueryCount, label: `occlusionQuerySet_${renderContext.id}` });
      renderContextData.occlusionQuerySet = occlusionQuerySet;
      renderContextData.occlusionQueryIndex = 0;
      renderContextData.occlusionQueryObjects = new Array(occlusionQueryCount);
      renderContextData.lastOcclusionObject = null;
    }
    let descriptor;
    if (renderContext.textures === null) {
      descriptor = this._getDefaultRenderPassDescriptor();
    } else {
      descriptor = this._getRenderPassDescriptor(renderContext, { loadOp: GPULoadOp.Load });
    }
    this.initTimestampQuery(TimestampQuery.RENDER, this.getTimestampUID(renderContext), descriptor);
    descriptor.occlusionQuerySet = occlusionQuerySet;
    const depthStencilAttachment = descriptor.depthStencilAttachment;
    if (renderContext.textures !== null) {
      const colorAttachments = descriptor.colorAttachments;
      for (let i2 = 0; i2 < colorAttachments.length; i2++) {
        const colorAttachment = colorAttachments[i2];
        if (renderContext.clearColor) {
          colorAttachment.clearValue = i2 === 0 ? renderContext.clearColorValue : { r: 0, g: 0, b: 0, a: 1 };
          colorAttachment.loadOp = GPULoadOp.Clear;
        } else {
          colorAttachment.loadOp = GPULoadOp.Load;
        }
        colorAttachment.storeOp = GPUStoreOp.Store;
      }
    } else {
      const colorAttachment = descriptor.colorAttachments[0];
      if (renderContext.clearColor) {
        colorAttachment.clearValue = renderContext.clearColorValue;
        colorAttachment.loadOp = GPULoadOp.Clear;
      } else {
        colorAttachment.loadOp = GPULoadOp.Load;
      }
      colorAttachment.storeOp = GPUStoreOp.Store;
    }
    if (renderContext.depth) {
      if (renderContext.clearDepth) {
        depthStencilAttachment.depthClearValue = renderContext.clearDepthValue;
        depthStencilAttachment.depthLoadOp = GPULoadOp.Clear;
      } else {
        depthStencilAttachment.depthLoadOp = GPULoadOp.Load;
      }
      depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;
    }
    if (renderContext.stencil) {
      if (renderContext.clearStencil) {
        depthStencilAttachment.stencilClearValue = renderContext.clearStencilValue;
        depthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;
      } else {
        depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;
      }
      depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;
    }
    const encoder = device.createCommandEncoder({ label: "renderContext_" + renderContext.id });
    if (this._isRenderCameraDepthArray(renderContext) === true) {
      const cameras = renderContext.camera.cameras;
      if (!renderContextData.layerDescriptors || renderContextData.layerDescriptors.length !== cameras.length) {
        this._createDepthLayerDescriptors(renderContext, renderContextData, descriptor, cameras);
      } else {
        this._updateDepthLayerDescriptors(renderContext, renderContextData, cameras);
      }
      renderContextData.bundleEncoders = [];
      renderContextData.bundleSets = [];
      for (let i2 = 0; i2 < cameras.length; i2++) {
        const bundleEncoder = this.pipelineUtils.createBundleEncoder(
          renderContext,
          "renderBundleArrayCamera_" + i2
        );
        const bundleSets = {
          attributes: {},
          bindingGroups: [],
          pipeline: null,
          index: null
        };
        renderContextData.bundleEncoders.push(bundleEncoder);
        renderContextData.bundleSets.push(bundleSets);
      }
      renderContextData.currentPass = null;
    } else {
      const currentPass = encoder.beginRenderPass(descriptor);
      renderContextData.currentPass = currentPass;
      if (renderContext.viewport) {
        this.updateViewport(renderContext);
      }
      if (renderContext.scissor) {
        this.updateScissor(renderContext);
      }
    }
    renderContextData.descriptor = descriptor;
    renderContextData.encoder = encoder;
    renderContextData.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null };
    renderContextData.renderBundles = [];
  }
  /**
   * This method creates layer descriptors for each camera in an array camera
   * to prepare for rendering to a depth array texture.
   *
   * @param {RenderContext} renderContext - The render context.
   * @param {Object} renderContextData - The render context data.
   * @param {Object} descriptor  - The render pass descriptor.
   * @param {ArrayCamera} cameras - The array camera.
   *
   * @private
   */
  _createDepthLayerDescriptors(renderContext, renderContextData, descriptor, cameras) {
    const depthStencilAttachment = descriptor.depthStencilAttachment;
    renderContextData.layerDescriptors = [];
    const depthTextureData = this.get(renderContext.depthTexture);
    if (!depthTextureData.viewCache) {
      depthTextureData.viewCache = [];
    }
    for (let i2 = 0; i2 < cameras.length; i2++) {
      const layerDescriptor = {
        ...descriptor,
        colorAttachments: [{
          ...descriptor.colorAttachments[0],
          view: descriptor.colorAttachments[i2].view
        }]
      };
      if (descriptor.depthStencilAttachment) {
        const layerIndex = i2;
        if (!depthTextureData.viewCache[layerIndex]) {
          depthTextureData.viewCache[layerIndex] = depthTextureData.texture.createView({
            dimension: GPUTextureViewDimension.TwoD,
            baseArrayLayer: i2,
            arrayLayerCount: 1
          });
        }
        layerDescriptor.depthStencilAttachment = {
          view: depthTextureData.viewCache[layerIndex],
          depthLoadOp: depthStencilAttachment.depthLoadOp || GPULoadOp.Clear,
          depthStoreOp: depthStencilAttachment.depthStoreOp || GPUStoreOp.Store,
          depthClearValue: depthStencilAttachment.depthClearValue || 1
        };
        if (renderContext.stencil) {
          layerDescriptor.depthStencilAttachment.stencilLoadOp = depthStencilAttachment.stencilLoadOp;
          layerDescriptor.depthStencilAttachment.stencilStoreOp = depthStencilAttachment.stencilStoreOp;
          layerDescriptor.depthStencilAttachment.stencilClearValue = depthStencilAttachment.stencilClearValue;
        }
      } else {
        layerDescriptor.depthStencilAttachment = { ...depthStencilAttachment };
      }
      renderContextData.layerDescriptors.push(layerDescriptor);
    }
  }
  /**
   * This method updates the layer descriptors for each camera in an array camera
   * to prepare for rendering to a depth array texture.
   *
   * @param {RenderContext} renderContext - The render context.
   * @param {Object} renderContextData - The render context data.
   * @param {ArrayCamera} cameras - The array camera.
   *
   */
  _updateDepthLayerDescriptors(renderContext, renderContextData, cameras) {
    for (let i2 = 0; i2 < cameras.length; i2++) {
      const layerDescriptor = renderContextData.layerDescriptors[i2];
      if (layerDescriptor.depthStencilAttachment) {
        const depthAttachment = layerDescriptor.depthStencilAttachment;
        if (renderContext.depth) {
          if (renderContext.clearDepth) {
            depthAttachment.depthClearValue = renderContext.clearDepthValue;
            depthAttachment.depthLoadOp = GPULoadOp.Clear;
          } else {
            depthAttachment.depthLoadOp = GPULoadOp.Load;
          }
        }
        if (renderContext.stencil) {
          if (renderContext.clearStencil) {
            depthAttachment.stencilClearValue = renderContext.clearStencilValue;
            depthAttachment.stencilLoadOp = GPULoadOp.Clear;
          } else {
            depthAttachment.stencilLoadOp = GPULoadOp.Load;
          }
        }
      }
    }
  }
  /**
   * This method is executed at the end of a render call and finalizes work
   * after draw calls.
   *
   * @param {RenderContext} renderContext - The render context.
   */
  finishRender(renderContext) {
    const renderContextData = this.get(renderContext);
    const occlusionQueryCount = renderContext.occlusionQueryCount;
    if (renderContextData.renderBundles.length > 0) {
      renderContextData.currentPass.executeBundles(renderContextData.renderBundles);
    }
    if (occlusionQueryCount > renderContextData.occlusionQueryIndex) {
      renderContextData.currentPass.endOcclusionQuery();
    }
    const encoder = renderContextData.encoder;
    if (this._isRenderCameraDepthArray(renderContext) === true) {
      const bundles = [];
      for (let i2 = 0; i2 < renderContextData.bundleEncoders.length; i2++) {
        const bundleEncoder = renderContextData.bundleEncoders[i2];
        bundles.push(bundleEncoder.finish());
      }
      for (let i2 = 0; i2 < renderContextData.layerDescriptors.length; i2++) {
        if (i2 < bundles.length) {
          const layerDescriptor = renderContextData.layerDescriptors[i2];
          const renderPass = encoder.beginRenderPass(layerDescriptor);
          if (renderContext.viewport) {
            const { x: x3, y: y3, width, height, minDepth, maxDepth } = renderContext.viewportValue;
            renderPass.setViewport(x3, y3, width, height, minDepth, maxDepth);
          }
          if (renderContext.scissor) {
            const { x: x3, y: y3, width, height } = renderContext.scissorValue;
            renderPass.setScissorRect(x3, y3, width, height);
          }
          renderPass.executeBundles([bundles[i2]]);
          renderPass.end();
        }
      }
    } else if (renderContextData.currentPass) {
      renderContextData.currentPass.end();
    }
    if (occlusionQueryCount > 0) {
      const bufferSize = occlusionQueryCount * 8;
      let queryResolveBuffer = this.occludedResolveCache.get(bufferSize);
      if (queryResolveBuffer === void 0) {
        queryResolveBuffer = this.device.createBuffer(
          {
            size: bufferSize,
            usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC
          }
        );
        this.occludedResolveCache.set(bufferSize, queryResolveBuffer);
      }
      const readBuffer = this.device.createBuffer(
        {
          size: bufferSize,
          usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
        }
      );
      renderContextData.encoder.resolveQuerySet(renderContextData.occlusionQuerySet, 0, occlusionQueryCount, queryResolveBuffer, 0);
      renderContextData.encoder.copyBufferToBuffer(queryResolveBuffer, 0, readBuffer, 0, bufferSize);
      renderContextData.occlusionQueryBuffer = readBuffer;
      this.resolveOccludedAsync(renderContext);
    }
    this.device.queue.submit([renderContextData.encoder.finish()]);
    if (renderContext.textures !== null) {
      const textures = renderContext.textures;
      for (let i2 = 0; i2 < textures.length; i2++) {
        const texture2 = textures[i2];
        if (texture2.generateMipmaps === true) {
          this.textureUtils.generateMipmaps(texture2);
        }
      }
    }
  }
  /**
   * Returns `true` if the given 3D object is fully occluded by other
   * 3D objects in the scene.
   *
   * @param {RenderContext} renderContext - The render context.
   * @param {Object3D} object - The 3D object to test.
   * @return {boolean} Whether the 3D object is fully occluded or not.
   */
  isOccluded(renderContext, object) {
    const renderContextData = this.get(renderContext);
    return renderContextData.occluded && renderContextData.occluded.has(object);
  }
  /**
   * This method processes the result of occlusion queries and writes it
   * into render context data.
   *
   * @async
   * @param {RenderContext} renderContext - The render context.
   * @return {Promise} A Promise that resolves when the occlusion query results have been processed.
   */
  async resolveOccludedAsync(renderContext) {
    const renderContextData = this.get(renderContext);
    const { currentOcclusionQueryBuffer, currentOcclusionQueryObjects } = renderContextData;
    if (currentOcclusionQueryBuffer && currentOcclusionQueryObjects) {
      const occluded = /* @__PURE__ */ new WeakSet();
      renderContextData.currentOcclusionQueryObjects = null;
      renderContextData.currentOcclusionQueryBuffer = null;
      await currentOcclusionQueryBuffer.mapAsync(GPUMapMode.READ);
      const buffer2 = currentOcclusionQueryBuffer.getMappedRange();
      const results = new BigUint64Array(buffer2);
      for (let i2 = 0; i2 < currentOcclusionQueryObjects.length; i2++) {
        if (results[i2] === BigInt(0)) {
          occluded.add(currentOcclusionQueryObjects[i2]);
        }
      }
      currentOcclusionQueryBuffer.destroy();
      renderContextData.occluded = occluded;
    }
  }
  /**
   * Updates the viewport with the values from the given render context.
   *
   * @param {RenderContext} renderContext - The render context.
   */
  updateViewport(renderContext) {
    const { currentPass } = this.get(renderContext);
    const { x: x3, y: y3, width, height, minDepth, maxDepth } = renderContext.viewportValue;
    currentPass.setViewport(x3, y3, width, height, minDepth, maxDepth);
  }
  /**
   * Updates the scissor with the values from the given render context.
   *
   * @param {RenderContext} renderContext - The render context.
   */
  updateScissor(renderContext) {
    const { currentPass } = this.get(renderContext);
    const { x: x3, y: y3, width, height } = renderContext.scissorValue;
    currentPass.setScissorRect(x3, y3, width, height);
  }
  /**
   * Returns the clear color and alpha into a single
   * color object.
   *
   * @return {Color4} The clear color.
   */
  getClearColor() {
    const clearColor = super.getClearColor();
    if (this.renderer.alpha === true) {
      clearColor.r *= clearColor.a;
      clearColor.g *= clearColor.a;
      clearColor.b *= clearColor.a;
    }
    return clearColor;
  }
  /**
   * Performs a clear operation.
   *
   * @param {boolean} color - Whether the color buffer should be cleared or not.
   * @param {boolean} depth - Whether the depth buffer should be cleared or not.
   * @param {boolean} stencil - Whether the stencil buffer should be cleared or not.
   * @param {?RenderContext} [renderTargetContext=null] - The render context of the current set render target.
   */
  clear(color3, depth2, stencil, renderTargetContext = null) {
    const device = this.device;
    const renderer3 = this.renderer;
    let colorAttachments = [];
    let depthStencilAttachment;
    let clearValue;
    let supportsDepth;
    let supportsStencil;
    if (color3) {
      const clearColor = this.getClearColor();
      clearValue = { r: clearColor.r, g: clearColor.g, b: clearColor.b, a: clearColor.a };
    }
    if (renderTargetContext === null) {
      supportsDepth = renderer3.depth;
      supportsStencil = renderer3.stencil;
      const descriptor = this._getDefaultRenderPassDescriptor();
      if (color3) {
        colorAttachments = descriptor.colorAttachments;
        const colorAttachment = colorAttachments[0];
        colorAttachment.clearValue = clearValue;
        colorAttachment.loadOp = GPULoadOp.Clear;
        colorAttachment.storeOp = GPUStoreOp.Store;
      }
      if (supportsDepth || supportsStencil) {
        depthStencilAttachment = descriptor.depthStencilAttachment;
      }
    } else {
      supportsDepth = renderTargetContext.depth;
      supportsStencil = renderTargetContext.stencil;
      const clearConfig = {
        loadOp: color3 ? GPULoadOp.Clear : GPULoadOp.Load,
        clearValue: color3 ? clearValue : void 0
      };
      if (supportsDepth) {
        clearConfig.depthLoadOp = depth2 ? GPULoadOp.Clear : GPULoadOp.Load;
        clearConfig.depthClearValue = depth2 ? renderer3.getClearDepth() : void 0;
        clearConfig.depthStoreOp = GPUStoreOp.Store;
      }
      if (supportsStencil) {
        clearConfig.stencilLoadOp = stencil ? GPULoadOp.Clear : GPULoadOp.Load;
        clearConfig.stencilClearValue = stencil ? renderer3.getClearStencil() : void 0;
        clearConfig.stencilStoreOp = GPUStoreOp.Store;
      }
      const descriptor = this._getRenderPassDescriptor(renderTargetContext, clearConfig);
      colorAttachments = descriptor.colorAttachments;
      depthStencilAttachment = descriptor.depthStencilAttachment;
    }
    if (supportsDepth && depthStencilAttachment) {
      if (depth2) {
        depthStencilAttachment.depthLoadOp = GPULoadOp.Clear;
        depthStencilAttachment.depthClearValue = renderer3.getClearDepth();
        depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;
      } else {
        depthStencilAttachment.depthLoadOp = GPULoadOp.Load;
        depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;
      }
    }
    if (supportsStencil && depthStencilAttachment) {
      if (stencil) {
        depthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;
        depthStencilAttachment.stencilClearValue = renderer3.getClearStencil();
        depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;
      } else {
        depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;
        depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;
      }
    }
    const encoder = device.createCommandEncoder({ label: "clear" });
    const currentPass = encoder.beginRenderPass({
      colorAttachments,
      depthStencilAttachment
    });
    currentPass.end();
    device.queue.submit([encoder.finish()]);
  }
  // compute
  /**
   * This method is executed at the beginning of a compute call and
   * prepares the state for upcoming compute tasks.
   *
   * @param {Node|Array<Node>} computeGroup - The compute node(s).
   */
  beginCompute(computeGroup) {
    const groupGPU = this.get(computeGroup);
    const descriptor = {
      label: "computeGroup_" + computeGroup.id
    };
    this.initTimestampQuery(TimestampQuery.COMPUTE, this.getTimestampUID(computeGroup), descriptor);
    groupGPU.cmdEncoderGPU = this.device.createCommandEncoder({ label: "computeGroup_" + computeGroup.id });
    groupGPU.passEncoderGPU = groupGPU.cmdEncoderGPU.beginComputePass(descriptor);
  }
  /**
   * Executes a compute command for the given compute node.
   *
   * @param {Node|Array<Node>} computeGroup - The group of compute nodes of a compute call. Can be a single compute node.
   * @param {Node} computeNode - The compute node.
   * @param {Array<BindGroup>} bindings - The bindings.
   * @param {ComputePipeline} pipeline - The compute pipeline.
   * @param {number|Array<number>|IndirectStorageBufferAttribute} [dispatchSize=null]
   * - A single number representing count, or
   * - An array [x, y, z] representing dispatch size, or
   * - A IndirectStorageBufferAttribute for indirect dispatch size.
   */
  compute(computeGroup, computeNode, bindings, pipeline, dispatchSize = null) {
    const computeNodeData = this.get(computeNode);
    const { passEncoderGPU } = this.get(computeGroup);
    const pipelineGPU = this.get(pipeline).pipeline;
    this.pipelineUtils.setPipeline(passEncoderGPU, pipelineGPU);
    for (let i2 = 0, l2 = bindings.length; i2 < l2; i2++) {
      const bindGroup = bindings[i2];
      const bindingsData = this.get(bindGroup);
      passEncoderGPU.setBindGroup(i2, bindingsData.group);
    }
    if (dispatchSize === null) {
      dispatchSize = computeNode.count;
    }
    if (dispatchSize && typeof dispatchSize === "object" && dispatchSize.isIndirectStorageBufferAttribute) {
      const dispatchBuffer = this.get(dispatchSize).buffer;
      passEncoderGPU.dispatchWorkgroupsIndirect(dispatchBuffer, 0);
      return;
    }
    if (typeof dispatchSize === "number") {
      const count2 = dispatchSize;
      if (computeNodeData.dispatchSize === void 0 || computeNodeData.count !== count2) {
        computeNodeData.dispatchSize = [0, 1, 1];
        computeNodeData.count = count2;
        const workgroupSize = computeNode.workgroupSize;
        let size2 = workgroupSize[0];
        for (let i2 = 1; i2 < workgroupSize.length; i2++)
          size2 *= workgroupSize[i2];
        const dispatchCount = Math.ceil(count2 / size2);
        const maxComputeWorkgroupsPerDimension = this.device.limits.maxComputeWorkgroupsPerDimension;
        dispatchSize = [dispatchCount, 1, 1];
        if (dispatchCount > maxComputeWorkgroupsPerDimension) {
          dispatchSize[0] = Math.min(dispatchCount, maxComputeWorkgroupsPerDimension);
          dispatchSize[1] = Math.ceil(dispatchCount / maxComputeWorkgroupsPerDimension);
        }
        computeNodeData.dispatchSize = dispatchSize;
      }
      dispatchSize = computeNodeData.dispatchSize;
    }
    passEncoderGPU.dispatchWorkgroups(
      dispatchSize[0],
      dispatchSize[1] || 1,
      dispatchSize[2] || 1
    );
  }
  /**
   * This method is executed at the end of a compute call and
   * finalizes work after compute tasks.
   *
   * @param {Node|Array<Node>} computeGroup - The compute node(s).
   */
  finishCompute(computeGroup) {
    const groupData = this.get(computeGroup);
    groupData.passEncoderGPU.end();
    this.device.queue.submit([groupData.cmdEncoderGPU.finish()]);
  }
  // render object
  /**
   * Executes a draw command for the given render object.
   *
   * @param {RenderObject} renderObject - The render object to draw.
   * @param {Info} info - Holds a series of statistical information about the GPU memory and the rendering process.
   */
  draw(renderObject, info) {
    const { object, material, context: context2, pipeline } = renderObject;
    const bindings = renderObject.getBindings();
    const renderContextData = this.get(context2);
    const pipelineData = this.get(pipeline);
    const pipelineGPU = pipelineData.pipeline;
    if (pipelineData.error === true) return;
    const index8 = renderObject.getIndex();
    const hasIndex = index8 !== null;
    const drawParams = renderObject.getDrawParameters();
    if (drawParams === null) return;
    const setPipelineAndBindings = (passEncoderGPU, currentSets) => {
      this.pipelineUtils.setPipeline(passEncoderGPU, pipelineGPU);
      currentSets.pipeline = pipelineGPU;
      const currentBindingGroups = currentSets.bindingGroups;
      for (let i2 = 0, l2 = bindings.length; i2 < l2; i2++) {
        const bindGroup = bindings[i2];
        const bindingsData = this.get(bindGroup);
        if (currentBindingGroups[bindGroup.index] !== bindGroup.id) {
          passEncoderGPU.setBindGroup(bindGroup.index, bindingsData.group);
          currentBindingGroups[bindGroup.index] = bindGroup.id;
        }
      }
      if (hasIndex === true) {
        if (currentSets.index !== index8) {
          const buffer2 = this.get(index8).buffer;
          const indexFormat = index8.array instanceof Uint16Array ? GPUIndexFormat.Uint16 : GPUIndexFormat.Uint32;
          passEncoderGPU.setIndexBuffer(buffer2, indexFormat);
          currentSets.index = index8;
        }
      }
      const vertexBuffers = renderObject.getVertexBuffers();
      for (let i2 = 0, l2 = vertexBuffers.length; i2 < l2; i2++) {
        const vertexBuffer = vertexBuffers[i2];
        if (currentSets.attributes[i2] !== vertexBuffer) {
          const buffer2 = this.get(vertexBuffer).buffer;
          passEncoderGPU.setVertexBuffer(i2, buffer2);
          currentSets.attributes[i2] = vertexBuffer;
        }
      }
      if (context2.stencil === true && material.stencilWrite === true && renderContextData.currentStencilRef !== material.stencilRef) {
        passEncoderGPU.setStencilReference(material.stencilRef);
        renderContextData.currentStencilRef = material.stencilRef;
      }
    };
    const draw = (passEncoderGPU, currentSets) => {
      setPipelineAndBindings(passEncoderGPU, currentSets);
      if (object.isBatchedMesh === true) {
        const starts = object._multiDrawStarts;
        const counts = object._multiDrawCounts;
        const drawCount = object._multiDrawCount;
        const drawInstances = object._multiDrawInstances;
        if (drawInstances !== null) {
          warnOnce("WebGPUBackend: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection.");
        }
        for (let i2 = 0; i2 < drawCount; i2++) {
          const count2 = drawInstances ? drawInstances[i2] : 1;
          const firstInstance = count2 > 1 ? 0 : i2;
          if (hasIndex === true) {
            passEncoderGPU.drawIndexed(counts[i2], count2, starts[i2] / index8.array.BYTES_PER_ELEMENT, 0, firstInstance);
          } else {
            passEncoderGPU.draw(counts[i2], count2, starts[i2], firstInstance);
          }
          info.update(object, counts[i2], count2);
        }
      } else if (hasIndex === true) {
        const { vertexCount: indexCount, instanceCount, firstVertex: firstIndex } = drawParams;
        const indirect = renderObject.getIndirect();
        if (indirect !== null) {
          const buffer2 = this.get(indirect).buffer;
          const indirectOffset = renderObject.getIndirectOffset();
          const indirectOffsets = Array.isArray(indirectOffset) ? indirectOffset : [indirectOffset];
          for (let i2 = 0; i2 < indirectOffsets.length; i2++) {
            passEncoderGPU.drawIndexedIndirect(buffer2, indirectOffsets[i2]);
          }
        } else {
          passEncoderGPU.drawIndexed(indexCount, instanceCount, firstIndex, 0, 0);
        }
        info.update(object, indexCount, instanceCount);
      } else {
        const { vertexCount, instanceCount, firstVertex } = drawParams;
        const indirect = renderObject.getIndirect();
        if (indirect !== null) {
          const buffer2 = this.get(indirect).buffer;
          const indirectOffset = renderObject.getIndirectOffset();
          const indirectOffsets = Array.isArray(indirectOffset) ? indirectOffset : [indirectOffset];
          for (let i2 = 0; i2 < indirectOffsets.length; i2++) {
            passEncoderGPU.drawIndirect(buffer2, indirectOffsets[i2]);
          }
        } else {
          passEncoderGPU.draw(vertexCount, instanceCount, firstVertex, 0);
        }
        info.update(object, vertexCount, instanceCount);
      }
    };
    if (renderObject.camera.isArrayCamera && renderObject.camera.cameras.length > 0) {
      const cameraData = this.get(renderObject.camera);
      const cameras = renderObject.camera.cameras;
      const cameraIndex2 = renderObject.getBindingGroup("cameraIndex");
      if (cameraData.indexesGPU === void 0 || cameraData.indexesGPU.length !== cameras.length) {
        const bindingsData = this.get(cameraIndex2);
        const indexesGPU = [];
        const data = new Uint32Array([0, 0, 0, 0]);
        for (let i2 = 0, len = cameras.length; i2 < len; i2++) {
          data[0] = i2;
          const { layoutGPU } = bindingsData.layout;
          const bindGroupIndex = this.bindingUtils.createBindGroupIndex(data, layoutGPU);
          indexesGPU.push(bindGroupIndex);
        }
        cameraData.indexesGPU = indexesGPU;
      }
      const pixelRatio = this.renderer.getPixelRatio();
      for (let i2 = 0, len = cameras.length; i2 < len; i2++) {
        const subCamera = cameras[i2];
        if (object.layers.test(subCamera.layers)) {
          const vp = subCamera.viewport;
          let pass2 = renderContextData.currentPass;
          let sets = renderContextData.currentSets;
          if (renderContextData.bundleEncoders) {
            const bundleEncoder = renderContextData.bundleEncoders[i2];
            const bundleSets = renderContextData.bundleSets[i2];
            pass2 = bundleEncoder;
            sets = bundleSets;
          }
          if (vp) {
            pass2.setViewport(
              Math.floor(vp.x * pixelRatio),
              Math.floor(vp.y * pixelRatio),
              Math.floor(vp.width * pixelRatio),
              Math.floor(vp.height * pixelRatio),
              context2.viewportValue.minDepth,
              context2.viewportValue.maxDepth
            );
          }
          if (cameraIndex2 && cameraData.indexesGPU) {
            pass2.setBindGroup(cameraIndex2.index, cameraData.indexesGPU[i2]);
            sets.bindingGroups[cameraIndex2.index] = cameraIndex2.id;
          }
          draw(pass2, sets);
        }
      }
    } else {
      if (renderContextData.currentPass) {
        if (renderContextData.occlusionQuerySet !== void 0) {
          const lastObject = renderContextData.lastOcclusionObject;
          if (lastObject !== object) {
            if (lastObject !== null && lastObject.occlusionTest === true) {
              renderContextData.currentPass.endOcclusionQuery();
              renderContextData.occlusionQueryIndex++;
            }
            if (object.occlusionTest === true) {
              renderContextData.currentPass.beginOcclusionQuery(renderContextData.occlusionQueryIndex);
              renderContextData.occlusionQueryObjects[renderContextData.occlusionQueryIndex] = object;
            }
            renderContextData.lastOcclusionObject = object;
          }
        }
        draw(renderContextData.currentPass, renderContextData.currentSets);
      }
    }
  }
  // cache key
  /**
   * Returns `true` if the render pipeline requires an update.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {boolean} Whether the render pipeline requires an update or not.
   */
  needsRenderUpdate(renderObject) {
    const data = this.get(renderObject);
    const { object, material } = renderObject;
    const utils2 = this.utils;
    const sampleCount = utils2.getSampleCountRenderContext(renderObject.context);
    const colorSpace = utils2.getCurrentColorSpace(renderObject.context);
    const colorFormat = utils2.getCurrentColorFormat(renderObject.context);
    const depthStencilFormat = utils2.getCurrentDepthStencilFormat(renderObject.context);
    const primitiveTopology = utils2.getPrimitiveTopology(object, material);
    let needsUpdate = false;
    if (data.material !== material || data.materialVersion !== material.version || data.transparent !== material.transparent || data.blending !== material.blending || data.premultipliedAlpha !== material.premultipliedAlpha || data.blendSrc !== material.blendSrc || data.blendDst !== material.blendDst || data.blendEquation !== material.blendEquation || data.blendSrcAlpha !== material.blendSrcAlpha || data.blendDstAlpha !== material.blendDstAlpha || data.blendEquationAlpha !== material.blendEquationAlpha || data.colorWrite !== material.colorWrite || data.depthWrite !== material.depthWrite || data.depthTest !== material.depthTest || data.depthFunc !== material.depthFunc || data.stencilWrite !== material.stencilWrite || data.stencilFunc !== material.stencilFunc || data.stencilFail !== material.stencilFail || data.stencilZFail !== material.stencilZFail || data.stencilZPass !== material.stencilZPass || data.stencilFuncMask !== material.stencilFuncMask || data.stencilWriteMask !== material.stencilWriteMask || data.side !== material.side || data.alphaToCoverage !== material.alphaToCoverage || data.sampleCount !== sampleCount || data.colorSpace !== colorSpace || data.colorFormat !== colorFormat || data.depthStencilFormat !== depthStencilFormat || data.primitiveTopology !== primitiveTopology || data.clippingContextCacheKey !== renderObject.clippingContextCacheKey) {
      data.material = material;
      data.materialVersion = material.version;
      data.transparent = material.transparent;
      data.blending = material.blending;
      data.premultipliedAlpha = material.premultipliedAlpha;
      data.blendSrc = material.blendSrc;
      data.blendDst = material.blendDst;
      data.blendEquation = material.blendEquation;
      data.blendSrcAlpha = material.blendSrcAlpha;
      data.blendDstAlpha = material.blendDstAlpha;
      data.blendEquationAlpha = material.blendEquationAlpha;
      data.colorWrite = material.colorWrite;
      data.depthWrite = material.depthWrite;
      data.depthTest = material.depthTest;
      data.depthFunc = material.depthFunc;
      data.stencilWrite = material.stencilWrite;
      data.stencilFunc = material.stencilFunc;
      data.stencilFail = material.stencilFail;
      data.stencilZFail = material.stencilZFail;
      data.stencilZPass = material.stencilZPass;
      data.stencilFuncMask = material.stencilFuncMask;
      data.stencilWriteMask = material.stencilWriteMask;
      data.side = material.side;
      data.alphaToCoverage = material.alphaToCoverage;
      data.sampleCount = sampleCount;
      data.colorSpace = colorSpace;
      data.colorFormat = colorFormat;
      data.depthStencilFormat = depthStencilFormat;
      data.primitiveTopology = primitiveTopology;
      data.clippingContextCacheKey = renderObject.clippingContextCacheKey;
      needsUpdate = true;
    }
    return needsUpdate;
  }
  /**
   * Returns a cache key that is used to identify render pipelines.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {string} The cache key.
   */
  getRenderCacheKey(renderObject) {
    const { object, material } = renderObject;
    const utils2 = this.utils;
    const renderContext = renderObject.context;
    const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
    return [
      material.transparent,
      material.blending,
      material.premultipliedAlpha,
      material.blendSrc,
      material.blendDst,
      material.blendEquation,
      material.blendSrcAlpha,
      material.blendDstAlpha,
      material.blendEquationAlpha,
      material.colorWrite,
      material.depthWrite,
      material.depthTest,
      material.depthFunc,
      material.stencilWrite,
      material.stencilFunc,
      material.stencilFail,
      material.stencilZFail,
      material.stencilZPass,
      material.stencilFuncMask,
      material.stencilWriteMask,
      material.side,
      frontFaceCW,
      utils2.getSampleCountRenderContext(renderContext),
      utils2.getCurrentColorSpace(renderContext),
      utils2.getCurrentColorFormat(renderContext),
      utils2.getCurrentDepthStencilFormat(renderContext),
      utils2.getPrimitiveTopology(object, material),
      renderObject.getGeometryCacheKey(),
      renderObject.clippingContextCacheKey
    ].join();
  }
  // textures
  /**
   * Updates a GPU sampler for the given texture.
   *
   * @param {Texture} texture - The texture to update the sampler for.
   * @return {string} The current sampler key.
   */
  updateSampler(texture2) {
    return this.textureUtils.updateSampler(texture2);
  }
  /**
   * Creates a default texture for the given texture that can be used
   * as a placeholder until the actual texture is ready for usage.
   *
   * @param {Texture} texture - The texture to create a default texture for.
   * @return {boolean} Whether the sampler has been updated or not.
   */
  createDefaultTexture(texture2) {
    return this.textureUtils.createDefaultTexture(texture2);
  }
  /**
   * Defines a texture on the GPU for the given texture object.
   *
   * @param {Texture} texture - The texture.
   * @param {Object} [options={}] - Optional configuration parameter.
   */
  createTexture(texture2, options) {
    this.textureUtils.createTexture(texture2, options);
  }
  /**
   * Uploads the updated texture data to the GPU.
   *
   * @param {Texture} texture - The texture.
   * @param {Object} [options={}] - Optional configuration parameter.
   */
  updateTexture(texture2, options) {
    this.textureUtils.updateTexture(texture2, options);
  }
  /**
   * Generates mipmaps for the given texture.
   *
   * @param {Texture} texture - The texture.
   */
  generateMipmaps(texture2) {
    this.textureUtils.generateMipmaps(texture2);
  }
  /**
   * Destroys the GPU data for the given texture object.
   *
   * @param {Texture} texture - The texture.
   * @param {boolean} [isDefaultTexture=false] - Whether the texture uses a default GPU texture or not.
   */
  destroyTexture(texture2, isDefaultTexture = false) {
    this.textureUtils.destroyTexture(texture2, isDefaultTexture);
  }
  /**
   * Returns texture data as a typed array.
   *
   * @async
   * @param {Texture} texture - The texture to copy.
   * @param {number} x - The x coordinate of the copy origin.
   * @param {number} y - The y coordinate of the copy origin.
   * @param {number} width - The width of the copy.
   * @param {number} height - The height of the copy.
   * @param {number} faceIndex - The face index.
   * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.
   */
  async copyTextureToBuffer(texture2, x3, y3, width, height, faceIndex) {
    return this.textureUtils.copyTextureToBuffer(texture2, x3, y3, width, height, faceIndex);
  }
  /**
   * Inits a time stamp query for the given render context.
   *
   * @param {string} type - The type of the timestamp query (e.g. 'render', 'compute').
   * @param {number} uid - Unique id for the context (e.g. render context id).
   * @param {Object} descriptor - The query descriptor.
   */
  initTimestampQuery(type, uid, descriptor) {
    if (!this.trackTimestamp) return;
    if (!this.timestampQueryPool[type]) {
      this.timestampQueryPool[type] = new WebGPUTimestampQueryPool(this.device, type, 2048);
    }
    const timestampQueryPool = this.timestampQueryPool[type];
    const baseOffset = timestampQueryPool.allocateQueriesForContext(uid);
    descriptor.timestampWrites = {
      querySet: timestampQueryPool.querySet,
      beginningOfPassWriteIndex: baseOffset,
      endOfPassWriteIndex: baseOffset + 1
    };
  }
  // node builder
  /**
   * Returns a node builder for the given render object.
   *
   * @param {RenderObject} object - The render object.
   * @param {Renderer} renderer - The renderer.
   * @return {WGSLNodeBuilder} The node builder.
   */
  createNodeBuilder(object, renderer3) {
    return new WGSLNodeBuilder(object, renderer3);
  }
  // program
  /**
   * Creates a shader program from the given programmable stage.
   *
   * @param {ProgrammableStage} program - The programmable stage.
   */
  createProgram(program) {
    const programGPU = this.get(program);
    programGPU.module = {
      module: this.device.createShaderModule({ code: program.code, label: program.stage + (program.name !== "" ? `_${program.name}` : "") }),
      entryPoint: "main"
    };
  }
  /**
   * Destroys the shader program of the given programmable stage.
   *
   * @param {ProgrammableStage} program - The programmable stage.
   */
  destroyProgram(program) {
    this.delete(program);
  }
  // pipelines
  /**
   * Creates a render pipeline for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @param {Array<Promise>} promises - An array of compilation promises which are used in `compileAsync()`.
   */
  createRenderPipeline(renderObject, promises) {
    this.pipelineUtils.createRenderPipeline(renderObject, promises);
  }
  /**
   * Creates a compute pipeline for the given compute node.
   *
   * @param {ComputePipeline} computePipeline - The compute pipeline.
   * @param {Array<BindGroup>} bindings - The bindings.
   */
  createComputePipeline(computePipeline, bindings) {
    this.pipelineUtils.createComputePipeline(computePipeline, bindings);
  }
  /**
   * Prepares the state for encoding render bundles.
   *
   * @param {RenderContext} renderContext - The render context.
   */
  beginBundle(renderContext) {
    const renderContextData = this.get(renderContext);
    renderContextData._currentPass = renderContextData.currentPass;
    renderContextData._currentSets = renderContextData.currentSets;
    renderContextData.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null };
    renderContextData.currentPass = this.pipelineUtils.createBundleEncoder(renderContext);
  }
  /**
   * After processing render bundles this method finalizes related work.
   *
   * @param {RenderContext} renderContext - The render context.
   * @param {RenderBundle} bundle - The render bundle.
   */
  finishBundle(renderContext, bundle) {
    const renderContextData = this.get(renderContext);
    const bundleEncoder = renderContextData.currentPass;
    const bundleGPU = bundleEncoder.finish();
    this.get(bundle).bundleGPU = bundleGPU;
    renderContextData.currentSets = renderContextData._currentSets;
    renderContextData.currentPass = renderContextData._currentPass;
  }
  /**
   * Adds a render bundle to the render context data.
   *
   * @param {RenderContext} renderContext - The render context.
   * @param {RenderBundle} bundle - The render bundle to add.
   */
  addBundle(renderContext, bundle) {
    const renderContextData = this.get(renderContext);
    renderContextData.renderBundles.push(this.get(bundle).bundleGPU);
  }
  // bindings
  /**
   * Creates bindings from the given bind group definition.
   *
   * @param {BindGroup} bindGroup - The bind group.
   * @param {Array<BindGroup>} bindings - Array of bind groups.
   * @param {number} cacheIndex - The cache index.
   * @param {number} version - The version.
   */
  createBindings(bindGroup, bindings, cacheIndex, version) {
    this.bindingUtils.createBindings(bindGroup, bindings, cacheIndex, version);
  }
  /**
   * Updates the given bind group definition.
   *
   * @param {BindGroup} bindGroup - The bind group.
   * @param {Array<BindGroup>} bindings - Array of bind groups.
   * @param {number} cacheIndex - The cache index.
   * @param {number} version - The version.
   */
  updateBindings(bindGroup, bindings, cacheIndex, version) {
    this.bindingUtils.createBindings(bindGroup, bindings, cacheIndex, version);
  }
  /**
   * Updates a buffer binding.
   *
   *  @param {Buffer} binding - The buffer binding to update.
   */
  updateBinding(binding) {
    this.bindingUtils.updateBinding(binding);
  }
  /**
   * Delete data associated with the current bind group.
   *
   * @param {BindGroup} bindGroup - The bind group.
   */
  deleteBindGroupData(bindGroup) {
    this.bindingUtils.deleteBindGroupData(bindGroup);
  }
  // attributes
  /**
   * Creates the buffer of an indexed shader attribute.
   *
   * @param {BufferAttribute} attribute - The indexed buffer attribute.
   */
  createIndexAttribute(attribute2) {
    let usage = GPUBufferUsage.INDEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST;
    if (attribute2.isStorageBufferAttribute || attribute2.isStorageInstancedBufferAttribute) {
      usage |= GPUBufferUsage.STORAGE;
    }
    this.attributeUtils.createAttribute(attribute2, usage);
  }
  /**
   * Creates the GPU buffer of a shader attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  createAttribute(attribute2) {
    this.attributeUtils.createAttribute(attribute2, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);
  }
  /**
   * Creates the GPU buffer of a storage attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  createStorageAttribute(attribute2) {
    this.attributeUtils.createAttribute(attribute2, GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);
  }
  /**
   * Creates the GPU buffer of an indirect storage attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  createIndirectStorageAttribute(attribute2) {
    this.attributeUtils.createAttribute(attribute2, GPUBufferUsage.STORAGE | GPUBufferUsage.INDIRECT | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);
  }
  /**
   * Updates the GPU buffer of a shader attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute to update.
   */
  updateAttribute(attribute2) {
    this.attributeUtils.updateAttribute(attribute2);
  }
  /**
   * Destroys the GPU buffer of a shader attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute to destroy.
   */
  destroyAttribute(attribute2) {
    this.attributeUtils.destroyAttribute(attribute2);
  }
  // canvas
  /**
   * Triggers an update of the default render pass descriptor.
   */
  updateSize() {
    this.delete(this.renderer.getCanvasTarget());
  }
  // utils public
  /**
   * Returns the maximum anisotropy texture filtering value.
   *
   * @return {number} The maximum anisotropy texture filtering value.
   */
  getMaxAnisotropy() {
    return 16;
  }
  /**
   * Checks if the given feature is supported by the backend.
   *
   * @param {string} name - The feature's name.
   * @return {boolean} Whether the feature is supported or not.
   */
  hasFeature(name) {
    if (GPUFeatureMap[name] !== void 0) name = GPUFeatureMap[name];
    return this.device.features.has(name);
  }
  /**
   * Copies data of the given source texture to the given destination texture.
   *
   * @param {Texture} srcTexture - The source texture.
   * @param {Texture} dstTexture - The destination texture.
   * @param {?(Box3|Box2)} [srcRegion=null] - The region of the source texture to copy.
   * @param {?(Vector2|Vector3)} [dstPosition=null] - The destination position of the copy.
   * @param {number} [srcLevel=0] - The mipmap level to copy.
   * @param {number} [dstLevel=0] - The destination mip level to copy to.
   */
  copyTextureToTexture(srcTexture, dstTexture, srcRegion = null, dstPosition = null, srcLevel = 0, dstLevel = 0) {
    let dstX = 0;
    let dstY = 0;
    let dstZ = 0;
    let srcX = 0;
    let srcY = 0;
    let srcZ = 0;
    let srcWidth = srcTexture.image.width;
    let srcHeight = srcTexture.image.height;
    let srcDepth = 1;
    if (srcRegion !== null) {
      if (srcRegion.isBox3 === true) {
        srcX = srcRegion.min.x;
        srcY = srcRegion.min.y;
        srcZ = srcRegion.min.z;
        srcWidth = srcRegion.max.x - srcRegion.min.x;
        srcHeight = srcRegion.max.y - srcRegion.min.y;
        srcDepth = srcRegion.max.z - srcRegion.min.z;
      } else {
        srcX = srcRegion.min.x;
        srcY = srcRegion.min.y;
        srcWidth = srcRegion.max.x - srcRegion.min.x;
        srcHeight = srcRegion.max.y - srcRegion.min.y;
        srcDepth = 1;
      }
    }
    if (dstPosition !== null) {
      dstX = dstPosition.x;
      dstY = dstPosition.y;
      dstZ = dstPosition.z || 0;
    }
    const encoder = this.device.createCommandEncoder({ label: "copyTextureToTexture_" + srcTexture.id + "_" + dstTexture.id });
    const sourceGPU = this.get(srcTexture).texture;
    const destinationGPU = this.get(dstTexture).texture;
    encoder.copyTextureToTexture(
      {
        texture: sourceGPU,
        mipLevel: srcLevel,
        origin: { x: srcX, y: srcY, z: srcZ }
      },
      {
        texture: destinationGPU,
        mipLevel: dstLevel,
        origin: { x: dstX, y: dstY, z: dstZ }
      },
      [
        srcWidth,
        srcHeight,
        srcDepth
      ]
    );
    this.device.queue.submit([encoder.finish()]);
    if (dstLevel === 0 && dstTexture.generateMipmaps) {
      this.textureUtils.generateMipmaps(dstTexture);
    }
  }
  /**
   * Copies the current bound framebuffer to the given texture.
   *
   * @param {Texture} texture - The destination texture.
   * @param {RenderContext} renderContext - The render context.
   * @param {Vector4} rectangle - A four dimensional vector defining the origin and dimension of the copy.
   */
  copyFramebufferToTexture(texture2, renderContext, rectangle) {
    const renderContextData = this.get(renderContext);
    let sourceGPU = null;
    if (renderContext.renderTarget) {
      if (texture2.isDepthTexture) {
        sourceGPU = this.get(renderContext.depthTexture).texture;
      } else {
        sourceGPU = this.get(renderContext.textures[0]).texture;
      }
    } else {
      if (texture2.isDepthTexture) {
        sourceGPU = this.textureUtils.getDepthBuffer(renderContext.depth, renderContext.stencil);
      } else {
        sourceGPU = this.context.getCurrentTexture();
      }
    }
    const destinationGPU = this.get(texture2).texture;
    if (sourceGPU.format !== destinationGPU.format) {
      error("WebGPUBackend: copyFramebufferToTexture: Source and destination formats do not match.", sourceGPU.format, destinationGPU.format);
      return;
    }
    let encoder;
    if (renderContextData.currentPass) {
      renderContextData.currentPass.end();
      encoder = renderContextData.encoder;
    } else {
      encoder = this.device.createCommandEncoder({ label: "copyFramebufferToTexture_" + texture2.id });
    }
    encoder.copyTextureToTexture(
      {
        texture: sourceGPU,
        origin: [rectangle.x, rectangle.y, 0]
      },
      {
        texture: destinationGPU
      },
      [
        rectangle.z,
        rectangle.w
      ]
    );
    if (texture2.generateMipmaps) {
      this.textureUtils.generateMipmaps(texture2, encoder);
    }
    if (renderContextData.currentPass) {
      const { descriptor } = renderContextData;
      for (let i2 = 0; i2 < descriptor.colorAttachments.length; i2++) {
        descriptor.colorAttachments[i2].loadOp = GPULoadOp.Load;
      }
      if (renderContext.depth) descriptor.depthStencilAttachment.depthLoadOp = GPULoadOp.Load;
      if (renderContext.stencil) descriptor.depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;
      renderContextData.currentPass = encoder.beginRenderPass(descriptor);
      renderContextData.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null };
      if (renderContext.viewport) {
        this.updateViewport(renderContext);
      }
      if (renderContext.scissor) {
        this.updateScissor(renderContext);
      }
    } else {
      this.device.queue.submit([encoder.finish()]);
    }
  }
  dispose() {
    this.bindingUtils.dispose();
    this.textureUtils.dispose();
    if (this.occludedResolveCache) {
      for (const buffer2 of this.occludedResolveCache.values()) {
        buffer2.destroy();
      }
      this.occludedResolveCache.clear();
    }
    if (this.timestampQueryPool) {
      for (const queryPool of Object.values(this.timestampQueryPool)) {
        if (queryPool !== null) queryPool.dispose();
      }
    }
    if (this.parameters.device === void 0 && this.device !== null) {
      this.device.destroy();
    }
  }
};
var IESSpotLight = class extends SpotLight {
  /**
   * Constructs a new IES spot light.
   *
   * @param {(number|Color|string)} [color=0xffffff] - The light's color.
   * @param {number} [intensity=1] - The light's strength/intensity measured in candela (cd).
   * @param {number} [distance=0] - Maximum range of the light. `0` means no limit.
   * @param {number} [angle=Math.PI/3] - Maximum angle of light dispersion from its direction whose upper bound is `Math.PI/2`.
   * @param {number} [penumbra=0] - Percent of the spotlight cone that is attenuated due to penumbra. Value range is `[0,1]`.
   * @param {number} [decay=2] - The amount the light dims along the distance of the light.
   */
  constructor(color3, intensity, distance4, angle2, penumbra, decay) {
    super(color3, intensity, distance4, angle2, penumbra, decay);
    this.iesMap = null;
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.iesMap = source.iesMap;
    return this;
  }
};
var ProjectorLight = class extends SpotLight {
  /**
   * Constructs a new projector light.
   *
   * @param {(number|Color|string)} [color=0xffffff] - The light's color.
   * @param {number} [intensity=1] - The light's strength/intensity measured in candela (cd).
   * @param {number} [distance=0] - Maximum range of the light. `0` means no limit.
   * @param {number} [angle=Math.PI/3] - Maximum angle of light dispersion from its direction whose upper bound is `Math.PI/2`.
   * @param {number} [penumbra=0] - Percent of the spotlight cone that is attenuated due to penumbra. Value range is `[0,1]`.
   * @param {number} [decay=2] - The amount the light dims along the distance of the light.
   */
  constructor(color3, intensity, distance4, angle2, penumbra, decay) {
    super(color3, intensity, distance4, angle2, penumbra, decay);
    this.aspect = null;
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.aspect = source.aspect;
    return this;
  }
};
var StandardNodeLibrary = class extends NodeLibrary {
  /**
   * Constructs a new standard node library.
   */
  constructor() {
    super();
    this.addMaterial(MeshPhongNodeMaterial, "MeshPhongMaterial");
    this.addMaterial(MeshStandardNodeMaterial, "MeshStandardMaterial");
    this.addMaterial(MeshPhysicalNodeMaterial, "MeshPhysicalMaterial");
    this.addMaterial(MeshToonNodeMaterial, "MeshToonMaterial");
    this.addMaterial(MeshBasicNodeMaterial, "MeshBasicMaterial");
    this.addMaterial(MeshLambertNodeMaterial, "MeshLambertMaterial");
    this.addMaterial(MeshNormalNodeMaterial, "MeshNormalMaterial");
    this.addMaterial(MeshMatcapNodeMaterial, "MeshMatcapMaterial");
    this.addMaterial(LineBasicNodeMaterial, "LineBasicMaterial");
    this.addMaterial(LineDashedNodeMaterial, "LineDashedMaterial");
    this.addMaterial(PointsNodeMaterial, "PointsMaterial");
    this.addMaterial(SpriteNodeMaterial, "SpriteMaterial");
    this.addMaterial(ShadowNodeMaterial, "ShadowMaterial");
    this.addLight(PointLightNode, PointLight);
    this.addLight(DirectionalLightNode, DirectionalLight);
    this.addLight(RectAreaLightNode, RectAreaLight);
    this.addLight(SpotLightNode, SpotLight);
    this.addLight(AmbientLightNode, AmbientLight);
    this.addLight(HemisphereLightNode, HemisphereLight);
    this.addLight(LightProbeNode, LightProbe);
    this.addLight(IESSpotLightNode, IESSpotLight);
    this.addLight(ProjectorLightNode, ProjectorLight);
    this.addToneMapping(linearToneMapping, LinearToneMapping);
    this.addToneMapping(reinhardToneMapping, ReinhardToneMapping);
    this.addToneMapping(cineonToneMapping, CineonToneMapping);
    this.addToneMapping(acesFilmicToneMapping, ACESFilmicToneMapping);
    this.addToneMapping(agxToneMapping, AgXToneMapping);
    this.addToneMapping(neutralToneMapping, NeutralToneMapping);
  }
};
var WebGPURenderer = class extends Renderer {
  /**
   * WebGPURenderer options.
   *
   * @typedef {Object} WebGPURenderer~Options
   * @property {boolean} [logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.
   * @property {boolean} [alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.
   * @property {boolean} [depth=true] - Whether the default framebuffer should have a depth buffer or not.
   * @property {boolean} [stencil=false] - Whether the default framebuffer should have a stencil buffer or not.
   * @property {boolean} [antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.
   * @property {number} [samples=0] - When `antialias` is `true`, `4` samples are used by default. Set this parameter to any other integer value than 0 to overwrite the default.
   * @property {boolean} [forceWebGL=false] - If set to `true`, the renderer uses a WebGL 2 backend no matter if WebGPU is supported or not.
   * @property {boolean} [multiview=false] - If set to `true`, the renderer will use multiview during WebXR rendering if supported.
   * @property {number} [outputType=undefined] - Texture type for output to canvas. By default, device's preferred format is used; other formats may incur overhead.
   * @property {number} [outputBufferType=HalfFloatType] - Defines the type of output buffers. The default `HalfFloatType` is recommend for best
   * quality. To save memory and bandwidth, `UnsignedByteType` might be used. This will reduce rendering quality though.
   */
  /**
   * Constructs a new WebGPU renderer.
   *
   * @param {WebGPURenderer~Options} [parameters] - The configuration parameter.
   */
  constructor(parameters = {}) {
    let BackendClass;
    if (parameters.forceWebGL) {
      BackendClass = WebGLBackend;
    } else {
      BackendClass = WebGPUBackend;
      parameters.getFallback = () => {
        warn("WebGPURenderer: WebGPU is not available, running under WebGL2 backend.");
        return new WebGLBackend(parameters);
      };
    }
    const backend = new BackendClass(parameters);
    super(backend, parameters);
    this.library = new StandardNodeLibrary();
    this.isWebGPURenderer = true;
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
    }
  }
};

// node_modules/three/examples/jsm/controls/TrackballControls.js
var _changeEvent = { type: "change" };
var _startEvent = { type: "start" };
var _endEvent = { type: "end" };
var _EPS = 1e-6;
var _STATE = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4 };
var _v22 = new Vector2();
var _mouseChange = new Vector2();
var _objectUp = new Vector3();
var _pan = new Vector3();
var _axis2 = new Vector3();
var _quaternion2 = new Quaternion();
var _eyeDirection = new Vector3();
var _objectUpDirection = new Vector3();
var _objectSidewaysDirection = new Vector3();
var _moveDirection = new Vector3();
var TrackballControls = class extends Controls {
  /**
   * Constructs a new controls instance.
   *
   * @param {Object3D} object - The object that is managed by the controls.
   * @param {?HTMLElement} domElement - The HTML element used for event listeners.
   */
  constructor(object, domElement = null) {
    super(object, domElement);
    this.screen = { left: 0, top: 0, width: 0, height: 0 };
    this.rotateSpeed = 1;
    this.zoomSpeed = 1.2;
    this.panSpeed = 0.3;
    this.noRotate = false;
    this.noZoom = false;
    this.noPan = false;
    this.staticMoving = false;
    this.dynamicDampingFactor = 0.2;
    this.minDistance = 0;
    this.maxDistance = Infinity;
    this.minZoom = 0;
    this.maxZoom = Infinity;
    this.keys = [
      "KeyA",
      "KeyS",
      "KeyD"
      /*D*/
    ];
    this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };
    this.target = new Vector3();
    this.state = _STATE.NONE;
    this.keyState = _STATE.NONE;
    this._lastPosition = new Vector3();
    this._lastZoom = 1;
    this._touchZoomDistanceStart = 0;
    this._touchZoomDistanceEnd = 0;
    this._lastAngle = 0;
    this._eye = new Vector3();
    this._movePrev = new Vector2();
    this._moveCurr = new Vector2();
    this._lastAxis = new Vector3();
    this._zoomStart = new Vector2();
    this._zoomEnd = new Vector2();
    this._panStart = new Vector2();
    this._panEnd = new Vector2();
    this._pointers = [];
    this._pointerPositions = {};
    this._onPointerMove = onPointerMove2.bind(this);
    this._onPointerDown = onPointerDown2.bind(this);
    this._onPointerUp = onPointerUp.bind(this);
    this._onPointerCancel = onPointerCancel2.bind(this);
    this._onContextMenu = onContextMenu2.bind(this);
    this._onMouseWheel = onMouseWheel.bind(this);
    this._onKeyDown = onKeyDown.bind(this);
    this._onKeyUp = onKeyUp.bind(this);
    this._onTouchStart = onTouchStart.bind(this);
    this._onTouchMove = onTouchMove.bind(this);
    this._onTouchEnd = onTouchEnd.bind(this);
    this._onMouseDown = onMouseDown.bind(this);
    this._onMouseMove = onMouseMove.bind(this);
    this._onMouseUp = onMouseUp.bind(this);
    this._target0 = this.target.clone();
    this._position0 = this.object.position.clone();
    this._up0 = this.object.up.clone();
    this._zoom0 = this.object.zoom;
    if (domElement !== null) {
      this.connect(domElement);
      this.handleResize();
    }
    this.update();
  }
  connect(element2) {
    super.connect(element2);
    window.addEventListener("keydown", this._onKeyDown);
    window.addEventListener("keyup", this._onKeyUp);
    this.domElement.addEventListener("pointerdown", this._onPointerDown);
    this.domElement.addEventListener("pointercancel", this._onPointerCancel);
    this.domElement.addEventListener("wheel", this._onMouseWheel, { passive: false });
    this.domElement.addEventListener("contextmenu", this._onContextMenu);
    this.domElement.style.touchAction = "none";
  }
  disconnect() {
    window.removeEventListener("keydown", this._onKeyDown);
    window.removeEventListener("keyup", this._onKeyUp);
    this.domElement.removeEventListener("pointerdown", this._onPointerDown);
    this.domElement.ownerDocument.removeEventListener("pointermove", this._onPointerMove);
    this.domElement.ownerDocument.removeEventListener("pointerup", this._onPointerUp);
    this.domElement.removeEventListener("pointercancel", this._onPointerCancel);
    this.domElement.removeEventListener("wheel", this._onMouseWheel);
    this.domElement.removeEventListener("contextmenu", this._onContextMenu);
    this.domElement.style.touchAction = "auto";
  }
  dispose() {
    this.disconnect();
  }
  /**
   * Must be called if the application window is resized.
   */
  handleResize() {
    const box = this.domElement.getBoundingClientRect();
    const d3 = this.domElement.ownerDocument.documentElement;
    this.screen.left = box.left + window.pageXOffset - d3.clientLeft;
    this.screen.top = box.top + window.pageYOffset - d3.clientTop;
    this.screen.width = box.width;
    this.screen.height = box.height;
  }
  update() {
    this._eye.subVectors(this.object.position, this.target);
    if (!this.noRotate) {
      this._rotateCamera();
    }
    if (!this.noZoom) {
      this._zoomCamera();
    }
    if (!this.noPan) {
      this._panCamera();
    }
    this.object.position.addVectors(this.target, this._eye);
    if (this.object.isPerspectiveCamera) {
      this._checkDistances();
      this.object.lookAt(this.target);
      if (this._lastPosition.distanceToSquared(this.object.position) > _EPS) {
        this.dispatchEvent(_changeEvent);
        this._lastPosition.copy(this.object.position);
      }
    } else if (this.object.isOrthographicCamera) {
      this.object.lookAt(this.target);
      if (this._lastPosition.distanceToSquared(this.object.position) > _EPS || this._lastZoom !== this.object.zoom) {
        this.dispatchEvent(_changeEvent);
        this._lastPosition.copy(this.object.position);
        this._lastZoom = this.object.zoom;
      }
    } else {
      console.warn("THREE.TrackballControls: Unsupported camera type.");
    }
  }
  /**
   * Resets the controls to its initial state.
   */
  reset() {
    this.state = _STATE.NONE;
    this.keyState = _STATE.NONE;
    this.target.copy(this._target0);
    this.object.position.copy(this._position0);
    this.object.up.copy(this._up0);
    this.object.zoom = this._zoom0;
    this.object.updateProjectionMatrix();
    this._eye.subVectors(this.object.position, this.target);
    this.object.lookAt(this.target);
    this.dispatchEvent(_changeEvent);
    this._lastPosition.copy(this.object.position);
    this._lastZoom = this.object.zoom;
  }
  _panCamera() {
    _mouseChange.copy(this._panEnd).sub(this._panStart);
    if (_mouseChange.lengthSq()) {
      if (this.object.isOrthographicCamera) {
        const scale_x = (this.object.right - this.object.left) / this.object.zoom / this.domElement.clientWidth;
        const scale_y = (this.object.top - this.object.bottom) / this.object.zoom / this.domElement.clientWidth;
        _mouseChange.x *= scale_x;
        _mouseChange.y *= scale_y;
      }
      _mouseChange.multiplyScalar(this._eye.length() * this.panSpeed);
      _pan.copy(this._eye).cross(this.object.up).setLength(_mouseChange.x);
      _pan.add(_objectUp.copy(this.object.up).setLength(_mouseChange.y));
      this.object.position.add(_pan);
      this.target.add(_pan);
      if (this.staticMoving) {
        this._panStart.copy(this._panEnd);
      } else {
        this._panStart.add(_mouseChange.subVectors(this._panEnd, this._panStart).multiplyScalar(this.dynamicDampingFactor));
      }
    }
  }
  _rotateCamera() {
    _moveDirection.set(this._moveCurr.x - this._movePrev.x, this._moveCurr.y - this._movePrev.y, 0);
    let angle2 = _moveDirection.length();
    if (angle2) {
      this._eye.copy(this.object.position).sub(this.target);
      _eyeDirection.copy(this._eye).normalize();
      _objectUpDirection.copy(this.object.up).normalize();
      _objectSidewaysDirection.crossVectors(_objectUpDirection, _eyeDirection).normalize();
      _objectUpDirection.setLength(this._moveCurr.y - this._movePrev.y);
      _objectSidewaysDirection.setLength(this._moveCurr.x - this._movePrev.x);
      _moveDirection.copy(_objectUpDirection.add(_objectSidewaysDirection));
      _axis2.crossVectors(_moveDirection, this._eye).normalize();
      angle2 *= this.rotateSpeed;
      _quaternion2.setFromAxisAngle(_axis2, angle2);
      this._eye.applyQuaternion(_quaternion2);
      this.object.up.applyQuaternion(_quaternion2);
      this._lastAxis.copy(_axis2);
      this._lastAngle = angle2;
    } else if (!this.staticMoving && this._lastAngle) {
      this._lastAngle *= Math.sqrt(1 - this.dynamicDampingFactor);
      this._eye.copy(this.object.position).sub(this.target);
      _quaternion2.setFromAxisAngle(this._lastAxis, this._lastAngle);
      this._eye.applyQuaternion(_quaternion2);
      this.object.up.applyQuaternion(_quaternion2);
    }
    this._movePrev.copy(this._moveCurr);
  }
  _zoomCamera() {
    let factor;
    if (this.state === _STATE.TOUCH_ZOOM_PAN) {
      factor = this._touchZoomDistanceStart / this._touchZoomDistanceEnd;
      this._touchZoomDistanceStart = this._touchZoomDistanceEnd;
      if (this.object.isPerspectiveCamera) {
        this._eye.multiplyScalar(factor);
      } else if (this.object.isOrthographicCamera) {
        this.object.zoom = MathUtils.clamp(this.object.zoom / factor, this.minZoom, this.maxZoom);
        if (this._lastZoom !== this.object.zoom) {
          this.object.updateProjectionMatrix();
        }
      } else {
        console.warn("THREE.TrackballControls: Unsupported camera type");
      }
    } else {
      factor = 1 + (this._zoomEnd.y - this._zoomStart.y) * this.zoomSpeed;
      if (factor !== 1 && factor > 0) {
        if (this.object.isPerspectiveCamera) {
          this._eye.multiplyScalar(factor);
        } else if (this.object.isOrthographicCamera) {
          this.object.zoom = MathUtils.clamp(this.object.zoom / factor, this.minZoom, this.maxZoom);
          if (this._lastZoom !== this.object.zoom) {
            this.object.updateProjectionMatrix();
          }
        } else {
          console.warn("THREE.TrackballControls: Unsupported camera type");
        }
      }
      if (this.staticMoving) {
        this._zoomStart.copy(this._zoomEnd);
      } else {
        this._zoomStart.y += (this._zoomEnd.y - this._zoomStart.y) * this.dynamicDampingFactor;
      }
    }
  }
  _getMouseOnScreen(pageX, pageY) {
    _v22.set(
      (pageX - this.screen.left) / this.screen.width,
      (pageY - this.screen.top) / this.screen.height
    );
    return _v22;
  }
  _getMouseOnCircle(pageX, pageY) {
    _v22.set(
      (pageX - this.screen.width * 0.5 - this.screen.left) / (this.screen.width * 0.5),
      (this.screen.height + 2 * (this.screen.top - pageY)) / this.screen.width
      // screen.width intentional
    );
    return _v22;
  }
  _addPointer(event) {
    this._pointers.push(event);
  }
  _removePointer(event) {
    delete this._pointerPositions[event.pointerId];
    for (let i2 = 0; i2 < this._pointers.length; i2++) {
      if (this._pointers[i2].pointerId == event.pointerId) {
        this._pointers.splice(i2, 1);
        return;
      }
    }
  }
  _trackPointer(event) {
    let position = this._pointerPositions[event.pointerId];
    if (position === void 0) {
      position = new Vector2();
      this._pointerPositions[event.pointerId] = position;
    }
    position.set(event.pageX, event.pageY);
  }
  _getSecondPointerPosition(event) {
    const pointer = event.pointerId === this._pointers[0].pointerId ? this._pointers[1] : this._pointers[0];
    return this._pointerPositions[pointer.pointerId];
  }
  _checkDistances() {
    if (!this.noZoom || !this.noPan) {
      if (this._eye.lengthSq() > this.maxDistance * this.maxDistance) {
        this.object.position.addVectors(this.target, this._eye.setLength(this.maxDistance));
        this._zoomStart.copy(this._zoomEnd);
      }
      if (this._eye.lengthSq() < this.minDistance * this.minDistance) {
        this.object.position.addVectors(this.target, this._eye.setLength(this.minDistance));
        this._zoomStart.copy(this._zoomEnd);
      }
    }
  }
};
function onPointerDown2(event) {
  if (this.enabled === false) return;
  if (this._pointers.length === 0) {
    this.domElement.setPointerCapture(event.pointerId);
    this.domElement.ownerDocument.addEventListener("pointermove", this._onPointerMove);
    this.domElement.ownerDocument.addEventListener("pointerup", this._onPointerUp);
  }
  this._addPointer(event);
  if (event.pointerType === "touch") {
    this._onTouchStart(event);
  } else {
    this._onMouseDown(event);
  }
}
function onPointerMove2(event) {
  if (this.enabled === false) return;
  if (event.pointerType === "touch") {
    this._onTouchMove(event);
  } else {
    this._onMouseMove(event);
  }
}
function onPointerUp(event) {
  if (this.enabled === false) return;
  if (event.pointerType === "touch") {
    this._onTouchEnd(event);
  } else {
    this._onMouseUp();
  }
  this._removePointer(event);
  if (this._pointers.length === 0) {
    this.domElement.releasePointerCapture(event.pointerId);
    this.domElement.ownerDocument.removeEventListener("pointermove", this._onPointerMove);
    this.domElement.ownerDocument.removeEventListener("pointerup", this._onPointerUp);
  }
}
function onPointerCancel2(event) {
  this._removePointer(event);
}
function onKeyUp() {
  if (this.enabled === false) return;
  this.keyState = _STATE.NONE;
  window.addEventListener("keydown", this._onKeyDown);
}
function onKeyDown(event) {
  if (this.enabled === false) return;
  window.removeEventListener("keydown", this._onKeyDown);
  if (this.keyState !== _STATE.NONE) {
    return;
  } else if (event.code === this.keys[_STATE.ROTATE] && !this.noRotate) {
    this.keyState = _STATE.ROTATE;
  } else if (event.code === this.keys[_STATE.ZOOM] && !this.noZoom) {
    this.keyState = _STATE.ZOOM;
  } else if (event.code === this.keys[_STATE.PAN] && !this.noPan) {
    this.keyState = _STATE.PAN;
  }
}
function onMouseDown(event) {
  let mouseAction;
  switch (event.button) {
    case 0:
      mouseAction = this.mouseButtons.LEFT;
      break;
    case 1:
      mouseAction = this.mouseButtons.MIDDLE;
      break;
    case 2:
      mouseAction = this.mouseButtons.RIGHT;
      break;
    default:
      mouseAction = -1;
  }
  switch (mouseAction) {
    case MOUSE.DOLLY:
      this.state = _STATE.ZOOM;
      break;
    case MOUSE.ROTATE:
      this.state = _STATE.ROTATE;
      break;
    case MOUSE.PAN:
      this.state = _STATE.PAN;
      break;
    default:
      this.state = _STATE.NONE;
  }
  const state = this.keyState !== _STATE.NONE ? this.keyState : this.state;
  if (state === _STATE.ROTATE && !this.noRotate) {
    this._moveCurr.copy(this._getMouseOnCircle(event.pageX, event.pageY));
    this._movePrev.copy(this._moveCurr);
  } else if (state === _STATE.ZOOM && !this.noZoom) {
    this._zoomStart.copy(this._getMouseOnScreen(event.pageX, event.pageY));
    this._zoomEnd.copy(this._zoomStart);
  } else if (state === _STATE.PAN && !this.noPan) {
    this._panStart.copy(this._getMouseOnScreen(event.pageX, event.pageY));
    this._panEnd.copy(this._panStart);
  }
  this.dispatchEvent(_startEvent);
}
function onMouseMove(event) {
  const state = this.keyState !== _STATE.NONE ? this.keyState : this.state;
  if (state === _STATE.ROTATE && !this.noRotate) {
    this._movePrev.copy(this._moveCurr);
    this._moveCurr.copy(this._getMouseOnCircle(event.pageX, event.pageY));
  } else if (state === _STATE.ZOOM && !this.noZoom) {
    this._zoomEnd.copy(this._getMouseOnScreen(event.pageX, event.pageY));
  } else if (state === _STATE.PAN && !this.noPan) {
    this._panEnd.copy(this._getMouseOnScreen(event.pageX, event.pageY));
  }
}
function onMouseUp() {
  this.state = _STATE.NONE;
  this.dispatchEvent(_endEvent);
}
function onMouseWheel(event) {
  if (this.enabled === false) return;
  if (this.noZoom === true) return;
  event.preventDefault();
  switch (event.deltaMode) {
    case 2:
      this._zoomStart.y -= event.deltaY * 0.025;
      break;
    case 1:
      this._zoomStart.y -= event.deltaY * 0.01;
      break;
    default:
      this._zoomStart.y -= event.deltaY * 25e-5;
      break;
  }
  this.dispatchEvent(_startEvent);
  this.dispatchEvent(_endEvent);
}
function onContextMenu2(event) {
  if (this.enabled === false) return;
  event.preventDefault();
}
function onTouchStart(event) {
  this._trackPointer(event);
  switch (this._pointers.length) {
    case 1:
      this.state = _STATE.TOUCH_ROTATE;
      this._moveCurr.copy(this._getMouseOnCircle(this._pointers[0].pageX, this._pointers[0].pageY));
      this._movePrev.copy(this._moveCurr);
      break;
    default:
      this.state = _STATE.TOUCH_ZOOM_PAN;
      const dx = this._pointers[0].pageX - this._pointers[1].pageX;
      const dy = this._pointers[0].pageY - this._pointers[1].pageY;
      this._touchZoomDistanceEnd = this._touchZoomDistanceStart = Math.sqrt(dx * dx + dy * dy);
      const x3 = (this._pointers[0].pageX + this._pointers[1].pageX) / 2;
      const y3 = (this._pointers[0].pageY + this._pointers[1].pageY) / 2;
      this._panStart.copy(this._getMouseOnScreen(x3, y3));
      this._panEnd.copy(this._panStart);
      break;
  }
  this.dispatchEvent(_startEvent);
}
function onTouchMove(event) {
  this._trackPointer(event);
  switch (this._pointers.length) {
    case 1:
      this._movePrev.copy(this._moveCurr);
      this._moveCurr.copy(this._getMouseOnCircle(event.pageX, event.pageY));
      break;
    default:
      const position = this._getSecondPointerPosition(event);
      const dx = event.pageX - position.x;
      const dy = event.pageY - position.y;
      this._touchZoomDistanceEnd = Math.sqrt(dx * dx + dy * dy);
      const x3 = (event.pageX + position.x) / 2;
      const y3 = (event.pageY + position.y) / 2;
      this._panEnd.copy(this._getMouseOnScreen(x3, y3));
      break;
  }
}
function onTouchEnd(event) {
  switch (this._pointers.length) {
    case 0:
      this.state = _STATE.NONE;
      break;
    case 1:
      this.state = _STATE.TOUCH_ROTATE;
      this._moveCurr.copy(this._getMouseOnCircle(event.pageX, event.pageY));
      this._movePrev.copy(this._moveCurr);
      break;
    case 2:
      this.state = _STATE.TOUCH_ZOOM_PAN;
      for (let i2 = 0; i2 < this._pointers.length; i2++) {
        if (this._pointers[i2].pointerId !== event.pointerId) {
          const position = this._pointerPositions[this._pointers[i2].pointerId];
          this._moveCurr.copy(this._getMouseOnCircle(position.x, position.y));
          this._movePrev.copy(this._moveCurr);
          break;
        }
      }
      break;
  }
  this.dispatchEvent(_endEvent);
}

// node_modules/three/examples/jsm/controls/OrbitControls.js
var _changeEvent2 = { type: "change" };
var _startEvent2 = { type: "start" };
var _endEvent2 = { type: "end" };
var _ray2 = new Ray();
var _plane3 = new Plane();
var _TILT_LIMIT = Math.cos(70 * MathUtils.DEG2RAD);
var _v = new Vector3();
var _twoPI = 2 * Math.PI;
var _STATE2 = {
  NONE: -1,
  ROTATE: 0,
  DOLLY: 1,
  PAN: 2,
  TOUCH_ROTATE: 3,
  TOUCH_PAN: 4,
  TOUCH_DOLLY_PAN: 5,
  TOUCH_DOLLY_ROTATE: 6
};
var _EPS2 = 1e-6;
var OrbitControls = class extends Controls {
  /**
   * Constructs a new controls instance.
   *
   * @param {Object3D} object - The object that is managed by the controls.
   * @param {?HTMLElement} domElement - The HTML element used for event listeners.
   */
  constructor(object, domElement = null) {
    super(object, domElement);
    this.state = _STATE2.NONE;
    this.target = new Vector3();
    this.cursor = new Vector3();
    this.minDistance = 0;
    this.maxDistance = Infinity;
    this.minZoom = 0;
    this.maxZoom = Infinity;
    this.minTargetRadius = 0;
    this.maxTargetRadius = Infinity;
    this.minPolarAngle = 0;
    this.maxPolarAngle = Math.PI;
    this.minAzimuthAngle = -Infinity;
    this.maxAzimuthAngle = Infinity;
    this.enableDamping = false;
    this.dampingFactor = 0.05;
    this.enableZoom = true;
    this.zoomSpeed = 1;
    this.enableRotate = true;
    this.rotateSpeed = 1;
    this.keyRotateSpeed = 1;
    this.enablePan = true;
    this.panSpeed = 1;
    this.screenSpacePanning = true;
    this.keyPanSpeed = 7;
    this.zoomToCursor = false;
    this.autoRotate = false;
    this.autoRotateSpeed = 2;
    this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" };
    this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };
    this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };
    this.target0 = this.target.clone();
    this.position0 = this.object.position.clone();
    this.zoom0 = this.object.zoom;
    this._domElementKeyEvents = null;
    this._lastPosition = new Vector3();
    this._lastQuaternion = new Quaternion();
    this._lastTargetPosition = new Vector3();
    this._quat = new Quaternion().setFromUnitVectors(object.up, new Vector3(0, 1, 0));
    this._quatInverse = this._quat.clone().invert();
    this._spherical = new Spherical();
    this._sphericalDelta = new Spherical();
    this._scale = 1;
    this._panOffset = new Vector3();
    this._rotateStart = new Vector2();
    this._rotateEnd = new Vector2();
    this._rotateDelta = new Vector2();
    this._panStart = new Vector2();
    this._panEnd = new Vector2();
    this._panDelta = new Vector2();
    this._dollyStart = new Vector2();
    this._dollyEnd = new Vector2();
    this._dollyDelta = new Vector2();
    this._dollyDirection = new Vector3();
    this._mouse = new Vector2();
    this._performCursorZoom = false;
    this._pointers = [];
    this._pointerPositions = {};
    this._controlActive = false;
    this._onPointerMove = onPointerMove3.bind(this);
    this._onPointerDown = onPointerDown3.bind(this);
    this._onPointerUp = onPointerUp2.bind(this);
    this._onContextMenu = onContextMenu3.bind(this);
    this._onMouseWheel = onMouseWheel2.bind(this);
    this._onKeyDown = onKeyDown2.bind(this);
    this._onTouchStart = onTouchStart2.bind(this);
    this._onTouchMove = onTouchMove2.bind(this);
    this._onMouseDown = onMouseDown2.bind(this);
    this._onMouseMove = onMouseMove2.bind(this);
    this._interceptControlDown = interceptControlDown.bind(this);
    this._interceptControlUp = interceptControlUp.bind(this);
    if (this.domElement !== null) {
      this.connect(this.domElement);
    }
    this.update();
  }
  connect(element2) {
    super.connect(element2);
    this.domElement.addEventListener("pointerdown", this._onPointerDown);
    this.domElement.addEventListener("pointercancel", this._onPointerUp);
    this.domElement.addEventListener("contextmenu", this._onContextMenu);
    this.domElement.addEventListener("wheel", this._onMouseWheel, { passive: false });
    const document2 = this.domElement.getRootNode();
    document2.addEventListener("keydown", this._interceptControlDown, { passive: true, capture: true });
    this.domElement.style.touchAction = "none";
  }
  disconnect() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown);
    this.domElement.ownerDocument.removeEventListener("pointermove", this._onPointerMove);
    this.domElement.ownerDocument.removeEventListener("pointerup", this._onPointerUp);
    this.domElement.removeEventListener("pointercancel", this._onPointerUp);
    this.domElement.removeEventListener("wheel", this._onMouseWheel);
    this.domElement.removeEventListener("contextmenu", this._onContextMenu);
    this.stopListenToKeyEvents();
    const document2 = this.domElement.getRootNode();
    document2.removeEventListener("keydown", this._interceptControlDown, { capture: true });
    this.domElement.style.touchAction = "auto";
  }
  dispose() {
    this.disconnect();
  }
  /**
   * Get the current vertical rotation, in radians.
   *
   * @return {number} The current vertical rotation, in radians.
   */
  getPolarAngle() {
    return this._spherical.phi;
  }
  /**
   * Get the current horizontal rotation, in radians.
   *
   * @return {number} The current horizontal rotation, in radians.
   */
  getAzimuthalAngle() {
    return this._spherical.theta;
  }
  /**
   * Returns the distance from the camera to the target.
   *
   * @return {number} The distance from the camera to the target.
   */
  getDistance() {
    return this.object.position.distanceTo(this.target);
  }
  /**
   * Adds key event listeners to the given DOM element.
   * `window` is a recommended argument for using this method.
   *
   * @param {HTMLElement} domElement - The DOM element
   */
  listenToKeyEvents(domElement) {
    domElement.addEventListener("keydown", this._onKeyDown);
    this._domElementKeyEvents = domElement;
  }
  /**
   * Removes the key event listener previously defined with `listenToKeyEvents()`.
   */
  stopListenToKeyEvents() {
    if (this._domElementKeyEvents !== null) {
      this._domElementKeyEvents.removeEventListener("keydown", this._onKeyDown);
      this._domElementKeyEvents = null;
    }
  }
  /**
   * Save the current state of the controls. This can later be recovered with `reset()`.
   */
  saveState() {
    this.target0.copy(this.target);
    this.position0.copy(this.object.position);
    this.zoom0 = this.object.zoom;
  }
  /**
   * Reset the controls to their state from either the last time the `saveState()`
   * was called, or the initial state.
   */
  reset() {
    this.target.copy(this.target0);
    this.object.position.copy(this.position0);
    this.object.zoom = this.zoom0;
    this.object.updateProjectionMatrix();
    this.dispatchEvent(_changeEvent2);
    this.update();
    this.state = _STATE2.NONE;
  }
  update(deltaTime2 = null) {
    const position = this.object.position;
    _v.copy(position).sub(this.target);
    _v.applyQuaternion(this._quat);
    this._spherical.setFromVector3(_v);
    if (this.autoRotate && this.state === _STATE2.NONE) {
      this._rotateLeft(this._getAutoRotationAngle(deltaTime2));
    }
    if (this.enableDamping) {
      this._spherical.theta += this._sphericalDelta.theta * this.dampingFactor;
      this._spherical.phi += this._sphericalDelta.phi * this.dampingFactor;
    } else {
      this._spherical.theta += this._sphericalDelta.theta;
      this._spherical.phi += this._sphericalDelta.phi;
    }
    let min5 = this.minAzimuthAngle;
    let max6 = this.maxAzimuthAngle;
    if (isFinite(min5) && isFinite(max6)) {
      if (min5 < -Math.PI) min5 += _twoPI;
      else if (min5 > Math.PI) min5 -= _twoPI;
      if (max6 < -Math.PI) max6 += _twoPI;
      else if (max6 > Math.PI) max6 -= _twoPI;
      if (min5 <= max6) {
        this._spherical.theta = Math.max(min5, Math.min(max6, this._spherical.theta));
      } else {
        this._spherical.theta = this._spherical.theta > (min5 + max6) / 2 ? Math.max(min5, this._spherical.theta) : Math.min(max6, this._spherical.theta);
      }
    }
    this._spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, this._spherical.phi));
    this._spherical.makeSafe();
    if (this.enableDamping === true) {
      this.target.addScaledVector(this._panOffset, this.dampingFactor);
    } else {
      this.target.add(this._panOffset);
    }
    this.target.sub(this.cursor);
    this.target.clampLength(this.minTargetRadius, this.maxTargetRadius);
    this.target.add(this.cursor);
    let zoomChanged = false;
    if (this.zoomToCursor && this._performCursorZoom || this.object.isOrthographicCamera) {
      this._spherical.radius = this._clampDistance(this._spherical.radius);
    } else {
      const prevRadius = this._spherical.radius;
      this._spherical.radius = this._clampDistance(this._spherical.radius * this._scale);
      zoomChanged = prevRadius != this._spherical.radius;
    }
    _v.setFromSpherical(this._spherical);
    _v.applyQuaternion(this._quatInverse);
    position.copy(this.target).add(_v);
    this.object.lookAt(this.target);
    if (this.enableDamping === true) {
      this._sphericalDelta.theta *= 1 - this.dampingFactor;
      this._sphericalDelta.phi *= 1 - this.dampingFactor;
      this._panOffset.multiplyScalar(1 - this.dampingFactor);
    } else {
      this._sphericalDelta.set(0, 0, 0);
      this._panOffset.set(0, 0, 0);
    }
    if (this.zoomToCursor && this._performCursorZoom) {
      let newRadius = null;
      if (this.object.isPerspectiveCamera) {
        const prevRadius = _v.length();
        newRadius = this._clampDistance(prevRadius * this._scale);
        const radiusDelta = prevRadius - newRadius;
        this.object.position.addScaledVector(this._dollyDirection, radiusDelta);
        this.object.updateMatrixWorld();
        zoomChanged = !!radiusDelta;
      } else if (this.object.isOrthographicCamera) {
        const mouseBefore = new Vector3(this._mouse.x, this._mouse.y, 0);
        mouseBefore.unproject(this.object);
        const prevZoom = this.object.zoom;
        this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale));
        this.object.updateProjectionMatrix();
        zoomChanged = prevZoom !== this.object.zoom;
        const mouseAfter = new Vector3(this._mouse.x, this._mouse.y, 0);
        mouseAfter.unproject(this.object);
        this.object.position.sub(mouseAfter).add(mouseBefore);
        this.object.updateMatrixWorld();
        newRadius = _v.length();
      } else {
        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.");
        this.zoomToCursor = false;
      }
      if (newRadius !== null) {
        if (this.screenSpacePanning) {
          this.target.set(0, 0, -1).transformDirection(this.object.matrix).multiplyScalar(newRadius).add(this.object.position);
        } else {
          _ray2.origin.copy(this.object.position);
          _ray2.direction.set(0, 0, -1).transformDirection(this.object.matrix);
          if (Math.abs(this.object.up.dot(_ray2.direction)) < _TILT_LIMIT) {
            this.object.lookAt(this.target);
          } else {
            _plane3.setFromNormalAndCoplanarPoint(this.object.up, this.target);
            _ray2.intersectPlane(_plane3, this.target);
          }
        }
      }
    } else if (this.object.isOrthographicCamera) {
      const prevZoom = this.object.zoom;
      this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale));
      if (prevZoom !== this.object.zoom) {
        this.object.updateProjectionMatrix();
        zoomChanged = true;
      }
    }
    this._scale = 1;
    this._performCursorZoom = false;
    if (zoomChanged || this._lastPosition.distanceToSquared(this.object.position) > _EPS2 || 8 * (1 - this._lastQuaternion.dot(this.object.quaternion)) > _EPS2 || this._lastTargetPosition.distanceToSquared(this.target) > _EPS2) {
      this.dispatchEvent(_changeEvent2);
      this._lastPosition.copy(this.object.position);
      this._lastQuaternion.copy(this.object.quaternion);
      this._lastTargetPosition.copy(this.target);
      return true;
    }
    return false;
  }
  _getAutoRotationAngle(deltaTime2) {
    if (deltaTime2 !== null) {
      return _twoPI / 60 * this.autoRotateSpeed * deltaTime2;
    } else {
      return _twoPI / 60 / 60 * this.autoRotateSpeed;
    }
  }
  _getZoomScale(delta) {
    const normalizedDelta = Math.abs(delta * 0.01);
    return Math.pow(0.95, this.zoomSpeed * normalizedDelta);
  }
  _rotateLeft(angle2) {
    this._sphericalDelta.theta -= angle2;
  }
  _rotateUp(angle2) {
    this._sphericalDelta.phi -= angle2;
  }
  _panLeft(distance4, objectMatrix) {
    _v.setFromMatrixColumn(objectMatrix, 0);
    _v.multiplyScalar(-distance4);
    this._panOffset.add(_v);
  }
  _panUp(distance4, objectMatrix) {
    if (this.screenSpacePanning === true) {
      _v.setFromMatrixColumn(objectMatrix, 1);
    } else {
      _v.setFromMatrixColumn(objectMatrix, 0);
      _v.crossVectors(this.object.up, _v);
    }
    _v.multiplyScalar(distance4);
    this._panOffset.add(_v);
  }
  // deltaX and deltaY are in pixels; right and down are positive
  _pan(deltaX, deltaY) {
    const element2 = this.domElement;
    if (this.object.isPerspectiveCamera) {
      const position = this.object.position;
      _v.copy(position).sub(this.target);
      let targetDistance = _v.length();
      targetDistance *= Math.tan(this.object.fov / 2 * Math.PI / 180);
      this._panLeft(2 * deltaX * targetDistance / element2.clientHeight, this.object.matrix);
      this._panUp(2 * deltaY * targetDistance / element2.clientHeight, this.object.matrix);
    } else if (this.object.isOrthographicCamera) {
      this._panLeft(deltaX * (this.object.right - this.object.left) / this.object.zoom / element2.clientWidth, this.object.matrix);
      this._panUp(deltaY * (this.object.top - this.object.bottom) / this.object.zoom / element2.clientHeight, this.object.matrix);
    } else {
      console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.");
      this.enablePan = false;
    }
  }
  _dollyOut(dollyScale) {
    if (this.object.isPerspectiveCamera || this.object.isOrthographicCamera) {
      this._scale /= dollyScale;
    } else {
      console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
      this.enableZoom = false;
    }
  }
  _dollyIn(dollyScale) {
    if (this.object.isPerspectiveCamera || this.object.isOrthographicCamera) {
      this._scale *= dollyScale;
    } else {
      console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
      this.enableZoom = false;
    }
  }
  _updateZoomParameters(x3, y3) {
    if (!this.zoomToCursor) {
      return;
    }
    this._performCursorZoom = true;
    const rect = this.domElement.getBoundingClientRect();
    const dx = x3 - rect.left;
    const dy = y3 - rect.top;
    const w4 = rect.width;
    const h2 = rect.height;
    this._mouse.x = dx / w4 * 2 - 1;
    this._mouse.y = -(dy / h2) * 2 + 1;
    this._dollyDirection.set(this._mouse.x, this._mouse.y, 1).unproject(this.object).sub(this.object.position).normalize();
  }
  _clampDistance(dist) {
    return Math.max(this.minDistance, Math.min(this.maxDistance, dist));
  }
  //
  // event callbacks - update the object state
  //
  _handleMouseDownRotate(event) {
    this._rotateStart.set(event.clientX, event.clientY);
  }
  _handleMouseDownDolly(event) {
    this._updateZoomParameters(event.clientX, event.clientX);
    this._dollyStart.set(event.clientX, event.clientY);
  }
  _handleMouseDownPan(event) {
    this._panStart.set(event.clientX, event.clientY);
  }
  _handleMouseMoveRotate(event) {
    this._rotateEnd.set(event.clientX, event.clientY);
    this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
    const element2 = this.domElement;
    this._rotateLeft(_twoPI * this._rotateDelta.x / element2.clientHeight);
    this._rotateUp(_twoPI * this._rotateDelta.y / element2.clientHeight);
    this._rotateStart.copy(this._rotateEnd);
    this.update();
  }
  _handleMouseMoveDolly(event) {
    this._dollyEnd.set(event.clientX, event.clientY);
    this._dollyDelta.subVectors(this._dollyEnd, this._dollyStart);
    if (this._dollyDelta.y > 0) {
      this._dollyOut(this._getZoomScale(this._dollyDelta.y));
    } else if (this._dollyDelta.y < 0) {
      this._dollyIn(this._getZoomScale(this._dollyDelta.y));
    }
    this._dollyStart.copy(this._dollyEnd);
    this.update();
  }
  _handleMouseMovePan(event) {
    this._panEnd.set(event.clientX, event.clientY);
    this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed);
    this._pan(this._panDelta.x, this._panDelta.y);
    this._panStart.copy(this._panEnd);
    this.update();
  }
  _handleMouseWheel(event) {
    this._updateZoomParameters(event.clientX, event.clientY);
    if (event.deltaY < 0) {
      this._dollyIn(this._getZoomScale(event.deltaY));
    } else if (event.deltaY > 0) {
      this._dollyOut(this._getZoomScale(event.deltaY));
    }
    this.update();
  }
  _handleKeyDown(event) {
    let needsUpdate = false;
    switch (event.code) {
      case this.keys.UP:
        if (event.ctrlKey || event.metaKey || event.shiftKey) {
          if (this.enableRotate) {
            this._rotateUp(_twoPI * this.keyRotateSpeed / this.domElement.clientHeight);
          }
        } else {
          if (this.enablePan) {
            this._pan(0, this.keyPanSpeed);
          }
        }
        needsUpdate = true;
        break;
      case this.keys.BOTTOM:
        if (event.ctrlKey || event.metaKey || event.shiftKey) {
          if (this.enableRotate) {
            this._rotateUp(-_twoPI * this.keyRotateSpeed / this.domElement.clientHeight);
          }
        } else {
          if (this.enablePan) {
            this._pan(0, -this.keyPanSpeed);
          }
        }
        needsUpdate = true;
        break;
      case this.keys.LEFT:
        if (event.ctrlKey || event.metaKey || event.shiftKey) {
          if (this.enableRotate) {
            this._rotateLeft(_twoPI * this.keyRotateSpeed / this.domElement.clientHeight);
          }
        } else {
          if (this.enablePan) {
            this._pan(this.keyPanSpeed, 0);
          }
        }
        needsUpdate = true;
        break;
      case this.keys.RIGHT:
        if (event.ctrlKey || event.metaKey || event.shiftKey) {
          if (this.enableRotate) {
            this._rotateLeft(-_twoPI * this.keyRotateSpeed / this.domElement.clientHeight);
          }
        } else {
          if (this.enablePan) {
            this._pan(-this.keyPanSpeed, 0);
          }
        }
        needsUpdate = true;
        break;
    }
    if (needsUpdate) {
      event.preventDefault();
      this.update();
    }
  }
  _handleTouchStartRotate(event) {
    if (this._pointers.length === 1) {
      this._rotateStart.set(event.pageX, event.pageY);
    } else {
      const position = this._getSecondPointerPosition(event);
      const x3 = 0.5 * (event.pageX + position.x);
      const y3 = 0.5 * (event.pageY + position.y);
      this._rotateStart.set(x3, y3);
    }
  }
  _handleTouchStartPan(event) {
    if (this._pointers.length === 1) {
      this._panStart.set(event.pageX, event.pageY);
    } else {
      const position = this._getSecondPointerPosition(event);
      const x3 = 0.5 * (event.pageX + position.x);
      const y3 = 0.5 * (event.pageY + position.y);
      this._panStart.set(x3, y3);
    }
  }
  _handleTouchStartDolly(event) {
    const position = this._getSecondPointerPosition(event);
    const dx = event.pageX - position.x;
    const dy = event.pageY - position.y;
    const distance4 = Math.sqrt(dx * dx + dy * dy);
    this._dollyStart.set(0, distance4);
  }
  _handleTouchStartDollyPan(event) {
    if (this.enableZoom) this._handleTouchStartDolly(event);
    if (this.enablePan) this._handleTouchStartPan(event);
  }
  _handleTouchStartDollyRotate(event) {
    if (this.enableZoom) this._handleTouchStartDolly(event);
    if (this.enableRotate) this._handleTouchStartRotate(event);
  }
  _handleTouchMoveRotate(event) {
    if (this._pointers.length == 1) {
      this._rotateEnd.set(event.pageX, event.pageY);
    } else {
      const position = this._getSecondPointerPosition(event);
      const x3 = 0.5 * (event.pageX + position.x);
      const y3 = 0.5 * (event.pageY + position.y);
      this._rotateEnd.set(x3, y3);
    }
    this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
    const element2 = this.domElement;
    this._rotateLeft(_twoPI * this._rotateDelta.x / element2.clientHeight);
    this._rotateUp(_twoPI * this._rotateDelta.y / element2.clientHeight);
    this._rotateStart.copy(this._rotateEnd);
  }
  _handleTouchMovePan(event) {
    if (this._pointers.length === 1) {
      this._panEnd.set(event.pageX, event.pageY);
    } else {
      const position = this._getSecondPointerPosition(event);
      const x3 = 0.5 * (event.pageX + position.x);
      const y3 = 0.5 * (event.pageY + position.y);
      this._panEnd.set(x3, y3);
    }
    this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed);
    this._pan(this._panDelta.x, this._panDelta.y);
    this._panStart.copy(this._panEnd);
  }
  _handleTouchMoveDolly(event) {
    const position = this._getSecondPointerPosition(event);
    const dx = event.pageX - position.x;
    const dy = event.pageY - position.y;
    const distance4 = Math.sqrt(dx * dx + dy * dy);
    this._dollyEnd.set(0, distance4);
    this._dollyDelta.set(0, Math.pow(this._dollyEnd.y / this._dollyStart.y, this.zoomSpeed));
    this._dollyOut(this._dollyDelta.y);
    this._dollyStart.copy(this._dollyEnd);
    const centerX = (event.pageX + position.x) * 0.5;
    const centerY = (event.pageY + position.y) * 0.5;
    this._updateZoomParameters(centerX, centerY);
  }
  _handleTouchMoveDollyPan(event) {
    if (this.enableZoom) this._handleTouchMoveDolly(event);
    if (this.enablePan) this._handleTouchMovePan(event);
  }
  _handleTouchMoveDollyRotate(event) {
    if (this.enableZoom) this._handleTouchMoveDolly(event);
    if (this.enableRotate) this._handleTouchMoveRotate(event);
  }
  // pointers
  _addPointer(event) {
    this._pointers.push(event.pointerId);
  }
  _removePointer(event) {
    delete this._pointerPositions[event.pointerId];
    for (let i2 = 0; i2 < this._pointers.length; i2++) {
      if (this._pointers[i2] == event.pointerId) {
        this._pointers.splice(i2, 1);
        return;
      }
    }
  }
  _isTrackingPointer(event) {
    for (let i2 = 0; i2 < this._pointers.length; i2++) {
      if (this._pointers[i2] == event.pointerId) return true;
    }
    return false;
  }
  _trackPointer(event) {
    let position = this._pointerPositions[event.pointerId];
    if (position === void 0) {
      position = new Vector2();
      this._pointerPositions[event.pointerId] = position;
    }
    position.set(event.pageX, event.pageY);
  }
  _getSecondPointerPosition(event) {
    const pointerId = event.pointerId === this._pointers[0] ? this._pointers[1] : this._pointers[0];
    return this._pointerPositions[pointerId];
  }
  //
  _customWheelEvent(event) {
    const mode2 = event.deltaMode;
    const newEvent = {
      clientX: event.clientX,
      clientY: event.clientY,
      deltaY: event.deltaY
    };
    switch (mode2) {
      case 1:
        newEvent.deltaY *= 16;
        break;
      case 2:
        newEvent.deltaY *= 100;
        break;
    }
    if (event.ctrlKey && !this._controlActive) {
      newEvent.deltaY *= 10;
    }
    return newEvent;
  }
};
function onPointerDown3(event) {
  if (this.enabled === false) return;
  if (this._pointers.length === 0) {
    this.domElement.setPointerCapture(event.pointerId);
    this.domElement.ownerDocument.addEventListener("pointermove", this._onPointerMove);
    this.domElement.ownerDocument.addEventListener("pointerup", this._onPointerUp);
  }
  if (this._isTrackingPointer(event)) return;
  this._addPointer(event);
  if (event.pointerType === "touch") {
    this._onTouchStart(event);
  } else {
    this._onMouseDown(event);
  }
}
function onPointerMove3(event) {
  if (this.enabled === false) return;
  if (event.pointerType === "touch") {
    this._onTouchMove(event);
  } else {
    this._onMouseMove(event);
  }
}
function onPointerUp2(event) {
  this._removePointer(event);
  switch (this._pointers.length) {
    case 0:
      this.domElement.releasePointerCapture(event.pointerId);
      this.domElement.ownerDocument.removeEventListener("pointermove", this._onPointerMove);
      this.domElement.ownerDocument.removeEventListener("pointerup", this._onPointerUp);
      this.dispatchEvent(_endEvent2);
      this.state = _STATE2.NONE;
      break;
    case 1:
      const pointerId = this._pointers[0];
      const position = this._pointerPositions[pointerId];
      this._onTouchStart({ pointerId, pageX: position.x, pageY: position.y });
      break;
  }
}
function onMouseDown2(event) {
  let mouseAction;
  switch (event.button) {
    case 0:
      mouseAction = this.mouseButtons.LEFT;
      break;
    case 1:
      mouseAction = this.mouseButtons.MIDDLE;
      break;
    case 2:
      mouseAction = this.mouseButtons.RIGHT;
      break;
    default:
      mouseAction = -1;
  }
  switch (mouseAction) {
    case MOUSE.DOLLY:
      if (this.enableZoom === false) return;
      this._handleMouseDownDolly(event);
      this.state = _STATE2.DOLLY;
      break;
    case MOUSE.ROTATE:
      if (event.ctrlKey || event.metaKey || event.shiftKey) {
        if (this.enablePan === false) return;
        this._handleMouseDownPan(event);
        this.state = _STATE2.PAN;
      } else {
        if (this.enableRotate === false) return;
        this._handleMouseDownRotate(event);
        this.state = _STATE2.ROTATE;
      }
      break;
    case MOUSE.PAN:
      if (event.ctrlKey || event.metaKey || event.shiftKey) {
        if (this.enableRotate === false) return;
        this._handleMouseDownRotate(event);
        this.state = _STATE2.ROTATE;
      } else {
        if (this.enablePan === false) return;
        this._handleMouseDownPan(event);
        this.state = _STATE2.PAN;
      }
      break;
    default:
      this.state = _STATE2.NONE;
  }
  if (this.state !== _STATE2.NONE) {
    this.dispatchEvent(_startEvent2);
  }
}
function onMouseMove2(event) {
  switch (this.state) {
    case _STATE2.ROTATE:
      if (this.enableRotate === false) return;
      this._handleMouseMoveRotate(event);
      break;
    case _STATE2.DOLLY:
      if (this.enableZoom === false) return;
      this._handleMouseMoveDolly(event);
      break;
    case _STATE2.PAN:
      if (this.enablePan === false) return;
      this._handleMouseMovePan(event);
      break;
  }
}
function onMouseWheel2(event) {
  if (this.enabled === false || this.enableZoom === false || this.state !== _STATE2.NONE) return;
  event.preventDefault();
  this.dispatchEvent(_startEvent2);
  this._handleMouseWheel(this._customWheelEvent(event));
  this.dispatchEvent(_endEvent2);
}
function onKeyDown2(event) {
  if (this.enabled === false) return;
  this._handleKeyDown(event);
}
function onTouchStart2(event) {
  this._trackPointer(event);
  switch (this._pointers.length) {
    case 1:
      switch (this.touches.ONE) {
        case TOUCH.ROTATE:
          if (this.enableRotate === false) return;
          this._handleTouchStartRotate(event);
          this.state = _STATE2.TOUCH_ROTATE;
          break;
        case TOUCH.PAN:
          if (this.enablePan === false) return;
          this._handleTouchStartPan(event);
          this.state = _STATE2.TOUCH_PAN;
          break;
        default:
          this.state = _STATE2.NONE;
      }
      break;
    case 2:
      switch (this.touches.TWO) {
        case TOUCH.DOLLY_PAN:
          if (this.enableZoom === false && this.enablePan === false) return;
          this._handleTouchStartDollyPan(event);
          this.state = _STATE2.TOUCH_DOLLY_PAN;
          break;
        case TOUCH.DOLLY_ROTATE:
          if (this.enableZoom === false && this.enableRotate === false) return;
          this._handleTouchStartDollyRotate(event);
          this.state = _STATE2.TOUCH_DOLLY_ROTATE;
          break;
        default:
          this.state = _STATE2.NONE;
      }
      break;
    default:
      this.state = _STATE2.NONE;
  }
  if (this.state !== _STATE2.NONE) {
    this.dispatchEvent(_startEvent2);
  }
}
function onTouchMove2(event) {
  this._trackPointer(event);
  switch (this.state) {
    case _STATE2.TOUCH_ROTATE:
      if (this.enableRotate === false) return;
      this._handleTouchMoveRotate(event);
      this.update();
      break;
    case _STATE2.TOUCH_PAN:
      if (this.enablePan === false) return;
      this._handleTouchMovePan(event);
      this.update();
      break;
    case _STATE2.TOUCH_DOLLY_PAN:
      if (this.enableZoom === false && this.enablePan === false) return;
      this._handleTouchMoveDollyPan(event);
      this.update();
      break;
    case _STATE2.TOUCH_DOLLY_ROTATE:
      if (this.enableZoom === false && this.enableRotate === false) return;
      this._handleTouchMoveDollyRotate(event);
      this.update();
      break;
    default:
      this.state = _STATE2.NONE;
  }
}
function onContextMenu3(event) {
  if (this.enabled === false) return;
  event.preventDefault();
}
function interceptControlDown(event) {
  if (event.key === "Control") {
    this._controlActive = true;
    const document2 = this.domElement.getRootNode();
    document2.addEventListener("keyup", this._interceptControlUp, { passive: true, capture: true });
  }
}
function interceptControlUp(event) {
  if (event.key === "Control") {
    this._controlActive = false;
    const document2 = this.domElement.getRootNode();
    document2.removeEventListener("keyup", this._interceptControlUp, { passive: true, capture: true });
  }
}

// node_modules/three/examples/jsm/controls/FlyControls.js
var _changeEvent3 = { type: "change" };
var _EPS3 = 1e-6;
var _tmpQuaternion = new Quaternion();
var FlyControls = class extends Controls {
  /**
   * Constructs a new controls instance.
   *
   * @param {Object3D} object - The object that is managed by the controls.
   * @param {?HTMLElement} domElement - The HTML element used for event listeners.
   */
  constructor(object, domElement = null) {
    super(object, domElement);
    this.movementSpeed = 1;
    this.rollSpeed = 5e-3;
    this.dragToLook = false;
    this.autoForward = false;
    this._moveState = { up: 0, down: 0, left: 0, right: 0, forward: 0, back: 0, pitchUp: 0, pitchDown: 0, yawLeft: 0, yawRight: 0, rollLeft: 0, rollRight: 0 };
    this._moveVector = new Vector3(0, 0, 0);
    this._rotationVector = new Vector3(0, 0, 0);
    this._lastQuaternion = new Quaternion();
    this._lastPosition = new Vector3();
    this._status = 0;
    this._onKeyDown = onKeyDown3.bind(this);
    this._onKeyUp = onKeyUp2.bind(this);
    this._onPointerMove = onPointerMove4.bind(this);
    this._onPointerDown = onPointerDown4.bind(this);
    this._onPointerUp = onPointerUp3.bind(this);
    this._onPointerCancel = onPointerCancel3.bind(this);
    this._onContextMenu = onContextMenu4.bind(this);
    if (domElement !== null) {
      this.connect(domElement);
    }
  }
  connect(element2) {
    super.connect(element2);
    window.addEventListener("keydown", this._onKeyDown);
    window.addEventListener("keyup", this._onKeyUp);
    this.domElement.addEventListener("pointermove", this._onPointerMove);
    this.domElement.addEventListener("pointerdown", this._onPointerDown);
    this.domElement.addEventListener("pointerup", this._onPointerUp);
    this.domElement.addEventListener("pointercancel", this._onPointerCancel);
    this.domElement.addEventListener("contextmenu", this._onContextMenu);
  }
  disconnect() {
    window.removeEventListener("keydown", this._onKeyDown);
    window.removeEventListener("keyup", this._onKeyUp);
    this.domElement.removeEventListener("pointermove", this._onPointerMove);
    this.domElement.removeEventListener("pointerdown", this._onPointerDown);
    this.domElement.removeEventListener("pointerup", this._onPointerUp);
    this.domElement.removeEventListener("pointercancel", this._onPointerCancel);
    this.domElement.removeEventListener("contextmenu", this._onContextMenu);
  }
  dispose() {
    this.disconnect();
  }
  update(delta) {
    if (this.enabled === false) return;
    const object = this.object;
    const moveMult = delta * this.movementSpeed;
    const rotMult = delta * this.rollSpeed;
    object.translateX(this._moveVector.x * moveMult);
    object.translateY(this._moveVector.y * moveMult);
    object.translateZ(this._moveVector.z * moveMult);
    _tmpQuaternion.set(this._rotationVector.x * rotMult, this._rotationVector.y * rotMult, this._rotationVector.z * rotMult, 1).normalize();
    object.quaternion.multiply(_tmpQuaternion);
    if (this._lastPosition.distanceToSquared(object.position) > _EPS3 || 8 * (1 - this._lastQuaternion.dot(object.quaternion)) > _EPS3) {
      this.dispatchEvent(_changeEvent3);
      this._lastQuaternion.copy(object.quaternion);
      this._lastPosition.copy(object.position);
    }
  }
  // private
  _updateMovementVector() {
    const forward = this._moveState.forward || this.autoForward && !this._moveState.back ? 1 : 0;
    this._moveVector.x = -this._moveState.left + this._moveState.right;
    this._moveVector.y = -this._moveState.down + this._moveState.up;
    this._moveVector.z = -forward + this._moveState.back;
  }
  _updateRotationVector() {
    this._rotationVector.x = -this._moveState.pitchDown + this._moveState.pitchUp;
    this._rotationVector.y = -this._moveState.yawRight + this._moveState.yawLeft;
    this._rotationVector.z = -this._moveState.rollRight + this._moveState.rollLeft;
  }
  _getContainerDimensions() {
    if (this.domElement != document) {
      return {
        size: [this.domElement.offsetWidth, this.domElement.offsetHeight],
        offset: [this.domElement.offsetLeft, this.domElement.offsetTop]
      };
    } else {
      return {
        size: [window.innerWidth, window.innerHeight],
        offset: [0, 0]
      };
    }
  }
};
function onKeyDown3(event) {
  if (event.altKey || this.enabled === false) {
    return;
  }
  switch (event.code) {
    case "ShiftLeft":
    case "ShiftRight":
      this.movementSpeedMultiplier = 0.1;
      break;
    case "KeyW":
      this._moveState.forward = 1;
      break;
    case "KeyS":
      this._moveState.back = 1;
      break;
    case "KeyA":
      this._moveState.left = 1;
      break;
    case "KeyD":
      this._moveState.right = 1;
      break;
    case "KeyR":
      this._moveState.up = 1;
      break;
    case "KeyF":
      this._moveState.down = 1;
      break;
    case "ArrowUp":
      this._moveState.pitchUp = 1;
      break;
    case "ArrowDown":
      this._moveState.pitchDown = 1;
      break;
    case "ArrowLeft":
      this._moveState.yawLeft = 1;
      break;
    case "ArrowRight":
      this._moveState.yawRight = 1;
      break;
    case "KeyQ":
      this._moveState.rollLeft = 1;
      break;
    case "KeyE":
      this._moveState.rollRight = 1;
      break;
  }
  this._updateMovementVector();
  this._updateRotationVector();
}
function onKeyUp2(event) {
  if (this.enabled === false) return;
  switch (event.code) {
    case "ShiftLeft":
    case "ShiftRight":
      this.movementSpeedMultiplier = 1;
      break;
    case "KeyW":
      this._moveState.forward = 0;
      break;
    case "KeyS":
      this._moveState.back = 0;
      break;
    case "KeyA":
      this._moveState.left = 0;
      break;
    case "KeyD":
      this._moveState.right = 0;
      break;
    case "KeyR":
      this._moveState.up = 0;
      break;
    case "KeyF":
      this._moveState.down = 0;
      break;
    case "ArrowUp":
      this._moveState.pitchUp = 0;
      break;
    case "ArrowDown":
      this._moveState.pitchDown = 0;
      break;
    case "ArrowLeft":
      this._moveState.yawLeft = 0;
      break;
    case "ArrowRight":
      this._moveState.yawRight = 0;
      break;
    case "KeyQ":
      this._moveState.rollLeft = 0;
      break;
    case "KeyE":
      this._moveState.rollRight = 0;
      break;
  }
  this._updateMovementVector();
  this._updateRotationVector();
}
function onPointerDown4(event) {
  if (this.enabled === false) return;
  if (this.dragToLook) {
    this._status++;
  } else {
    switch (event.button) {
      case 0:
        this._moveState.forward = 1;
        break;
      case 2:
        this._moveState.back = 1;
        break;
    }
    this._updateMovementVector();
  }
}
function onPointerMove4(event) {
  if (this.enabled === false) return;
  if (!this.dragToLook || this._status > 0) {
    const container = this._getContainerDimensions();
    const halfWidth = container.size[0] / 2;
    const halfHeight = container.size[1] / 2;
    this._moveState.yawLeft = -(event.pageX - container.offset[0] - halfWidth) / halfWidth;
    this._moveState.pitchDown = (event.pageY - container.offset[1] - halfHeight) / halfHeight;
    this._updateRotationVector();
  }
}
function onPointerUp3(event) {
  if (this.enabled === false) return;
  if (this.dragToLook) {
    this._status--;
    this._moveState.yawLeft = this._moveState.pitchDown = 0;
  } else {
    switch (event.button) {
      case 0:
        this._moveState.forward = 0;
        break;
      case 2:
        this._moveState.back = 0;
        break;
    }
    this._updateMovementVector();
  }
  this._updateRotationVector();
}
function onPointerCancel3() {
  if (this.enabled === false) return;
  if (this.dragToLook) {
    this._status = 0;
    this._moveState.yawLeft = this._moveState.pitchDown = 0;
  } else {
    this._moveState.forward = 0;
    this._moveState.back = 0;
    this._updateMovementVector();
  }
  this._updateRotationVector();
}
function onContextMenu4(event) {
  if (this.enabled === false) return;
  event.preventDefault();
}

// node_modules/three/examples/jsm/shaders/CopyShader.js
var CopyShader = {
  name: "CopyShader",
  uniforms: {
    "tDiffuse": { value: null },
    "opacity": { value: 1 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;


		}`
  )
};

// node_modules/three/examples/jsm/postprocessing/Pass.js
var Pass = class {
  /**
   * Constructs a new pass.
   */
  constructor() {
    this.isPass = true;
    this.enabled = true;
    this.needsSwap = true;
    this.clear = false;
    this.renderToScreen = false;
  }
  /**
   * Sets the size of the pass.
   *
   * @abstract
   * @param {number} width - The width to set.
   * @param {number} height - The height to set.
   */
  setSize() {
  }
  /**
   * This method holds the render logic of a pass. It must be implemented in all derived classes.
   *
   * @abstract
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering
   * destination for the pass.
   * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the
   * previous pass from this buffer.
   * @param {number} deltaTime - The delta time in seconds.
   * @param {boolean} maskActive - Whether masking is active or not.
   */
  render() {
    console.error("THREE.Pass: .render() must be implemented in derived pass.");
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever the pass is no longer used in your app.
   *
   * @abstract
   */
  dispose() {
  }
};
var _camera3 = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
var FullscreenTriangleGeometry = class extends BufferGeometry {
  constructor() {
    super();
    this.setAttribute("position", new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));
    this.setAttribute("uv", new Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2));
  }
};
var _geometry2 = new FullscreenTriangleGeometry();
var FullScreenQuad = class {
  /**
   * Constructs a new full screen quad.
   *
   * @param {?Material} material - The material to render te full screen quad with.
   */
  constructor(material) {
    this._mesh = new Mesh(_geometry2, material);
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever the instance is no longer used in your app.
   */
  dispose() {
    this._mesh.geometry.dispose();
  }
  /**
   * Renders the full screen quad.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   */
  render(renderer3) {
    renderer3.render(this._mesh, _camera3);
  }
  /**
   * The quad's material.
   *
   * @type {?Material}
   */
  get material() {
    return this._mesh.material;
  }
  set material(value) {
    this._mesh.material = value;
  }
};

// node_modules/three/examples/jsm/postprocessing/ShaderPass.js
var ShaderPass = class extends Pass {
  /**
   * Constructs a new shader pass.
   *
   * @param {Object|ShaderMaterial} [shader] - A shader object holding vertex and fragment shader as well as
   * defines and uniforms. It's also valid to pass a custom shader material.
   * @param {string} [textureID='tDiffuse'] - The name of the texture uniform that should sample
   * the read buffer.
   */
  constructor(shader, textureID = "tDiffuse") {
    super();
    this.textureID = textureID;
    this.uniforms = null;
    this.material = null;
    if (shader instanceof ShaderMaterial) {
      this.uniforms = shader.uniforms;
      this.material = shader;
    } else if (shader) {
      this.uniforms = UniformsUtils.clone(shader.uniforms);
      this.material = new ShaderMaterial({
        name: shader.name !== void 0 ? shader.name : "unspecified",
        defines: Object.assign({}, shader.defines),
        uniforms: this.uniforms,
        vertexShader: shader.vertexShader,
        fragmentShader: shader.fragmentShader
      });
    }
    this._fsQuad = new FullScreenQuad(this.material);
  }
  /**
   * Performs the shader pass.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering
   * destination for the pass.
   * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the
   * previous pass from this buffer.
   * @param {number} deltaTime - The delta time in seconds.
   * @param {boolean} maskActive - Whether masking is active or not.
   */
  render(renderer3, writeBuffer, readBuffer) {
    if (this.uniforms[this.textureID]) {
      this.uniforms[this.textureID].value = readBuffer.texture;
    }
    this._fsQuad.material = this.material;
    if (this.renderToScreen) {
      renderer3.setRenderTarget(null);
      this._fsQuad.render(renderer3);
    } else {
      renderer3.setRenderTarget(writeBuffer);
      if (this.clear) renderer3.clear(renderer3.autoClearColor, renderer3.autoClearDepth, renderer3.autoClearStencil);
      this._fsQuad.render(renderer3);
    }
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever the pass is no longer used in your app.
   */
  dispose() {
    this.material.dispose();
    this._fsQuad.dispose();
  }
};

// node_modules/three/examples/jsm/postprocessing/MaskPass.js
var MaskPass = class extends Pass {
  /**
   * Constructs a new mask pass.
   *
   * @param {Scene} scene - The 3D objects in this scene will define the mask.
   * @param {Camera} camera - The camera.
   */
  constructor(scene3, camera3) {
    super();
    this.scene = scene3;
    this.camera = camera3;
    this.clear = true;
    this.needsSwap = false;
    this.inverse = false;
  }
  /**
   * Performs a mask pass with the configured scene and camera.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering
   * destination for the pass.
   * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the
   * previous pass from this buffer.
   * @param {number} deltaTime - The delta time in seconds.
   * @param {boolean} maskActive - Whether masking is active or not.
   */
  render(renderer3, writeBuffer, readBuffer) {
    const context2 = renderer3.getContext();
    const state = renderer3.state;
    state.buffers.color.setMask(false);
    state.buffers.depth.setMask(false);
    state.buffers.color.setLocked(true);
    state.buffers.depth.setLocked(true);
    let writeValue, clearValue;
    if (this.inverse) {
      writeValue = 0;
      clearValue = 1;
    } else {
      writeValue = 1;
      clearValue = 0;
    }
    state.buffers.stencil.setTest(true);
    state.buffers.stencil.setOp(context2.REPLACE, context2.REPLACE, context2.REPLACE);
    state.buffers.stencil.setFunc(context2.ALWAYS, writeValue, 4294967295);
    state.buffers.stencil.setClear(clearValue);
    state.buffers.stencil.setLocked(true);
    renderer3.setRenderTarget(readBuffer);
    if (this.clear) renderer3.clear();
    renderer3.render(this.scene, this.camera);
    renderer3.setRenderTarget(writeBuffer);
    if (this.clear) renderer3.clear();
    renderer3.render(this.scene, this.camera);
    state.buffers.color.setLocked(false);
    state.buffers.depth.setLocked(false);
    state.buffers.color.setMask(true);
    state.buffers.depth.setMask(true);
    state.buffers.stencil.setLocked(false);
    state.buffers.stencil.setFunc(context2.EQUAL, 1, 4294967295);
    state.buffers.stencil.setOp(context2.KEEP, context2.KEEP, context2.KEEP);
    state.buffers.stencil.setLocked(true);
  }
};
var ClearMaskPass = class extends Pass {
  /**
   * Constructs a new clear mask pass.
   */
  constructor() {
    super();
    this.needsSwap = false;
  }
  /**
   * Performs the clear of the currently defined mask.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering
   * destination for the pass.
   * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the
   * previous pass from this buffer.
   * @param {number} deltaTime - The delta time in seconds.
   * @param {boolean} maskActive - Whether masking is active or not.
   */
  render(renderer3) {
    renderer3.state.buffers.stencil.setLocked(false);
    renderer3.state.buffers.stencil.setTest(false);
  }
};

// node_modules/three/examples/jsm/postprocessing/EffectComposer.js
var EffectComposer = class {
  /**
   * Constructs a new effect composer.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} [renderTarget] - This render target and a clone will
   * be used as the internal read and write buffers. If not given, the composer creates
   * the buffers automatically.
   */
  constructor(renderer3, renderTarget) {
    this.renderer = renderer3;
    this._pixelRatio = renderer3.getPixelRatio();
    if (renderTarget === void 0) {
      const size2 = renderer3.getSize(new Vector2());
      this._width = size2.width;
      this._height = size2.height;
      renderTarget = new WebGLRenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio, { type: HalfFloatType });
      renderTarget.texture.name = "EffectComposer.rt1";
    } else {
      this._width = renderTarget.width;
      this._height = renderTarget.height;
    }
    this.renderTarget1 = renderTarget;
    this.renderTarget2 = renderTarget.clone();
    this.renderTarget2.texture.name = "EffectComposer.rt2";
    this.writeBuffer = this.renderTarget1;
    this.readBuffer = this.renderTarget2;
    this.renderToScreen = true;
    this.passes = [];
    this.copyPass = new ShaderPass(CopyShader);
    this.copyPass.material.blending = NoBlending;
    this.clock = new Clock();
  }
  /**
   * Swaps the internal read/write buffers.
   */
  swapBuffers() {
    const tmp2 = this.readBuffer;
    this.readBuffer = this.writeBuffer;
    this.writeBuffer = tmp2;
  }
  /**
   * Adds the given pass to the pass chain.
   *
   * @param {Pass} pass - The pass to add.
   */
  addPass(pass2) {
    this.passes.push(pass2);
    pass2.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  /**
   * Inserts the given pass at a given index.
   *
   * @param {Pass} pass - The pass to insert.
   * @param {number} index - The index into the pass chain.
   */
  insertPass(pass2, index8) {
    this.passes.splice(index8, 0, pass2);
    pass2.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  /**
   * Removes the given pass from the pass chain.
   *
   * @param {Pass} pass - The pass to remove.
   */
  removePass(pass2) {
    const index8 = this.passes.indexOf(pass2);
    if (index8 !== -1) {
      this.passes.splice(index8, 1);
    }
  }
  /**
   * Returns `true` if the pass for the given index is the last enabled pass in the pass chain.
   *
   * @param {number} passIndex - The pass index.
   * @return {boolean} Whether the pass for the given index is the last pass in the pass chain.
   */
  isLastEnabledPass(passIndex) {
    for (let i2 = passIndex + 1; i2 < this.passes.length; i2++) {
      if (this.passes[i2].enabled) {
        return false;
      }
    }
    return true;
  }
  /**
   * Executes all enabled post-processing passes in order to produce the final frame.
   *
   * @param {number} deltaTime - The delta time in seconds. If not given, the composer computes
   * its own time delta value.
   */
  render(deltaTime2) {
    if (deltaTime2 === void 0) {
      deltaTime2 = this.clock.getDelta();
    }
    const currentRenderTarget = this.renderer.getRenderTarget();
    let maskActive = false;
    for (let i2 = 0, il = this.passes.length; i2 < il; i2++) {
      const pass2 = this.passes[i2];
      if (pass2.enabled === false) continue;
      pass2.renderToScreen = this.renderToScreen && this.isLastEnabledPass(i2);
      pass2.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime2, maskActive);
      if (pass2.needsSwap) {
        if (maskActive) {
          const context2 = this.renderer.getContext();
          const stencil = this.renderer.state.buffers.stencil;
          stencil.setFunc(context2.NOTEQUAL, 1, 4294967295);
          this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime2);
          stencil.setFunc(context2.EQUAL, 1, 4294967295);
        }
        this.swapBuffers();
      }
      if (MaskPass !== void 0) {
        if (pass2 instanceof MaskPass) {
          maskActive = true;
        } else if (pass2 instanceof ClearMaskPass) {
          maskActive = false;
        }
      }
    }
    this.renderer.setRenderTarget(currentRenderTarget);
  }
  /**
   * Resets the internal state of the EffectComposer.
   *
   * @param {WebGLRenderTarget} [renderTarget] - This render target has the same purpose like
   * the one from the constructor. If set, it is used to setup the read and write buffers.
   */
  reset(renderTarget) {
    if (renderTarget === void 0) {
      const size2 = this.renderer.getSize(new Vector2());
      this._pixelRatio = this.renderer.getPixelRatio();
      this._width = size2.width;
      this._height = size2.height;
      renderTarget = this.renderTarget1.clone();
      renderTarget.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
    this.renderTarget1.dispose();
    this.renderTarget2.dispose();
    this.renderTarget1 = renderTarget;
    this.renderTarget2 = renderTarget.clone();
    this.writeBuffer = this.renderTarget1;
    this.readBuffer = this.renderTarget2;
  }
  /**
   * Resizes the internal read and write buffers as well as all passes. Similar to {@link WebGLRenderer#setSize},
   * this method honors the current pixel ration.
   *
   * @param {number} width - The width in logical pixels.
   * @param {number} height - The height in logical pixels.
   */
  setSize(width, height) {
    this._width = width;
    this._height = height;
    const effectiveWidth = this._width * this._pixelRatio;
    const effectiveHeight = this._height * this._pixelRatio;
    this.renderTarget1.setSize(effectiveWidth, effectiveHeight);
    this.renderTarget2.setSize(effectiveWidth, effectiveHeight);
    for (let i2 = 0; i2 < this.passes.length; i2++) {
      this.passes[i2].setSize(effectiveWidth, effectiveHeight);
    }
  }
  /**
   * Sets device pixel ratio. This is usually used for HiDPI device to prevent blurring output.
   * Setting the pixel ratio will automatically resize the composer.
   *
   * @param {number} pixelRatio - The pixel ratio to set.
   */
  setPixelRatio(pixelRatio) {
    this._pixelRatio = pixelRatio;
    this.setSize(this._width, this._height);
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever the composer is no longer used in your app.
   */
  dispose() {
    this.renderTarget1.dispose();
    this.renderTarget2.dispose();
    this.copyPass.dispose();
  }
};

// node_modules/three/examples/jsm/postprocessing/RenderPass.js
var RenderPass = class extends Pass {
  /**
   * Constructs a new render pass.
   *
   * @param {Scene} scene - The scene to render.
   * @param {Camera} camera - The camera.
   * @param {?Material} [overrideMaterial=null] - The override material. If set, this material is used
   * for all objects in the scene.
   * @param {?(number|Color|string)} [clearColor=null] - The clear color of the render pass.
   * @param {?number} [clearAlpha=null] - The clear alpha of the render pass.
   */
  constructor(scene3, camera3, overrideMaterial = null, clearColor = null, clearAlpha = null) {
    super();
    this.scene = scene3;
    this.camera = camera3;
    this.overrideMaterial = overrideMaterial;
    this.clearColor = clearColor;
    this.clearAlpha = clearAlpha;
    this.clear = true;
    this.clearDepth = false;
    this.needsSwap = false;
    this.isRenderPass = true;
    this._oldClearColor = new Color();
  }
  /**
   * Performs a beauty pass with the configured scene and camera.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering
   * destination for the pass.
   * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the
   * previous pass from this buffer.
   * @param {number} deltaTime - The delta time in seconds.
   * @param {boolean} maskActive - Whether masking is active or not.
   */
  render(renderer3, writeBuffer, readBuffer) {
    const oldAutoClear = renderer3.autoClear;
    renderer3.autoClear = false;
    let oldClearAlpha, oldOverrideMaterial;
    if (this.overrideMaterial !== null) {
      oldOverrideMaterial = this.scene.overrideMaterial;
      this.scene.overrideMaterial = this.overrideMaterial;
    }
    if (this.clearColor !== null) {
      renderer3.getClearColor(this._oldClearColor);
      renderer3.setClearColor(this.clearColor, renderer3.getClearAlpha());
    }
    if (this.clearAlpha !== null) {
      oldClearAlpha = renderer3.getClearAlpha();
      renderer3.setClearAlpha(this.clearAlpha);
    }
    if (this.clearDepth == true) {
      renderer3.clearDepth();
    }
    renderer3.setRenderTarget(this.renderToScreen ? null : readBuffer);
    if (this.clear === true) {
      renderer3.clear(renderer3.autoClearColor, renderer3.autoClearDepth, renderer3.autoClearStencil);
    }
    renderer3.render(this.scene, this.camera);
    if (this.clearColor !== null) {
      renderer3.setClearColor(this._oldClearColor);
    }
    if (this.clearAlpha !== null) {
      renderer3.setClearAlpha(oldClearAlpha);
    }
    if (this.overrideMaterial !== null) {
      this.scene.overrideMaterial = oldOverrideMaterial;
    }
    renderer3.autoClear = oldAutoClear;
  }
};

// node_modules/@tweenjs/tween.js/dist/tween.esm.js
var Easing = Object.freeze({
  Linear: Object.freeze({
    None: function(amount) {
      return amount;
    },
    In: function(amount) {
      return amount;
    },
    Out: function(amount) {
      return amount;
    },
    InOut: function(amount) {
      return amount;
    }
  }),
  Quadratic: Object.freeze({
    In: function(amount) {
      return amount * amount;
    },
    Out: function(amount) {
      return amount * (2 - amount);
    },
    InOut: function(amount) {
      if ((amount *= 2) < 1) {
        return 0.5 * amount * amount;
      }
      return -0.5 * (--amount * (amount - 2) - 1);
    }
  }),
  Cubic: Object.freeze({
    In: function(amount) {
      return amount * amount * amount;
    },
    Out: function(amount) {
      return --amount * amount * amount + 1;
    },
    InOut: function(amount) {
      if ((amount *= 2) < 1) {
        return 0.5 * amount * amount * amount;
      }
      return 0.5 * ((amount -= 2) * amount * amount + 2);
    }
  }),
  Quartic: Object.freeze({
    In: function(amount) {
      return amount * amount * amount * amount;
    },
    Out: function(amount) {
      return 1 - --amount * amount * amount * amount;
    },
    InOut: function(amount) {
      if ((amount *= 2) < 1) {
        return 0.5 * amount * amount * amount * amount;
      }
      return -0.5 * ((amount -= 2) * amount * amount * amount - 2);
    }
  }),
  Quintic: Object.freeze({
    In: function(amount) {
      return amount * amount * amount * amount * amount;
    },
    Out: function(amount) {
      return --amount * amount * amount * amount * amount + 1;
    },
    InOut: function(amount) {
      if ((amount *= 2) < 1) {
        return 0.5 * amount * amount * amount * amount * amount;
      }
      return 0.5 * ((amount -= 2) * amount * amount * amount * amount + 2);
    }
  }),
  Sinusoidal: Object.freeze({
    In: function(amount) {
      return 1 - Math.sin((1 - amount) * Math.PI / 2);
    },
    Out: function(amount) {
      return Math.sin(amount * Math.PI / 2);
    },
    InOut: function(amount) {
      return 0.5 * (1 - Math.sin(Math.PI * (0.5 - amount)));
    }
  }),
  Exponential: Object.freeze({
    In: function(amount) {
      return amount === 0 ? 0 : Math.pow(1024, amount - 1);
    },
    Out: function(amount) {
      return amount === 1 ? 1 : 1 - Math.pow(2, -10 * amount);
    },
    InOut: function(amount) {
      if (amount === 0) {
        return 0;
      }
      if (amount === 1) {
        return 1;
      }
      if ((amount *= 2) < 1) {
        return 0.5 * Math.pow(1024, amount - 1);
      }
      return 0.5 * (-Math.pow(2, -10 * (amount - 1)) + 2);
    }
  }),
  Circular: Object.freeze({
    In: function(amount) {
      return 1 - Math.sqrt(1 - amount * amount);
    },
    Out: function(amount) {
      return Math.sqrt(1 - --amount * amount);
    },
    InOut: function(amount) {
      if ((amount *= 2) < 1) {
        return -0.5 * (Math.sqrt(1 - amount * amount) - 1);
      }
      return 0.5 * (Math.sqrt(1 - (amount -= 2) * amount) + 1);
    }
  }),
  Elastic: Object.freeze({
    In: function(amount) {
      if (amount === 0) {
        return 0;
      }
      if (amount === 1) {
        return 1;
      }
      return -Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);
    },
    Out: function(amount) {
      if (amount === 0) {
        return 0;
      }
      if (amount === 1) {
        return 1;
      }
      return Math.pow(2, -10 * amount) * Math.sin((amount - 0.1) * 5 * Math.PI) + 1;
    },
    InOut: function(amount) {
      if (amount === 0) {
        return 0;
      }
      if (amount === 1) {
        return 1;
      }
      amount *= 2;
      if (amount < 1) {
        return -0.5 * Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);
      }
      return 0.5 * Math.pow(2, -10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI) + 1;
    }
  }),
  Back: Object.freeze({
    In: function(amount) {
      var s2 = 1.70158;
      return amount === 1 ? 1 : amount * amount * ((s2 + 1) * amount - s2);
    },
    Out: function(amount) {
      var s2 = 1.70158;
      return amount === 0 ? 0 : --amount * amount * ((s2 + 1) * amount + s2) + 1;
    },
    InOut: function(amount) {
      var s2 = 1.70158 * 1.525;
      if ((amount *= 2) < 1) {
        return 0.5 * (amount * amount * ((s2 + 1) * amount - s2));
      }
      return 0.5 * ((amount -= 2) * amount * ((s2 + 1) * amount + s2) + 2);
    }
  }),
  Bounce: Object.freeze({
    In: function(amount) {
      return 1 - Easing.Bounce.Out(1 - amount);
    },
    Out: function(amount) {
      if (amount < 1 / 2.75) {
        return 7.5625 * amount * amount;
      } else if (amount < 2 / 2.75) {
        return 7.5625 * (amount -= 1.5 / 2.75) * amount + 0.75;
      } else if (amount < 2.5 / 2.75) {
        return 7.5625 * (amount -= 2.25 / 2.75) * amount + 0.9375;
      } else {
        return 7.5625 * (amount -= 2.625 / 2.75) * amount + 0.984375;
      }
    },
    InOut: function(amount) {
      if (amount < 0.5) {
        return Easing.Bounce.In(amount * 2) * 0.5;
      }
      return Easing.Bounce.Out(amount * 2 - 1) * 0.5 + 0.5;
    }
  }),
  generatePow: function(power) {
    if (power === void 0) {
      power = 4;
    }
    power = power < Number.EPSILON ? Number.EPSILON : power;
    power = power > 1e4 ? 1e4 : power;
    return {
      In: function(amount) {
        return Math.pow(amount, power);
      },
      Out: function(amount) {
        return 1 - Math.pow(1 - amount, power);
      },
      InOut: function(amount) {
        if (amount < 0.5) {
          return Math.pow(amount * 2, power) / 2;
        }
        return (1 - Math.pow(2 - amount * 2, power)) / 2 + 0.5;
      }
    };
  }
});
var now3 = function() {
  return performance.now();
};
var Group3 = (
  /** @class */
  (function() {
    function Group4() {
      var tweens = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        tweens[_i] = arguments[_i];
      }
      this._tweens = {};
      this._tweensAddedDuringUpdate = {};
      this.add.apply(this, tweens);
    }
    Group4.prototype.getAll = function() {
      var _this = this;
      return Object.keys(this._tweens).map(function(tweenId) {
        return _this._tweens[tweenId];
      });
    };
    Group4.prototype.removeAll = function() {
      this._tweens = {};
    };
    Group4.prototype.add = function() {
      var _a2;
      var tweens = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        tweens[_i] = arguments[_i];
      }
      for (var _b2 = 0, tweens_1 = tweens; _b2 < tweens_1.length; _b2++) {
        var tween = tweens_1[_b2];
        (_a2 = tween._group) === null || _a2 === void 0 ? void 0 : _a2.remove(tween);
        tween._group = this;
        this._tweens[tween.getId()] = tween;
        this._tweensAddedDuringUpdate[tween.getId()] = tween;
      }
    };
    Group4.prototype.remove = function() {
      var tweens = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        tweens[_i] = arguments[_i];
      }
      for (var _a2 = 0, tweens_2 = tweens; _a2 < tweens_2.length; _a2++) {
        var tween = tweens_2[_a2];
        tween._group = void 0;
        delete this._tweens[tween.getId()];
        delete this._tweensAddedDuringUpdate[tween.getId()];
      }
    };
    Group4.prototype.allStopped = function() {
      return this.getAll().every(function(tween) {
        return !tween.isPlaying();
      });
    };
    Group4.prototype.update = function(time3, preserve) {
      if (time3 === void 0) {
        time3 = now3();
      }
      if (preserve === void 0) {
        preserve = true;
      }
      var tweenIds = Object.keys(this._tweens);
      if (tweenIds.length === 0)
        return;
      while (tweenIds.length > 0) {
        this._tweensAddedDuringUpdate = {};
        for (var i2 = 0; i2 < tweenIds.length; i2++) {
          var tween = this._tweens[tweenIds[i2]];
          var autoStart = !preserve;
          if (tween && tween.update(time3, autoStart) === false && !preserve)
            this.remove(tween);
        }
        tweenIds = Object.keys(this._tweensAddedDuringUpdate);
      }
    };
    return Group4;
  })()
);
var Interpolation = {
  Linear: function(v2, k2) {
    var m3 = v2.length - 1;
    var f3 = m3 * k2;
    var i2 = Math.floor(f3);
    var fn = Interpolation.Utils.Linear;
    if (k2 < 0) {
      return fn(v2[0], v2[1], f3);
    }
    if (k2 > 1) {
      return fn(v2[m3], v2[m3 - 1], m3 - f3);
    }
    return fn(v2[i2], v2[i2 + 1 > m3 ? m3 : i2 + 1], f3 - i2);
  },
  Bezier: function(v2, k2) {
    var b = 0;
    var n2 = v2.length - 1;
    var pw = Math.pow;
    var bn = Interpolation.Utils.Bernstein;
    for (var i2 = 0; i2 <= n2; i2++) {
      b += pw(1 - k2, n2 - i2) * pw(k2, i2) * v2[i2] * bn(n2, i2);
    }
    return b;
  },
  CatmullRom: function(v2, k2) {
    var m3 = v2.length - 1;
    var f3 = m3 * k2;
    var i2 = Math.floor(f3);
    var fn = Interpolation.Utils.CatmullRom;
    if (v2[0] === v2[m3]) {
      if (k2 < 0) {
        i2 = Math.floor(f3 = m3 * (1 + k2));
      }
      return fn(v2[(i2 - 1 + m3) % m3], v2[i2], v2[(i2 + 1) % m3], v2[(i2 + 2) % m3], f3 - i2);
    } else {
      if (k2 < 0) {
        return v2[0] - (fn(v2[0], v2[0], v2[1], v2[1], -f3) - v2[0]);
      }
      if (k2 > 1) {
        return v2[m3] - (fn(v2[m3], v2[m3], v2[m3 - 1], v2[m3 - 1], f3 - m3) - v2[m3]);
      }
      return fn(v2[i2 ? i2 - 1 : 0], v2[i2], v2[m3 < i2 + 1 ? m3 : i2 + 1], v2[m3 < i2 + 2 ? m3 : i2 + 2], f3 - i2);
    }
  },
  Utils: {
    Linear: function(p0, p1, t5) {
      return (p1 - p0) * t5 + p0;
    },
    Bernstein: function(n2, i2) {
      var fc = Interpolation.Utils.Factorial;
      return fc(n2) / fc(i2) / fc(n2 - i2);
    },
    Factorial: /* @__PURE__ */ (function() {
      var a3 = [1];
      return function(n2) {
        var s2 = 1;
        if (a3[n2]) {
          return a3[n2];
        }
        for (var i2 = n2; i2 > 1; i2--) {
          s2 *= i2;
        }
        a3[n2] = s2;
        return s2;
      };
    })(),
    CatmullRom: function(p0, p1, p22, p3, t5) {
      var v0 = (p22 - p0) * 0.5;
      var v1 = (p3 - p1) * 0.5;
      var t22 = t5 * t5;
      var t32 = t5 * t22;
      return (2 * p1 - 2 * p22 + v0 + v1) * t32 + (-3 * p1 + 3 * p22 - 2 * v0 - v1) * t22 + v0 * t5 + p1;
    }
  }
};
var Sequence = (
  /** @class */
  (function() {
    function Sequence2() {
    }
    Sequence2.nextId = function() {
      return Sequence2._nextId++;
    };
    Sequence2._nextId = 0;
    return Sequence2;
  })()
);
var mainGroup = new Group3();
var Tween = (
  /** @class */
  (function() {
    function Tween2(object, group2) {
      this._isPaused = false;
      this._pauseStart = 0;
      this._valuesStart = {};
      this._valuesEnd = {};
      this._valuesStartRepeat = {};
      this._duration = 1e3;
      this._isDynamic = false;
      this._initialRepeat = 0;
      this._repeat = 0;
      this._yoyo = false;
      this._isPlaying = false;
      this._reversed = false;
      this._delayTime = 0;
      this._startTime = 0;
      this._easingFunction = Easing.Linear.None;
      this._interpolationFunction = Interpolation.Linear;
      this._chainedTweens = [];
      this._onStartCallbackFired = false;
      this._onEveryStartCallbackFired = false;
      this._id = Sequence.nextId();
      this._isChainStopped = false;
      this._propertiesAreSetUp = false;
      this._goToEnd = false;
      this._object = object;
      if (typeof group2 === "object") {
        this._group = group2;
        group2.add(this);
      } else if (group2 === true) {
        this._group = mainGroup;
        mainGroup.add(this);
      }
    }
    Tween2.prototype.getId = function() {
      return this._id;
    };
    Tween2.prototype.isPlaying = function() {
      return this._isPlaying;
    };
    Tween2.prototype.isPaused = function() {
      return this._isPaused;
    };
    Tween2.prototype.getDuration = function() {
      return this._duration;
    };
    Tween2.prototype.to = function(target, duration) {
      if (duration === void 0) {
        duration = 1e3;
      }
      if (this._isPlaying)
        throw new Error("Can not call Tween.to() while Tween is already started or paused. Stop the Tween first.");
      this._valuesEnd = target;
      this._propertiesAreSetUp = false;
      this._duration = duration < 0 ? 0 : duration;
      return this;
    };
    Tween2.prototype.duration = function(duration) {
      if (duration === void 0) {
        duration = 1e3;
      }
      this._duration = duration < 0 ? 0 : duration;
      return this;
    };
    Tween2.prototype.dynamic = function(dynamic) {
      if (dynamic === void 0) {
        dynamic = false;
      }
      this._isDynamic = dynamic;
      return this;
    };
    Tween2.prototype.start = function(time3, overrideStartingValues) {
      if (time3 === void 0) {
        time3 = now3();
      }
      if (overrideStartingValues === void 0) {
        overrideStartingValues = false;
      }
      if (this._isPlaying) {
        return this;
      }
      this._repeat = this._initialRepeat;
      if (this._reversed) {
        this._reversed = false;
        for (var property3 in this._valuesStartRepeat) {
          this._swapEndStartRepeatValues(property3);
          this._valuesStart[property3] = this._valuesStartRepeat[property3];
        }
      }
      this._isPlaying = true;
      this._isPaused = false;
      this._onStartCallbackFired = false;
      this._onEveryStartCallbackFired = false;
      this._isChainStopped = false;
      this._startTime = time3;
      this._startTime += this._delayTime;
      if (!this._propertiesAreSetUp || overrideStartingValues) {
        this._propertiesAreSetUp = true;
        if (!this._isDynamic) {
          var tmp2 = {};
          for (var prop in this._valuesEnd)
            tmp2[prop] = this._valuesEnd[prop];
          this._valuesEnd = tmp2;
        }
        this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat, overrideStartingValues);
      }
      return this;
    };
    Tween2.prototype.startFromCurrentValues = function(time3) {
      return this.start(time3, true);
    };
    Tween2.prototype._setupProperties = function(_object, _valuesStart, _valuesEnd, _valuesStartRepeat, overrideStartingValues) {
      for (var property3 in _valuesEnd) {
        var startValue = _object[property3];
        var startValueIsArray = Array.isArray(startValue);
        var propType = startValueIsArray ? "array" : typeof startValue;
        var isInterpolationList = !startValueIsArray && Array.isArray(_valuesEnd[property3]);
        if (propType === "undefined" || propType === "function") {
          continue;
        }
        if (isInterpolationList) {
          var endValues = _valuesEnd[property3];
          if (endValues.length === 0) {
            continue;
          }
          var temp = [startValue];
          for (var i2 = 0, l2 = endValues.length; i2 < l2; i2 += 1) {
            var value = this._handleRelativeValue(startValue, endValues[i2]);
            if (isNaN(value)) {
              isInterpolationList = false;
              console.warn("Found invalid interpolation list. Skipping.");
              break;
            }
            temp.push(value);
          }
          if (isInterpolationList) {
            _valuesEnd[property3] = temp;
          }
        }
        if ((propType === "object" || startValueIsArray) && startValue && !isInterpolationList) {
          _valuesStart[property3] = startValueIsArray ? [] : {};
          var nestedObject = startValue;
          for (var prop in nestedObject) {
            _valuesStart[property3][prop] = nestedObject[prop];
          }
          _valuesStartRepeat[property3] = startValueIsArray ? [] : {};
          var endValues = _valuesEnd[property3];
          if (!this._isDynamic) {
            var tmp2 = {};
            for (var prop in endValues)
              tmp2[prop] = endValues[prop];
            _valuesEnd[property3] = endValues = tmp2;
          }
          this._setupProperties(nestedObject, _valuesStart[property3], endValues, _valuesStartRepeat[property3], overrideStartingValues);
        } else {
          if (typeof _valuesStart[property3] === "undefined" || overrideStartingValues) {
            _valuesStart[property3] = startValue;
          }
          if (!startValueIsArray) {
            _valuesStart[property3] *= 1;
          }
          if (isInterpolationList) {
            _valuesStartRepeat[property3] = _valuesEnd[property3].slice().reverse();
          } else {
            _valuesStartRepeat[property3] = _valuesStart[property3] || 0;
          }
        }
      }
    };
    Tween2.prototype.stop = function() {
      if (!this._isChainStopped) {
        this._isChainStopped = true;
        this.stopChainedTweens();
      }
      if (!this._isPlaying) {
        return this;
      }
      this._isPlaying = false;
      this._isPaused = false;
      if (this._onStopCallback) {
        this._onStopCallback(this._object);
      }
      return this;
    };
    Tween2.prototype.end = function() {
      this._goToEnd = true;
      this.update(this._startTime + this._duration);
      return this;
    };
    Tween2.prototype.pause = function(time3) {
      if (time3 === void 0) {
        time3 = now3();
      }
      if (this._isPaused || !this._isPlaying) {
        return this;
      }
      this._isPaused = true;
      this._pauseStart = time3;
      return this;
    };
    Tween2.prototype.resume = function(time3) {
      if (time3 === void 0) {
        time3 = now3();
      }
      if (!this._isPaused || !this._isPlaying) {
        return this;
      }
      this._isPaused = false;
      this._startTime += time3 - this._pauseStart;
      this._pauseStart = 0;
      return this;
    };
    Tween2.prototype.stopChainedTweens = function() {
      for (var i2 = 0, numChainedTweens = this._chainedTweens.length; i2 < numChainedTweens; i2++) {
        this._chainedTweens[i2].stop();
      }
      return this;
    };
    Tween2.prototype.group = function(group2) {
      if (!group2) {
        console.warn("tween.group() without args has been removed, use group.add(tween) instead.");
        return this;
      }
      group2.add(this);
      return this;
    };
    Tween2.prototype.remove = function() {
      var _a2;
      (_a2 = this._group) === null || _a2 === void 0 ? void 0 : _a2.remove(this);
      return this;
    };
    Tween2.prototype.delay = function(amount) {
      if (amount === void 0) {
        amount = 0;
      }
      this._delayTime = amount;
      return this;
    };
    Tween2.prototype.repeat = function(times2) {
      if (times2 === void 0) {
        times2 = 0;
      }
      this._initialRepeat = times2;
      this._repeat = times2;
      return this;
    };
    Tween2.prototype.repeatDelay = function(amount) {
      this._repeatDelayTime = amount;
      return this;
    };
    Tween2.prototype.yoyo = function(yoyo) {
      if (yoyo === void 0) {
        yoyo = false;
      }
      this._yoyo = yoyo;
      return this;
    };
    Tween2.prototype.easing = function(easingFunction) {
      if (easingFunction === void 0) {
        easingFunction = Easing.Linear.None;
      }
      this._easingFunction = easingFunction;
      return this;
    };
    Tween2.prototype.interpolation = function(interpolationFunction) {
      if (interpolationFunction === void 0) {
        interpolationFunction = Interpolation.Linear;
      }
      this._interpolationFunction = interpolationFunction;
      return this;
    };
    Tween2.prototype.chain = function() {
      var tweens = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        tweens[_i] = arguments[_i];
      }
      this._chainedTweens = tweens;
      return this;
    };
    Tween2.prototype.onStart = function(callback) {
      this._onStartCallback = callback;
      return this;
    };
    Tween2.prototype.onEveryStart = function(callback) {
      this._onEveryStartCallback = callback;
      return this;
    };
    Tween2.prototype.onUpdate = function(callback) {
      this._onUpdateCallback = callback;
      return this;
    };
    Tween2.prototype.onRepeat = function(callback) {
      this._onRepeatCallback = callback;
      return this;
    };
    Tween2.prototype.onComplete = function(callback) {
      this._onCompleteCallback = callback;
      return this;
    };
    Tween2.prototype.onStop = function(callback) {
      this._onStopCallback = callback;
      return this;
    };
    Tween2.prototype.update = function(time3, autoStart) {
      var _this = this;
      var _a2;
      if (time3 === void 0) {
        time3 = now3();
      }
      if (autoStart === void 0) {
        autoStart = Tween2.autoStartOnUpdate;
      }
      if (this._isPaused)
        return true;
      var property3;
      if (!this._goToEnd && !this._isPlaying) {
        if (autoStart)
          this.start(time3, true);
        else
          return false;
      }
      this._goToEnd = false;
      if (time3 < this._startTime) {
        return true;
      }
      if (this._onStartCallbackFired === false) {
        if (this._onStartCallback) {
          this._onStartCallback(this._object);
        }
        this._onStartCallbackFired = true;
      }
      if (this._onEveryStartCallbackFired === false) {
        if (this._onEveryStartCallback) {
          this._onEveryStartCallback(this._object);
        }
        this._onEveryStartCallbackFired = true;
      }
      var elapsedTime = time3 - this._startTime;
      var durationAndDelay = this._duration + ((_a2 = this._repeatDelayTime) !== null && _a2 !== void 0 ? _a2 : this._delayTime);
      var totalTime = this._duration + this._repeat * durationAndDelay;
      var calculateElapsedPortion = function() {
        if (_this._duration === 0)
          return 1;
        if (elapsedTime > totalTime) {
          return 1;
        }
        var timesRepeated = Math.trunc(elapsedTime / durationAndDelay);
        var timeIntoCurrentRepeat = elapsedTime - timesRepeated * durationAndDelay;
        var portion = Math.min(timeIntoCurrentRepeat / _this._duration, 1);
        if (portion === 0 && elapsedTime === _this._duration) {
          return 1;
        }
        return portion;
      };
      var elapsed = calculateElapsedPortion();
      var value = this._easingFunction(elapsed);
      this._updateProperties(this._object, this._valuesStart, this._valuesEnd, value);
      if (this._onUpdateCallback) {
        this._onUpdateCallback(this._object, elapsed);
      }
      if (this._duration === 0 || elapsedTime >= this._duration) {
        if (this._repeat > 0) {
          var completeCount = Math.min(Math.trunc((elapsedTime - this._duration) / durationAndDelay) + 1, this._repeat);
          if (isFinite(this._repeat)) {
            this._repeat -= completeCount;
          }
          for (property3 in this._valuesStartRepeat) {
            if (!this._yoyo && typeof this._valuesEnd[property3] === "string") {
              this._valuesStartRepeat[property3] = // eslint-disable-next-line
              // @ts-ignore FIXME?
              this._valuesStartRepeat[property3] + parseFloat(this._valuesEnd[property3]);
            }
            if (this._yoyo) {
              this._swapEndStartRepeatValues(property3);
            }
            this._valuesStart[property3] = this._valuesStartRepeat[property3];
          }
          if (this._yoyo) {
            this._reversed = !this._reversed;
          }
          this._startTime += durationAndDelay * completeCount;
          if (this._onRepeatCallback) {
            this._onRepeatCallback(this._object);
          }
          this._onEveryStartCallbackFired = false;
          return true;
        } else {
          if (this._onCompleteCallback) {
            this._onCompleteCallback(this._object);
          }
          for (var i2 = 0, numChainedTweens = this._chainedTweens.length; i2 < numChainedTweens; i2++) {
            this._chainedTweens[i2].start(this._startTime + this._duration, false);
          }
          this._isPlaying = false;
          return false;
        }
      }
      return true;
    };
    Tween2.prototype._updateProperties = function(_object, _valuesStart, _valuesEnd, value) {
      for (var property3 in _valuesEnd) {
        if (_valuesStart[property3] === void 0) {
          continue;
        }
        var start2 = _valuesStart[property3] || 0;
        var end = _valuesEnd[property3];
        var startIsArray = Array.isArray(_object[property3]);
        var endIsArray = Array.isArray(end);
        var isInterpolationList = !startIsArray && endIsArray;
        if (isInterpolationList) {
          _object[property3] = this._interpolationFunction(end, value);
        } else if (typeof end === "object" && end) {
          this._updateProperties(_object[property3], start2, end, value);
        } else {
          end = this._handleRelativeValue(start2, end);
          if (typeof end === "number") {
            _object[property3] = start2 + (end - start2) * value;
          }
        }
      }
    };
    Tween2.prototype._handleRelativeValue = function(start2, end) {
      if (typeof end !== "string") {
        return end;
      }
      if (end.charAt(0) === "+" || end.charAt(0) === "-") {
        return start2 + parseFloat(end);
      }
      return parseFloat(end);
    };
    Tween2.prototype._swapEndStartRepeatValues = function(property3) {
      var tmp2 = this._valuesStartRepeat[property3];
      var endValue = this._valuesEnd[property3];
      if (typeof endValue === "string") {
        this._valuesStartRepeat[property3] = this._valuesStartRepeat[property3] + parseFloat(endValue);
      } else {
        this._valuesStartRepeat[property3] = this._valuesEnd[property3];
      }
      this._valuesEnd[property3] = tmp2;
    };
    Tween2.autoStartOnUpdate = false;
    return Tween2;
  })()
);
var nextId = Sequence.nextId;
var TWEEN = mainGroup;
var getAll = TWEEN.getAll.bind(TWEEN);
var removeAll4 = TWEEN.removeAll.bind(TWEEN);
var add5 = TWEEN.add.bind(TWEEN);
var remove = TWEEN.remove.bind(TWEEN);
var update4 = TWEEN.update.bind(TWEEN);

// node_modules/d3-selection/src/namespaces.js
var xhtml = "http://www.w3.org/1999/xhtml";
var namespaces_default = {
  svg: "http://www.w3.org/2000/svg",
  xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

// node_modules/d3-selection/src/namespace.js
function namespace_default(name) {
  var prefix = name += "", i2 = prefix.indexOf(":");
  if (i2 >= 0 && (prefix = name.slice(0, i2)) !== "xmlns") name = name.slice(i2 + 1);
  return namespaces_default.hasOwnProperty(prefix) ? { space: namespaces_default[prefix], local: name } : name;
}

// node_modules/d3-selection/src/creator.js
function creatorInherit(name) {
  return function() {
    var document2 = this.ownerDocument, uri = this.namespaceURI;
    return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name) : document2.createElementNS(uri, name);
  };
}
function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
function creator_default(name) {
  var fullname = namespace_default(name);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}

// node_modules/d3-selection/src/selector.js
function none() {
}
function selector_default(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}

// node_modules/d3-selection/src/selection/select.js
function select_default(select2) {
  if (typeof select2 !== "function") select2 = selector_default(select2);
  for (var groups2 = this._groups, m3 = groups2.length, subgroups = new Array(m3), j2 = 0; j2 < m3; ++j2) {
    for (var group2 = groups2[j2], n2 = group2.length, subgroup = subgroups[j2] = new Array(n2), node, subnode, i2 = 0; i2 < n2; ++i2) {
      if ((node = group2[i2]) && (subnode = select2.call(node, node.__data__, i2, group2))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i2] = subnode;
      }
    }
  }
  return new Selection(subgroups, this._parents);
}

// node_modules/d3-selection/src/array.js
function array3(x3) {
  return x3 == null ? [] : Array.isArray(x3) ? x3 : Array.from(x3);
}

// node_modules/d3-selection/src/selectorAll.js
function empty() {
  return [];
}
function selectorAll_default(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
}

// node_modules/d3-selection/src/selection/selectAll.js
function arrayAll(select2) {
  return function() {
    return array3(select2.apply(this, arguments));
  };
}
function selectAll_default(select2) {
  if (typeof select2 === "function") select2 = arrayAll(select2);
  else select2 = selectorAll_default(select2);
  for (var groups2 = this._groups, m3 = groups2.length, subgroups = [], parents = [], j2 = 0; j2 < m3; ++j2) {
    for (var group2 = groups2[j2], n2 = group2.length, node, i2 = 0; i2 < n2; ++i2) {
      if (node = group2[i2]) {
        subgroups.push(select2.call(node, node.__data__, i2, group2));
        parents.push(node);
      }
    }
  }
  return new Selection(subgroups, parents);
}

// node_modules/d3-selection/src/matcher.js
function matcher_default(selector) {
  return function() {
    return this.matches(selector);
  };
}
function childMatcher(selector) {
  return function(node) {
    return node.matches(selector);
  };
}

// node_modules/d3-selection/src/selection/selectChild.js
var find2 = Array.prototype.find;
function childFind(match) {
  return function() {
    return find2.call(this.children, match);
  };
}
function childFirst() {
  return this.firstElementChild;
}
function selectChild_default(match) {
  return this.select(match == null ? childFirst : childFind(typeof match === "function" ? match : childMatcher(match)));
}

// node_modules/d3-selection/src/selection/selectChildren.js
var filter2 = Array.prototype.filter;
function children() {
  return Array.from(this.children);
}
function childrenFilter(match) {
  return function() {
    return filter2.call(this.children, match);
  };
}
function selectChildren_default(match) {
  return this.selectAll(match == null ? children : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
}

// node_modules/d3-selection/src/selection/filter.js
function filter_default(match) {
  if (typeof match !== "function") match = matcher_default(match);
  for (var groups2 = this._groups, m3 = groups2.length, subgroups = new Array(m3), j2 = 0; j2 < m3; ++j2) {
    for (var group2 = groups2[j2], n2 = group2.length, subgroup = subgroups[j2] = [], node, i2 = 0; i2 < n2; ++i2) {
      if ((node = group2[i2]) && match.call(node, node.__data__, i2, group2)) {
        subgroup.push(node);
      }
    }
  }
  return new Selection(subgroups, this._parents);
}

// node_modules/d3-selection/src/selection/sparse.js
function sparse_default(update9) {
  return new Array(update9.length);
}

// node_modules/d3-selection/src/selection/enter.js
function enter_default() {
  return new Selection(this._enter || this._groups.map(sparse_default), this._parents);
}
function EnterNode(parent2, datum2) {
  this.ownerDocument = parent2.ownerDocument;
  this.namespaceURI = parent2.namespaceURI;
  this._next = null;
  this._parent = parent2;
  this.__data__ = datum2;
}
EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) {
    return this._parent.insertBefore(child, this._next);
  },
  insertBefore: function(child, next) {
    return this._parent.insertBefore(child, next);
  },
  querySelector: function(selector) {
    return this._parent.querySelector(selector);
  },
  querySelectorAll: function(selector) {
    return this._parent.querySelectorAll(selector);
  }
};

// node_modules/d3-selection/src/constant.js
function constant_default3(x3) {
  return function() {
    return x3;
  };
}

// node_modules/d3-selection/src/selection/data.js
function bindIndex(parent2, group2, enter, update9, exit, data) {
  var i2 = 0, node, groupLength = group2.length, dataLength = data.length;
  for (; i2 < dataLength; ++i2) {
    if (node = group2[i2]) {
      node.__data__ = data[i2];
      update9[i2] = node;
    } else {
      enter[i2] = new EnterNode(parent2, data[i2]);
    }
  }
  for (; i2 < groupLength; ++i2) {
    if (node = group2[i2]) {
      exit[i2] = node;
    }
  }
}
function bindKey(parent2, group2, enter, update9, exit, data, key) {
  var i2, node, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group2.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
  for (i2 = 0; i2 < groupLength; ++i2) {
    if (node = group2[i2]) {
      keyValues[i2] = keyValue = key.call(node, node.__data__, i2, group2) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i2] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }
  for (i2 = 0; i2 < dataLength; ++i2) {
    keyValue = key.call(parent2, data[i2], i2, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update9[i2] = node;
      node.__data__ = data[i2];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i2] = new EnterNode(parent2, data[i2]);
    }
  }
  for (i2 = 0; i2 < groupLength; ++i2) {
    if ((node = group2[i2]) && nodeByKeyValue.get(keyValues[i2]) === node) {
      exit[i2] = node;
    }
  }
}
function datum(node) {
  return node.__data__;
}
function data_default4(value, key) {
  if (!arguments.length) return Array.from(this, datum);
  var bind2 = key ? bindKey : bindIndex, parents = this._parents, groups2 = this._groups;
  if (typeof value !== "function") value = constant_default3(value);
  for (var m3 = groups2.length, update9 = new Array(m3), enter = new Array(m3), exit = new Array(m3), j2 = 0; j2 < m3; ++j2) {
    var parent2 = parents[j2], group2 = groups2[j2], groupLength = group2.length, data = arraylike(value.call(parent2, parent2 && parent2.__data__, j2, parents)), dataLength = data.length, enterGroup = enter[j2] = new Array(dataLength), updateGroup = update9[j2] = new Array(dataLength), exitGroup = exit[j2] = new Array(groupLength);
    bind2(parent2, group2, enterGroup, updateGroup, exitGroup, data, key);
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength) ;
        previous._next = next || null;
      }
    }
  }
  update9 = new Selection(update9, parents);
  update9._enter = enter;
  update9._exit = exit;
  return update9;
}
function arraylike(data) {
  return typeof data === "object" && "length" in data ? data : Array.from(data);
}

// node_modules/d3-selection/src/selection/exit.js
function exit_default() {
  return new Selection(this._exit || this._groups.map(sparse_default), this._parents);
}

// node_modules/d3-selection/src/selection/join.js
function join_default(onenter, onupdate, onexit) {
  var enter = this.enter(), update9 = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter) enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update9 = onupdate(update9);
    if (update9) update9 = update9.selection();
  }
  if (onexit == null) exit.remove();
  else onexit(exit);
  return enter && update9 ? enter.merge(update9).order() : update9;
}

// node_modules/d3-selection/src/selection/merge.js
function merge_default(context2) {
  var selection2 = context2.selection ? context2.selection() : context2;
  for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m3 = Math.min(m0, m1), merges = new Array(m0), j2 = 0; j2 < m3; ++j2) {
    for (var group0 = groups0[j2], group1 = groups1[j2], n2 = group0.length, merge3 = merges[j2] = new Array(n2), node, i2 = 0; i2 < n2; ++i2) {
      if (node = group0[i2] || group1[i2]) {
        merge3[i2] = node;
      }
    }
  }
  for (; j2 < m0; ++j2) {
    merges[j2] = groups0[j2];
  }
  return new Selection(merges, this._parents);
}

// node_modules/d3-selection/src/selection/order.js
function order_default() {
  for (var groups2 = this._groups, j2 = -1, m3 = groups2.length; ++j2 < m3; ) {
    for (var group2 = groups2[j2], i2 = group2.length - 1, next = group2[i2], node; --i2 >= 0; ) {
      if (node = group2[i2]) {
        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }
  return this;
}

// node_modules/d3-selection/src/selection/sort.js
function sort_default(compare) {
  if (!compare) compare = ascending2;
  function compareNode(a3, b) {
    return a3 && b ? compare(a3.__data__, b.__data__) : !a3 - !b;
  }
  for (var groups2 = this._groups, m3 = groups2.length, sortgroups = new Array(m3), j2 = 0; j2 < m3; ++j2) {
    for (var group2 = groups2[j2], n2 = group2.length, sortgroup = sortgroups[j2] = new Array(n2), node, i2 = 0; i2 < n2; ++i2) {
      if (node = group2[i2]) {
        sortgroup[i2] = node;
      }
    }
    sortgroup.sort(compareNode);
  }
  return new Selection(sortgroups, this._parents).order();
}
function ascending2(a3, b) {
  return a3 < b ? -1 : a3 > b ? 1 : a3 >= b ? 0 : NaN;
}

// node_modules/d3-selection/src/selection/call.js
function call_default() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}

// node_modules/d3-selection/src/selection/nodes.js
function nodes_default() {
  return Array.from(this);
}

// node_modules/d3-selection/src/selection/node.js
function node_default() {
  for (var groups2 = this._groups, j2 = 0, m3 = groups2.length; j2 < m3; ++j2) {
    for (var group2 = groups2[j2], i2 = 0, n2 = group2.length; i2 < n2; ++i2) {
      var node = group2[i2];
      if (node) return node;
    }
  }
  return null;
}

// node_modules/d3-selection/src/selection/size.js
function size_default4() {
  let size2 = 0;
  for (const node of this) ++size2;
  return size2;
}

// node_modules/d3-selection/src/selection/empty.js
function empty_default() {
  return !this.node();
}

// node_modules/d3-selection/src/selection/each.js
function each_default(callback) {
  for (var groups2 = this._groups, j2 = 0, m3 = groups2.length; j2 < m3; ++j2) {
    for (var group2 = groups2[j2], i2 = 0, n2 = group2.length, node; i2 < n2; ++i2) {
      if (node = group2[i2]) callback.call(node, node.__data__, i2, group2);
    }
  }
  return this;
}

// node_modules/d3-selection/src/selection/attr.js
function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}
function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}
function attrFunction(name, value) {
  return function() {
    var v2 = value.apply(this, arguments);
    if (v2 == null) this.removeAttribute(name);
    else this.setAttribute(name, v2);
  };
}
function attrFunctionNS(fullname, value) {
  return function() {
    var v2 = value.apply(this, arguments);
    if (v2 == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v2);
  };
}
function attr_default(name, value) {
  var fullname = namespace_default(name);
  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
  }
  return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
}

// node_modules/d3-selection/src/window.js
function window_default(node) {
  return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
}

// node_modules/d3-selection/src/selection/style.js
function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}
function styleFunction(name, value, priority) {
  return function() {
    var v2 = value.apply(this, arguments);
    if (v2 == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v2, priority);
  };
}
function style_default(name, value, priority) {
  return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
}
function styleValue(node, name) {
  return node.style.getPropertyValue(name) || window_default(node).getComputedStyle(node, null).getPropertyValue(name);
}

// node_modules/d3-selection/src/selection/property.js
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}
function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}
function propertyFunction(name, value) {
  return function() {
    var v2 = value.apply(this, arguments);
    if (v2 == null) delete this[name];
    else this[name] = v2;
  };
}
function property_default(name, value) {
  return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
}

// node_modules/d3-selection/src/selection/classed.js
function classArray(string2) {
  return string2.trim().split(/^|\s+/);
}
function classList(node) {
  return node.classList || new ClassList(node);
}
function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}
ClassList.prototype = {
  add: function(name) {
    var i2 = this._names.indexOf(name);
    if (i2 < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i2 = this._names.indexOf(name);
    if (i2 >= 0) {
      this._names.splice(i2, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};
function classedAdd(node, names2) {
  var list = classList(node), i2 = -1, n2 = names2.length;
  while (++i2 < n2) list.add(names2[i2]);
}
function classedRemove(node, names2) {
  var list = classList(node), i2 = -1, n2 = names2.length;
  while (++i2 < n2) list.remove(names2[i2]);
}
function classedTrue(names2) {
  return function() {
    classedAdd(this, names2);
  };
}
function classedFalse(names2) {
  return function() {
    classedRemove(this, names2);
  };
}
function classedFunction(names2, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names2);
  };
}
function classed_default(name, value) {
  var names2 = classArray(name + "");
  if (arguments.length < 2) {
    var list = classList(this.node()), i2 = -1, n2 = names2.length;
    while (++i2 < n2) if (!list.contains(names2[i2])) return false;
    return true;
  }
  return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names2, value));
}

// node_modules/d3-selection/src/selection/text.js
function textRemove() {
  this.textContent = "";
}
function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction(value) {
  return function() {
    var v2 = value.apply(this, arguments);
    this.textContent = v2 == null ? "" : v2;
  };
}
function text_default(value) {
  return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
}

// node_modules/d3-selection/src/selection/html.js
function htmlRemove() {
  this.innerHTML = "";
}
function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}
function htmlFunction(value) {
  return function() {
    var v2 = value.apply(this, arguments);
    this.innerHTML = v2 == null ? "" : v2;
  };
}
function html_default(value) {
  return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
}

// node_modules/d3-selection/src/selection/raise.js
function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}
function raise_default() {
  return this.each(raise);
}

// node_modules/d3-selection/src/selection/lower.js
function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function lower_default() {
  return this.each(lower);
}

// node_modules/d3-selection/src/selection/append.js
function append_default(name) {
  var create3 = typeof name === "function" ? name : creator_default(name);
  return this.select(function() {
    return this.appendChild(create3.apply(this, arguments));
  });
}

// node_modules/d3-selection/src/selection/insert.js
function constantNull() {
  return null;
}
function insert_default(name, before2) {
  var create3 = typeof name === "function" ? name : creator_default(name), select2 = before2 == null ? constantNull : typeof before2 === "function" ? before2 : selector_default(before2);
  return this.select(function() {
    return this.insertBefore(create3.apply(this, arguments), select2.apply(this, arguments) || null);
  });
}

// node_modules/d3-selection/src/selection/remove.js
function remove2() {
  var parent2 = this.parentNode;
  if (parent2) parent2.removeChild(this);
}
function remove_default4() {
  return this.each(remove2);
}

// node_modules/d3-selection/src/selection/clone.js
function selection_cloneShallow() {
  var clone3 = this.cloneNode(false), parent2 = this.parentNode;
  return parent2 ? parent2.insertBefore(clone3, this.nextSibling) : clone3;
}
function selection_cloneDeep() {
  var clone3 = this.cloneNode(true), parent2 = this.parentNode;
  return parent2 ? parent2.insertBefore(clone3, this.nextSibling) : clone3;
}
function clone_default(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}

// node_modules/d3-selection/src/selection/datum.js
function datum_default(value) {
  return arguments.length ? this.property("__data__", value) : this.node().__data__;
}

// node_modules/d3-selection/src/selection/on.js
function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}
function parseTypenames2(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t5) {
    var name = "", i2 = t5.indexOf(".");
    if (i2 >= 0) name = t5.slice(i2 + 1), t5 = t5.slice(0, i2);
    return { type: t5, name };
  });
}
function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j2 = 0, i2 = -1, m3 = on.length, o2; j2 < m3; ++j2) {
      if (o2 = on[j2], (!typename.type || o2.type === typename.type) && o2.name === typename.name) {
        this.removeEventListener(o2.type, o2.listener, o2.options);
      } else {
        on[++i2] = o2;
      }
    }
    if (++i2) on.length = i2;
    else delete this.__on;
  };
}
function onAdd(typename, value, options) {
  return function() {
    var on = this.__on, o2, listener = contextListener(value);
    if (on) for (var j2 = 0, m3 = on.length; j2 < m3; ++j2) {
      if ((o2 = on[j2]).type === typename.type && o2.name === typename.name) {
        this.removeEventListener(o2.type, o2.listener, o2.options);
        this.addEventListener(o2.type, o2.listener = listener, o2.options = options);
        o2.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, options);
    o2 = { type: typename.type, name: typename.name, value, listener, options };
    if (!on) this.__on = [o2];
    else on.push(o2);
  };
}
function on_default(typename, value, options) {
  var typenames = parseTypenames2(typename + ""), i2, n2 = typenames.length, t5;
  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j2 = 0, m3 = on.length, o2; j2 < m3; ++j2) {
      for (i2 = 0, o2 = on[j2]; i2 < n2; ++i2) {
        if ((t5 = typenames[i2]).type === o2.type && t5.name === o2.name) {
          return o2.value;
        }
      }
    }
    return;
  }
  on = value ? onAdd : onRemove;
  for (i2 = 0; i2 < n2; ++i2) this.each(on(typenames[i2], value, options));
  return this;
}

// node_modules/d3-selection/src/selection/dispatch.js
function dispatchEvent(node, type, params) {
  var window2 = window_default(node), event = window2.CustomEvent;
  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window2.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }
  node.dispatchEvent(event);
}
function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}
function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}
function dispatch_default2(type, params) {
  return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type, params));
}

// node_modules/d3-selection/src/selection/iterator.js
function* iterator_default() {
  for (var groups2 = this._groups, j2 = 0, m3 = groups2.length; j2 < m3; ++j2) {
    for (var group2 = groups2[j2], i2 = 0, n2 = group2.length, node; i2 < n2; ++i2) {
      if (node = group2[i2]) yield node;
    }
  }
}

// node_modules/d3-selection/src/selection/index.js
var root2 = [null];
function Selection(groups2, parents) {
  this._groups = groups2;
  this._parents = parents;
}
function selection() {
  return new Selection([[document.documentElement]], root2);
}
function selection_selection() {
  return this;
}
Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: select_default,
  selectAll: selectAll_default,
  selectChild: selectChild_default,
  selectChildren: selectChildren_default,
  filter: filter_default,
  data: data_default4,
  enter: enter_default,
  exit: exit_default,
  join: join_default,
  merge: merge_default,
  selection: selection_selection,
  order: order_default,
  sort: sort_default,
  call: call_default,
  nodes: nodes_default,
  node: node_default,
  size: size_default4,
  empty: empty_default,
  each: each_default,
  attr: attr_default,
  style: style_default,
  property: property_default,
  classed: classed_default,
  text: text_default,
  html: html_default,
  raise: raise_default,
  lower: lower_default,
  append: append_default,
  insert: insert_default,
  remove: remove_default4,
  clone: clone_default,
  datum: datum_default,
  on: on_default,
  dispatch: dispatch_default2,
  [Symbol.iterator]: iterator_default
};
var selection_default = selection;

// node_modules/d3-selection/src/select.js
function select_default2(selector) {
  return typeof selector === "string" ? new Selection([[document.querySelector(selector)]], [document.documentElement]) : new Selection([[selector]], root2);
}

// node_modules/d3-selection/src/local.js
var nextId2 = 0;
function local() {
  return new Local();
}
function Local() {
  this._ = "@" + (++nextId2).toString(36);
}
Local.prototype = local.prototype = {
  constructor: Local,
  get: function(node) {
    var id2 = this._;
    while (!(id2 in node)) if (!(node = node.parentNode)) return;
    return node[id2];
  },
  set: function(node, value) {
    return node[this._] = value;
  },
  remove: function(node) {
    return this._ in node && delete node[this._];
  },
  toString: function() {
    return this._;
  }
};

// node_modules/d3-selection/src/sourceEvent.js
function sourceEvent_default(event) {
  let sourceEvent;
  while (sourceEvent = event.sourceEvent) event = sourceEvent;
  return event;
}

// node_modules/d3-selection/src/pointer.js
function pointer_default(event, node) {
  event = sourceEvent_default(event);
  if (node === void 0) node = event.currentTarget;
  if (node) {
    var svg = node.ownerSVGElement || node;
    if (svg.createSVGPoint) {
      var point2 = svg.createSVGPoint();
      point2.x = event.clientX, point2.y = event.clientY;
      point2 = point2.matrixTransform(node.getScreenCTM().inverse());
      return [point2.x, point2.y];
    }
    if (node.getBoundingClientRect) {
      var rect = node.getBoundingClientRect();
      return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
    }
  }
  return [event.pageX, event.pageY];
}

// node_modules/preact/dist/preact.module.js
var n;
var l;
var u;
var t4;
var i;
var o;
var r;
var e;
var f2;
var c4;
var s;
var a2;
var h;
var p2 = {};
var v = [];
var y2 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
var d2 = Array.isArray;
function w(n2, l2) {
  for (var u2 in l2) n2[u2] = l2[u2];
  return n2;
}
function g2(n2) {
  n2 && n2.parentNode && n2.parentNode.removeChild(n2);
}
function _(l2, u2, t5) {
  var i2, o2, r2, e3 = {};
  for (r2 in u2) "key" == r2 ? i2 = u2[r2] : "ref" == r2 ? o2 = u2[r2] : e3[r2] = u2[r2];
  if (arguments.length > 2 && (e3.children = arguments.length > 3 ? n.call(arguments, 2) : t5), "function" == typeof l2 && null != l2.defaultProps) for (r2 in l2.defaultProps) void 0 === e3[r2] && (e3[r2] = l2.defaultProps[r2]);
  return m2(l2, e3, i2, o2, null);
}
function m2(n2, t5, i2, o2, r2) {
  var e3 = { type: n2, props: t5, key: i2, ref: o2, __k: null, __: null, __b: 0, __e: null, __c: null, constructor: void 0, __v: null == r2 ? ++u : r2, __i: -1, __u: 0 };
  return null == r2 && null != l.vnode && l.vnode(e3), e3;
}
function k(n2) {
  return n2.children;
}
function x2(n2, l2) {
  this.props = n2, this.context = l2;
}
function S(n2, l2) {
  if (null == l2) return n2.__ ? S(n2.__, n2.__i + 1) : null;
  for (var u2; l2 < n2.__k.length; l2++) if (null != (u2 = n2.__k[l2]) && null != u2.__e) return u2.__e;
  return "function" == typeof n2.type ? S(n2) : null;
}
function C2(n2) {
  var l2, u2;
  if (null != (n2 = n2.__) && null != n2.__c) {
    for (n2.__e = n2.__c.base = null, l2 = 0; l2 < n2.__k.length; l2++) if (null != (u2 = n2.__k[l2]) && null != u2.__e) {
      n2.__e = n2.__c.base = u2.__e;
      break;
    }
    return C2(n2);
  }
}
function M(n2) {
  (!n2.__d && (n2.__d = true) && i.push(n2) && !$.__r++ || o != l.debounceRendering) && ((o = l.debounceRendering) || r)($);
}
function $() {
  for (var n2, u2, t5, o2, r2, f3, c5, s2 = 1; i.length; ) i.length > s2 && i.sort(e), n2 = i.shift(), s2 = i.length, n2.__d && (t5 = void 0, o2 = void 0, r2 = (o2 = (u2 = n2).__v).__e, f3 = [], c5 = [], u2.__P && ((t5 = w({}, o2)).__v = o2.__v + 1, l.vnode && l.vnode(t5), O(u2.__P, t5, o2, u2.__n, u2.__P.namespaceURI, 32 & o2.__u ? [r2] : null, f3, null == r2 ? S(o2) : r2, !!(32 & o2.__u), c5), t5.__v = o2.__v, t5.__.__k[t5.__i] = t5, N2(f3, t5, c5), o2.__e = o2.__ = null, t5.__e != r2 && C2(t5)));
  $.__r = 0;
}
function I(n2, l2, u2, t5, i2, o2, r2, e3, f3, c5, s2) {
  var a3, h2, y3, d3, w4, g3, _2, m3 = t5 && t5.__k || v, b = l2.length;
  for (f3 = P(u2, l2, m3, f3, b), a3 = 0; a3 < b; a3++) null != (y3 = u2.__k[a3]) && (h2 = -1 == y3.__i ? p2 : m3[y3.__i] || p2, y3.__i = a3, g3 = O(n2, y3, h2, i2, o2, r2, e3, f3, c5, s2), d3 = y3.__e, y3.ref && h2.ref != y3.ref && (h2.ref && B3(h2.ref, null, y3), s2.push(y3.ref, y3.__c || d3, y3)), null == w4 && null != d3 && (w4 = d3), (_2 = !!(4 & y3.__u)) || h2.__k === y3.__k ? f3 = A2(y3, f3, n2, _2) : "function" == typeof y3.type && void 0 !== g3 ? f3 = g3 : d3 && (f3 = d3.nextSibling), y3.__u &= -7);
  return u2.__e = w4, f3;
}
function P(n2, l2, u2, t5, i2) {
  var o2, r2, e3, f3, c5, s2 = u2.length, a3 = s2, h2 = 0;
  for (n2.__k = new Array(i2), o2 = 0; o2 < i2; o2++) null != (r2 = l2[o2]) && "boolean" != typeof r2 && "function" != typeof r2 ? ("string" == typeof r2 || "number" == typeof r2 || "bigint" == typeof r2 || r2.constructor == String ? r2 = n2.__k[o2] = m2(null, r2, null, null, null) : d2(r2) ? r2 = n2.__k[o2] = m2(k, { children: r2 }, null, null, null) : void 0 === r2.constructor && r2.__b > 0 ? r2 = n2.__k[o2] = m2(r2.type, r2.props, r2.key, r2.ref ? r2.ref : null, r2.__v) : n2.__k[o2] = r2, f3 = o2 + h2, r2.__ = n2, r2.__b = n2.__b + 1, e3 = null, -1 != (c5 = r2.__i = L(r2, u2, f3, a3)) && (a3--, (e3 = u2[c5]) && (e3.__u |= 2)), null == e3 || null == e3.__v ? (-1 == c5 && (i2 > s2 ? h2-- : i2 < s2 && h2++), "function" != typeof r2.type && (r2.__u |= 4)) : c5 != f3 && (c5 == f3 - 1 ? h2-- : c5 == f3 + 1 ? h2++ : (c5 > f3 ? h2-- : h2++, r2.__u |= 4))) : n2.__k[o2] = null;
  if (a3) for (o2 = 0; o2 < s2; o2++) null != (e3 = u2[o2]) && 0 == (2 & e3.__u) && (e3.__e == t5 && (t5 = S(e3)), D2(e3, e3));
  return t5;
}
function A2(n2, l2, u2, t5) {
  var i2, o2;
  if ("function" == typeof n2.type) {
    for (i2 = n2.__k, o2 = 0; i2 && o2 < i2.length; o2++) i2[o2] && (i2[o2].__ = n2, l2 = A2(i2[o2], l2, u2, t5));
    return l2;
  }
  n2.__e != l2 && (t5 && (l2 && n2.type && !l2.parentNode && (l2 = S(n2)), u2.insertBefore(n2.__e, l2 || null)), l2 = n2.__e);
  do {
    l2 = l2 && l2.nextSibling;
  } while (null != l2 && 8 == l2.nodeType);
  return l2;
}
function L(n2, l2, u2, t5) {
  var i2, o2, r2, e3 = n2.key, f3 = n2.type, c5 = l2[u2], s2 = null != c5 && 0 == (2 & c5.__u);
  if (null === c5 && null == e3 || s2 && e3 == c5.key && f3 == c5.type) return u2;
  if (t5 > (s2 ? 1 : 0)) {
    for (i2 = u2 - 1, o2 = u2 + 1; i2 >= 0 || o2 < l2.length; ) if (null != (c5 = l2[r2 = i2 >= 0 ? i2-- : o2++]) && 0 == (2 & c5.__u) && e3 == c5.key && f3 == c5.type) return r2;
  }
  return -1;
}
function T2(n2, l2, u2) {
  "-" == l2[0] ? n2.setProperty(l2, null == u2 ? "" : u2) : n2[l2] = null == u2 ? "" : "number" != typeof u2 || y2.test(l2) ? u2 : u2 + "px";
}
function j(n2, l2, u2, t5, i2) {
  var o2, r2;
  n: if ("style" == l2) if ("string" == typeof u2) n2.style.cssText = u2;
  else {
    if ("string" == typeof t5 && (n2.style.cssText = t5 = ""), t5) for (l2 in t5) u2 && l2 in u2 || T2(n2.style, l2, "");
    if (u2) for (l2 in u2) t5 && u2[l2] == t5[l2] || T2(n2.style, l2, u2[l2]);
  }
  else if ("o" == l2[0] && "n" == l2[1]) o2 = l2 != (l2 = l2.replace(f2, "$1")), r2 = l2.toLowerCase(), l2 = r2 in n2 || "onFocusOut" == l2 || "onFocusIn" == l2 ? r2.slice(2) : l2.slice(2), n2.l || (n2.l = {}), n2.l[l2 + o2] = u2, u2 ? t5 ? u2.u = t5.u : (u2.u = c4, n2.addEventListener(l2, o2 ? a2 : s, o2)) : n2.removeEventListener(l2, o2 ? a2 : s, o2);
  else {
    if ("http://www.w3.org/2000/svg" == i2) l2 = l2.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
    else if ("width" != l2 && "height" != l2 && "href" != l2 && "list" != l2 && "form" != l2 && "tabIndex" != l2 && "download" != l2 && "rowSpan" != l2 && "colSpan" != l2 && "role" != l2 && "popover" != l2 && l2 in n2) try {
      n2[l2] = null == u2 ? "" : u2;
      break n;
    } catch (n3) {
    }
    "function" == typeof u2 || (null == u2 || false === u2 && "-" != l2[4] ? n2.removeAttribute(l2) : n2.setAttribute(l2, "popover" == l2 && 1 == u2 ? "" : u2));
  }
}
function F(n2) {
  return function(u2) {
    if (this.l) {
      var t5 = this.l[u2.type + n2];
      if (null == u2.t) u2.t = c4++;
      else if (u2.t < t5.u) return;
      return t5(l.event ? l.event(u2) : u2);
    }
  };
}
function O(n2, u2, t5, i2, o2, r2, e3, f3, c5, s2) {
  var a3, h2, p3, v2, y3, _2, m3, b, S2, C3, M2, $2, P2, A3, H, L2, T3, j2 = u2.type;
  if (void 0 !== u2.constructor) return null;
  128 & t5.__u && (c5 = !!(32 & t5.__u), r2 = [f3 = u2.__e = t5.__e]), (a3 = l.__b) && a3(u2);
  n: if ("function" == typeof j2) try {
    if (b = u2.props, S2 = "prototype" in j2 && j2.prototype.render, C3 = (a3 = j2.contextType) && i2[a3.__c], M2 = a3 ? C3 ? C3.props.value : a3.__ : i2, t5.__c ? m3 = (h2 = u2.__c = t5.__c).__ = h2.__E : (S2 ? u2.__c = h2 = new j2(b, M2) : (u2.__c = h2 = new x2(b, M2), h2.constructor = j2, h2.render = E2), C3 && C3.sub(h2), h2.state || (h2.state = {}), h2.__n = i2, p3 = h2.__d = true, h2.__h = [], h2._sb = []), S2 && null == h2.__s && (h2.__s = h2.state), S2 && null != j2.getDerivedStateFromProps && (h2.__s == h2.state && (h2.__s = w({}, h2.__s)), w(h2.__s, j2.getDerivedStateFromProps(b, h2.__s))), v2 = h2.props, y3 = h2.state, h2.__v = u2, p3) S2 && null == j2.getDerivedStateFromProps && null != h2.componentWillMount && h2.componentWillMount(), S2 && null != h2.componentDidMount && h2.__h.push(h2.componentDidMount);
    else {
      if (S2 && null == j2.getDerivedStateFromProps && b !== v2 && null != h2.componentWillReceiveProps && h2.componentWillReceiveProps(b, M2), u2.__v == t5.__v || !h2.__e && null != h2.shouldComponentUpdate && false === h2.shouldComponentUpdate(b, h2.__s, M2)) {
        for (u2.__v != t5.__v && (h2.props = b, h2.state = h2.__s, h2.__d = false), u2.__e = t5.__e, u2.__k = t5.__k, u2.__k.some(function(n3) {
          n3 && (n3.__ = u2);
        }), $2 = 0; $2 < h2._sb.length; $2++) h2.__h.push(h2._sb[$2]);
        h2._sb = [], h2.__h.length && e3.push(h2);
        break n;
      }
      null != h2.componentWillUpdate && h2.componentWillUpdate(b, h2.__s, M2), S2 && null != h2.componentDidUpdate && h2.__h.push(function() {
        h2.componentDidUpdate(v2, y3, _2);
      });
    }
    if (h2.context = M2, h2.props = b, h2.__P = n2, h2.__e = false, P2 = l.__r, A3 = 0, S2) {
      for (h2.state = h2.__s, h2.__d = false, P2 && P2(u2), a3 = h2.render(h2.props, h2.state, h2.context), H = 0; H < h2._sb.length; H++) h2.__h.push(h2._sb[H]);
      h2._sb = [];
    } else do {
      h2.__d = false, P2 && P2(u2), a3 = h2.render(h2.props, h2.state, h2.context), h2.state = h2.__s;
    } while (h2.__d && ++A3 < 25);
    h2.state = h2.__s, null != h2.getChildContext && (i2 = w(w({}, i2), h2.getChildContext())), S2 && !p3 && null != h2.getSnapshotBeforeUpdate && (_2 = h2.getSnapshotBeforeUpdate(v2, y3)), L2 = a3, null != a3 && a3.type === k && null == a3.key && (L2 = V(a3.props.children)), f3 = I(n2, d2(L2) ? L2 : [L2], u2, t5, i2, o2, r2, e3, f3, c5, s2), h2.base = u2.__e, u2.__u &= -161, h2.__h.length && e3.push(h2), m3 && (h2.__E = h2.__ = null);
  } catch (n3) {
    if (u2.__v = null, c5 || null != r2) if (n3.then) {
      for (u2.__u |= c5 ? 160 : 128; f3 && 8 == f3.nodeType && f3.nextSibling; ) f3 = f3.nextSibling;
      r2[r2.indexOf(f3)] = null, u2.__e = f3;
    } else {
      for (T3 = r2.length; T3--; ) g2(r2[T3]);
      z2(u2);
    }
    else u2.__e = t5.__e, u2.__k = t5.__k, n3.then || z2(u2);
    l.__e(n3, u2, t5);
  }
  else null == r2 && u2.__v == t5.__v ? (u2.__k = t5.__k, u2.__e = t5.__e) : f3 = u2.__e = q(t5.__e, u2, t5, i2, o2, r2, e3, c5, s2);
  return (a3 = l.diffed) && a3(u2), 128 & u2.__u ? void 0 : f3;
}
function z2(n2) {
  n2 && n2.__c && (n2.__c.__e = true), n2 && n2.__k && n2.__k.forEach(z2);
}
function N2(n2, u2, t5) {
  for (var i2 = 0; i2 < t5.length; i2++) B3(t5[i2], t5[++i2], t5[++i2]);
  l.__c && l.__c(u2, n2), n2.some(function(u3) {
    try {
      n2 = u3.__h, u3.__h = [], n2.some(function(n3) {
        n3.call(u3);
      });
    } catch (n3) {
      l.__e(n3, u3.__v);
    }
  });
}
function V(n2) {
  return "object" != typeof n2 || null == n2 || n2.__b && n2.__b > 0 ? n2 : d2(n2) ? n2.map(V) : w({}, n2);
}
function q(u2, t5, i2, o2, r2, e3, f3, c5, s2) {
  var a3, h2, v2, y3, w4, _2, m3, b = i2.props || p2, k2 = t5.props, x3 = t5.type;
  if ("svg" == x3 ? r2 = "http://www.w3.org/2000/svg" : "math" == x3 ? r2 = "http://www.w3.org/1998/Math/MathML" : r2 || (r2 = "http://www.w3.org/1999/xhtml"), null != e3) {
    for (a3 = 0; a3 < e3.length; a3++) if ((w4 = e3[a3]) && "setAttribute" in w4 == !!x3 && (x3 ? w4.localName == x3 : 3 == w4.nodeType)) {
      u2 = w4, e3[a3] = null;
      break;
    }
  }
  if (null == u2) {
    if (null == x3) return document.createTextNode(k2);
    u2 = document.createElementNS(r2, x3, k2.is && k2), c5 && (l.__m && l.__m(t5, e3), c5 = false), e3 = null;
  }
  if (null == x3) b === k2 || c5 && u2.data == k2 || (u2.data = k2);
  else {
    if (e3 = e3 && n.call(u2.childNodes), !c5 && null != e3) for (b = {}, a3 = 0; a3 < u2.attributes.length; a3++) b[(w4 = u2.attributes[a3]).name] = w4.value;
    for (a3 in b) if (w4 = b[a3], "children" == a3) ;
    else if ("dangerouslySetInnerHTML" == a3) v2 = w4;
    else if (!(a3 in k2)) {
      if ("value" == a3 && "defaultValue" in k2 || "checked" == a3 && "defaultChecked" in k2) continue;
      j(u2, a3, null, w4, r2);
    }
    for (a3 in k2) w4 = k2[a3], "children" == a3 ? y3 = w4 : "dangerouslySetInnerHTML" == a3 ? h2 = w4 : "value" == a3 ? _2 = w4 : "checked" == a3 ? m3 = w4 : c5 && "function" != typeof w4 || b[a3] === w4 || j(u2, a3, w4, b[a3], r2);
    if (h2) c5 || v2 && (h2.__html == v2.__html || h2.__html == u2.innerHTML) || (u2.innerHTML = h2.__html), t5.__k = [];
    else if (v2 && (u2.innerHTML = ""), I("template" == t5.type ? u2.content : u2, d2(y3) ? y3 : [y3], t5, i2, o2, "foreignObject" == x3 ? "http://www.w3.org/1999/xhtml" : r2, e3, f3, e3 ? e3[0] : i2.__k && S(i2, 0), c5, s2), null != e3) for (a3 = e3.length; a3--; ) g2(e3[a3]);
    c5 || (a3 = "value", "progress" == x3 && null == _2 ? u2.removeAttribute("value") : null != _2 && (_2 !== u2[a3] || "progress" == x3 && !_2 || "option" == x3 && _2 != b[a3]) && j(u2, a3, _2, b[a3], r2), a3 = "checked", null != m3 && m3 != u2[a3] && j(u2, a3, m3, b[a3], r2));
  }
  return u2;
}
function B3(n2, u2, t5) {
  try {
    if ("function" == typeof n2) {
      var i2 = "function" == typeof n2.__u;
      i2 && n2.__u(), i2 && null == u2 || (n2.__u = n2(u2));
    } else n2.current = u2;
  } catch (n3) {
    l.__e(n3, t5);
  }
}
function D2(n2, u2, t5) {
  var i2, o2;
  if (l.unmount && l.unmount(n2), (i2 = n2.ref) && (i2.current && i2.current != n2.__e || B3(i2, null, u2)), null != (i2 = n2.__c)) {
    if (i2.componentWillUnmount) try {
      i2.componentWillUnmount();
    } catch (n3) {
      l.__e(n3, u2);
    }
    i2.base = i2.__P = null;
  }
  if (i2 = n2.__k) for (o2 = 0; o2 < i2.length; o2++) i2[o2] && D2(i2[o2], u2, t5 || "function" != typeof n2.type);
  t5 || g2(n2.__e), n2.__c = n2.__ = n2.__e = void 0;
}
function E2(n2, l2, u2) {
  return this.constructor(n2, u2);
}
function G(u2, t5, i2) {
  var o2, r2, e3, f3;
  t5 == document && (t5 = document.documentElement), l.__ && l.__(u2, t5), r2 = (o2 = "function" == typeof i2) ? null : i2 && i2.__k || t5.__k, e3 = [], f3 = [], O(t5, u2 = (!o2 && i2 || t5).__k = _(k, null, [u2]), r2 || p2, p2, t5.namespaceURI, !o2 && i2 ? [i2] : r2 ? null : t5.firstChild ? n.call(t5.childNodes) : null, e3, !o2 && i2 ? i2 : r2 ? r2.__e : t5.firstChild, o2, f3), N2(e3, u2, f3);
}
function K2(l2, u2, t5) {
  var i2, o2, r2, e3, f3 = w({}, l2.props);
  for (r2 in l2.type && l2.type.defaultProps && (e3 = l2.type.defaultProps), u2) "key" == r2 ? i2 = u2[r2] : "ref" == r2 ? o2 = u2[r2] : f3[r2] = void 0 === u2[r2] && null != e3 ? e3[r2] : u2[r2];
  return arguments.length > 2 && (f3.children = arguments.length > 3 ? n.call(arguments, 2) : t5), m2(l2.type, f3, i2 || l2.key, o2 || l2.ref, null);
}
n = v.slice, l = { __e: function(n2, l2, u2, t5) {
  for (var i2, o2, r2; l2 = l2.__; ) if ((i2 = l2.__c) && !i2.__) try {
    if ((o2 = i2.constructor) && null != o2.getDerivedStateFromError && (i2.setState(o2.getDerivedStateFromError(n2)), r2 = i2.__d), null != i2.componentDidCatch && (i2.componentDidCatch(n2, t5 || {}), r2 = i2.__d), r2) return i2.__E = i2;
  } catch (l3) {
    n2 = l3;
  }
  throw n2;
} }, u = 0, t4 = function(n2) {
  return null != n2 && void 0 === n2.constructor;
}, x2.prototype.setState = function(n2, l2) {
  var u2;
  u2 = null != this.__s && this.__s != this.state ? this.__s : this.__s = w({}, this.state), "function" == typeof n2 && (n2 = n2(w({}, u2), this.props)), n2 && w(u2, n2), null != n2 && this.__v && (l2 && this._sb.push(l2), M(this));
}, x2.prototype.forceUpdate = function(n2) {
  this.__v && (this.__e = true, n2 && this.__h.push(n2), M(this));
}, x2.prototype.render = k, i = [], r = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, e = function(n2, l2) {
  return n2.__v.__b - l2.__v.__b;
}, $.__r = 0, f2 = /(PointerCapture)$|Capture$/i, c4 = 0, s = F(false), a2 = F(true), h = 0;

// node_modules/float-tooltip/dist/float-tooltip.mjs
function _arrayLikeToArray8(r2, a3) {
  (null == a3 || a3 > r2.length) && (a3 = r2.length);
  for (var e3 = 0, n2 = Array(a3); e3 < a3; e3++) n2[e3] = r2[e3];
  return n2;
}
function _arrayWithHoles8(r2) {
  if (Array.isArray(r2)) return r2;
}
function _defineProperty5(e3, r2, t5) {
  return (r2 = _toPropertyKey6(r2)) in e3 ? Object.defineProperty(e3, r2, {
    value: t5,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e3[r2] = t5, e3;
}
function _iterableToArrayLimit8(r2, l2) {
  var t5 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t5) {
    var e3, n2, i2, u2, a3 = [], f3 = true, o2 = false;
    try {
      if (i2 = (t5 = t5.call(r2)).next, 0 === l2) ;
      else for (; !(f3 = (e3 = i2.call(t5)).done) && (a3.push(e3.value), a3.length !== l2); f3 = true) ;
    } catch (r3) {
      o2 = true, n2 = r3;
    } finally {
      try {
        if (!f3 && null != t5.return && (u2 = t5.return(), Object(u2) !== u2)) return;
      } finally {
        if (o2) throw n2;
      }
    }
    return a3;
  }
}
function _nonIterableRest8() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function ownKeys4(e3, r2) {
  var t5 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t5.push.apply(t5, o2);
  }
  return t5;
}
function _objectSpread24(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t5 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys4(Object(t5), true).forEach(function(r3) {
      _defineProperty5(e3, r3, t5[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t5)) : ownKeys4(Object(t5)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t5, r3));
    });
  }
  return e3;
}
function _slicedToArray8(r2, e3) {
  return _arrayWithHoles8(r2) || _iterableToArrayLimit8(r2, e3) || _unsupportedIterableToArray8(r2, e3) || _nonIterableRest8();
}
function _toPrimitive6(t5, r2) {
  if ("object" != typeof t5 || !t5) return t5;
  var e3 = t5[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t5, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t5);
}
function _toPropertyKey6(t5) {
  var i2 = _toPrimitive6(t5, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _typeof3(o2) {
  "@babel/helpers - typeof";
  return _typeof3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof3(o2);
}
function _unsupportedIterableToArray8(r2, a3) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray8(r2, a3);
    var t5 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t5 && r2.constructor && (t5 = r2.constructor.name), "Map" === t5 || "Set" === t5 ? Array.from(r2) : "Arguments" === t5 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t5) ? _arrayLikeToArray8(r2, a3) : void 0;
  }
}
var _reactElement2VNode = function reactElement2VNode(el) {
  if (!(_typeof3(el) === "object")) return el;
  var res = K2(el);
  if (res.props) {
    var _res$props;
    res.props = _objectSpread24({}, res.props);
    if (res !== null && res !== void 0 && (_res$props = res.props) !== null && _res$props !== void 0 && _res$props.children) {
      res.props.children = Array.isArray(res.props.children) ? res.props.children.map(_reactElement2VNode) : _reactElement2VNode(res.props.children);
    }
  }
  return res;
};
var isReactRenderable = function isReactRenderable2(o2) {
  return t4(K2(o2));
};
var render = function render2(jsx, domEl) {
  delete domEl.__k;
  G(_reactElement2VNode(jsx), domEl);
};
function styleInject2(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;
  if (typeof document === "undefined") {
    return;
  }
  var head2 = document.head || document.getElementsByTagName("head")[0];
  var style = document.createElement("style");
  style.type = "text/css";
  if (insertAt === "top") {
    if (head2.firstChild) {
      head2.insertBefore(style, head2.firstChild);
    } else {
      head2.appendChild(style);
    }
  } else {
    head2.appendChild(style);
  }
  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}
var css_248z2 = ".float-tooltip-kap {\n  position: absolute;\n  width: max-content; /* prevent shrinking near right edge */\n  max-width: max(50%, 150px);\n  padding: 3px 5px;\n  border-radius: 3px;\n  font: 12px sans-serif;\n  color: #eee;\n  background: rgba(0,0,0,0.6);\n  pointer-events: none;\n}\n";
styleInject2(css_248z2);
var index6 = index3({
  props: {
    content: {
      "default": false
    },
    offsetX: {
      triggerUpdate: false
    },
    // null or number
    offsetY: {
      triggerUpdate: false
    }
    // null or number
  },
  init: function init4(domNode, state) {
    var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, _ref$style = _ref.style, style = _ref$style === void 0 ? {} : _ref$style;
    var isD3Selection = !!domNode && _typeof3(domNode) === "object" && !!domNode.node && typeof domNode.node === "function";
    var el = select_default2(isD3Selection ? domNode.node() : domNode);
    el.style("position") === "static" && el.style("position", "relative");
    state.tooltipEl = el.append("div").attr("class", "float-tooltip-kap");
    Object.entries(style).forEach(function(_ref2) {
      var _ref3 = _slicedToArray8(_ref2, 2), k2 = _ref3[0], v2 = _ref3[1];
      return state.tooltipEl.style(k2, v2);
    });
    state.tooltipEl.style("left", "-10000px").style("display", "none");
    var evSuffix = "tooltip-".concat(Math.round(Math.random() * 1e12));
    state.mouseInside = false;
    el.on("mousemove.".concat(evSuffix), function(ev) {
      state.mouseInside = true;
      var mousePos = pointer_default(ev);
      var domNode2 = el.node();
      var canvasWidth = domNode2.offsetWidth;
      var canvasHeight = domNode2.offsetHeight;
      var translate = [state.offsetX === null || state.offsetX === void 0 ? "-".concat(mousePos[0] / canvasWidth * 100, "%") : typeof state.offsetX === "number" ? "calc(-50% + ".concat(state.offsetX, "px)") : state.offsetX, state.offsetY === null || state.offsetY === void 0 ? canvasHeight > 130 && canvasHeight - mousePos[1] < 100 ? "calc(-100% - 6px)" : "21px" : typeof state.offsetY === "number" ? state.offsetY < 0 ? "calc(-100% - ".concat(Math.abs(state.offsetY), "px)") : "".concat(state.offsetY, "px") : state.offsetY];
      state.tooltipEl.style("left", mousePos[0] + "px").style("top", mousePos[1] + "px").style("transform", "translate(".concat(translate.join(","), ")"));
      state.content && state.tooltipEl.style("display", "inline");
    });
    el.on("mouseover.".concat(evSuffix), function() {
      state.mouseInside = true;
      state.content && state.tooltipEl.style("display", "inline");
    });
    el.on("mouseout.".concat(evSuffix), function() {
      state.mouseInside = false;
      state.tooltipEl.style("display", "none");
    });
  },
  update: function update5(state) {
    state.tooltipEl.style("display", !!state.content && state.mouseInside ? "inline" : "none");
    if (!state.content) {
      state.tooltipEl.text("");
    } else if (state.content instanceof HTMLElement) {
      state.tooltipEl.text("");
      state.tooltipEl.append(function() {
        return state.content;
      });
    } else if (typeof state.content === "string") {
      state.tooltipEl.html(state.content);
    } else if (isReactRenderable(state.content)) {
      state.tooltipEl.text("");
      render(state.content, state.tooltipEl.node());
    } else {
      state.tooltipEl.style("display", "none");
      console.warn("Tooltip content is invalid, skipping.", state.content, state.content.toString());
    }
  }
});

// node_modules/three-render-objects/dist/three-render-objects.mjs
function styleInject3(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;
  if (typeof document === "undefined") {
    return;
  }
  var head2 = document.head || document.getElementsByTagName("head")[0];
  var style = document.createElement("style");
  style.type = "text/css";
  if (insertAt === "top") {
    if (head2.firstChild) {
      head2.insertBefore(style, head2.firstChild);
    } else {
      head2.appendChild(style);
    }
  } else {
    head2.appendChild(style);
  }
  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}
var css_248z3 = ".scene-nav-info {\n  position: absolute;\n  bottom: 5px;\n  width: 100%;\n  text-align: center;\n  color: slategrey;\n  opacity: 0.7;\n  font-size: 10px;\n  font-family: sans-serif;\n  pointer-events: none;\n  user-select: none;\n}\n\n.scene-container canvas:focus {\n  outline: none;\n}";
styleInject3(css_248z3);
function _arrayLikeToArray9(r2, a3) {
  (null == a3 || a3 > r2.length) && (a3 = r2.length);
  for (var e3 = 0, n2 = Array(a3); e3 < a3; e3++) n2[e3] = r2[e3];
  return n2;
}
function _arrayWithHoles9(r2) {
  if (Array.isArray(r2)) return r2;
}
function _arrayWithoutHoles7(r2) {
  if (Array.isArray(r2)) return _arrayLikeToArray9(r2);
}
function _defineProperty6(e3, r2, t5) {
  return (r2 = _toPropertyKey7(r2)) in e3 ? Object.defineProperty(e3, r2, {
    value: t5,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e3[r2] = t5, e3;
}
function _iterableToArray7(r2) {
  if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"]) return Array.from(r2);
}
function _iterableToArrayLimit9(r2, l2) {
  var t5 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t5) {
    var e3, n2, i2, u2, a3 = [], f3 = true, o2 = false;
    try {
      if (i2 = (t5 = t5.call(r2)).next, 0 === l2) ;
      else for (; !(f3 = (e3 = i2.call(t5)).done) && (a3.push(e3.value), a3.length !== l2); f3 = true) ;
    } catch (r3) {
      o2 = true, n2 = r3;
    } finally {
      try {
        if (!f3 && null != t5.return && (u2 = t5.return(), Object(u2) !== u2)) return;
      } finally {
        if (o2) throw n2;
      }
    }
    return a3;
  }
}
function _nonIterableRest9() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableSpread7() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _slicedToArray9(r2, e3) {
  return _arrayWithHoles9(r2) || _iterableToArrayLimit9(r2, e3) || _unsupportedIterableToArray9(r2, e3) || _nonIterableRest9();
}
function _toConsumableArray7(r2) {
  return _arrayWithoutHoles7(r2) || _iterableToArray7(r2) || _unsupportedIterableToArray9(r2) || _nonIterableSpread7();
}
function _toPrimitive7(t5, r2) {
  if ("object" != typeof t5 || !t5) return t5;
  var e3 = t5[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t5, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t5);
}
function _toPropertyKey7(t5) {
  var i2 = _toPrimitive7(t5, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _unsupportedIterableToArray9(r2, a3) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray9(r2, a3);
    var t5 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t5 && r2.constructor && (t5 = r2.constructor.name), "Map" === t5 || "Set" === t5 ? Array.from(r2) : "Arguments" === t5 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t5) ? _arrayLikeToArray9(r2, a3) : void 0;
  }
}
var three2 = window.THREE ? window.THREE : {
  WebGLRenderer,
  Scene,
  PerspectiveCamera,
  Raycaster,
  SRGBColorSpace,
  TextureLoader,
  Vector2,
  Vector3,
  Box3,
  Color,
  Mesh,
  SphereGeometry,
  MeshBasicMaterial,
  BackSide,
  Clock
};
var threeRenderObjects = index3({
  props: {
    width: {
      "default": window.innerWidth,
      onChange: function onChange10(width, state, prevWidth) {
        isNaN(width) && (state.width = prevWidth);
      }
    },
    height: {
      "default": window.innerHeight,
      onChange: function onChange11(height, state, prevHeight) {
        isNaN(height) && (state.height = prevHeight);
      }
    },
    viewOffset: {
      "default": [0, 0]
    },
    backgroundColor: {
      "default": "#000011"
    },
    backgroundImageUrl: {},
    onBackgroundImageLoaded: {},
    showNavInfo: {
      "default": true
    },
    skyRadius: {
      "default": 5e4
    },
    objects: {
      "default": []
    },
    lights: {
      "default": []
    },
    enablePointerInteraction: {
      "default": true,
      onChange: function onChange12(_2, state) {
        state.hoverObj = null;
        state.tooltip && state.tooltip.content(null);
      },
      triggerUpdate: false
    },
    pointerRaycasterThrottleMs: {
      "default": 50,
      triggerUpdate: false
    },
    lineHoverPrecision: {
      "default": 1,
      triggerUpdate: false
    },
    pointsHoverPrecision: {
      "default": 1,
      triggerUpdate: false
    },
    hoverOrderComparator: {
      triggerUpdate: false
    },
    // keep existing order by default
    hoverFilter: {
      "default": function _default10() {
        return true;
      },
      triggerUpdate: false
    },
    // exclude objects from interaction
    tooltipContent: {
      triggerUpdate: false
    },
    hoverDuringDrag: {
      "default": false,
      triggerUpdate: false
    },
    clickAfterDrag: {
      "default": false,
      triggerUpdate: false
    },
    onHover: {
      "default": function _default11() {
      },
      triggerUpdate: false
    },
    onClick: {
      "default": function _default12() {
      },
      triggerUpdate: false
    },
    onRightClick: {
      triggerUpdate: false
    }
  },
  methods: {
    tick: function tick(state) {
      if (state.initialised) {
        state.controls.enabled && state.controls.update && state.controls.update(Math.min(1, state.clock.getDelta()));
        state.postProcessingComposer ? state.postProcessingComposer.render() : state.renderer.render(state.scene, state.camera);
        state.extraRenderers.forEach(function(r2) {
          return r2.render(state.scene, state.camera);
        });
        var now4 = +/* @__PURE__ */ new Date();
        if (state.enablePointerInteraction && now4 - state.lastRaycasterCheck >= state.pointerRaycasterThrottleMs) {
          state.lastRaycasterCheck = now4;
          var topObject = null;
          if (state.hoverDuringDrag || !state.isPointerDragging) {
            var intersects2 = this.intersectingObjects(state.pointerPos.x, state.pointerPos.y);
            state.hoverOrderComparator && intersects2.sort(function(a3, b) {
              return state.hoverOrderComparator(a3.object, b.object);
            });
            var topIntersect = intersects2.find(function(d3) {
              return state.hoverFilter(d3.object);
            }) || null;
            topObject = topIntersect ? topIntersect.object : null;
            state.intersection = topIntersect || null;
          }
          if (topObject !== state.hoverObj) {
            state.onHover(topObject, state.hoverObj, state.intersection);
            state.tooltip.content(topObject ? index4(state.tooltipContent)(topObject, state.intersection) || null : null);
            state.hoverObj = topObject;
          }
        }
        state.tweenGroup.update();
      }
      return this;
    },
    getPointerPos: function getPointerPos(state) {
      var _state$pointerPos = state.pointerPos, x3 = _state$pointerPos.x, y3 = _state$pointerPos.y;
      return {
        x: x3,
        y: y3
      };
    },
    cameraPosition: function cameraPosition2(state, position, lookAt, transitionDuration) {
      var camera3 = state.camera;
      if (position && state.initialised) {
        var finalPos = position;
        var finalLookAt = lookAt || {
          x: 0,
          y: 0,
          z: 0
        };
        if (!transitionDuration) {
          setCameraPos(finalPos);
          setLookAt(finalLookAt);
        } else {
          var camPos = Object.assign({}, camera3.position);
          var camLookAt = getLookAt();
          state.tweenGroup.add(new Tween(camPos).to(finalPos, transitionDuration).easing(Easing.Quadratic.Out).onUpdate(setCameraPos).start());
          state.tweenGroup.add(new Tween(camLookAt).to(finalLookAt, transitionDuration / 3).easing(Easing.Quadratic.Out).onUpdate(setLookAt).start());
        }
        return this;
      }
      return Object.assign({}, camera3.position, {
        lookAt: getLookAt()
      });
      function setCameraPos(pos) {
        var x3 = pos.x, y3 = pos.y, z3 = pos.z;
        if (x3 !== void 0) camera3.position.x = x3;
        if (y3 !== void 0) camera3.position.y = y3;
        if (z3 !== void 0) camera3.position.z = z3;
      }
      function setLookAt(lookAt2) {
        var lookAtVect = new three2.Vector3(lookAt2.x, lookAt2.y, lookAt2.z);
        if (state.controls.enabled && state.controls.target) {
          state.controls.target = lookAtVect;
        } else {
          camera3.lookAt(lookAtVect);
        }
      }
      function getLookAt() {
        return Object.assign(new three2.Vector3(0, 0, -1e3).applyQuaternion(camera3.quaternion).add(camera3.position));
      }
    },
    zoomToFit: function zoomToFit(state) {
      var transitionDuration = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var padding = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 10;
      for (var _len = arguments.length, bboxArgs = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
        bboxArgs[_key - 3] = arguments[_key];
      }
      return this.fitToBbox(this.getBbox.apply(this, bboxArgs), transitionDuration, padding);
    },
    fitToBbox: function fitToBbox(state, bbox) {
      var transitionDuration = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      var padding = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 10;
      var camera3 = state.camera;
      if (bbox) {
        var center = new three2.Vector3(0, 0, 0);
        var maxBoxSide = Math.max.apply(Math, _toConsumableArray7(Object.entries(bbox).map(function(_ref) {
          var _ref2 = _slicedToArray9(_ref, 2), coordType = _ref2[0], coords = _ref2[1];
          return Math.max.apply(Math, _toConsumableArray7(coords.map(function(c5) {
            return Math.abs(center[coordType] - c5);
          })));
        }))) * 2;
        var paddedFov = (1 - padding * 2 / state.height) * camera3.fov;
        var fitHeightDistance = maxBoxSide / Math.atan(paddedFov * Math.PI / 180);
        var fitWidthDistance = fitHeightDistance / camera3.aspect;
        var distance4 = Math.max(fitHeightDistance, fitWidthDistance);
        if (distance4 > 0) {
          var newCameraPosition = center.clone().sub(camera3.position).normalize().multiplyScalar(-distance4);
          this.cameraPosition(newCameraPosition, center, transitionDuration);
        }
      }
      return this;
    },
    getBbox: function getBbox(state) {
      var objFilter = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
        return true;
      };
      var box = new three2.Box3(new three2.Vector3(0, 0, 0), new three2.Vector3(0, 0, 0));
      var objs = state.objects.filter(objFilter);
      if (!objs.length) return null;
      objs.forEach(function(obj) {
        return box.expandByObject(obj);
      });
      return Object.assign.apply(Object, _toConsumableArray7(["x", "y", "z"].map(function(c5) {
        return _defineProperty6({}, c5, [box.min[c5], box.max[c5]]);
      })));
    },
    getScreenCoords: function getScreenCoords(state, x3, y3, z3) {
      var vec = new three2.Vector3(x3, y3, z3);
      vec.project(this.camera());
      return {
        // align relative pos to canvas dimensions
        x: (vec.x + 1) * state.width / 2,
        y: -(vec.y - 1) * state.height / 2
      };
    },
    getSceneCoords: function getSceneCoords(state, screenX, screenY) {
      var distance4 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      var relCoords = new three2.Vector2(screenX / state.width * 2 - 1, -(screenY / state.height) * 2 + 1);
      var raycaster = new three2.Raycaster();
      raycaster.setFromCamera(relCoords, state.camera);
      return Object.assign({}, raycaster.ray.at(distance4, new three2.Vector3()));
    },
    intersectingObjects: function intersectingObjects(state, x3, y3) {
      var relCoords = new three2.Vector2(x3 / state.width * 2 - 1, -(y3 / state.height) * 2 + 1);
      var raycaster = new three2.Raycaster();
      raycaster.params.Line.threshold = state.lineHoverPrecision;
      raycaster.params.Points.threshold = state.pointsHoverPrecision;
      raycaster.setFromCamera(relCoords, state.camera);
      return raycaster.intersectObjects(state.objects, true);
    },
    renderer: function renderer(state) {
      return state.renderer;
    },
    scene: function scene(state) {
      return state.scene;
    },
    camera: function camera(state) {
      return state.camera;
    },
    postProcessingComposer: function postProcessingComposer(state) {
      return state.postProcessingComposer;
    },
    controls: function controls(state) {
      return state.controls;
    },
    tbControls: function tbControls(state) {
      return state.controls;
    }
    // to be deprecated
  },
  stateInit: function stateInit2() {
    return {
      scene: new three2.Scene(),
      camera: new three2.PerspectiveCamera(),
      clock: new three2.Clock(),
      tweenGroup: new Group3(),
      lastRaycasterCheck: 0
    };
  },
  init: function init5(domNode, state) {
    var _ref4 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, _ref4$controlType = _ref4.controlType, controlType = _ref4$controlType === void 0 ? "trackball" : _ref4$controlType, _ref4$useWebGPU = _ref4.useWebGPU, useWebGPU = _ref4$useWebGPU === void 0 ? false : _ref4$useWebGPU, _ref4$rendererConfig = _ref4.rendererConfig, rendererConfig = _ref4$rendererConfig === void 0 ? {} : _ref4$rendererConfig, _ref4$extraRenderers = _ref4.extraRenderers, extraRenderers = _ref4$extraRenderers === void 0 ? [] : _ref4$extraRenderers, _ref4$waitForLoadComp = _ref4.waitForLoadComplete, waitForLoadComplete = _ref4$waitForLoadComp === void 0 ? true : _ref4$waitForLoadComp;
    domNode.innerHTML = "";
    domNode.appendChild(state.container = document.createElement("div"));
    state.container.className = "scene-container";
    state.container.style.position = "relative";
    state.container.appendChild(state.navInfo = document.createElement("div"));
    state.navInfo.className = "scene-nav-info";
    state.navInfo.textContent = {
      orbit: "Left-click: rotate, Mouse-wheel/middle-click: zoom, Right-click: pan",
      trackball: "Left-click: rotate, Mouse-wheel/middle-click: zoom, Right-click: pan",
      fly: "WASD: move, R|F: up | down, Q|E: roll, up|down: pitch, left|right: yaw"
    }[controlType] || "";
    state.navInfo.style.display = state.showNavInfo ? null : "none";
    state.tooltip = new index6(state.container);
    state.pointerPos = new three2.Vector2();
    state.pointerPos.x = -2;
    state.pointerPos.y = -2;
    ["pointermove", "pointerdown"].forEach(function(evType) {
      return state.container.addEventListener(evType, function(ev) {
        evType === "pointerdown" && (state.isPointerPressed = true);
        !state.isPointerDragging && ev.type === "pointermove" && (ev.pressure > 0 || state.isPointerPressed) && (ev.pointerType === "mouse" || ev.movementX === void 0 || [ev.movementX, ev.movementY].some(function(m3) {
          return Math.abs(m3) > 1;
        })) && (state.isPointerDragging = true);
        if (state.enablePointerInteraction) {
          var offset = getOffset(state.container);
          state.pointerPos.x = ev.pageX - offset.left;
          state.pointerPos.y = ev.pageY - offset.top;
        }
        function getOffset(el) {
          var rect = el.getBoundingClientRect(), scrollLeft = window.pageXOffset || document.documentElement.scrollLeft, scrollTop = window.pageYOffset || document.documentElement.scrollTop;
          return {
            top: rect.top + scrollTop,
            left: rect.left + scrollLeft
          };
        }
      }, {
        passive: true
      });
    });
    state.container.addEventListener("pointerup", function(ev) {
      if (!state.isPointerPressed) return;
      state.isPointerPressed = false;
      if (state.isPointerDragging) {
        state.isPointerDragging = false;
        if (!state.clickAfterDrag) return;
      }
      requestAnimationFrame(function() {
        if (ev.button === 0) {
          state.onClick(state.hoverObj || null, ev, state.intersection);
        }
        if (ev.button === 2 && state.onRightClick) {
          state.onRightClick(state.hoverObj || null, ev, state.intersection);
        }
      });
    }, {
      passive: true,
      capture: true
    });
    state.container.addEventListener("contextmenu", function(ev) {
      if (state.onRightClick) ev.preventDefault();
    });
    state.renderer = new (useWebGPU ? WebGPURenderer : three2.WebGLRenderer)(Object.assign({
      antialias: true,
      alpha: true
    }, rendererConfig));
    state.renderer.setPixelRatio(Math.min(2, window.devicePixelRatio));
    state.container.appendChild(state.renderer.domElement);
    state.extraRenderers = extraRenderers;
    state.extraRenderers.forEach(function(r2) {
      r2.domElement.style.position = "absolute";
      r2.domElement.style.top = "0px";
      r2.domElement.style.pointerEvents = "none";
      state.container.appendChild(r2.domElement);
    });
    state.postProcessingComposer = new EffectComposer(state.renderer);
    state.postProcessingComposer.addPass(new RenderPass(state.scene, state.camera));
    state.controls = new {
      trackball: TrackballControls,
      orbit: OrbitControls,
      fly: FlyControls
    }[controlType](state.camera, state.renderer.domElement);
    if (controlType === "fly") {
      state.controls.movementSpeed = 300;
      state.controls.rollSpeed = Math.PI / 6;
      state.controls.dragToLook = true;
    }
    if (controlType === "trackball" || controlType === "orbit") {
      state.controls.minDistance = 0.1;
      state.controls.maxDistance = state.skyRadius;
      state.controls.addEventListener("start", function() {
        state.controlsEngaged = true;
      });
      state.controls.addEventListener("change", function() {
        if (state.controlsEngaged) {
          state.controlsDragging = true;
        }
      });
      state.controls.addEventListener("end", function() {
        state.controlsEngaged = false;
        state.controlsDragging = false;
      });
    }
    [state.renderer, state.postProcessingComposer].concat(_toConsumableArray7(state.extraRenderers)).forEach(function(r2) {
      return r2.setSize(state.width, state.height);
    });
    state.camera.aspect = state.width / state.height;
    state.camera.updateProjectionMatrix();
    state.camera.position.z = 1e3;
    state.scene.add(state.skysphere = new three2.Mesh());
    state.skysphere.visible = false;
    state.loadComplete = state.scene.visible = !waitForLoadComplete;
    window.scene = state.scene;
  },
  update: function update6(state, changedProps) {
    if (state.width && state.height && (changedProps.hasOwnProperty("width") || changedProps.hasOwnProperty("height"))) {
      var _state$camera;
      var w4 = state.width;
      var h2 = state.height;
      state.container.style.width = "".concat(w4, "px");
      state.container.style.height = "".concat(h2, "px");
      [state.renderer, state.postProcessingComposer].concat(_toConsumableArray7(state.extraRenderers)).forEach(function(r2) {
        return r2.setSize(w4, h2);
      });
      state.camera.aspect = w4 / h2;
      var o2 = state.viewOffset.slice(0, 2);
      o2.some(function(n2) {
        return n2;
      }) && (_state$camera = state.camera).setViewOffset.apply(_state$camera, [w4, h2].concat(_toConsumableArray7(o2), [w4, h2]));
      state.camera.updateProjectionMatrix();
    }
    if (changedProps.hasOwnProperty("viewOffset")) {
      var _state$camera2;
      var _w = state.width;
      var _h = state.height;
      var _o = state.viewOffset.slice(0, 2);
      _o.some(function(n2) {
        return n2;
      }) ? (_state$camera2 = state.camera).setViewOffset.apply(_state$camera2, [_w, _h].concat(_toConsumableArray7(_o), [_w, _h])) : state.camera.clearViewOffset();
    }
    if (changedProps.hasOwnProperty("skyRadius") && state.skyRadius) {
      state.controls.hasOwnProperty("maxDistance") && changedProps.skyRadius && (state.controls.maxDistance = Math.min(state.controls.maxDistance, state.skyRadius));
      state.camera.far = state.skyRadius * 2.5;
      state.camera.updateProjectionMatrix();
      state.skysphere.geometry = new three2.SphereGeometry(state.skyRadius);
    }
    if (changedProps.hasOwnProperty("backgroundColor")) {
      var alpha = parseToRgb(state.backgroundColor).alpha;
      if (alpha === void 0) alpha = 1;
      state.renderer.setClearColor(new three2.Color(curriedOpacify$1(1, state.backgroundColor)), alpha);
    }
    if (changedProps.hasOwnProperty("backgroundImageUrl")) {
      if (!state.backgroundImageUrl) {
        state.skysphere.visible = false;
        state.skysphere.material.map = null;
        !state.loadComplete && finishLoad();
      } else {
        new three2.TextureLoader().load(state.backgroundImageUrl, function(texture2) {
          texture2.colorSpace = three2.SRGBColorSpace;
          state.skysphere.material = new three2.MeshBasicMaterial({
            map: texture2,
            side: three2.BackSide
          });
          state.skysphere.visible = true;
          state.onBackgroundImageLoaded && setTimeout(state.onBackgroundImageLoaded);
          !state.loadComplete && finishLoad();
        });
      }
    }
    changedProps.hasOwnProperty("showNavInfo") && (state.navInfo.style.display = state.showNavInfo ? null : "none");
    if (changedProps.hasOwnProperty("lights")) {
      (changedProps.lights || []).forEach(function(light) {
        return state.scene.remove(light);
      });
      state.lights.forEach(function(light) {
        return state.scene.add(light);
      });
    }
    if (changedProps.hasOwnProperty("objects")) {
      (changedProps.objects || []).forEach(function(obj) {
        return state.scene.remove(obj);
      });
      state.objects.forEach(function(obj) {
        return state.scene.add(obj);
      });
    }
    function finishLoad() {
      state.loadComplete = state.scene.visible = true;
    }
  }
});

// node_modules/3d-force-graph/dist/3d-force-graph.mjs
function styleInject4(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;
  if (typeof document === "undefined") {
    return;
  }
  var head2 = document.head || document.getElementsByTagName("head")[0];
  var style = document.createElement("style");
  style.type = "text/css";
  if (insertAt === "top") {
    if (head2.firstChild) {
      head2.insertBefore(style, head2.firstChild);
    } else {
      head2.appendChild(style);
    }
  } else {
    head2.appendChild(style);
  }
  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}
var css_248z4 = ".graph-info-msg {\n  top: 50%;\n  width: 100%;\n  text-align: center;\n  color: lavender;\n  opacity: 0.7;\n  font-size: 22px;\n  position: absolute;\n  font-family: Sans-serif;\n}\n\n.scene-container .clickable {\n  cursor: pointer;\n}\n\n.scene-container .grabbable {\n  cursor: move;\n  cursor: grab;\n  cursor: -moz-grab;\n  cursor: -webkit-grab;\n}\n\n.scene-container .grabbable:active {\n  cursor: grabbing;\n  cursor: -moz-grabbing;\n  cursor: -webkit-grabbing;\n}";
styleInject4(css_248z4);
function _arrayLikeToArray10(r2, a3) {
  (null == a3 || a3 > r2.length) && (a3 = r2.length);
  for (var e3 = 0, n2 = Array(a3); e3 < a3; e3++) n2[e3] = r2[e3];
  return n2;
}
function _arrayWithoutHoles8(r2) {
  if (Array.isArray(r2)) return _arrayLikeToArray10(r2);
}
function _defineProperty7(e3, r2, t5) {
  return (r2 = _toPropertyKey8(r2)) in e3 ? Object.defineProperty(e3, r2, {
    value: t5,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e3[r2] = t5, e3;
}
function _iterableToArray8(r2) {
  if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"]) return Array.from(r2);
}
function _nonIterableSpread8() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function ownKeys5(e3, r2) {
  var t5 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t5.push.apply(t5, o2);
  }
  return t5;
}
function _objectSpread25(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t5 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys5(Object(t5), true).forEach(function(r3) {
      _defineProperty7(e3, r3, t5[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t5)) : ownKeys5(Object(t5)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t5, r3));
    });
  }
  return e3;
}
function _toConsumableArray8(r2) {
  return _arrayWithoutHoles8(r2) || _iterableToArray8(r2) || _unsupportedIterableToArray10(r2) || _nonIterableSpread8();
}
function _toPrimitive8(t5, r2) {
  if ("object" != typeof t5 || !t5) return t5;
  var e3 = t5[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t5, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t5);
}
function _toPropertyKey8(t5) {
  var i2 = _toPrimitive8(t5, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _unsupportedIterableToArray10(r2, a3) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray10(r2, a3);
    var t5 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t5 && r2.constructor && (t5 = r2.constructor.name), "Map" === t5 || "Set" === t5 ? Array.from(r2) : "Arguments" === t5 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t5) ? _arrayLikeToArray10(r2, a3) : void 0;
  }
}
function linkKapsule(kapsulePropName, kapsuleType) {
  var dummyK = new kapsuleType();
  dummyK._destructor && dummyK._destructor();
  return {
    linkProp: function linkProp(prop) {
      return {
        "default": dummyK[prop](),
        onChange: function onChange29(v2, state) {
          state[kapsulePropName][prop](v2);
        },
        triggerUpdate: false
      };
    },
    linkMethod: function linkMethod(method2) {
      return function(state) {
        var kapsuleInstance = state[kapsulePropName];
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        var returnVal = kapsuleInstance[method2].apply(kapsuleInstance, args);
        return returnVal === kapsuleInstance ? this : returnVal;
      };
    }
  };
}
var three3 = window.THREE ? window.THREE : {
  AmbientLight,
  DirectionalLight,
  REVISION
};
var CAMERA_DISTANCE2NODES_FACTOR = 170;
var bindFG = linkKapsule("forceGraph", threeForcegraph);
var linkedFGProps = Object.assign.apply(Object, _toConsumableArray8(["jsonUrl", "graphData", "numDimensions", "dagMode", "dagLevelDistance", "dagNodeFilter", "onDagError", "nodeRelSize", "nodeId", "nodeVal", "nodeResolution", "nodeColor", "nodeAutoColorBy", "nodeOpacity", "nodeVisibility", "nodeThreeObject", "nodeThreeObjectExtend", "nodePositionUpdate", "linkSource", "linkTarget", "linkVisibility", "linkColor", "linkAutoColorBy", "linkOpacity", "linkWidth", "linkResolution", "linkCurvature", "linkCurveRotation", "linkMaterial", "linkThreeObject", "linkThreeObjectExtend", "linkPositionUpdate", "linkDirectionalArrowLength", "linkDirectionalArrowColor", "linkDirectionalArrowRelPos", "linkDirectionalArrowResolution", "linkDirectionalParticles", "linkDirectionalParticleSpeed", "linkDirectionalParticleOffset", "linkDirectionalParticleWidth", "linkDirectionalParticleColor", "linkDirectionalParticleResolution", "linkDirectionalParticleThreeObject", "forceEngine", "d3AlphaDecay", "d3VelocityDecay", "d3AlphaMin", "ngraphPhysics", "warmupTicks", "cooldownTicks", "cooldownTime", "onEngineTick", "onEngineStop"].map(function(p3) {
  return _defineProperty7({}, p3, bindFG.linkProp(p3));
})));
var linkedFGMethods = Object.assign.apply(Object, _toConsumableArray8(["refresh", "getGraphBbox", "d3Force", "d3ReheatSimulation", "emitParticle"].map(function(p3) {
  return _defineProperty7({}, p3, bindFG.linkMethod(p3));
})));
var bindRenderObjs = linkKapsule("renderObjs", threeRenderObjects);
var linkedRenderObjsProps = Object.assign.apply(Object, _toConsumableArray8(["width", "height", "backgroundColor", "showNavInfo", "enablePointerInteraction"].map(function(p3) {
  return _defineProperty7({}, p3, bindRenderObjs.linkProp(p3));
})));
var linkedRenderObjsMethods = Object.assign.apply(Object, _toConsumableArray8(["lights", "cameraPosition", "postProcessingComposer"].map(function(p3) {
  return _defineProperty7({}, p3, bindRenderObjs.linkMethod(p3));
})).concat([{
  graph2ScreenCoords: bindRenderObjs.linkMethod("getScreenCoords"),
  screen2GraphCoords: bindRenderObjs.linkMethod("getSceneCoords")
}]));
var _3dForceGraph = index3({
  props: _objectSpread25(_objectSpread25({
    nodeLabel: {
      "default": "name",
      triggerUpdate: false
    },
    linkLabel: {
      "default": "name",
      triggerUpdate: false
    },
    linkHoverPrecision: {
      "default": 1,
      onChange: function onChange13(p3, state) {
        return state.renderObjs.lineHoverPrecision(p3);
      },
      triggerUpdate: false
    },
    enableNavigationControls: {
      "default": true,
      onChange: function onChange14(enable, state) {
        var controls3 = state.renderObjs.controls();
        if (controls3) {
          controls3.enabled = enable;
          enable && controls3.domElement && controls3.domElement.dispatchEvent(new PointerEvent("pointerup"));
        }
      },
      triggerUpdate: false
    },
    enableNodeDrag: {
      "default": true,
      triggerUpdate: false
    },
    onNodeDrag: {
      "default": function _default13() {
      },
      triggerUpdate: false
    },
    onNodeDragEnd: {
      "default": function _default14() {
      },
      triggerUpdate: false
    },
    onNodeClick: {
      triggerUpdate: false
    },
    onNodeRightClick: {
      triggerUpdate: false
    },
    onNodeHover: {
      triggerUpdate: false
    },
    onLinkClick: {
      triggerUpdate: false
    },
    onLinkRightClick: {
      triggerUpdate: false
    },
    onLinkHover: {
      triggerUpdate: false
    },
    onBackgroundClick: {
      triggerUpdate: false
    },
    onBackgroundRightClick: {
      triggerUpdate: false
    },
    showPointerCursor: {
      "default": true,
      triggerUpdate: false
    }
  }, linkedFGProps), linkedRenderObjsProps),
  methods: _objectSpread25(_objectSpread25({
    zoomToFit: function zoomToFit2(state, transitionDuration, padding) {
      var _state$forceGraph;
      for (var _len = arguments.length, bboxArgs = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
        bboxArgs[_key - 3] = arguments[_key];
      }
      state.renderObjs.fitToBbox((_state$forceGraph = state.forceGraph).getGraphBbox.apply(_state$forceGraph, bboxArgs), transitionDuration, padding);
      return this;
    },
    pauseAnimation: function pauseAnimation(state) {
      if (state.animationFrameRequestId !== null) {
        cancelAnimationFrame(state.animationFrameRequestId);
        state.animationFrameRequestId = null;
      }
      return this;
    },
    resumeAnimation: function resumeAnimation(state) {
      if (state.animationFrameRequestId === null) {
        this._animationCycle();
      }
      return this;
    },
    _animationCycle: function _animationCycle(state) {
      if (state.enablePointerInteraction) {
        this.renderer().domElement.style.cursor = null;
      }
      state.forceGraph.tickFrame();
      state.renderObjs.tick();
      state.animationFrameRequestId = requestAnimationFrame(this._animationCycle);
    },
    scene: function scene2(state) {
      return state.renderObjs.scene();
    },
    // Expose scene
    camera: function camera2(state) {
      return state.renderObjs.camera();
    },
    // Expose camera
    renderer: function renderer2(state) {
      return state.renderObjs.renderer();
    },
    // Expose renderer
    controls: function controls2(state) {
      return state.renderObjs.controls();
    },
    // Expose controls
    tbControls: function tbControls2(state) {
      return state.renderObjs.tbControls();
    },
    // To be deprecated
    _destructor: function _destructor3() {
      this.pauseAnimation();
      this.graphData({
        nodes: [],
        links: []
      });
    }
  }, linkedFGMethods), linkedRenderObjsMethods),
  stateInit: function stateInit3(_ref5) {
    var controlType = _ref5.controlType, rendererConfig = _ref5.rendererConfig, extraRenderers = _ref5.extraRenderers;
    var forceGraph2 = new threeForcegraph();
    return {
      forceGraph: forceGraph2,
      renderObjs: threeRenderObjects({
        controlType,
        rendererConfig,
        extraRenderers
      }).objects([forceGraph2]).lights([new three3.AmbientLight(13421772, Math.PI), new three3.DirectionalLight(16777215, 0.6 * Math.PI)])
    };
  },
  init: function init6(domNode, state) {
    domNode.innerHTML = "";
    domNode.appendChild(state.container = document.createElement("div"));
    state.container.style.position = "relative";
    var roDomNode = document.createElement("div");
    state.container.appendChild(roDomNode);
    state.renderObjs(roDomNode);
    var camera3 = state.renderObjs.camera();
    var renderer3 = state.renderObjs.renderer();
    var controls3 = state.renderObjs.controls();
    controls3.enabled = !!state.enableNavigationControls;
    state.lastSetCameraZ = camera3.position.z;
    var infoElem;
    state.container.appendChild(infoElem = document.createElement("div"));
    infoElem.className = "graph-info-msg";
    infoElem.textContent = "";
    state.forceGraph.onLoading(function() {
      infoElem.textContent = "Loading...";
    }).onFinishLoading(function() {
      infoElem.textContent = "";
    }).onUpdate(function() {
      state.graphData = state.forceGraph.graphData();
      if (camera3.position.x === 0 && camera3.position.y === 0 && camera3.position.z === state.lastSetCameraZ && state.graphData.nodes.length) {
        camera3.lookAt(state.forceGraph.position);
        state.lastSetCameraZ = camera3.position.z = Math.cbrt(state.graphData.nodes.length) * CAMERA_DISTANCE2NODES_FACTOR;
      }
    }).onFinishUpdate(function() {
      if (state._dragControls) {
        var curNodeDrag = state.graphData.nodes.find(function(node) {
          return node.__initialFixedPos && !node.__disposeControlsAfterDrag;
        });
        if (curNodeDrag) {
          curNodeDrag.__disposeControlsAfterDrag = true;
        } else {
          state._dragControls.dispose();
        }
        state._dragControls = void 0;
      }
      if (state.enableNodeDrag && state.enablePointerInteraction && state.forceEngine === "d3") {
        var dragControls = state._dragControls = new DragControls(state.graphData.nodes.map(function(node) {
          return node.__threeObj;
        }).filter(function(obj) {
          return obj;
        }), camera3, renderer3.domElement);
        dragControls.addEventListener("dragstart", function(event) {
          var nodeObj = getGraphObj(event.object);
          if (!nodeObj) return;
          controls3.enabled = false;
          event.object.__initialPos = event.object.position.clone();
          event.object.__prevPos = event.object.position.clone();
          var node = nodeObj.__data;
          !node.__initialFixedPos && (node.__initialFixedPos = {
            fx: node.fx,
            fy: node.fy,
            fz: node.fz
          });
          !node.__initialPos && (node.__initialPos = {
            x: node.x,
            y: node.y,
            z: node.z
          });
          ["x", "y", "z"].forEach(function(c5) {
            return node["f".concat(c5)] = node[c5];
          });
          renderer3.domElement.classList.add("grabbable");
        });
        dragControls.addEventListener("drag", function(event) {
          var nodeObj = getGraphObj(event.object);
          if (!nodeObj) return;
          if (!event.object.hasOwnProperty("__graphObjType")) {
            var initPos = event.object.__initialPos;
            var prevPos = event.object.__prevPos;
            var _newPos = event.object.position;
            nodeObj.position.add(_newPos.clone().sub(prevPos));
            prevPos.copy(_newPos);
            _newPos.copy(initPos);
          }
          var node = nodeObj.__data;
          var newPos = nodeObj.position;
          var translate = {
            x: newPos.x - node.x,
            y: newPos.y - node.y,
            z: newPos.z - node.z
          };
          ["x", "y", "z"].forEach(function(c5) {
            return node["f".concat(c5)] = node[c5] = newPos[c5];
          });
          state.forceGraph.d3AlphaTarget(0.3).resetCountdown();
          node.__dragged = true;
          state.onNodeDrag(node, translate);
        });
        dragControls.addEventListener("dragend", function(event) {
          var nodeObj = getGraphObj(event.object);
          if (!nodeObj) return;
          delete event.object.__initialPos;
          delete event.object.__prevPos;
          var node = nodeObj.__data;
          if (node.__disposeControlsAfterDrag) {
            dragControls.dispose();
            delete node.__disposeControlsAfterDrag;
          }
          var initFixedPos = node.__initialFixedPos;
          var initPos = node.__initialPos;
          var translate = {
            x: initPos.x - node.x,
            y: initPos.y - node.y,
            z: initPos.z - node.z
          };
          if (initFixedPos) {
            ["x", "y", "z"].forEach(function(c5) {
              var fc = "f".concat(c5);
              if (initFixedPos[fc] === void 0) {
                delete node[fc];
              }
            });
            delete node.__initialFixedPos;
            delete node.__initialPos;
            if (node.__dragged) {
              delete node.__dragged;
              state.onNodeDragEnd(node, translate);
            }
          }
          state.forceGraph.d3AlphaTarget(0).resetCountdown();
          if (state.enableNavigationControls) {
            var _controls$_onPointerC;
            controls3.enabled = true;
            controls3._status && ((_controls$_onPointerC = controls3._onPointerCancel) === null || _controls$_onPointerC === void 0 ? void 0 : _controls$_onPointerC.call(controls3));
            controls3.domElement && controls3.domElement.ownerDocument && controls3.domElement.ownerDocument.dispatchEvent(
              // simulate mouseup to ensure the controls don't take over after dragend
              new PointerEvent("pointerup", {
                pointerType: "touch"
              })
            );
          }
          renderer3.domElement.classList.remove("grabbable");
        });
      }
    });
    three3.REVISION < 155 && (state.renderObjs.renderer().useLegacyLights = false);
    state.renderObjs.hoverOrderComparator(function(a3, b) {
      var aObj = getGraphObj(a3);
      if (!aObj) return 1;
      var bObj = getGraphObj(b);
      if (!bObj) return -1;
      var isNode = function isNode2(o2) {
        return o2.__graphObjType === "node";
      };
      return isNode(bObj) - isNode(aObj);
    }).tooltipContent(function(obj) {
      var graphObj = getGraphObj(obj);
      return graphObj ? index4(state["".concat(graphObj.__graphObjType, "Label")])(graphObj.__data) || "" : "";
    }).hoverDuringDrag(false).onHover(function(obj) {
      var hoverObj = getGraphObj(obj);
      if (hoverObj !== state.hoverObj) {
        var prevObjType = state.hoverObj ? state.hoverObj.__graphObjType : null;
        var prevObjData = state.hoverObj ? state.hoverObj.__data : null;
        var objType = hoverObj ? hoverObj.__graphObjType : null;
        var objData = hoverObj ? hoverObj.__data : null;
        if (prevObjType && prevObjType !== objType) {
          var fn = state["on".concat(prevObjType === "node" ? "Node" : "Link", "Hover")];
          fn && fn(null, prevObjData);
        }
        if (objType) {
          var _fn = state["on".concat(objType === "node" ? "Node" : "Link", "Hover")];
          _fn && _fn(objData, prevObjType === objType ? prevObjData : null);
        }
        renderer3.domElement.classList[(hoverObj && state["on".concat(objType === "node" ? "Node" : "Link", "Click")] || !hoverObj && state.onBackgroundClick) && index4(state.showPointerCursor)(objData) ? "add" : "remove"]("clickable");
        state.hoverObj = hoverObj;
      }
    }).clickAfterDrag(false).onClick(function(obj, ev) {
      var graphObj = getGraphObj(obj);
      if (graphObj) {
        var fn = state["on".concat(graphObj.__graphObjType === "node" ? "Node" : "Link", "Click")];
        fn && fn(graphObj.__data, ev);
      } else {
        state.onBackgroundClick && state.onBackgroundClick(ev);
      }
    }).onRightClick(function(obj, ev) {
      var graphObj = getGraphObj(obj);
      if (graphObj) {
        var fn = state["on".concat(graphObj.__graphObjType === "node" ? "Node" : "Link", "RightClick")];
        fn && fn(graphObj.__data, ev);
      } else {
        state.onBackgroundRightClick && state.onBackgroundRightClick(ev);
      }
    });
    this._animationCycle();
  }
});
function getGraphObj(object) {
  var obj = object;
  while (obj && !obj.hasOwnProperty("__graphObjType")) {
    obj = obj.parent;
  }
  return obj;
}

// node_modules/d3-drag/src/noevent.js
var nonpassive = { passive: false };
var nonpassivecapture = { capture: true, passive: false };
function nopropagation(event) {
  event.stopImmediatePropagation();
}
function noevent_default(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}

// node_modules/d3-drag/src/nodrag.js
function nodrag_default(view) {
  var root3 = view.document.documentElement, selection2 = select_default2(view).on("dragstart.drag", noevent_default, nonpassivecapture);
  if ("onselectstart" in root3) {
    selection2.on("selectstart.drag", noevent_default, nonpassivecapture);
  } else {
    root3.__noselect = root3.style.MozUserSelect;
    root3.style.MozUserSelect = "none";
  }
}
function yesdrag(view, noclick) {
  var root3 = view.document.documentElement, selection2 = select_default2(view).on("dragstart.drag", null);
  if (noclick) {
    selection2.on("click.drag", noevent_default, nonpassivecapture);
    setTimeout(function() {
      selection2.on("click.drag", null);
    }, 0);
  }
  if ("onselectstart" in root3) {
    selection2.on("selectstart.drag", null);
  } else {
    root3.style.MozUserSelect = root3.__noselect;
    delete root3.__noselect;
  }
}

// node_modules/d3-drag/src/constant.js
var constant_default4 = (x3) => () => x3;

// node_modules/d3-drag/src/event.js
function DragEvent(type, {
  sourceEvent,
  subject,
  target,
  identifier,
  active,
  x: x3,
  y: y3,
  dx,
  dy,
  dispatch: dispatch2
}) {
  Object.defineProperties(this, {
    type: { value: type, enumerable: true, configurable: true },
    sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },
    subject: { value: subject, enumerable: true, configurable: true },
    target: { value: target, enumerable: true, configurable: true },
    identifier: { value: identifier, enumerable: true, configurable: true },
    active: { value: active, enumerable: true, configurable: true },
    x: { value: x3, enumerable: true, configurable: true },
    y: { value: y3, enumerable: true, configurable: true },
    dx: { value: dx, enumerable: true, configurable: true },
    dy: { value: dy, enumerable: true, configurable: true },
    _: { value: dispatch2 }
  });
}
DragEvent.prototype.on = function() {
  var value = this._.on.apply(this._, arguments);
  return value === this._ ? this : value;
};

// node_modules/d3-drag/src/drag.js
function defaultFilter(event) {
  return !event.ctrlKey && !event.button;
}
function defaultContainer() {
  return this.parentNode;
}
function defaultSubject(event, d3) {
  return d3 == null ? { x: event.x, y: event.y } : d3;
}
function defaultTouchable() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function drag_default() {
  var filter4 = defaultFilter, container = defaultContainer, subject = defaultSubject, touchable = defaultTouchable, gestures = {}, listeners = dispatch_default("start", "drag", "end"), active = 0, mousedownx, mousedowny, mousemoving, touchending, clickDistance2 = 0;
  function drag(selection2) {
    selection2.on("mousedown.drag", mousedowned).filter(touchable).on("touchstart.drag", touchstarted).on("touchmove.drag", touchmoved, nonpassive).on("touchend.drag touchcancel.drag", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  function mousedowned(event, d3) {
    if (touchending || !filter4.call(this, event, d3)) return;
    var gesture = beforestart(this, container.call(this, event, d3), event, d3, "mouse");
    if (!gesture) return;
    select_default2(event.view).on("mousemove.drag", mousemoved, nonpassivecapture).on("mouseup.drag", mouseupped, nonpassivecapture);
    nodrag_default(event.view);
    nopropagation(event);
    mousemoving = false;
    mousedownx = event.clientX;
    mousedowny = event.clientY;
    gesture("start", event);
  }
  function mousemoved(event) {
    noevent_default(event);
    if (!mousemoving) {
      var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }
    gestures.mouse("drag", event);
  }
  function mouseupped(event) {
    select_default2(event.view).on("mousemove.drag mouseup.drag", null);
    yesdrag(event.view, mousemoving);
    noevent_default(event);
    gestures.mouse("end", event);
  }
  function touchstarted(event, d3) {
    if (!filter4.call(this, event, d3)) return;
    var touches = event.changedTouches, c5 = container.call(this, event, d3), n2 = touches.length, i2, gesture;
    for (i2 = 0; i2 < n2; ++i2) {
      if (gesture = beforestart(this, c5, event, d3, touches[i2].identifier, touches[i2])) {
        nopropagation(event);
        gesture("start", event, touches[i2]);
      }
    }
  }
  function touchmoved(event) {
    var touches = event.changedTouches, n2 = touches.length, i2, gesture;
    for (i2 = 0; i2 < n2; ++i2) {
      if (gesture = gestures[touches[i2].identifier]) {
        noevent_default(event);
        gesture("drag", event, touches[i2]);
      }
    }
  }
  function touchended(event) {
    var touches = event.changedTouches, n2 = touches.length, i2, gesture;
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() {
      touchending = null;
    }, 500);
    for (i2 = 0; i2 < n2; ++i2) {
      if (gesture = gestures[touches[i2].identifier]) {
        nopropagation(event);
        gesture("end", event, touches[i2]);
      }
    }
  }
  function beforestart(that, container2, event, d3, identifier, touch) {
    var dispatch2 = listeners.copy(), p3 = pointer_default(touch || event, container2), dx, dy, s2;
    if ((s2 = subject.call(that, new DragEvent("beforestart", {
      sourceEvent: event,
      target: drag,
      identifier,
      active,
      x: p3[0],
      y: p3[1],
      dx: 0,
      dy: 0,
      dispatch: dispatch2
    }), d3)) == null) return;
    dx = s2.x - p3[0] || 0;
    dy = s2.y - p3[1] || 0;
    return function gesture(type, event2, touch2) {
      var p0 = p3, n2;
      switch (type) {
        case "start":
          gestures[identifier] = gesture, n2 = active++;
          break;
        case "end":
          delete gestures[identifier], --active;
        // falls through
        case "drag":
          p3 = pointer_default(touch2 || event2, container2), n2 = active;
          break;
      }
      dispatch2.call(
        type,
        that,
        new DragEvent(type, {
          sourceEvent: event2,
          subject: s2,
          target: drag,
          identifier,
          active: n2,
          x: p3[0] + dx,
          y: p3[1] + dy,
          dx: p3[0] - p0[0],
          dy: p3[1] - p0[1],
          dispatch: dispatch2
        }),
        d3
      );
    };
  }
  drag.filter = function(_2) {
    return arguments.length ? (filter4 = typeof _2 === "function" ? _2 : constant_default4(!!_2), drag) : filter4;
  };
  drag.container = function(_2) {
    return arguments.length ? (container = typeof _2 === "function" ? _2 : constant_default4(_2), drag) : container;
  };
  drag.subject = function(_2) {
    return arguments.length ? (subject = typeof _2 === "function" ? _2 : constant_default4(_2), drag) : subject;
  };
  drag.touchable = function(_2) {
    return arguments.length ? (touchable = typeof _2 === "function" ? _2 : constant_default4(!!_2), drag) : touchable;
  };
  drag.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag : value;
  };
  drag.clickDistance = function(_2) {
    return arguments.length ? (clickDistance2 = (_2 = +_2) * _2, drag) : Math.sqrt(clickDistance2);
  };
  return drag;
}

// node_modules/d3-transition/src/transition/schedule.js
var emptyOn = dispatch_default("start", "end", "cancel", "interrupt");
var emptyTween = [];
var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;
function schedule_default(node, name, id2, index8, group2, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};
  else if (id2 in schedules) return;
  create(node, id2, {
    name,
    index: index8,
    // For context during callback.
    group: group2,
    // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}
function init7(node, id2) {
  var schedule = get2(node, id2);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}
function set2(node, id2) {
  var schedule = get2(node, id2);
  if (schedule.state > STARTED) throw new Error("too late; already running");
  return schedule;
}
function get2(node, id2) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id2])) throw new Error("transition not found");
  return schedule;
}
function create(node, id2, self2) {
  var schedules = node.__transition, tween;
  schedules[id2] = self2;
  self2.timer = timer(schedule, 0, self2.time);
  function schedule(elapsed) {
    self2.state = SCHEDULED;
    self2.timer.restart(start2, self2.delay, self2.time);
    if (self2.delay <= elapsed) start2(elapsed - self2.delay);
  }
  function start2(elapsed) {
    var i2, j2, n2, o2;
    if (self2.state !== SCHEDULED) return stop();
    for (i2 in schedules) {
      o2 = schedules[i2];
      if (o2.name !== self2.name) continue;
      if (o2.state === STARTED) return timeout_default(start2);
      if (o2.state === RUNNING) {
        o2.state = ENDED;
        o2.timer.stop();
        o2.on.call("interrupt", node, node.__data__, o2.index, o2.group);
        delete schedules[i2];
      } else if (+i2 < id2) {
        o2.state = ENDED;
        o2.timer.stop();
        o2.on.call("cancel", node, node.__data__, o2.index, o2.group);
        delete schedules[i2];
      }
    }
    timeout_default(function() {
      if (self2.state === STARTED) {
        self2.state = RUNNING;
        self2.timer.restart(tick2, self2.delay, self2.time);
        tick2(elapsed);
      }
    });
    self2.state = STARTING;
    self2.on.call("start", node, node.__data__, self2.index, self2.group);
    if (self2.state !== STARTING) return;
    self2.state = STARTED;
    tween = new Array(n2 = self2.tween.length);
    for (i2 = 0, j2 = -1; i2 < n2; ++i2) {
      if (o2 = self2.tween[i2].value.call(node, node.__data__, self2.index, self2.group)) {
        tween[++j2] = o2;
      }
    }
    tween.length = j2 + 1;
  }
  function tick2(elapsed) {
    var t5 = elapsed < self2.duration ? self2.ease.call(null, elapsed / self2.duration) : (self2.timer.restart(stop), self2.state = ENDING, 1), i2 = -1, n2 = tween.length;
    while (++i2 < n2) {
      tween[i2].call(node, t5);
    }
    if (self2.state === ENDING) {
      self2.on.call("end", node, node.__data__, self2.index, self2.group);
      stop();
    }
  }
  function stop() {
    self2.state = ENDED;
    self2.timer.stop();
    delete schedules[id2];
    for (var i2 in schedules) return;
    delete node.__transition;
  }
}

// node_modules/d3-transition/src/interrupt.js
function interrupt_default(node, name) {
  var schedules = node.__transition, schedule, active, empty2 = true, i2;
  if (!schedules) return;
  name = name == null ? null : name + "";
  for (i2 in schedules) {
    if ((schedule = schedules[i2]).name !== name) {
      empty2 = false;
      continue;
    }
    active = schedule.state > STARTING && schedule.state < ENDING;
    schedule.state = ENDED;
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i2];
  }
  if (empty2) delete node.__transition;
}

// node_modules/d3-transition/src/selection/interrupt.js
function interrupt_default2(name) {
  return this.each(function() {
    interrupt_default(this, name);
  });
}

// node_modules/d3-transition/src/transition/tween.js
function tweenRemove(id2, name) {
  var tween0, tween1;
  return function() {
    var schedule = set2(this, id2), tween = schedule.tween;
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i2 = 0, n2 = tween1.length; i2 < n2; ++i2) {
        if (tween1[i2].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i2, 1);
          break;
        }
      }
    }
    schedule.tween = tween1;
  };
}
function tweenFunction(id2, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error();
  return function() {
    var schedule = set2(this, id2), tween = schedule.tween;
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t5 = { name, value }, i2 = 0, n2 = tween1.length; i2 < n2; ++i2) {
        if (tween1[i2].name === name) {
          tween1[i2] = t5;
          break;
        }
      }
      if (i2 === n2) tween1.push(t5);
    }
    schedule.tween = tween1;
  };
}
function tween_default(name, value) {
  var id2 = this._id;
  name += "";
  if (arguments.length < 2) {
    var tween = get2(this.node(), id2).tween;
    for (var i2 = 0, n2 = tween.length, t5; i2 < n2; ++i2) {
      if ((t5 = tween[i2]).name === name) {
        return t5.value;
      }
    }
    return null;
  }
  return this.each((value == null ? tweenRemove : tweenFunction)(id2, name, value));
}
function tweenValue(transition2, name, value) {
  var id2 = transition2._id;
  transition2.each(function() {
    var schedule = set2(this, id2);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });
  return function(node) {
    return get2(node, id2).value[name];
  };
}

// node_modules/d3-transition/src/transition/interpolate.js
function interpolate_default(a3, b) {
  var c5;
  return (typeof b === "number" ? number_default : b instanceof color ? rgb_default : (c5 = color(b)) ? (b = c5, rgb_default) : string_default)(a3, b);
}

// node_modules/d3-transition/src/transition/attr.js
function attrRemove2(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS2(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant2(name, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function attrConstantNS2(fullname, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function attrFunction2(name, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function attrFunctionNS2(fullname, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function attr_default2(name, value) {
  var fullname = namespace_default(name), i2 = fullname === "transform" ? interpolateTransformSvg : interpolate_default;
  return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS2 : attrFunction2)(fullname, i2, tweenValue(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS2 : attrRemove2)(fullname) : (fullname.local ? attrConstantNS2 : attrConstant2)(fullname, i2, value));
}

// node_modules/d3-transition/src/transition/attrTween.js
function attrInterpolate(name, i2) {
  return function(t5) {
    this.setAttribute(name, i2.call(this, t5));
  };
}
function attrInterpolateNS(fullname, i2) {
  return function(t5) {
    this.setAttributeNS(fullname.space, fullname.local, i2.call(this, t5));
  };
}
function attrTweenNS(fullname, value) {
  var t03, i0;
  function tween() {
    var i2 = value.apply(this, arguments);
    if (i2 !== i0) t03 = (i0 = i2) && attrInterpolateNS(fullname, i2);
    return t03;
  }
  tween._value = value;
  return tween;
}
function attrTween(name, value) {
  var t03, i0;
  function tween() {
    var i2 = value.apply(this, arguments);
    if (i2 !== i0) t03 = (i0 = i2) && attrInterpolate(name, i2);
    return t03;
  }
  tween._value = value;
  return tween;
}
function attrTween_default(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error();
  var fullname = namespace_default(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}

// node_modules/d3-transition/src/transition/delay.js
function delayFunction(id2, value) {
  return function() {
    init7(this, id2).delay = +value.apply(this, arguments);
  };
}
function delayConstant(id2, value) {
  return value = +value, function() {
    init7(this, id2).delay = value;
  };
}
function delay_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id2, value)) : get2(this.node(), id2).delay;
}

// node_modules/d3-transition/src/transition/duration.js
function durationFunction(id2, value) {
  return function() {
    set2(this, id2).duration = +value.apply(this, arguments);
  };
}
function durationConstant(id2, value) {
  return value = +value, function() {
    set2(this, id2).duration = value;
  };
}
function duration_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id2, value)) : get2(this.node(), id2).duration;
}

// node_modules/d3-transition/src/transition/ease.js
function easeConstant(id2, value) {
  if (typeof value !== "function") throw new Error();
  return function() {
    set2(this, id2).ease = value;
  };
}
function ease_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each(easeConstant(id2, value)) : get2(this.node(), id2).ease;
}

// node_modules/d3-transition/src/transition/easeVarying.js
function easeVarying(id2, value) {
  return function() {
    var v2 = value.apply(this, arguments);
    if (typeof v2 !== "function") throw new Error();
    set2(this, id2).ease = v2;
  };
}
function easeVarying_default(value) {
  if (typeof value !== "function") throw new Error();
  return this.each(easeVarying(this._id, value));
}

// node_modules/d3-transition/src/transition/filter.js
function filter_default2(match) {
  if (typeof match !== "function") match = matcher_default(match);
  for (var groups2 = this._groups, m3 = groups2.length, subgroups = new Array(m3), j2 = 0; j2 < m3; ++j2) {
    for (var group2 = groups2[j2], n2 = group2.length, subgroup = subgroups[j2] = [], node, i2 = 0; i2 < n2; ++i2) {
      if ((node = group2[i2]) && match.call(node, node.__data__, i2, group2)) {
        subgroup.push(node);
      }
    }
  }
  return new Transition(subgroups, this._parents, this._name, this._id);
}

// node_modules/d3-transition/src/transition/merge.js
function merge_default2(transition2) {
  if (transition2._id !== this._id) throw new Error();
  for (var groups0 = this._groups, groups1 = transition2._groups, m0 = groups0.length, m1 = groups1.length, m3 = Math.min(m0, m1), merges = new Array(m0), j2 = 0; j2 < m3; ++j2) {
    for (var group0 = groups0[j2], group1 = groups1[j2], n2 = group0.length, merge3 = merges[j2] = new Array(n2), node, i2 = 0; i2 < n2; ++i2) {
      if (node = group0[i2] || group1[i2]) {
        merge3[i2] = node;
      }
    }
  }
  for (; j2 < m0; ++j2) {
    merges[j2] = groups0[j2];
  }
  return new Transition(merges, this._parents, this._name, this._id);
}

// node_modules/d3-transition/src/transition/on.js
function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t5) {
    var i2 = t5.indexOf(".");
    if (i2 >= 0) t5 = t5.slice(0, i2);
    return !t5 || t5 === "start";
  });
}
function onFunction(id2, name, listener) {
  var on0, on1, sit = start(name) ? init7 : set2;
  return function() {
    var schedule = sit(this, id2), on = schedule.on;
    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);
    schedule.on = on1;
  };
}
function on_default2(name, listener) {
  var id2 = this._id;
  return arguments.length < 2 ? get2(this.node(), id2).on.on(name) : this.each(onFunction(id2, name, listener));
}

// node_modules/d3-transition/src/transition/remove.js
function removeFunction(id2) {
  return function() {
    var parent2 = this.parentNode;
    for (var i2 in this.__transition) if (+i2 !== id2) return;
    if (parent2) parent2.removeChild(this);
  };
}
function remove_default5() {
  return this.on("end.remove", removeFunction(this._id));
}

// node_modules/d3-transition/src/transition/select.js
function select_default3(select2) {
  var name = this._name, id2 = this._id;
  if (typeof select2 !== "function") select2 = selector_default(select2);
  for (var groups2 = this._groups, m3 = groups2.length, subgroups = new Array(m3), j2 = 0; j2 < m3; ++j2) {
    for (var group2 = groups2[j2], n2 = group2.length, subgroup = subgroups[j2] = new Array(n2), node, subnode, i2 = 0; i2 < n2; ++i2) {
      if ((node = group2[i2]) && (subnode = select2.call(node, node.__data__, i2, group2))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i2] = subnode;
        schedule_default(subgroup[i2], name, id2, i2, subgroup, get2(node, id2));
      }
    }
  }
  return new Transition(subgroups, this._parents, name, id2);
}

// node_modules/d3-transition/src/transition/selectAll.js
function selectAll_default3(select2) {
  var name = this._name, id2 = this._id;
  if (typeof select2 !== "function") select2 = selectorAll_default(select2);
  for (var groups2 = this._groups, m3 = groups2.length, subgroups = [], parents = [], j2 = 0; j2 < m3; ++j2) {
    for (var group2 = groups2[j2], n2 = group2.length, node, i2 = 0; i2 < n2; ++i2) {
      if (node = group2[i2]) {
        for (var children2 = select2.call(node, node.__data__, i2, group2), child, inherit2 = get2(node, id2), k2 = 0, l2 = children2.length; k2 < l2; ++k2) {
          if (child = children2[k2]) {
            schedule_default(child, name, id2, k2, children2, inherit2);
          }
        }
        subgroups.push(children2);
        parents.push(node);
      }
    }
  }
  return new Transition(subgroups, parents, name, id2);
}

// node_modules/d3-transition/src/transition/selection.js
var Selection2 = selection_default.prototype.constructor;
function selection_default2() {
  return new Selection2(this._groups, this._parents);
}

// node_modules/d3-transition/src/transition/style.js
function styleNull(name, interpolate) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), string1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}
function styleRemove2(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant2(name, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = styleValue(this, name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function styleFunction2(name, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), value1 = value(this), string1 = value1 + "";
    if (value1 == null) string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function styleMaybeRemove(id2, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove4;
  return function() {
    var schedule = set2(this, id2), on = schedule.on, listener = schedule.value[key] == null ? remove4 || (remove4 = styleRemove2(name)) : void 0;
    if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);
    schedule.on = on1;
  };
}
function style_default2(name, value, priority) {
  var i2 = (name += "") === "transform" ? interpolateTransformCss : interpolate_default;
  return value == null ? this.styleTween(name, styleNull(name, i2)).on("end.style." + name, styleRemove2(name)) : typeof value === "function" ? this.styleTween(name, styleFunction2(name, i2, tweenValue(this, "style." + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant2(name, i2, value), priority).on("end.style." + name, null);
}

// node_modules/d3-transition/src/transition/styleTween.js
function styleInterpolate(name, i2, priority) {
  return function(t5) {
    this.style.setProperty(name, i2.call(this, t5), priority);
  };
}
function styleTween(name, value, priority) {
  var t5, i0;
  function tween() {
    var i2 = value.apply(this, arguments);
    if (i2 !== i0) t5 = (i0 = i2) && styleInterpolate(name, i2, priority);
    return t5;
  }
  tween._value = value;
  return tween;
}
function styleTween_default(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error();
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
}

// node_modules/d3-transition/src/transition/text.js
function textConstant2(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction2(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}
function text_default2(value) {
  return this.tween("text", typeof value === "function" ? textFunction2(tweenValue(this, "text", value)) : textConstant2(value == null ? "" : value + ""));
}

// node_modules/d3-transition/src/transition/textTween.js
function textInterpolate(i2) {
  return function(t5) {
    this.textContent = i2.call(this, t5);
  };
}
function textTween(value) {
  var t03, i0;
  function tween() {
    var i2 = value.apply(this, arguments);
    if (i2 !== i0) t03 = (i0 = i2) && textInterpolate(i2);
    return t03;
  }
  tween._value = value;
  return tween;
}
function textTween_default(value) {
  var key = "text";
  if (arguments.length < 1) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error();
  return this.tween(key, textTween(value));
}

// node_modules/d3-transition/src/transition/transition.js
function transition_default() {
  var name = this._name, id0 = this._id, id1 = newId();
  for (var groups2 = this._groups, m3 = groups2.length, j2 = 0; j2 < m3; ++j2) {
    for (var group2 = groups2[j2], n2 = group2.length, node, i2 = 0; i2 < n2; ++i2) {
      if (node = group2[i2]) {
        var inherit2 = get2(node, id0);
        schedule_default(node, name, id1, i2, group2, {
          time: inherit2.time + inherit2.delay + inherit2.duration,
          delay: 0,
          duration: inherit2.duration,
          ease: inherit2.ease
        });
      }
    }
  }
  return new Transition(groups2, this._parents, name, id1);
}

// node_modules/d3-transition/src/transition/end.js
function end_default() {
  var on0, on1, that = this, id2 = that._id, size2 = that.size();
  return new Promise(function(resolve, reject2) {
    var cancel = { value: reject2 }, end = { value: function() {
      if (--size2 === 0) resolve();
    } };
    that.each(function() {
      var schedule = set2(this, id2), on = schedule.on;
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }
      schedule.on = on1;
    });
    if (size2 === 0) resolve();
  });
}

// node_modules/d3-transition/src/transition/index.js
var id = 0;
function Transition(groups2, parents, name, id2) {
  this._groups = groups2;
  this._parents = parents;
  this._name = name;
  this._id = id2;
}
function transition(name) {
  return selection_default().transition(name);
}
function newId() {
  return ++id;
}
var selection_prototype = selection_default.prototype;
Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: select_default3,
  selectAll: selectAll_default3,
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: filter_default2,
  merge: merge_default2,
  selection: selection_default2,
  transition: transition_default,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: on_default2,
  attr: attr_default2,
  attrTween: attrTween_default,
  style: style_default2,
  styleTween: styleTween_default,
  text: text_default2,
  textTween: textTween_default,
  remove: remove_default5,
  tween: tween_default,
  delay: delay_default,
  duration: duration_default,
  ease: ease_default,
  easeVarying: easeVarying_default,
  end: end_default,
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};

// node_modules/d3-ease/src/cubic.js
function cubicInOut(t5) {
  return ((t5 *= 2) <= 1 ? t5 * t5 * t5 : (t5 -= 2) * t5 * t5 + 2) / 2;
}

// node_modules/d3-ease/src/poly.js
var exponent = 3;
var polyIn = (function custom(e3) {
  e3 = +e3;
  function polyIn2(t5) {
    return Math.pow(t5, e3);
  }
  polyIn2.exponent = custom;
  return polyIn2;
})(exponent);
var polyOut = (function custom2(e3) {
  e3 = +e3;
  function polyOut2(t5) {
    return 1 - Math.pow(1 - t5, e3);
  }
  polyOut2.exponent = custom2;
  return polyOut2;
})(exponent);
var polyInOut = (function custom3(e3) {
  e3 = +e3;
  function polyInOut2(t5) {
    return ((t5 *= 2) <= 1 ? Math.pow(t5, e3) : 2 - Math.pow(2 - t5, e3)) / 2;
  }
  polyInOut2.exponent = custom3;
  return polyInOut2;
})(exponent);

// node_modules/d3-ease/src/sin.js
var pi = Math.PI;
var halfPi = pi / 2;

// node_modules/d3-ease/src/math.js
function tpmt(x3) {
  return (Math.pow(2, -10 * x3) - 9765625e-10) * 1.0009775171065494;
}

// node_modules/d3-ease/src/bounce.js
var b1 = 4 / 11;
var b22 = 6 / 11;
var b3 = 8 / 11;
var b42 = 3 / 4;
var b5 = 9 / 11;
var b6 = 10 / 11;
var b7 = 15 / 16;
var b82 = 21 / 22;
var b9 = 63 / 64;
var b0 = 1 / b1 / b1;

// node_modules/d3-ease/src/back.js
var overshoot = 1.70158;
var backIn = (function custom4(s2) {
  s2 = +s2;
  function backIn2(t5) {
    return (t5 = +t5) * t5 * (s2 * (t5 - 1) + t5);
  }
  backIn2.overshoot = custom4;
  return backIn2;
})(overshoot);
var backOut = (function custom5(s2) {
  s2 = +s2;
  function backOut2(t5) {
    return --t5 * t5 * ((t5 + 1) * s2 + t5) + 1;
  }
  backOut2.overshoot = custom5;
  return backOut2;
})(overshoot);
var backInOut = (function custom6(s2) {
  s2 = +s2;
  function backInOut2(t5) {
    return ((t5 *= 2) < 1 ? t5 * t5 * ((s2 + 1) * t5 - s2) : (t5 -= 2) * t5 * ((s2 + 1) * t5 + s2) + 2) / 2;
  }
  backInOut2.overshoot = custom6;
  return backInOut2;
})(overshoot);

// node_modules/d3-ease/src/elastic.js
var tau = 2 * Math.PI;
var amplitude = 1;
var period = 0.3;
var elasticIn = (function custom7(a3, p3) {
  var s2 = Math.asin(1 / (a3 = Math.max(1, a3))) * (p3 /= tau);
  function elasticIn2(t5) {
    return a3 * tpmt(- --t5) * Math.sin((s2 - t5) / p3);
  }
  elasticIn2.amplitude = function(a4) {
    return custom7(a4, p3 * tau);
  };
  elasticIn2.period = function(p4) {
    return custom7(a3, p4);
  };
  return elasticIn2;
})(amplitude, period);
var elasticOut = (function custom8(a3, p3) {
  var s2 = Math.asin(1 / (a3 = Math.max(1, a3))) * (p3 /= tau);
  function elasticOut2(t5) {
    return 1 - a3 * tpmt(t5 = +t5) * Math.sin((t5 + s2) / p3);
  }
  elasticOut2.amplitude = function(a4) {
    return custom8(a4, p3 * tau);
  };
  elasticOut2.period = function(p4) {
    return custom8(a3, p4);
  };
  return elasticOut2;
})(amplitude, period);
var elasticInOut = (function custom9(a3, p3) {
  var s2 = Math.asin(1 / (a3 = Math.max(1, a3))) * (p3 /= tau);
  function elasticInOut2(t5) {
    return ((t5 = t5 * 2 - 1) < 0 ? a3 * tpmt(-t5) * Math.sin((s2 - t5) / p3) : 2 - a3 * tpmt(t5) * Math.sin((s2 + t5) / p3)) / 2;
  }
  elasticInOut2.amplitude = function(a4) {
    return custom9(a4, p3 * tau);
  };
  elasticInOut2.period = function(p4) {
    return custom9(a3, p4);
  };
  return elasticInOut2;
})(amplitude, period);

// node_modules/d3-transition/src/selection/transition.js
var defaultTiming = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: cubicInOut
};
function inherit(node, id2) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id2])) {
    if (!(node = node.parentNode)) {
      throw new Error(`transition ${id2} not found`);
    }
  }
  return timing;
}
function transition_default2(name) {
  var id2, timing;
  if (name instanceof Transition) {
    id2 = name._id, name = name._name;
  } else {
    id2 = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
  }
  for (var groups2 = this._groups, m3 = groups2.length, j2 = 0; j2 < m3; ++j2) {
    for (var group2 = groups2[j2], n2 = group2.length, node, i2 = 0; i2 < n2; ++i2) {
      if (node = group2[i2]) {
        schedule_default(node, name, id2, i2, group2, timing || inherit(node, id2));
      }
    }
  }
  return new Transition(groups2, this._parents, name, id2);
}

// node_modules/d3-transition/src/selection/index.js
selection_default.prototype.interrupt = interrupt_default2;
selection_default.prototype.transition = transition_default2;

// node_modules/d3-zoom/src/constant.js
var constant_default5 = (x3) => () => x3;

// node_modules/d3-zoom/src/event.js
function ZoomEvent(type, {
  sourceEvent,
  target,
  transform: transform3,
  dispatch: dispatch2
}) {
  Object.defineProperties(this, {
    type: { value: type, enumerable: true, configurable: true },
    sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },
    target: { value: target, enumerable: true, configurable: true },
    transform: { value: transform3, enumerable: true, configurable: true },
    _: { value: dispatch2 }
  });
}

// node_modules/d3-zoom/src/transform.js
function Transform(k2, x3, y3) {
  this.k = k2;
  this.x = x3;
  this.y = y3;
}
Transform.prototype = {
  constructor: Transform,
  scale: function(k2) {
    return k2 === 1 ? this : new Transform(this.k * k2, this.x, this.y);
  },
  translate: function(x3, y3) {
    return x3 === 0 & y3 === 0 ? this : new Transform(this.k, this.x + this.k * x3, this.y + this.k * y3);
  },
  apply: function(point2) {
    return [point2[0] * this.k + this.x, point2[1] * this.k + this.y];
  },
  applyX: function(x3) {
    return x3 * this.k + this.x;
  },
  applyY: function(y3) {
    return y3 * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x3) {
    return (x3 - this.x) / this.k;
  },
  invertY: function(y3) {
    return (y3 - this.y) / this.k;
  },
  rescaleX: function(x3) {
    return x3.copy().domain(x3.range().map(this.invertX, this).map(x3.invert, x3));
  },
  rescaleY: function(y3) {
    return y3.copy().domain(y3.range().map(this.invertY, this).map(y3.invert, y3));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var identity5 = new Transform(1, 0, 0);
transform.prototype = Transform.prototype;
function transform(node) {
  while (!node.__zoom) if (!(node = node.parentNode)) return identity5;
  return node.__zoom;
}

// node_modules/d3-zoom/src/noevent.js
function nopropagation2(event) {
  event.stopImmediatePropagation();
}
function noevent_default2(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}

// node_modules/d3-zoom/src/zoom.js
function defaultFilter2(event) {
  return (!event.ctrlKey || event.type === "wheel") && !event.button;
}
function defaultExtent() {
  var e3 = this;
  if (e3 instanceof SVGElement) {
    e3 = e3.ownerSVGElement || e3;
    if (e3.hasAttribute("viewBox")) {
      e3 = e3.viewBox.baseVal;
      return [[e3.x, e3.y], [e3.x + e3.width, e3.y + e3.height]];
    }
    return [[0, 0], [e3.width.baseVal.value, e3.height.baseVal.value]];
  }
  return [[0, 0], [e3.clientWidth, e3.clientHeight]];
}
function defaultTransform() {
  return this.__zoom || identity5;
}
function defaultWheelDelta(event) {
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 2e-3) * (event.ctrlKey ? 10 : 1);
}
function defaultTouchable2() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function defaultConstrain(transform3, extent2, translateExtent) {
  var dx0 = transform3.invertX(extent2[0][0]) - translateExtent[0][0], dx1 = transform3.invertX(extent2[1][0]) - translateExtent[1][0], dy0 = transform3.invertY(extent2[0][1]) - translateExtent[0][1], dy1 = transform3.invertY(extent2[1][1]) - translateExtent[1][1];
  return transform3.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}
function zoom_default2() {
  var filter4 = defaultFilter2, extent2 = defaultExtent, constrain = defaultConstrain, wheelDelta = defaultWheelDelta, touchable = defaultTouchable2, scaleExtent = [0, Infinity], translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]], duration = 250, interpolate = zoom_default, listeners = dispatch_default("start", "zoom", "end"), touchstarting, touchfirst, touchending, touchDelay = 500, wheelDelay = 150, clickDistance2 = 0, tapDistance = 10;
  function zoom2(selection2) {
    selection2.property("__zoom", defaultTransform).on("wheel.zoom", wheeled, { passive: false }).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  zoom2.transform = function(collection, transform3, point2, event) {
    var selection2 = collection.selection ? collection.selection() : collection;
    selection2.property("__zoom", defaultTransform);
    if (collection !== selection2) {
      schedule(collection, transform3, point2, event);
    } else {
      selection2.interrupt().each(function() {
        gesture(this, arguments).event(event).start().zoom(null, typeof transform3 === "function" ? transform3.apply(this, arguments) : transform3).end();
      });
    }
  };
  zoom2.scaleBy = function(selection2, k2, p3, event) {
    zoom2.scaleTo(selection2, function() {
      var k0 = this.__zoom.k, k1 = typeof k2 === "function" ? k2.apply(this, arguments) : k2;
      return k0 * k1;
    }, p3, event);
  };
  zoom2.scaleTo = function(selection2, k2, p3, event) {
    zoom2.transform(selection2, function() {
      var e3 = extent2.apply(this, arguments), t03 = this.__zoom, p0 = p3 == null ? centroid(e3) : typeof p3 === "function" ? p3.apply(this, arguments) : p3, p1 = t03.invert(p0), k1 = typeof k2 === "function" ? k2.apply(this, arguments) : k2;
      return constrain(translate(scale2(t03, k1), p0, p1), e3, translateExtent);
    }, p3, event);
  };
  zoom2.translateBy = function(selection2, x3, y3, event) {
    zoom2.transform(selection2, function() {
      return constrain(this.__zoom.translate(
        typeof x3 === "function" ? x3.apply(this, arguments) : x3,
        typeof y3 === "function" ? y3.apply(this, arguments) : y3
      ), extent2.apply(this, arguments), translateExtent);
    }, null, event);
  };
  zoom2.translateTo = function(selection2, x3, y3, p3, event) {
    zoom2.transform(selection2, function() {
      var e3 = extent2.apply(this, arguments), t5 = this.__zoom, p0 = p3 == null ? centroid(e3) : typeof p3 === "function" ? p3.apply(this, arguments) : p3;
      return constrain(identity5.translate(p0[0], p0[1]).scale(t5.k).translate(
        typeof x3 === "function" ? -x3.apply(this, arguments) : -x3,
        typeof y3 === "function" ? -y3.apply(this, arguments) : -y3
      ), e3, translateExtent);
    }, p3, event);
  };
  function scale2(transform3, k2) {
    k2 = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k2));
    return k2 === transform3.k ? transform3 : new Transform(k2, transform3.x, transform3.y);
  }
  function translate(transform3, p0, p1) {
    var x3 = p0[0] - p1[0] * transform3.k, y3 = p0[1] - p1[1] * transform3.k;
    return x3 === transform3.x && y3 === transform3.y ? transform3 : new Transform(transform3.k, x3, y3);
  }
  function centroid(extent3) {
    return [(+extent3[0][0] + +extent3[1][0]) / 2, (+extent3[0][1] + +extent3[1][1]) / 2];
  }
  function schedule(transition2, transform3, point2, event) {
    transition2.on("start.zoom", function() {
      gesture(this, arguments).event(event).start();
    }).on("interrupt.zoom end.zoom", function() {
      gesture(this, arguments).event(event).end();
    }).tween("zoom", function() {
      var that = this, args = arguments, g3 = gesture(that, args).event(event), e3 = extent2.apply(that, args), p3 = point2 == null ? centroid(e3) : typeof point2 === "function" ? point2.apply(that, args) : point2, w4 = Math.max(e3[1][0] - e3[0][0], e3[1][1] - e3[0][1]), a3 = that.__zoom, b = typeof transform3 === "function" ? transform3.apply(that, args) : transform3, i2 = interpolate(a3.invert(p3).concat(w4 / a3.k), b.invert(p3).concat(w4 / b.k));
      return function(t5) {
        if (t5 === 1) t5 = b;
        else {
          var l2 = i2(t5), k2 = w4 / l2[2];
          t5 = new Transform(k2, p3[0] - l2[0] * k2, p3[1] - l2[1] * k2);
        }
        g3.zoom(null, t5);
      };
    });
  }
  function gesture(that, args, clean) {
    return !clean && that.__zooming || new Gesture(that, args);
  }
  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.active = 0;
    this.sourceEvent = null;
    this.extent = extent2.apply(that, args);
    this.taps = 0;
  }
  Gesture.prototype = {
    event: function(event) {
      if (event) this.sourceEvent = event;
      return this;
    },
    start: function() {
      if (++this.active === 1) {
        this.that.__zooming = this;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key, transform3) {
      if (this.mouse && key !== "mouse") this.mouse[1] = transform3.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch") this.touch0[1] = transform3.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch") this.touch1[1] = transform3.invert(this.touch1[0]);
      this.that.__zoom = transform3;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        delete this.that.__zooming;
        this.emit("end");
      }
      return this;
    },
    emit: function(type) {
      var d3 = select_default2(this.that).datum();
      listeners.call(
        type,
        this.that,
        new ZoomEvent(type, {
          sourceEvent: this.sourceEvent,
          target: zoom2,
          type,
          transform: this.that.__zoom,
          dispatch: listeners
        }),
        d3
      );
    }
  };
  function wheeled(event, ...args) {
    if (!filter4.apply(this, arguments)) return;
    var g3 = gesture(this, args).event(event), t5 = this.__zoom, k2 = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t5.k * Math.pow(2, wheelDelta.apply(this, arguments)))), p3 = pointer_default(event);
    if (g3.wheel) {
      if (g3.mouse[0][0] !== p3[0] || g3.mouse[0][1] !== p3[1]) {
        g3.mouse[1] = t5.invert(g3.mouse[0] = p3);
      }
      clearTimeout(g3.wheel);
    } else if (t5.k === k2) return;
    else {
      g3.mouse = [p3, t5.invert(p3)];
      interrupt_default(this);
      g3.start();
    }
    noevent_default2(event);
    g3.wheel = setTimeout(wheelidled, wheelDelay);
    g3.zoom("mouse", constrain(translate(scale2(t5, k2), g3.mouse[0], g3.mouse[1]), g3.extent, translateExtent));
    function wheelidled() {
      g3.wheel = null;
      g3.end();
    }
  }
  function mousedowned(event, ...args) {
    if (touchending || !filter4.apply(this, arguments)) return;
    var currentTarget = event.currentTarget, g3 = gesture(this, args, true).event(event), v2 = select_default2(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true), p3 = pointer_default(event, currentTarget), x0 = event.clientX, y0 = event.clientY;
    nodrag_default(event.view);
    nopropagation2(event);
    g3.mouse = [p3, this.__zoom.invert(p3)];
    interrupt_default(this);
    g3.start();
    function mousemoved(event2) {
      noevent_default2(event2);
      if (!g3.moved) {
        var dx = event2.clientX - x0, dy = event2.clientY - y0;
        g3.moved = dx * dx + dy * dy > clickDistance2;
      }
      g3.event(event2).zoom("mouse", constrain(translate(g3.that.__zoom, g3.mouse[0] = pointer_default(event2, currentTarget), g3.mouse[1]), g3.extent, translateExtent));
    }
    function mouseupped(event2) {
      v2.on("mousemove.zoom mouseup.zoom", null);
      yesdrag(event2.view, g3.moved);
      noevent_default2(event2);
      g3.event(event2).end();
    }
  }
  function dblclicked(event, ...args) {
    if (!filter4.apply(this, arguments)) return;
    var t03 = this.__zoom, p0 = pointer_default(event.changedTouches ? event.changedTouches[0] : event, this), p1 = t03.invert(p0), k1 = t03.k * (event.shiftKey ? 0.5 : 2), t13 = constrain(translate(scale2(t03, k1), p0, p1), extent2.apply(this, args), translateExtent);
    noevent_default2(event);
    if (duration > 0) select_default2(this).transition().duration(duration).call(schedule, t13, p0, event);
    else select_default2(this).call(zoom2.transform, t13, p0, event);
  }
  function touchstarted(event, ...args) {
    if (!filter4.apply(this, arguments)) return;
    var touches = event.touches, n2 = touches.length, g3 = gesture(this, args, event.changedTouches.length === n2).event(event), started, i2, t5, p3;
    nopropagation2(event);
    for (i2 = 0; i2 < n2; ++i2) {
      t5 = touches[i2], p3 = pointer_default(t5, this);
      p3 = [p3, this.__zoom.invert(p3), t5.identifier];
      if (!g3.touch0) g3.touch0 = p3, started = true, g3.taps = 1 + !!touchstarting;
      else if (!g3.touch1 && g3.touch0[2] !== p3[2]) g3.touch1 = p3, g3.taps = 0;
    }
    if (touchstarting) touchstarting = clearTimeout(touchstarting);
    if (started) {
      if (g3.taps < 2) touchfirst = p3[0], touchstarting = setTimeout(function() {
        touchstarting = null;
      }, touchDelay);
      interrupt_default(this);
      g3.start();
    }
  }
  function touchmoved(event, ...args) {
    if (!this.__zooming) return;
    var g3 = gesture(this, args).event(event), touches = event.changedTouches, n2 = touches.length, i2, t5, p3, l2;
    noevent_default2(event);
    for (i2 = 0; i2 < n2; ++i2) {
      t5 = touches[i2], p3 = pointer_default(t5, this);
      if (g3.touch0 && g3.touch0[2] === t5.identifier) g3.touch0[0] = p3;
      else if (g3.touch1 && g3.touch1[2] === t5.identifier) g3.touch1[0] = p3;
    }
    t5 = g3.that.__zoom;
    if (g3.touch1) {
      var p0 = g3.touch0[0], l0 = g3.touch0[1], p1 = g3.touch1[0], l1 = g3.touch1[1], dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp, dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t5 = scale2(t5, Math.sqrt(dp / dl));
      p3 = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l2 = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    } else if (g3.touch0) p3 = g3.touch0[0], l2 = g3.touch0[1];
    else return;
    g3.zoom("touch", constrain(translate(t5, p3, l2), g3.extent, translateExtent));
  }
  function touchended(event, ...args) {
    if (!this.__zooming) return;
    var g3 = gesture(this, args).event(event), touches = event.changedTouches, n2 = touches.length, i2, t5;
    nopropagation2(event);
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() {
      touchending = null;
    }, touchDelay);
    for (i2 = 0; i2 < n2; ++i2) {
      t5 = touches[i2];
      if (g3.touch0 && g3.touch0[2] === t5.identifier) delete g3.touch0;
      else if (g3.touch1 && g3.touch1[2] === t5.identifier) delete g3.touch1;
    }
    if (g3.touch1 && !g3.touch0) g3.touch0 = g3.touch1, delete g3.touch1;
    if (g3.touch0) g3.touch0[1] = this.__zoom.invert(g3.touch0[0]);
    else {
      g3.end();
      if (g3.taps === 2) {
        t5 = pointer_default(t5, this);
        if (Math.hypot(touchfirst[0] - t5[0], touchfirst[1] - t5[1]) < tapDistance) {
          var p3 = select_default2(this).on("dblclick.zoom");
          if (p3) p3.apply(this, arguments);
        }
      }
    }
  }
  zoom2.wheelDelta = function(_2) {
    return arguments.length ? (wheelDelta = typeof _2 === "function" ? _2 : constant_default5(+_2), zoom2) : wheelDelta;
  };
  zoom2.filter = function(_2) {
    return arguments.length ? (filter4 = typeof _2 === "function" ? _2 : constant_default5(!!_2), zoom2) : filter4;
  };
  zoom2.touchable = function(_2) {
    return arguments.length ? (touchable = typeof _2 === "function" ? _2 : constant_default5(!!_2), zoom2) : touchable;
  };
  zoom2.extent = function(_2) {
    return arguments.length ? (extent2 = typeof _2 === "function" ? _2 : constant_default5([[+_2[0][0], +_2[0][1]], [+_2[1][0], +_2[1][1]]]), zoom2) : extent2;
  };
  zoom2.scaleExtent = function(_2) {
    return arguments.length ? (scaleExtent[0] = +_2[0], scaleExtent[1] = +_2[1], zoom2) : [scaleExtent[0], scaleExtent[1]];
  };
  zoom2.translateExtent = function(_2) {
    return arguments.length ? (translateExtent[0][0] = +_2[0][0], translateExtent[1][0] = +_2[1][0], translateExtent[0][1] = +_2[0][1], translateExtent[1][1] = +_2[1][1], zoom2) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };
  zoom2.constrain = function(_2) {
    return arguments.length ? (constrain = _2, zoom2) : constrain;
  };
  zoom2.duration = function(_2) {
    return arguments.length ? (duration = +_2, zoom2) : duration;
  };
  zoom2.interpolate = function(_2) {
    return arguments.length ? (interpolate = _2, zoom2) : interpolate;
  };
  zoom2.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom2 : value;
  };
  zoom2.clickDistance = function(_2) {
    return arguments.length ? (clickDistance2 = (_2 = +_2) * _2, zoom2) : Math.sqrt(clickDistance2);
  };
  zoom2.tapDistance = function(_2) {
    return arguments.length ? (tapDistance = +_2, zoom2) : tapDistance;
  };
  return zoom2;
}

// node_modules/lodash-es/_baseToNumber.js
var NAN2 = 0 / 0;
function baseToNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol_default(value)) {
    return NAN2;
  }
  return +value;
}
var baseToNumber_default = baseToNumber;

// node_modules/lodash-es/_arrayMap.js
function arrayMap(array4, iteratee2) {
  var index8 = -1, length2 = array4 == null ? 0 : array4.length, result2 = Array(length2);
  while (++index8 < length2) {
    result2[index8] = iteratee2(array4[index8], index8, array4);
  }
  return result2;
}
var arrayMap_default = arrayMap;

// node_modules/lodash-es/isArray.js
var isArray = Array.isArray;
var isArray_default = isArray;

// node_modules/lodash-es/_baseToString.js
var INFINITY2 = 1 / 0;
var symbolProto = Symbol_default ? Symbol_default.prototype : void 0;
var symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray_default(value)) {
    return arrayMap_default(value, baseToString) + "";
  }
  if (isSymbol_default(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result2 = value + "";
  return result2 == "0" && 1 / value == -INFINITY2 ? "-0" : result2;
}
var baseToString_default = baseToString;

// node_modules/lodash-es/_createMathOperation.js
function createMathOperation(operator, defaultValue) {
  return function(value, other) {
    var result2;
    if (value === void 0 && other === void 0) {
      return defaultValue;
    }
    if (value !== void 0) {
      result2 = value;
    }
    if (other !== void 0) {
      if (result2 === void 0) {
        return other;
      }
      if (typeof value == "string" || typeof other == "string") {
        value = baseToString_default(value);
        other = baseToString_default(other);
      } else {
        value = baseToNumber_default(value);
        other = baseToNumber_default(other);
      }
      result2 = operator(value, other);
    }
    return result2;
  };
}
var createMathOperation_default = createMathOperation;

// node_modules/lodash-es/add.js
var add6 = createMathOperation_default(function(augend, addend) {
  return augend + addend;
}, 0);
var add_default4 = add6;

// node_modules/lodash-es/toFinite.js
var INFINITY3 = 1 / 0;
var MAX_INTEGER = 17976931348623157e292;
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber_default(value);
  if (value === INFINITY3 || value === -INFINITY3) {
    var sign3 = value < 0 ? -1 : 1;
    return sign3 * MAX_INTEGER;
  }
  return value === value ? value : 0;
}
var toFinite_default = toFinite;

// node_modules/lodash-es/toInteger.js
function toInteger(value) {
  var result2 = toFinite_default(value), remainder = result2 % 1;
  return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
}
var toInteger_default = toInteger;

// node_modules/lodash-es/after.js
var FUNC_ERROR_TEXT2 = "Expected a function";
function after(n2, func) {
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT2);
  }
  n2 = toInteger_default(n2);
  return function() {
    if (--n2 < 1) {
      return func.apply(this, arguments);
    }
  };
}
var after_default = after;

// node_modules/lodash-es/identity.js
function identity6(value) {
  return value;
}
var identity_default2 = identity6;

// node_modules/lodash-es/isFunction.js
var asyncTag = "[object AsyncFunction]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction(value) {
  if (!isObject_default(value)) {
    return false;
  }
  var tag = baseGetTag_default(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_default = isFunction;

// node_modules/lodash-es/_coreJsData.js
var coreJsData = root_default4["__core-js_shared__"];
var coreJsData_default = coreJsData;

// node_modules/lodash-es/_isMasked.js
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData_default && coreJsData_default.keys && coreJsData_default.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
})();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var isMasked_default = isMasked;

// node_modules/lodash-es/_toSource.js
var funcProto = Function.prototype;
var funcToString = funcProto.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e3) {
    }
    try {
      return func + "";
    } catch (e3) {
    }
  }
  return "";
}
var toSource_default = toSource;

// node_modules/lodash-es/_baseIsNative.js
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto2 = Function.prototype;
var objectProto3 = Object.prototype;
var funcToString2 = funcProto2.toString;
var hasOwnProperty2 = objectProto3.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value) {
  if (!isObject_default(value) || isMasked_default(value)) {
    return false;
  }
  var pattern = isFunction_default(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource_default(value));
}
var baseIsNative_default = baseIsNative;

// node_modules/lodash-es/_getValue.js
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
var getValue_default = getValue;

// node_modules/lodash-es/_getNative.js
function getNative(object, key) {
  var value = getValue_default(object, key);
  return baseIsNative_default(value) ? value : void 0;
}
var getNative_default = getNative;

// node_modules/lodash-es/_WeakMap.js
var WeakMap2 = getNative_default(root_default4, "WeakMap");
var WeakMap_default = WeakMap2;

// node_modules/lodash-es/_metaMap.js
var metaMap = WeakMap_default && new WeakMap_default();
var metaMap_default = metaMap;

// node_modules/lodash-es/_baseSetData.js
var baseSetData = !metaMap_default ? identity_default2 : function(func, data) {
  metaMap_default.set(func, data);
  return func;
};
var baseSetData_default = baseSetData;

// node_modules/lodash-es/_baseCreate.js
var objectCreate = Object.create;
var baseCreate = /* @__PURE__ */ (function() {
  function object() {
  }
  return function(proto2) {
    if (!isObject_default(proto2)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto2);
    }
    object.prototype = proto2;
    var result2 = new object();
    object.prototype = void 0;
    return result2;
  };
})();
var baseCreate_default = baseCreate;

// node_modules/lodash-es/_createCtor.js
function createCtor(Ctor) {
  return function() {
    var args = arguments;
    switch (args.length) {
      case 0:
        return new Ctor();
      case 1:
        return new Ctor(args[0]);
      case 2:
        return new Ctor(args[0], args[1]);
      case 3:
        return new Ctor(args[0], args[1], args[2]);
      case 4:
        return new Ctor(args[0], args[1], args[2], args[3]);
      case 5:
        return new Ctor(args[0], args[1], args[2], args[3], args[4]);
      case 6:
        return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
      case 7:
        return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
    }
    var thisBinding = baseCreate_default(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
    return isObject_default(result2) ? result2 : thisBinding;
  };
}
var createCtor_default = createCtor;

// node_modules/lodash-es/_createBind.js
var WRAP_BIND_FLAG = 1;
function createBind(func, bitmask, thisArg) {
  var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor_default(func);
  function wrapper() {
    var fn = this && this !== root_default4 && this instanceof wrapper ? Ctor : func;
    return fn.apply(isBind ? thisArg : this, arguments);
  }
  return wrapper;
}
var createBind_default = createBind;

// node_modules/lodash-es/_apply.js
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var apply_default = apply;

// node_modules/lodash-es/_composeArgs.js
var nativeMax2 = Math.max;
function composeArgs(args, partials, holders, isCurried) {
  var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax2(argsLength - holdersLength, 0), result2 = Array(leftLength + rangeLength), isUncurried = !isCurried;
  while (++leftIndex < leftLength) {
    result2[leftIndex] = partials[leftIndex];
  }
  while (++argsIndex < holdersLength) {
    if (isUncurried || argsIndex < argsLength) {
      result2[holders[argsIndex]] = args[argsIndex];
    }
  }
  while (rangeLength--) {
    result2[leftIndex++] = args[argsIndex++];
  }
  return result2;
}
var composeArgs_default = composeArgs;

// node_modules/lodash-es/_composeArgsRight.js
var nativeMax3 = Math.max;
function composeArgsRight(args, partials, holders, isCurried) {
  var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax3(argsLength - holdersLength, 0), result2 = Array(rangeLength + rightLength), isUncurried = !isCurried;
  while (++argsIndex < rangeLength) {
    result2[argsIndex] = args[argsIndex];
  }
  var offset = argsIndex;
  while (++rightIndex < rightLength) {
    result2[offset + rightIndex] = partials[rightIndex];
  }
  while (++holdersIndex < holdersLength) {
    if (isUncurried || argsIndex < argsLength) {
      result2[offset + holders[holdersIndex]] = args[argsIndex++];
    }
  }
  return result2;
}
var composeArgsRight_default = composeArgsRight;

// node_modules/lodash-es/_countHolders.js
function countHolders(array4, placeholder) {
  var length2 = array4.length, result2 = 0;
  while (length2--) {
    if (array4[length2] === placeholder) {
      ++result2;
    }
  }
  return result2;
}
var countHolders_default = countHolders;

// node_modules/lodash-es/_baseLodash.js
function baseLodash() {
}
var baseLodash_default = baseLodash;

// node_modules/lodash-es/_LazyWrapper.js
var MAX_ARRAY_LENGTH = 4294967295;
function LazyWrapper(value) {
  this.__wrapped__ = value;
  this.__actions__ = [];
  this.__dir__ = 1;
  this.__filtered__ = false;
  this.__iteratees__ = [];
  this.__takeCount__ = MAX_ARRAY_LENGTH;
  this.__views__ = [];
}
LazyWrapper.prototype = baseCreate_default(baseLodash_default.prototype);
LazyWrapper.prototype.constructor = LazyWrapper;
var LazyWrapper_default = LazyWrapper;

// node_modules/lodash-es/noop.js
function noop2() {
}
var noop_default = noop2;

// node_modules/lodash-es/_getData.js
var getData3 = !metaMap_default ? noop_default : function(func) {
  return metaMap_default.get(func);
};
var getData_default = getData3;

// node_modules/lodash-es/_realNames.js
var realNames = {};
var realNames_default = realNames;

// node_modules/lodash-es/_getFuncName.js
var objectProto4 = Object.prototype;
var hasOwnProperty3 = objectProto4.hasOwnProperty;
function getFuncName(func) {
  var result2 = func.name + "", array4 = realNames_default[result2], length2 = hasOwnProperty3.call(realNames_default, result2) ? array4.length : 0;
  while (length2--) {
    var data = array4[length2], otherFunc = data.func;
    if (otherFunc == null || otherFunc == func) {
      return data.name;
    }
  }
  return result2;
}
var getFuncName_default = getFuncName;

// node_modules/lodash-es/_LodashWrapper.js
function LodashWrapper(value, chainAll) {
  this.__wrapped__ = value;
  this.__actions__ = [];
  this.__chain__ = !!chainAll;
  this.__index__ = 0;
  this.__values__ = void 0;
}
LodashWrapper.prototype = baseCreate_default(baseLodash_default.prototype);
LodashWrapper.prototype.constructor = LodashWrapper;
var LodashWrapper_default = LodashWrapper;

// node_modules/lodash-es/_copyArray.js
function copyArray2(source, array4) {
  var index8 = -1, length2 = source.length;
  array4 || (array4 = Array(length2));
  while (++index8 < length2) {
    array4[index8] = source[index8];
  }
  return array4;
}
var copyArray_default = copyArray2;

// node_modules/lodash-es/_wrapperClone.js
function wrapperClone(wrapper) {
  if (wrapper instanceof LazyWrapper_default) {
    return wrapper.clone();
  }
  var result2 = new LodashWrapper_default(wrapper.__wrapped__, wrapper.__chain__);
  result2.__actions__ = copyArray_default(wrapper.__actions__);
  result2.__index__ = wrapper.__index__;
  result2.__values__ = wrapper.__values__;
  return result2;
}
var wrapperClone_default = wrapperClone;

// node_modules/lodash-es/wrapperLodash.js
var objectProto5 = Object.prototype;
var hasOwnProperty4 = objectProto5.hasOwnProperty;
function lodash(value) {
  if (isObjectLike_default(value) && !isArray_default(value) && !(value instanceof LazyWrapper_default)) {
    if (value instanceof LodashWrapper_default) {
      return value;
    }
    if (hasOwnProperty4.call(value, "__wrapped__")) {
      return wrapperClone_default(value);
    }
  }
  return new LodashWrapper_default(value);
}
lodash.prototype = baseLodash_default.prototype;
lodash.prototype.constructor = lodash;
var wrapperLodash_default = lodash;

// node_modules/lodash-es/_isLaziable.js
function isLaziable(func) {
  var funcName = getFuncName_default(func), other = wrapperLodash_default[funcName];
  if (typeof other != "function" || !(funcName in LazyWrapper_default.prototype)) {
    return false;
  }
  if (func === other) {
    return true;
  }
  var data = getData_default(other);
  return !!data && func === data[0];
}
var isLaziable_default = isLaziable;

// node_modules/lodash-es/_shortOut.js
var HOT_COUNT = 800;
var HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func) {
  var count2 = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count2 >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count2 = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var shortOut_default = shortOut;

// node_modules/lodash-es/_setData.js
var setData = shortOut_default(baseSetData_default);
var setData_default = setData;

// node_modules/lodash-es/_getWrapDetails.js
var reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/;
var reSplitDetails = /,? & /;
function getWrapDetails(source) {
  var match = source.match(reWrapDetails);
  return match ? match[1].split(reSplitDetails) : [];
}
var getWrapDetails_default = getWrapDetails;

// node_modules/lodash-es/_insertWrapDetails.js
var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/;
function insertWrapDetails(source, details) {
  var length2 = details.length;
  if (!length2) {
    return source;
  }
  var lastIndex = length2 - 1;
  details[lastIndex] = (length2 > 1 ? "& " : "") + details[lastIndex];
  details = details.join(length2 > 2 ? ", " : " ");
  return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
}
var insertWrapDetails_default = insertWrapDetails;

// node_modules/lodash-es/constant.js
function constant2(value) {
  return function() {
    return value;
  };
}
var constant_default6 = constant2;

// node_modules/lodash-es/_defineProperty.js
var defineProperty = (function() {
  try {
    var func = getNative_default(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e3) {
  }
})();
var defineProperty_default = defineProperty;

// node_modules/lodash-es/_baseSetToString.js
var baseSetToString = !defineProperty_default ? identity_default2 : function(func, string2) {
  return defineProperty_default(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant_default6(string2),
    "writable": true
  });
};
var baseSetToString_default = baseSetToString;

// node_modules/lodash-es/_setToString.js
var setToString = shortOut_default(baseSetToString_default);
var setToString_default = setToString;

// node_modules/lodash-es/_arrayEach.js
function arrayEach(array4, iteratee2) {
  var index8 = -1, length2 = array4 == null ? 0 : array4.length;
  while (++index8 < length2) {
    if (iteratee2(array4[index8], index8, array4) === false) {
      break;
    }
  }
  return array4;
}
var arrayEach_default = arrayEach;

// node_modules/lodash-es/_baseFindIndex.js
function baseFindIndex(array4, predicate, fromIndex, fromRight) {
  var length2 = array4.length, index8 = fromIndex + (fromRight ? 1 : -1);
  while (fromRight ? index8-- : ++index8 < length2) {
    if (predicate(array4[index8], index8, array4)) {
      return index8;
    }
  }
  return -1;
}
var baseFindIndex_default = baseFindIndex;

// node_modules/lodash-es/_baseIsNaN.js
function baseIsNaN(value) {
  return value !== value;
}
var baseIsNaN_default = baseIsNaN;

// node_modules/lodash-es/_strictIndexOf.js
function strictIndexOf(array4, value, fromIndex) {
  var index8 = fromIndex - 1, length2 = array4.length;
  while (++index8 < length2) {
    if (array4[index8] === value) {
      return index8;
    }
  }
  return -1;
}
var strictIndexOf_default = strictIndexOf;

// node_modules/lodash-es/_baseIndexOf.js
function baseIndexOf(array4, value, fromIndex) {
  return value === value ? strictIndexOf_default(array4, value, fromIndex) : baseFindIndex_default(array4, baseIsNaN_default, fromIndex);
}
var baseIndexOf_default = baseIndexOf;

// node_modules/lodash-es/_arrayIncludes.js
function arrayIncludes(array4, value) {
  var length2 = array4 == null ? 0 : array4.length;
  return !!length2 && baseIndexOf_default(array4, value, 0) > -1;
}
var arrayIncludes_default = arrayIncludes;

// node_modules/lodash-es/_updateWrapDetails.js
var WRAP_BIND_FLAG2 = 1;
var WRAP_BIND_KEY_FLAG = 2;
var WRAP_CURRY_FLAG = 8;
var WRAP_CURRY_RIGHT_FLAG = 16;
var WRAP_PARTIAL_FLAG = 32;
var WRAP_PARTIAL_RIGHT_FLAG = 64;
var WRAP_ARY_FLAG = 128;
var WRAP_REARG_FLAG = 256;
var WRAP_FLIP_FLAG = 512;
var wrapFlags = [
  ["ary", WRAP_ARY_FLAG],
  ["bind", WRAP_BIND_FLAG2],
  ["bindKey", WRAP_BIND_KEY_FLAG],
  ["curry", WRAP_CURRY_FLAG],
  ["curryRight", WRAP_CURRY_RIGHT_FLAG],
  ["flip", WRAP_FLIP_FLAG],
  ["partial", WRAP_PARTIAL_FLAG],
  ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
  ["rearg", WRAP_REARG_FLAG]
];
function updateWrapDetails(details, bitmask) {
  arrayEach_default(wrapFlags, function(pair) {
    var value = "_." + pair[0];
    if (bitmask & pair[1] && !arrayIncludes_default(details, value)) {
      details.push(value);
    }
  });
  return details.sort();
}
var updateWrapDetails_default = updateWrapDetails;

// node_modules/lodash-es/_setWrapToString.js
function setWrapToString(wrapper, reference2, bitmask) {
  var source = reference2 + "";
  return setToString_default(wrapper, insertWrapDetails_default(source, updateWrapDetails_default(getWrapDetails_default(source), bitmask)));
}
var setWrapToString_default = setWrapToString;

// node_modules/lodash-es/_createRecurry.js
var WRAP_BIND_FLAG3 = 1;
var WRAP_BIND_KEY_FLAG2 = 2;
var WRAP_CURRY_BOUND_FLAG = 4;
var WRAP_CURRY_FLAG2 = 8;
var WRAP_PARTIAL_FLAG2 = 32;
var WRAP_PARTIAL_RIGHT_FLAG2 = 64;
function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
  var isCurry = bitmask & WRAP_CURRY_FLAG2, newHolders = isCurry ? holders : void 0, newHoldersRight = isCurry ? void 0 : holders, newPartials = isCurry ? partials : void 0, newPartialsRight = isCurry ? void 0 : partials;
  bitmask |= isCurry ? WRAP_PARTIAL_FLAG2 : WRAP_PARTIAL_RIGHT_FLAG2;
  bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG2 : WRAP_PARTIAL_FLAG2);
  if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
    bitmask &= ~(WRAP_BIND_FLAG3 | WRAP_BIND_KEY_FLAG2);
  }
  var newData = [
    func,
    bitmask,
    thisArg,
    newPartials,
    newHolders,
    newPartialsRight,
    newHoldersRight,
    argPos,
    ary2,
    arity
  ];
  var result2 = wrapFunc.apply(void 0, newData);
  if (isLaziable_default(func)) {
    setData_default(result2, newData);
  }
  result2.placeholder = placeholder;
  return setWrapToString_default(result2, func, bitmask);
}
var createRecurry_default = createRecurry;

// node_modules/lodash-es/_getHolder.js
function getHolder(func) {
  var object = func;
  return object.placeholder;
}
var getHolder_default = getHolder;

// node_modules/lodash-es/_isIndex.js
var MAX_SAFE_INTEGER = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length2) {
  var type = typeof value;
  length2 = length2 == null ? MAX_SAFE_INTEGER : length2;
  return !!length2 && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
}
var isIndex_default = isIndex;

// node_modules/lodash-es/_reorder.js
var nativeMin2 = Math.min;
function reorder(array4, indexes2) {
  var arrLength = array4.length, length2 = nativeMin2(indexes2.length, arrLength), oldArray = copyArray_default(array4);
  while (length2--) {
    var index8 = indexes2[length2];
    array4[length2] = isIndex_default(index8, arrLength) ? oldArray[index8] : void 0;
  }
  return array4;
}
var reorder_default = reorder;

// node_modules/lodash-es/_replaceHolders.js
var PLACEHOLDER = "__lodash_placeholder__";
function replaceHolders(array4, placeholder) {
  var index8 = -1, length2 = array4.length, resIndex = 0, result2 = [];
  while (++index8 < length2) {
    var value = array4[index8];
    if (value === placeholder || value === PLACEHOLDER) {
      array4[index8] = PLACEHOLDER;
      result2[resIndex++] = index8;
    }
  }
  return result2;
}
var replaceHolders_default = replaceHolders;

// node_modules/lodash-es/_createHybrid.js
var WRAP_BIND_FLAG4 = 1;
var WRAP_BIND_KEY_FLAG3 = 2;
var WRAP_CURRY_FLAG3 = 8;
var WRAP_CURRY_RIGHT_FLAG2 = 16;
var WRAP_ARY_FLAG2 = 128;
var WRAP_FLIP_FLAG2 = 512;
function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
  var isAry = bitmask & WRAP_ARY_FLAG2, isBind = bitmask & WRAP_BIND_FLAG4, isBindKey = bitmask & WRAP_BIND_KEY_FLAG3, isCurried = bitmask & (WRAP_CURRY_FLAG3 | WRAP_CURRY_RIGHT_FLAG2), isFlip = bitmask & WRAP_FLIP_FLAG2, Ctor = isBindKey ? void 0 : createCtor_default(func);
  function wrapper() {
    var length2 = arguments.length, args = Array(length2), index8 = length2;
    while (index8--) {
      args[index8] = arguments[index8];
    }
    if (isCurried) {
      var placeholder = getHolder_default(wrapper), holdersCount = countHolders_default(args, placeholder);
    }
    if (partials) {
      args = composeArgs_default(args, partials, holders, isCurried);
    }
    if (partialsRight) {
      args = composeArgsRight_default(args, partialsRight, holdersRight, isCurried);
    }
    length2 -= holdersCount;
    if (isCurried && length2 < arity) {
      var newHolders = replaceHolders_default(args, placeholder);
      return createRecurry_default(
        func,
        bitmask,
        createHybrid,
        wrapper.placeholder,
        thisArg,
        args,
        newHolders,
        argPos,
        ary2,
        arity - length2
      );
    }
    var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
    length2 = args.length;
    if (argPos) {
      args = reorder_default(args, argPos);
    } else if (isFlip && length2 > 1) {
      args.reverse();
    }
    if (isAry && ary2 < length2) {
      args.length = ary2;
    }
    if (this && this !== root_default4 && this instanceof wrapper) {
      fn = Ctor || createCtor_default(fn);
    }
    return fn.apply(thisBinding, args);
  }
  return wrapper;
}
var createHybrid_default = createHybrid;

// node_modules/lodash-es/_createCurry.js
function createCurry(func, bitmask, arity) {
  var Ctor = createCtor_default(func);
  function wrapper() {
    var length2 = arguments.length, args = Array(length2), index8 = length2, placeholder = getHolder_default(wrapper);
    while (index8--) {
      args[index8] = arguments[index8];
    }
    var holders = length2 < 3 && args[0] !== placeholder && args[length2 - 1] !== placeholder ? [] : replaceHolders_default(args, placeholder);
    length2 -= holders.length;
    if (length2 < arity) {
      return createRecurry_default(
        func,
        bitmask,
        createHybrid_default,
        wrapper.placeholder,
        void 0,
        args,
        holders,
        void 0,
        void 0,
        arity - length2
      );
    }
    var fn = this && this !== root_default4 && this instanceof wrapper ? Ctor : func;
    return apply_default(fn, this, args);
  }
  return wrapper;
}
var createCurry_default = createCurry;

// node_modules/lodash-es/_createPartial.js
var WRAP_BIND_FLAG5 = 1;
function createPartial(func, bitmask, thisArg, partials) {
  var isBind = bitmask & WRAP_BIND_FLAG5, Ctor = createCtor_default(func);
  function wrapper() {
    var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength), fn = this && this !== root_default4 && this instanceof wrapper ? Ctor : func;
    while (++leftIndex < leftLength) {
      args[leftIndex] = partials[leftIndex];
    }
    while (argsLength--) {
      args[leftIndex++] = arguments[++argsIndex];
    }
    return apply_default(fn, isBind ? thisArg : this, args);
  }
  return wrapper;
}
var createPartial_default = createPartial;

// node_modules/lodash-es/_mergeData.js
var PLACEHOLDER2 = "__lodash_placeholder__";
var WRAP_BIND_FLAG6 = 1;
var WRAP_BIND_KEY_FLAG4 = 2;
var WRAP_CURRY_BOUND_FLAG2 = 4;
var WRAP_CURRY_FLAG4 = 8;
var WRAP_ARY_FLAG3 = 128;
var WRAP_REARG_FLAG2 = 256;
var nativeMin3 = Math.min;
function mergeData(data, source) {
  var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG6 | WRAP_BIND_KEY_FLAG4 | WRAP_ARY_FLAG3);
  var isCombo = srcBitmask == WRAP_ARY_FLAG3 && bitmask == WRAP_CURRY_FLAG4 || srcBitmask == WRAP_ARY_FLAG3 && bitmask == WRAP_REARG_FLAG2 && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG3 | WRAP_REARG_FLAG2) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG4;
  if (!(isCommon || isCombo)) {
    return data;
  }
  if (srcBitmask & WRAP_BIND_FLAG6) {
    data[2] = source[2];
    newBitmask |= bitmask & WRAP_BIND_FLAG6 ? 0 : WRAP_CURRY_BOUND_FLAG2;
  }
  var value = source[3];
  if (value) {
    var partials = data[3];
    data[3] = partials ? composeArgs_default(partials, value, source[4]) : value;
    data[4] = partials ? replaceHolders_default(data[3], PLACEHOLDER2) : source[4];
  }
  value = source[5];
  if (value) {
    partials = data[5];
    data[5] = partials ? composeArgsRight_default(partials, value, source[6]) : value;
    data[6] = partials ? replaceHolders_default(data[5], PLACEHOLDER2) : source[6];
  }
  value = source[7];
  if (value) {
    data[7] = value;
  }
  if (srcBitmask & WRAP_ARY_FLAG3) {
    data[8] = data[8] == null ? source[8] : nativeMin3(data[8], source[8]);
  }
  if (data[9] == null) {
    data[9] = source[9];
  }
  data[0] = source[0];
  data[1] = newBitmask;
  return data;
}
var mergeData_default = mergeData;

// node_modules/lodash-es/_createWrap.js
var FUNC_ERROR_TEXT3 = "Expected a function";
var WRAP_BIND_FLAG7 = 1;
var WRAP_BIND_KEY_FLAG5 = 2;
var WRAP_CURRY_FLAG5 = 8;
var WRAP_CURRY_RIGHT_FLAG3 = 16;
var WRAP_PARTIAL_FLAG3 = 32;
var WRAP_PARTIAL_RIGHT_FLAG3 = 64;
var nativeMax4 = Math.max;
function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
  var isBindKey = bitmask & WRAP_BIND_KEY_FLAG5;
  if (!isBindKey && typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT3);
  }
  var length2 = partials ? partials.length : 0;
  if (!length2) {
    bitmask &= ~(WRAP_PARTIAL_FLAG3 | WRAP_PARTIAL_RIGHT_FLAG3);
    partials = holders = void 0;
  }
  ary2 = ary2 === void 0 ? ary2 : nativeMax4(toInteger_default(ary2), 0);
  arity = arity === void 0 ? arity : toInteger_default(arity);
  length2 -= holders ? holders.length : 0;
  if (bitmask & WRAP_PARTIAL_RIGHT_FLAG3) {
    var partialsRight = partials, holdersRight = holders;
    partials = holders = void 0;
  }
  var data = isBindKey ? void 0 : getData_default(func);
  var newData = [
    func,
    bitmask,
    thisArg,
    partials,
    holders,
    partialsRight,
    holdersRight,
    argPos,
    ary2,
    arity
  ];
  if (data) {
    mergeData_default(newData, data);
  }
  func = newData[0];
  bitmask = newData[1];
  thisArg = newData[2];
  partials = newData[3];
  holders = newData[4];
  arity = newData[9] = newData[9] === void 0 ? isBindKey ? 0 : func.length : nativeMax4(newData[9] - length2, 0);
  if (!arity && bitmask & (WRAP_CURRY_FLAG5 | WRAP_CURRY_RIGHT_FLAG3)) {
    bitmask &= ~(WRAP_CURRY_FLAG5 | WRAP_CURRY_RIGHT_FLAG3);
  }
  if (!bitmask || bitmask == WRAP_BIND_FLAG7) {
    var result2 = createBind_default(func, bitmask, thisArg);
  } else if (bitmask == WRAP_CURRY_FLAG5 || bitmask == WRAP_CURRY_RIGHT_FLAG3) {
    result2 = createCurry_default(func, bitmask, arity);
  } else if ((bitmask == WRAP_PARTIAL_FLAG3 || bitmask == (WRAP_BIND_FLAG7 | WRAP_PARTIAL_FLAG3)) && !holders.length) {
    result2 = createPartial_default(func, bitmask, thisArg, partials);
  } else {
    result2 = createHybrid_default.apply(void 0, newData);
  }
  var setter = data ? baseSetData_default : setData_default;
  return setWrapToString_default(setter(result2, newData), func, bitmask);
}
var createWrap_default = createWrap;

// node_modules/lodash-es/ary.js
var WRAP_ARY_FLAG4 = 128;
function ary(func, n2, guard2) {
  n2 = guard2 ? void 0 : n2;
  n2 = func && n2 == null ? func.length : n2;
  return createWrap_default(func, WRAP_ARY_FLAG4, void 0, void 0, void 0, void 0, n2);
}
var ary_default = ary;

// node_modules/lodash-es/_baseAssignValue.js
function baseAssignValue(object, key, value) {
  if (key == "__proto__" && defineProperty_default) {
    defineProperty_default(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
var baseAssignValue_default = baseAssignValue;

// node_modules/lodash-es/eq.js
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_default = eq;

// node_modules/lodash-es/_assignValue.js
var objectProto6 = Object.prototype;
var hasOwnProperty5 = objectProto6.hasOwnProperty;
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty5.call(object, key) && eq_default(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue_default(object, key, value);
  }
}
var assignValue_default = assignValue;

// node_modules/lodash-es/_copyObject.js
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index8 = -1, length2 = props.length;
  while (++index8 < length2) {
    var key = props[index8];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue_default(object, key, newValue);
    } else {
      assignValue_default(object, key, newValue);
    }
  }
  return object;
}
var copyObject_default = copyObject;

// node_modules/lodash-es/_overRest.js
var nativeMax5 = Math.max;
function overRest(func, start2, transform3) {
  start2 = nativeMax5(start2 === void 0 ? func.length - 1 : start2, 0);
  return function() {
    var args = arguments, index8 = -1, length2 = nativeMax5(args.length - start2, 0), array4 = Array(length2);
    while (++index8 < length2) {
      array4[index8] = args[start2 + index8];
    }
    index8 = -1;
    var otherArgs = Array(start2 + 1);
    while (++index8 < start2) {
      otherArgs[index8] = args[index8];
    }
    otherArgs[start2] = transform3(array4);
    return apply_default(func, this, otherArgs);
  };
}
var overRest_default = overRest;

// node_modules/lodash-es/_baseRest.js
function baseRest(func, start2) {
  return setToString_default(overRest_default(func, start2, identity_default2), func + "");
}
var baseRest_default = baseRest;

// node_modules/lodash-es/isLength.js
var MAX_SAFE_INTEGER2 = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
}
var isLength_default = isLength;

// node_modules/lodash-es/isArrayLike.js
function isArrayLike(value) {
  return value != null && isLength_default(value.length) && !isFunction_default(value);
}
var isArrayLike_default = isArrayLike;

// node_modules/lodash-es/_isIterateeCall.js
function isIterateeCall(value, index8, object) {
  if (!isObject_default(object)) {
    return false;
  }
  var type = typeof index8;
  if (type == "number" ? isArrayLike_default(object) && isIndex_default(index8, object.length) : type == "string" && index8 in object) {
    return eq_default(object[index8], value);
  }
  return false;
}
var isIterateeCall_default = isIterateeCall;

// node_modules/lodash-es/_createAssigner.js
function createAssigner(assigner) {
  return baseRest_default(function(object, sources) {
    var index8 = -1, length2 = sources.length, customizer = length2 > 1 ? sources[length2 - 1] : void 0, guard2 = length2 > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length2--, customizer) : void 0;
    if (guard2 && isIterateeCall_default(sources[0], sources[1], guard2)) {
      customizer = length2 < 3 ? void 0 : customizer;
      length2 = 1;
    }
    object = Object(object);
    while (++index8 < length2) {
      var source = sources[index8];
      if (source) {
        assigner(object, source, index8, customizer);
      }
    }
    return object;
  });
}
var createAssigner_default = createAssigner;

// node_modules/lodash-es/_isPrototype.js
var objectProto7 = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto7;
  return value === proto2;
}
var isPrototype_default = isPrototype;

// node_modules/lodash-es/_baseTimes.js
function baseTimes(n2, iteratee2) {
  var index8 = -1, result2 = Array(n2);
  while (++index8 < n2) {
    result2[index8] = iteratee2(index8);
  }
  return result2;
}
var baseTimes_default = baseTimes;

// node_modules/lodash-es/_baseIsArguments.js
var argsTag = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == argsTag;
}
var baseIsArguments_default = baseIsArguments;

// node_modules/lodash-es/isArguments.js
var objectProto8 = Object.prototype;
var hasOwnProperty6 = objectProto8.hasOwnProperty;
var propertyIsEnumerable = objectProto8.propertyIsEnumerable;
var isArguments = baseIsArguments_default(/* @__PURE__ */ (function() {
  return arguments;
})()) ? baseIsArguments_default : function(value) {
  return isObjectLike_default(value) && hasOwnProperty6.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
};
var isArguments_default = isArguments;

// node_modules/lodash-es/stubFalse.js
function stubFalse() {
  return false;
}
var stubFalse_default = stubFalse;

// node_modules/lodash-es/isBuffer.js
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer2 = moduleExports ? root_default4.Buffer : void 0;
var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse_default;
var isBuffer_default = isBuffer;

// node_modules/lodash-es/_baseIsTypedArray.js
var argsTag2 = "[object Arguments]";
var arrayTag = "[object Array]";
var boolTag = "[object Boolean]";
var dateTag = "[object Date]";
var errorTag = "[object Error]";
var funcTag2 = "[object Function]";
var mapTag = "[object Map]";
var numberTag = "[object Number]";
var objectTag = "[object Object]";
var regexpTag = "[object RegExp]";
var setTag = "[object Set]";
var stringTag = "[object String]";
var weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag2] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag2] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
function baseIsTypedArray(value) {
  return isObjectLike_default(value) && isLength_default(value.length) && !!typedArrayTags[baseGetTag_default(value)];
}
var baseIsTypedArray_default = baseIsTypedArray;

// node_modules/lodash-es/_baseUnary.js
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
var baseUnary_default = baseUnary;

// node_modules/lodash-es/_nodeUtil.js
var freeExports2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule2 = freeExports2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
var freeProcess = moduleExports2 && freeGlobal_default.process;
var nodeUtil = (function() {
  try {
    var types = freeModule2 && freeModule2.require && freeModule2.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e3) {
  }
})();
var nodeUtil_default = nodeUtil;

// node_modules/lodash-es/isTypedArray.js
var nodeIsTypedArray = nodeUtil_default && nodeUtil_default.isTypedArray;
var isTypedArray3 = nodeIsTypedArray ? baseUnary_default(nodeIsTypedArray) : baseIsTypedArray_default;
var isTypedArray_default = isTypedArray3;

// node_modules/lodash-es/_arrayLikeKeys.js
var objectProto9 = Object.prototype;
var hasOwnProperty7 = objectProto9.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray_default(value), isArg = !isArr && isArguments_default(value), isBuff = !isArr && !isArg && isBuffer_default(value), isType = !isArr && !isArg && !isBuff && isTypedArray_default(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes_default(value.length, String) : [], length2 = result2.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty7.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex_default(key, length2)))) {
      result2.push(key);
    }
  }
  return result2;
}
var arrayLikeKeys_default = arrayLikeKeys;

// node_modules/lodash-es/_overArg.js
function overArg(func, transform3) {
  return function(arg) {
    return func(transform3(arg));
  };
}
var overArg_default = overArg;

// node_modules/lodash-es/_nativeKeys.js
var nativeKeys = overArg_default(Object.keys, Object);
var nativeKeys_default = nativeKeys;

// node_modules/lodash-es/_baseKeys.js
var objectProto10 = Object.prototype;
var hasOwnProperty8 = objectProto10.hasOwnProperty;
function baseKeys(object) {
  if (!isPrototype_default(object)) {
    return nativeKeys_default(object);
  }
  var result2 = [];
  for (var key in Object(object)) {
    if (hasOwnProperty8.call(object, key) && key != "constructor") {
      result2.push(key);
    }
  }
  return result2;
}
var baseKeys_default = baseKeys;

// node_modules/lodash-es/keys.js
function keys(object) {
  return isArrayLike_default(object) ? arrayLikeKeys_default(object) : baseKeys_default(object);
}
var keys_default = keys;

// node_modules/lodash-es/assign.js
var objectProto11 = Object.prototype;
var hasOwnProperty9 = objectProto11.hasOwnProperty;
var assign2 = createAssigner_default(function(object, source) {
  if (isPrototype_default(source) || isArrayLike_default(source)) {
    copyObject_default(source, keys_default(source), object);
    return;
  }
  for (var key in source) {
    if (hasOwnProperty9.call(source, key)) {
      assignValue_default(object, key, source[key]);
    }
  }
});
var assign_default = assign2;

// node_modules/lodash-es/_nativeKeysIn.js
function nativeKeysIn(object) {
  var result2 = [];
  if (object != null) {
    for (var key in Object(object)) {
      result2.push(key);
    }
  }
  return result2;
}
var nativeKeysIn_default = nativeKeysIn;

// node_modules/lodash-es/_baseKeysIn.js
var objectProto12 = Object.prototype;
var hasOwnProperty10 = objectProto12.hasOwnProperty;
function baseKeysIn(object) {
  if (!isObject_default(object)) {
    return nativeKeysIn_default(object);
  }
  var isProto = isPrototype_default(object), result2 = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty10.call(object, key)))) {
      result2.push(key);
    }
  }
  return result2;
}
var baseKeysIn_default = baseKeysIn;

// node_modules/lodash-es/keysIn.js
function keysIn(object) {
  return isArrayLike_default(object) ? arrayLikeKeys_default(object, true) : baseKeysIn_default(object);
}
var keysIn_default = keysIn;

// node_modules/lodash-es/assignIn.js
var assignIn = createAssigner_default(function(object, source) {
  copyObject_default(source, keysIn_default(source), object);
});
var assignIn_default = assignIn;

// node_modules/lodash-es/assignInWith.js
var assignInWith = createAssigner_default(function(object, source, srcIndex, customizer) {
  copyObject_default(source, keysIn_default(source), object, customizer);
});
var assignInWith_default = assignInWith;

// node_modules/lodash-es/assignWith.js
var assignWith = createAssigner_default(function(object, source, srcIndex, customizer) {
  copyObject_default(source, keys_default(source), object, customizer);
});
var assignWith_default = assignWith;

// node_modules/lodash-es/_isKey.js
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
function isKey(value, object) {
  if (isArray_default(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol_default(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var isKey_default = isKey;

// node_modules/lodash-es/_nativeCreate.js
var nativeCreate = getNative_default(Object, "create");
var nativeCreate_default = nativeCreate;

// node_modules/lodash-es/_hashClear.js
function hashClear() {
  this.__data__ = nativeCreate_default ? nativeCreate_default(null) : {};
  this.size = 0;
}
var hashClear_default = hashClear;

// node_modules/lodash-es/_hashDelete.js
function hashDelete(key) {
  var result2 = this.has(key) && delete this.__data__[key];
  this.size -= result2 ? 1 : 0;
  return result2;
}
var hashDelete_default = hashDelete;

// node_modules/lodash-es/_hashGet.js
var HASH_UNDEFINED = "__lodash_hash_undefined__";
var objectProto13 = Object.prototype;
var hasOwnProperty11 = objectProto13.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate_default) {
    var result2 = data[key];
    return result2 === HASH_UNDEFINED ? void 0 : result2;
  }
  return hasOwnProperty11.call(data, key) ? data[key] : void 0;
}
var hashGet_default = hashGet;

// node_modules/lodash-es/_hashHas.js
var objectProto14 = Object.prototype;
var hasOwnProperty12 = objectProto14.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate_default ? data[key] !== void 0 : hasOwnProperty12.call(data, key);
}
var hashHas_default = hashHas;

// node_modules/lodash-es/_hashSet.js
var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate_default && value === void 0 ? HASH_UNDEFINED2 : value;
  return this;
}
var hashSet_default = hashSet;

// node_modules/lodash-es/_Hash.js
function Hash(entries) {
  var index8 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index8 < length2) {
    var entry = entries[index8];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear_default;
Hash.prototype["delete"] = hashDelete_default;
Hash.prototype.get = hashGet_default;
Hash.prototype.has = hashHas_default;
Hash.prototype.set = hashSet_default;
var Hash_default = Hash;

// node_modules/lodash-es/_listCacheClear.js
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
var listCacheClear_default = listCacheClear;

// node_modules/lodash-es/_assocIndexOf.js
function assocIndexOf(array4, key) {
  var length2 = array4.length;
  while (length2--) {
    if (eq_default(array4[length2][0], key)) {
      return length2;
    }
  }
  return -1;
}
var assocIndexOf_default = assocIndexOf;

// node_modules/lodash-es/_listCacheDelete.js
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data = this.__data__, index8 = assocIndexOf_default(data, key);
  if (index8 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index8 == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index8, 1);
  }
  --this.size;
  return true;
}
var listCacheDelete_default = listCacheDelete;

// node_modules/lodash-es/_listCacheGet.js
function listCacheGet(key) {
  var data = this.__data__, index8 = assocIndexOf_default(data, key);
  return index8 < 0 ? void 0 : data[index8][1];
}
var listCacheGet_default = listCacheGet;

// node_modules/lodash-es/_listCacheHas.js
function listCacheHas(key) {
  return assocIndexOf_default(this.__data__, key) > -1;
}
var listCacheHas_default = listCacheHas;

// node_modules/lodash-es/_listCacheSet.js
function listCacheSet(key, value) {
  var data = this.__data__, index8 = assocIndexOf_default(data, key);
  if (index8 < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index8][1] = value;
  }
  return this;
}
var listCacheSet_default = listCacheSet;

// node_modules/lodash-es/_ListCache.js
function ListCache(entries) {
  var index8 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index8 < length2) {
    var entry = entries[index8];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear_default;
ListCache.prototype["delete"] = listCacheDelete_default;
ListCache.prototype.get = listCacheGet_default;
ListCache.prototype.has = listCacheHas_default;
ListCache.prototype.set = listCacheSet_default;
var ListCache_default = ListCache;

// node_modules/lodash-es/_Map.js
var Map2 = getNative_default(root_default4, "Map");
var Map_default = Map2;

// node_modules/lodash-es/_mapCacheClear.js
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash_default(),
    "map": new (Map_default || ListCache_default)(),
    "string": new Hash_default()
  };
}
var mapCacheClear_default = mapCacheClear;

// node_modules/lodash-es/_isKeyable.js
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
var isKeyable_default = isKeyable;

// node_modules/lodash-es/_getMapData.js
function getMapData(map6, key) {
  var data = map6.__data__;
  return isKeyable_default(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var getMapData_default = getMapData;

// node_modules/lodash-es/_mapCacheDelete.js
function mapCacheDelete(key) {
  var result2 = getMapData_default(this, key)["delete"](key);
  this.size -= result2 ? 1 : 0;
  return result2;
}
var mapCacheDelete_default = mapCacheDelete;

// node_modules/lodash-es/_mapCacheGet.js
function mapCacheGet(key) {
  return getMapData_default(this, key).get(key);
}
var mapCacheGet_default = mapCacheGet;

// node_modules/lodash-es/_mapCacheHas.js
function mapCacheHas(key) {
  return getMapData_default(this, key).has(key);
}
var mapCacheHas_default = mapCacheHas;

// node_modules/lodash-es/_mapCacheSet.js
function mapCacheSet(key, value) {
  var data = getMapData_default(this, key), size2 = data.size;
  data.set(key, value);
  this.size += data.size == size2 ? 0 : 1;
  return this;
}
var mapCacheSet_default = mapCacheSet;

// node_modules/lodash-es/_MapCache.js
function MapCache(entries) {
  var index8 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index8 < length2) {
    var entry = entries[index8];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear_default;
MapCache.prototype["delete"] = mapCacheDelete_default;
MapCache.prototype.get = mapCacheGet_default;
MapCache.prototype.has = mapCacheHas_default;
MapCache.prototype.set = mapCacheSet_default;
var MapCache_default = MapCache;

// node_modules/lodash-es/memoize.js
var FUNC_ERROR_TEXT4 = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT4);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
    if (cache2.has(key)) {
      return cache2.get(key);
    }
    var result2 = func.apply(this, args);
    memoized.cache = cache2.set(key, result2) || cache2;
    return result2;
  };
  memoized.cache = new (memoize.Cache || MapCache_default)();
  return memoized;
}
memoize.Cache = MapCache_default;
var memoize_default = memoize;

// node_modules/lodash-es/_memoizeCapped.js
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result2 = memoize_default(func, function(key) {
    if (cache2.size === MAX_MEMOIZE_SIZE) {
      cache2.clear();
    }
    return key;
  });
  var cache2 = result2.cache;
  return result2;
}
var memoizeCapped_default = memoizeCapped;

// node_modules/lodash-es/_stringToPath.js
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped_default(function(string2) {
  var result2 = [];
  if (string2.charCodeAt(0) === 46) {
    result2.push("");
  }
  string2.replace(rePropName, function(match, number3, quote, subString) {
    result2.push(quote ? subString.replace(reEscapeChar, "$1") : number3 || match);
  });
  return result2;
});
var stringToPath_default = stringToPath;

// node_modules/lodash-es/toString.js
function toString2(value) {
  return value == null ? "" : baseToString_default(value);
}
var toString_default = toString2;

// node_modules/lodash-es/_castPath.js
function castPath(value, object) {
  if (isArray_default(value)) {
    return value;
  }
  return isKey_default(value, object) ? [value] : stringToPath_default(toString_default(value));
}
var castPath_default = castPath;

// node_modules/lodash-es/_toKey.js
var INFINITY4 = 1 / 0;
function toKey(value) {
  if (typeof value == "string" || isSymbol_default(value)) {
    return value;
  }
  var result2 = value + "";
  return result2 == "0" && 1 / value == -INFINITY4 ? "-0" : result2;
}
var toKey_default = toKey;

// node_modules/lodash-es/_baseGet.js
function baseGet(object, path) {
  path = castPath_default(path, object);
  var index8 = 0, length2 = path.length;
  while (object != null && index8 < length2) {
    object = object[toKey_default(path[index8++])];
  }
  return index8 && index8 == length2 ? object : void 0;
}
var baseGet_default = baseGet;

// node_modules/lodash-es/get.js
function get3(object, path, defaultValue) {
  var result2 = object == null ? void 0 : baseGet_default(object, path);
  return result2 === void 0 ? defaultValue : result2;
}
var get_default = get3;

// node_modules/lodash-es/_baseAt.js
function baseAt(object, paths) {
  var index8 = -1, length2 = paths.length, result2 = Array(length2), skip = object == null;
  while (++index8 < length2) {
    result2[index8] = skip ? void 0 : get_default(object, paths[index8]);
  }
  return result2;
}
var baseAt_default = baseAt;

// node_modules/lodash-es/_arrayPush.js
function arrayPush(array4, values2) {
  var index8 = -1, length2 = values2.length, offset = array4.length;
  while (++index8 < length2) {
    array4[offset + index8] = values2[index8];
  }
  return array4;
}
var arrayPush_default = arrayPush;

// node_modules/lodash-es/_isFlattenable.js
var spreadableSymbol = Symbol_default ? Symbol_default.isConcatSpreadable : void 0;
function isFlattenable(value) {
  return isArray_default(value) || isArguments_default(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
var isFlattenable_default = isFlattenable;

// node_modules/lodash-es/_baseFlatten.js
function baseFlatten(array4, depth2, predicate, isStrict, result2) {
  var index8 = -1, length2 = array4.length;
  predicate || (predicate = isFlattenable_default);
  result2 || (result2 = []);
  while (++index8 < length2) {
    var value = array4[index8];
    if (depth2 > 0 && predicate(value)) {
      if (depth2 > 1) {
        baseFlatten(value, depth2 - 1, predicate, isStrict, result2);
      } else {
        arrayPush_default(result2, value);
      }
    } else if (!isStrict) {
      result2[result2.length] = value;
    }
  }
  return result2;
}
var baseFlatten_default = baseFlatten;

// node_modules/lodash-es/flatten.js
function flatten(array4) {
  var length2 = array4 == null ? 0 : array4.length;
  return length2 ? baseFlatten_default(array4, 1) : [];
}
var flatten_default = flatten;

// node_modules/lodash-es/_flatRest.js
function flatRest(func) {
  return setToString_default(overRest_default(func, void 0, flatten_default), func + "");
}
var flatRest_default = flatRest;

// node_modules/lodash-es/at.js
var at = flatRest_default(baseAt_default);
var at_default = at;

// node_modules/lodash-es/_getPrototype.js
var getPrototype = overArg_default(Object.getPrototypeOf, Object);
var getPrototype_default = getPrototype;

// node_modules/lodash-es/isPlainObject.js
var objectTag2 = "[object Object]";
var funcProto3 = Function.prototype;
var objectProto15 = Object.prototype;
var funcToString3 = funcProto3.toString;
var hasOwnProperty13 = objectProto15.hasOwnProperty;
var objectCtorString = funcToString3.call(Object);
function isPlainObject(value) {
  if (!isObjectLike_default(value) || baseGetTag_default(value) != objectTag2) {
    return false;
  }
  var proto2 = getPrototype_default(value);
  if (proto2 === null) {
    return true;
  }
  var Ctor = hasOwnProperty13.call(proto2, "constructor") && proto2.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString3.call(Ctor) == objectCtorString;
}
var isPlainObject_default = isPlainObject;

// node_modules/lodash-es/isError.js
var domExcTag = "[object DOMException]";
var errorTag2 = "[object Error]";
function isError(value) {
  if (!isObjectLike_default(value)) {
    return false;
  }
  var tag = baseGetTag_default(value);
  return tag == errorTag2 || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject_default(value);
}
var isError_default = isError;

// node_modules/lodash-es/attempt.js
var attempt = baseRest_default(function(func, args) {
  try {
    return apply_default(func, void 0, args);
  } catch (e3) {
    return isError_default(e3) ? e3 : new Error(e3);
  }
});
var attempt_default = attempt;

// node_modules/lodash-es/before.js
var FUNC_ERROR_TEXT5 = "Expected a function";
function before(n2, func) {
  var result2;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT5);
  }
  n2 = toInteger_default(n2);
  return function() {
    if (--n2 > 0) {
      result2 = func.apply(this, arguments);
    }
    if (n2 <= 1) {
      func = void 0;
    }
    return result2;
  };
}
var before_default = before;

// node_modules/lodash-es/bind.js
var WRAP_BIND_FLAG8 = 1;
var WRAP_PARTIAL_FLAG4 = 32;
var bind = baseRest_default(function(func, thisArg, partials) {
  var bitmask = WRAP_BIND_FLAG8;
  if (partials.length) {
    var holders = replaceHolders_default(partials, getHolder_default(bind));
    bitmask |= WRAP_PARTIAL_FLAG4;
  }
  return createWrap_default(func, bitmask, thisArg, partials, holders);
});
bind.placeholder = {};
var bind_default = bind;

// node_modules/lodash-es/bindAll.js
var bindAll = flatRest_default(function(object, methodNames) {
  arrayEach_default(methodNames, function(key) {
    key = toKey_default(key);
    baseAssignValue_default(object, key, bind_default(object[key], object));
  });
  return object;
});
var bindAll_default = bindAll;

// node_modules/lodash-es/bindKey.js
var WRAP_BIND_FLAG9 = 1;
var WRAP_BIND_KEY_FLAG6 = 2;
var WRAP_PARTIAL_FLAG5 = 32;
var bindKey2 = baseRest_default(function(object, key, partials) {
  var bitmask = WRAP_BIND_FLAG9 | WRAP_BIND_KEY_FLAG6;
  if (partials.length) {
    var holders = replaceHolders_default(partials, getHolder_default(bindKey2));
    bitmask |= WRAP_PARTIAL_FLAG5;
  }
  return createWrap_default(key, bitmask, object, partials, holders);
});
bindKey2.placeholder = {};
var bindKey_default = bindKey2;

// node_modules/lodash-es/_baseSlice.js
function baseSlice(array4, start2, end) {
  var index8 = -1, length2 = array4.length;
  if (start2 < 0) {
    start2 = -start2 > length2 ? 0 : length2 + start2;
  }
  end = end > length2 ? length2 : end;
  if (end < 0) {
    end += length2;
  }
  length2 = start2 > end ? 0 : end - start2 >>> 0;
  start2 >>>= 0;
  var result2 = Array(length2);
  while (++index8 < length2) {
    result2[index8] = array4[index8 + start2];
  }
  return result2;
}
var baseSlice_default = baseSlice;

// node_modules/lodash-es/_castSlice.js
function castSlice(array4, start2, end) {
  var length2 = array4.length;
  end = end === void 0 ? length2 : end;
  return !start2 && end >= length2 ? array4 : baseSlice_default(array4, start2, end);
}
var castSlice_default = castSlice;

// node_modules/lodash-es/_hasUnicode.js
var rsAstralRange = "\\ud800-\\udfff";
var rsComboMarksRange = "\\u0300-\\u036f";
var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange = "\\u20d0-\\u20ff";
var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
var rsVarRange = "\\ufe0e\\ufe0f";
var rsZWJ = "\\u200d";
var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
function hasUnicode(string2) {
  return reHasUnicode.test(string2);
}
var hasUnicode_default = hasUnicode;

// node_modules/lodash-es/_asciiToArray.js
function asciiToArray(string2) {
  return string2.split("");
}
var asciiToArray_default = asciiToArray;

// node_modules/lodash-es/_unicodeToArray.js
var rsAstralRange2 = "\\ud800-\\udfff";
var rsComboMarksRange2 = "\\u0300-\\u036f";
var reComboHalfMarksRange2 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange2 = "\\u20d0-\\u20ff";
var rsComboRange2 = rsComboMarksRange2 + reComboHalfMarksRange2 + rsComboSymbolsRange2;
var rsVarRange2 = "\\ufe0e\\ufe0f";
var rsAstral = "[" + rsAstralRange2 + "]";
var rsCombo = "[" + rsComboRange2 + "]";
var rsFitz = "\\ud83c[\\udffb-\\udfff]";
var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
var rsNonAstral = "[^" + rsAstralRange2 + "]";
var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsZWJ2 = "\\u200d";
var reOptMod = rsModifier + "?";
var rsOptVar = "[" + rsVarRange2 + "]?";
var rsOptJoin = "(?:" + rsZWJ2 + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
var rsSeq = rsOptVar + reOptMod + rsOptJoin;
var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
function unicodeToArray(string2) {
  return string2.match(reUnicode) || [];
}
var unicodeToArray_default = unicodeToArray;

// node_modules/lodash-es/_stringToArray.js
function stringToArray(string2) {
  return hasUnicode_default(string2) ? unicodeToArray_default(string2) : asciiToArray_default(string2);
}
var stringToArray_default = stringToArray;

// node_modules/lodash-es/_createCaseFirst.js
function createCaseFirst(methodName) {
  return function(string2) {
    string2 = toString_default(string2);
    var strSymbols = hasUnicode_default(string2) ? stringToArray_default(string2) : void 0;
    var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
    var trailing = strSymbols ? castSlice_default(strSymbols, 1).join("") : string2.slice(1);
    return chr[methodName]() + trailing;
  };
}
var createCaseFirst_default = createCaseFirst;

// node_modules/lodash-es/upperFirst.js
var upperFirst = createCaseFirst_default("toUpperCase");
var upperFirst_default = upperFirst;

// node_modules/lodash-es/capitalize.js
function capitalize(string2) {
  return upperFirst_default(toString_default(string2).toLowerCase());
}
var capitalize_default = capitalize;

// node_modules/lodash-es/_arrayReduce.js
function arrayReduce(array4, iteratee2, accumulator, initAccum) {
  var index8 = -1, length2 = array4 == null ? 0 : array4.length;
  if (initAccum && length2) {
    accumulator = array4[++index8];
  }
  while (++index8 < length2) {
    accumulator = iteratee2(accumulator, array4[index8], index8, array4);
  }
  return accumulator;
}
var arrayReduce_default = arrayReduce;

// node_modules/lodash-es/_basePropertyOf.js
function basePropertyOf(object) {
  return function(key) {
    return object == null ? void 0 : object[key];
  };
}
var basePropertyOf_default = basePropertyOf;

// node_modules/lodash-es/_deburrLetter.js
var deburredLetters = {
  // Latin-1 Supplement block.
  "Ã": "A",
  "Ã": "A",
  "Ã": "A",
  "Ã": "A",
  "Ã": "A",
  "Ã": "A",
  "Ã ": "a",
  "Ã¡": "a",
  "Ã¢": "a",
  "Ã£": "a",
  "Ã¤": "a",
  "Ã¥": "a",
  "Ã": "C",
  "Ã§": "c",
  "Ã": "D",
  "Ã°": "d",
  "Ã": "E",
  "Ã": "E",
  "Ã": "E",
  "Ã": "E",
  "Ã¨": "e",
  "Ã©": "e",
  "Ãª": "e",
  "Ã«": "e",
  "Ã": "I",
  "Ã": "I",
  "Ã": "I",
  "Ã": "I",
  "Ã¬": "i",
  "Ã­": "i",
  "Ã®": "i",
  "Ã¯": "i",
  "Ã": "N",
  "Ã±": "n",
  "Ã": "O",
  "Ã": "O",
  "Ã": "O",
  "Ã": "O",
  "Ã": "O",
  "Ã": "O",
  "Ã²": "o",
  "Ã³": "o",
  "Ã´": "o",
  "Ãµ": "o",
  "Ã¶": "o",
  "Ã¸": "o",
  "Ã": "U",
  "Ã": "U",
  "Ã": "U",
  "Ã": "U",
  "Ã¹": "u",
  "Ãº": "u",
  "Ã»": "u",
  "Ã¼": "u",
  "Ã": "Y",
  "Ã½": "y",
  "Ã¿": "y",
  "Ã": "Ae",
  "Ã¦": "ae",
  "Ã": "Th",
  "Ã¾": "th",
  "Ã": "ss",
  // Latin Extended-A block.
  "Ä": "A",
  "Ä": "A",
  "Ä": "A",
  "Ä": "a",
  "Ä": "a",
  "Ä": "a",
  "Ä": "C",
  "Ä": "C",
  "Ä": "C",
  "Ä": "C",
  "Ä": "c",
  "Ä": "c",
  "Ä": "c",
  "Ä": "c",
  "Ä": "D",
  "Ä": "D",
  "Ä": "d",
  "Ä": "d",
  "Ä": "E",
  "Ä": "E",
  "Ä": "E",
  "Ä": "E",
  "Ä": "E",
  "Ä": "e",
  "Ä": "e",
  "Ä": "e",
  "Ä": "e",
  "Ä": "e",
  "Ä": "G",
  "Ä": "G",
  "Ä ": "G",
  "Ä¢": "G",
  "Ä": "g",
  "Ä": "g",
  "Ä¡": "g",
  "Ä£": "g",
  "Ä¤": "H",
  "Ä¦": "H",
  "Ä¥": "h",
  "Ä§": "h",
  "Ä¨": "I",
  "Äª": "I",
  "Ä¬": "I",
  "Ä®": "I",
  "Ä°": "I",
  "Ä©": "i",
  "Ä«": "i",
  "Ä­": "i",
  "Ä¯": "i",
  "Ä±": "i",
  "Ä´": "J",
  "Äµ": "j",
  "Ä¶": "K",
  "Ä·": "k",
  "Ä¸": "k",
  "Ä¹": "L",
  "Ä»": "L",
  "Ä½": "L",
  "Ä¿": "L",
  "Å": "L",
  "Äº": "l",
  "Ä¼": "l",
  "Ä¾": "l",
  "Å": "l",
  "Å": "l",
  "Å": "N",
  "Å": "N",
  "Å": "N",
  "Å": "N",
  "Å": "n",
  "Å": "n",
  "Å": "n",
  "Å": "n",
  "Å": "O",
  "Å": "O",
  "Å": "O",
  "Å": "o",
  "Å": "o",
  "Å": "o",
  "Å": "R",
  "Å": "R",
  "Å": "R",
  "Å": "r",
  "Å": "r",
  "Å": "r",
  "Å": "S",
  "Å": "S",
  "Å": "S",
  "Å ": "S",
  "Å": "s",
  "Å": "s",
  "Å": "s",
  "Å¡": "s",
  "Å¢": "T",
  "Å¤": "T",
  "Å¦": "T",
  "Å£": "t",
  "Å¥": "t",
  "Å§": "t",
  "Å¨": "U",
  "Åª": "U",
  "Å¬": "U",
  "Å®": "U",
  "Å°": "U",
  "Å²": "U",
  "Å©": "u",
  "Å«": "u",
  "Å­": "u",
  "Å¯": "u",
  "Å±": "u",
  "Å³": "u",
  "Å´": "W",
  "Åµ": "w",
  "Å¶": "Y",
  "Å·": "y",
  "Å¸": "Y",
  "Å¹": "Z",
  "Å»": "Z",
  "Å½": "Z",
  "Åº": "z",
  "Å¼": "z",
  "Å¾": "z",
  "Ä²": "IJ",
  "Ä³": "ij",
  "Å": "Oe",
  "Å": "oe",
  "Å": "'n",
  "Å¿": "s"
};
var deburrLetter = basePropertyOf_default(deburredLetters);
var deburrLetter_default = deburrLetter;

// node_modules/lodash-es/deburr.js
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
var rsComboMarksRange3 = "\\u0300-\\u036f";
var reComboHalfMarksRange3 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange3 = "\\u20d0-\\u20ff";
var rsComboRange3 = rsComboMarksRange3 + reComboHalfMarksRange3 + rsComboSymbolsRange3;
var rsCombo2 = "[" + rsComboRange3 + "]";
var reComboMark = RegExp(rsCombo2, "g");
function deburr(string2) {
  string2 = toString_default(string2);
  return string2 && string2.replace(reLatin, deburrLetter_default).replace(reComboMark, "");
}
var deburr_default = deburr;

// node_modules/lodash-es/_asciiWords.js
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function asciiWords(string2) {
  return string2.match(reAsciiWord) || [];
}
var asciiWords_default = asciiWords;

// node_modules/lodash-es/_hasUnicodeWord.js
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function hasUnicodeWord(string2) {
  return reHasUnicodeWord.test(string2);
}
var hasUnicodeWord_default = hasUnicodeWord;

// node_modules/lodash-es/_unicodeWords.js
var rsAstralRange3 = "\\ud800-\\udfff";
var rsComboMarksRange4 = "\\u0300-\\u036f";
var reComboHalfMarksRange4 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange4 = "\\u20d0-\\u20ff";
var rsComboRange4 = rsComboMarksRange4 + reComboHalfMarksRange4 + rsComboSymbolsRange4;
var rsDingbatRange = "\\u2700-\\u27bf";
var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
var rsPunctuationRange = "\\u2000-\\u206f";
var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
var rsVarRange3 = "\\ufe0e\\ufe0f";
var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
var rsApos = "['â]";
var rsBreak = "[" + rsBreakRange + "]";
var rsCombo3 = "[" + rsComboRange4 + "]";
var rsDigits = "\\d+";
var rsDingbat = "[" + rsDingbatRange + "]";
var rsLower = "[" + rsLowerRange + "]";
var rsMisc = "[^" + rsAstralRange3 + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
var rsFitz2 = "\\ud83c[\\udffb-\\udfff]";
var rsModifier2 = "(?:" + rsCombo3 + "|" + rsFitz2 + ")";
var rsNonAstral2 = "[^" + rsAstralRange3 + "]";
var rsRegional2 = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair2 = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsUpper = "[" + rsUpperRange + "]";
var rsZWJ3 = "\\u200d";
var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")";
var rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")";
var rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
var rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
var reOptMod2 = rsModifier2 + "?";
var rsOptVar2 = "[" + rsVarRange3 + "]?";
var rsOptJoin2 = "(?:" + rsZWJ3 + "(?:" + [rsNonAstral2, rsRegional2, rsSurrPair2].join("|") + ")" + rsOptVar2 + reOptMod2 + ")*";
var rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])";
var rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])";
var rsSeq2 = rsOptVar2 + reOptMod2 + rsOptJoin2;
var rsEmoji = "(?:" + [rsDingbat, rsRegional2, rsSurrPair2].join("|") + ")" + rsSeq2;
var reUnicodeWord = RegExp([
  rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
  rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
  rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
  rsUpper + "+" + rsOptContrUpper,
  rsOrdUpper,
  rsOrdLower,
  rsDigits,
  rsEmoji
].join("|"), "g");
function unicodeWords(string2) {
  return string2.match(reUnicodeWord) || [];
}
var unicodeWords_default = unicodeWords;

// node_modules/lodash-es/words.js
function words(string2, pattern, guard2) {
  string2 = toString_default(string2);
  pattern = guard2 ? void 0 : pattern;
  if (pattern === void 0) {
    return hasUnicodeWord_default(string2) ? unicodeWords_default(string2) : asciiWords_default(string2);
  }
  return string2.match(pattern) || [];
}
var words_default = words;

// node_modules/lodash-es/_createCompounder.js
var rsApos2 = "['â]";
var reApos = RegExp(rsApos2, "g");
function createCompounder(callback) {
  return function(string2) {
    return arrayReduce_default(words_default(deburr_default(string2).replace(reApos, "")), callback, "");
  };
}
var createCompounder_default = createCompounder;

// node_modules/lodash-es/camelCase.js
var camelCase = createCompounder_default(function(result2, word, index8) {
  word = word.toLowerCase();
  return result2 + (index8 ? capitalize_default(word) : word);
});
var camelCase_default = camelCase;

// node_modules/lodash-es/castArray.js
function castArray() {
  if (!arguments.length) {
    return [];
  }
  var value = arguments[0];
  return isArray_default(value) ? value : [value];
}
var castArray_default = castArray;

// node_modules/lodash-es/_createRound.js
var nativeIsFinite = root_default4.isFinite;
var nativeMin4 = Math.min;
function createRound(methodName) {
  var func = Math[methodName];
  return function(number3, precision) {
    number3 = toNumber_default(number3);
    precision = precision == null ? 0 : nativeMin4(toInteger_default(precision), 292);
    if (precision && nativeIsFinite(number3)) {
      var pair = (toString_default(number3) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
      pair = (toString_default(value) + "e").split("e");
      return +(pair[0] + "e" + (+pair[1] - precision));
    }
    return func(number3);
  };
}
var createRound_default = createRound;

// node_modules/lodash-es/ceil.js
var ceil2 = createRound_default("ceil");
var ceil_default = ceil2;

// node_modules/lodash-es/chain.js
function chain(value) {
  var result2 = wrapperLodash_default(value);
  result2.__chain__ = true;
  return result2;
}
var chain_default = chain;

// node_modules/lodash-es/chunk.js
var nativeCeil = Math.ceil;
var nativeMax6 = Math.max;
function chunk(array4, size2, guard2) {
  if (guard2 ? isIterateeCall_default(array4, size2, guard2) : size2 === void 0) {
    size2 = 1;
  } else {
    size2 = nativeMax6(toInteger_default(size2), 0);
  }
  var length2 = array4 == null ? 0 : array4.length;
  if (!length2 || size2 < 1) {
    return [];
  }
  var index8 = 0, resIndex = 0, result2 = Array(nativeCeil(length2 / size2));
  while (index8 < length2) {
    result2[resIndex++] = baseSlice_default(array4, index8, index8 += size2);
  }
  return result2;
}
var chunk_default = chunk;

// node_modules/lodash-es/_baseClamp.js
function baseClamp(number3, lower2, upper) {
  if (number3 === number3) {
    if (upper !== void 0) {
      number3 = number3 <= upper ? number3 : upper;
    }
    if (lower2 !== void 0) {
      number3 = number3 >= lower2 ? number3 : lower2;
    }
  }
  return number3;
}
var baseClamp_default = baseClamp;

// node_modules/lodash-es/clamp.js
function clamp4(number3, lower2, upper) {
  if (upper === void 0) {
    upper = lower2;
    lower2 = void 0;
  }
  if (upper !== void 0) {
    upper = toNumber_default(upper);
    upper = upper === upper ? upper : 0;
  }
  if (lower2 !== void 0) {
    lower2 = toNumber_default(lower2);
    lower2 = lower2 === lower2 ? lower2 : 0;
  }
  return baseClamp_default(toNumber_default(number3), lower2, upper);
}
var clamp_default = clamp4;

// node_modules/lodash-es/_stackClear.js
function stackClear() {
  this.__data__ = new ListCache_default();
  this.size = 0;
}
var stackClear_default = stackClear;

// node_modules/lodash-es/_stackDelete.js
function stackDelete(key) {
  var data = this.__data__, result2 = data["delete"](key);
  this.size = data.size;
  return result2;
}
var stackDelete_default = stackDelete;

// node_modules/lodash-es/_stackGet.js
function stackGet(key) {
  return this.__data__.get(key);
}
var stackGet_default = stackGet;

// node_modules/lodash-es/_stackHas.js
function stackHas(key) {
  return this.__data__.has(key);
}
var stackHas_default = stackHas;

// node_modules/lodash-es/_stackSet.js
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache_default) {
    var pairs2 = data.__data__;
    if (!Map_default || pairs2.length < LARGE_ARRAY_SIZE - 1) {
      pairs2.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache_default(pairs2);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
var stackSet_default = stackSet;

// node_modules/lodash-es/_Stack.js
function Stack2(entries) {
  var data = this.__data__ = new ListCache_default(entries);
  this.size = data.size;
}
Stack2.prototype.clear = stackClear_default;
Stack2.prototype["delete"] = stackDelete_default;
Stack2.prototype.get = stackGet_default;
Stack2.prototype.has = stackHas_default;
Stack2.prototype.set = stackSet_default;
var Stack_default = Stack2;

// node_modules/lodash-es/_baseAssign.js
function baseAssign(object, source) {
  return object && copyObject_default(source, keys_default(source), object);
}
var baseAssign_default = baseAssign;

// node_modules/lodash-es/_baseAssignIn.js
function baseAssignIn(object, source) {
  return object && copyObject_default(source, keysIn_default(source), object);
}
var baseAssignIn_default = baseAssignIn;

// node_modules/lodash-es/_cloneBuffer.js
var freeExports3 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule3 = freeExports3 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports3 = freeModule3 && freeModule3.exports === freeExports3;
var Buffer3 = moduleExports3 ? root_default4.Buffer : void 0;
var allocUnsafe = Buffer3 ? Buffer3.allocUnsafe : void 0;
function cloneBuffer(buffer2, isDeep) {
  if (isDeep) {
    return buffer2.slice();
  }
  var length2 = buffer2.length, result2 = allocUnsafe ? allocUnsafe(length2) : new buffer2.constructor(length2);
  buffer2.copy(result2);
  return result2;
}
var cloneBuffer_default = cloneBuffer;

// node_modules/lodash-es/_arrayFilter.js
function arrayFilter(array4, predicate) {
  var index8 = -1, length2 = array4 == null ? 0 : array4.length, resIndex = 0, result2 = [];
  while (++index8 < length2) {
    var value = array4[index8];
    if (predicate(value, index8, array4)) {
      result2[resIndex++] = value;
    }
  }
  return result2;
}
var arrayFilter_default = arrayFilter;

// node_modules/lodash-es/stubArray.js
function stubArray() {
  return [];
}
var stubArray_default = stubArray;

// node_modules/lodash-es/_getSymbols.js
var objectProto16 = Object.prototype;
var propertyIsEnumerable2 = objectProto16.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols ? stubArray_default : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter_default(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable2.call(object, symbol);
  });
};
var getSymbols_default = getSymbols;

// node_modules/lodash-es/_copySymbols.js
function copySymbols(source, object) {
  return copyObject_default(source, getSymbols_default(source), object);
}
var copySymbols_default = copySymbols;

// node_modules/lodash-es/_getSymbolsIn.js
var nativeGetSymbols2 = Object.getOwnPropertySymbols;
var getSymbolsIn = !nativeGetSymbols2 ? stubArray_default : function(object) {
  var result2 = [];
  while (object) {
    arrayPush_default(result2, getSymbols_default(object));
    object = getPrototype_default(object);
  }
  return result2;
};
var getSymbolsIn_default = getSymbolsIn;

// node_modules/lodash-es/_copySymbolsIn.js
function copySymbolsIn(source, object) {
  return copyObject_default(source, getSymbolsIn_default(source), object);
}
var copySymbolsIn_default = copySymbolsIn;

// node_modules/lodash-es/_baseGetAllKeys.js
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result2 = keysFunc(object);
  return isArray_default(object) ? result2 : arrayPush_default(result2, symbolsFunc(object));
}
var baseGetAllKeys_default = baseGetAllKeys;

// node_modules/lodash-es/_getAllKeys.js
function getAllKeys(object) {
  return baseGetAllKeys_default(object, keys_default, getSymbols_default);
}
var getAllKeys_default = getAllKeys;

// node_modules/lodash-es/_getAllKeysIn.js
function getAllKeysIn(object) {
  return baseGetAllKeys_default(object, keysIn_default, getSymbolsIn_default);
}
var getAllKeysIn_default = getAllKeysIn;

// node_modules/lodash-es/_DataView.js
var DataView2 = getNative_default(root_default4, "DataView");
var DataView_default = DataView2;

// node_modules/lodash-es/_Promise.js
var Promise2 = getNative_default(root_default4, "Promise");
var Promise_default = Promise2;

// node_modules/lodash-es/_Set.js
var Set2 = getNative_default(root_default4, "Set");
var Set_default = Set2;

// node_modules/lodash-es/_getTag.js
var mapTag2 = "[object Map]";
var objectTag3 = "[object Object]";
var promiseTag = "[object Promise]";
var setTag2 = "[object Set]";
var weakMapTag2 = "[object WeakMap]";
var dataViewTag2 = "[object DataView]";
var dataViewCtorString = toSource_default(DataView_default);
var mapCtorString = toSource_default(Map_default);
var promiseCtorString = toSource_default(Promise_default);
var setCtorString = toSource_default(Set_default);
var weakMapCtorString = toSource_default(WeakMap_default);
var getTag = baseGetTag_default;
if (DataView_default && getTag(new DataView_default(new ArrayBuffer(1))) != dataViewTag2 || Map_default && getTag(new Map_default()) != mapTag2 || Promise_default && getTag(Promise_default.resolve()) != promiseTag || Set_default && getTag(new Set_default()) != setTag2 || WeakMap_default && getTag(new WeakMap_default()) != weakMapTag2) {
  getTag = function(value) {
    var result2 = baseGetTag_default(value), Ctor = result2 == objectTag3 ? value.constructor : void 0, ctorString = Ctor ? toSource_default(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag2;
        case mapCtorString:
          return mapTag2;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag2;
        case weakMapCtorString:
          return weakMapTag2;
      }
    }
    return result2;
  };
}
var getTag_default = getTag;

// node_modules/lodash-es/_initCloneArray.js
var objectProto17 = Object.prototype;
var hasOwnProperty14 = objectProto17.hasOwnProperty;
function initCloneArray(array4) {
  var length2 = array4.length, result2 = new array4.constructor(length2);
  if (length2 && typeof array4[0] == "string" && hasOwnProperty14.call(array4, "index")) {
    result2.index = array4.index;
    result2.input = array4.input;
  }
  return result2;
}
var initCloneArray_default = initCloneArray;

// node_modules/lodash-es/_Uint8Array.js
var Uint8Array2 = root_default4.Uint8Array;
var Uint8Array_default = Uint8Array2;

// node_modules/lodash-es/_cloneArrayBuffer.js
function cloneArrayBuffer(arrayBuffer2) {
  var result2 = new arrayBuffer2.constructor(arrayBuffer2.byteLength);
  new Uint8Array_default(result2).set(new Uint8Array_default(arrayBuffer2));
  return result2;
}
var cloneArrayBuffer_default = cloneArrayBuffer;

// node_modules/lodash-es/_cloneDataView.js
function cloneDataView(dataView, isDeep) {
  var buffer2 = isDeep ? cloneArrayBuffer_default(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer2, dataView.byteOffset, dataView.byteLength);
}
var cloneDataView_default = cloneDataView;

// node_modules/lodash-es/_cloneRegExp.js
var reFlags = /\w*$/;
function cloneRegExp(regexp) {
  var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result2.lastIndex = regexp.lastIndex;
  return result2;
}
var cloneRegExp_default = cloneRegExp;

// node_modules/lodash-es/_cloneSymbol.js
var symbolProto2 = Symbol_default ? Symbol_default.prototype : void 0;
var symbolValueOf = symbolProto2 ? symbolProto2.valueOf : void 0;
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}
var cloneSymbol_default = cloneSymbol;

// node_modules/lodash-es/_cloneTypedArray.js
function cloneTypedArray(typedArray, isDeep) {
  var buffer2 = isDeep ? cloneArrayBuffer_default(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
}
var cloneTypedArray_default = cloneTypedArray;

// node_modules/lodash-es/_initCloneByTag.js
var boolTag2 = "[object Boolean]";
var dateTag2 = "[object Date]";
var mapTag3 = "[object Map]";
var numberTag2 = "[object Number]";
var regexpTag2 = "[object RegExp]";
var setTag3 = "[object Set]";
var stringTag2 = "[object String]";
var symbolTag2 = "[object Symbol]";
var arrayBufferTag2 = "[object ArrayBuffer]";
var dataViewTag3 = "[object DataView]";
var float32Tag2 = "[object Float32Array]";
var float64Tag2 = "[object Float64Array]";
var int8Tag2 = "[object Int8Array]";
var int16Tag2 = "[object Int16Array]";
var int32Tag2 = "[object Int32Array]";
var uint8Tag2 = "[object Uint8Array]";
var uint8ClampedTag2 = "[object Uint8ClampedArray]";
var uint16Tag2 = "[object Uint16Array]";
var uint32Tag2 = "[object Uint32Array]";
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag2:
      return cloneArrayBuffer_default(object);
    case boolTag2:
    case dateTag2:
      return new Ctor(+object);
    case dataViewTag3:
      return cloneDataView_default(object, isDeep);
    case float32Tag2:
    case float64Tag2:
    case int8Tag2:
    case int16Tag2:
    case int32Tag2:
    case uint8Tag2:
    case uint8ClampedTag2:
    case uint16Tag2:
    case uint32Tag2:
      return cloneTypedArray_default(object, isDeep);
    case mapTag3:
      return new Ctor();
    case numberTag2:
    case stringTag2:
      return new Ctor(object);
    case regexpTag2:
      return cloneRegExp_default(object);
    case setTag3:
      return new Ctor();
    case symbolTag2:
      return cloneSymbol_default(object);
  }
}
var initCloneByTag_default = initCloneByTag;

// node_modules/lodash-es/_initCloneObject.js
function initCloneObject(object) {
  return typeof object.constructor == "function" && !isPrototype_default(object) ? baseCreate_default(getPrototype_default(object)) : {};
}
var initCloneObject_default = initCloneObject;

// node_modules/lodash-es/_baseIsMap.js
var mapTag4 = "[object Map]";
function baseIsMap(value) {
  return isObjectLike_default(value) && getTag_default(value) == mapTag4;
}
var baseIsMap_default = baseIsMap;

// node_modules/lodash-es/isMap.js
var nodeIsMap = nodeUtil_default && nodeUtil_default.isMap;
var isMap = nodeIsMap ? baseUnary_default(nodeIsMap) : baseIsMap_default;
var isMap_default = isMap;

// node_modules/lodash-es/_baseIsSet.js
var setTag4 = "[object Set]";
function baseIsSet(value) {
  return isObjectLike_default(value) && getTag_default(value) == setTag4;
}
var baseIsSet_default = baseIsSet;

// node_modules/lodash-es/isSet.js
var nodeIsSet = nodeUtil_default && nodeUtil_default.isSet;
var isSet = nodeIsSet ? baseUnary_default(nodeIsSet) : baseIsSet_default;
var isSet_default = isSet;

// node_modules/lodash-es/_baseClone.js
var CLONE_DEEP_FLAG = 1;
var CLONE_FLAT_FLAG = 2;
var CLONE_SYMBOLS_FLAG = 4;
var argsTag3 = "[object Arguments]";
var arrayTag2 = "[object Array]";
var boolTag3 = "[object Boolean]";
var dateTag3 = "[object Date]";
var errorTag3 = "[object Error]";
var funcTag3 = "[object Function]";
var genTag2 = "[object GeneratorFunction]";
var mapTag5 = "[object Map]";
var numberTag3 = "[object Number]";
var objectTag4 = "[object Object]";
var regexpTag3 = "[object RegExp]";
var setTag5 = "[object Set]";
var stringTag3 = "[object String]";
var symbolTag3 = "[object Symbol]";
var weakMapTag3 = "[object WeakMap]";
var arrayBufferTag3 = "[object ArrayBuffer]";
var dataViewTag4 = "[object DataView]";
var float32Tag3 = "[object Float32Array]";
var float64Tag3 = "[object Float64Array]";
var int8Tag3 = "[object Int8Array]";
var int16Tag3 = "[object Int16Array]";
var int32Tag3 = "[object Int32Array]";
var uint8Tag3 = "[object Uint8Array]";
var uint8ClampedTag3 = "[object Uint8ClampedArray]";
var uint16Tag3 = "[object Uint16Array]";
var uint32Tag3 = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag3] = cloneableTags[arrayTag2] = cloneableTags[arrayBufferTag3] = cloneableTags[dataViewTag4] = cloneableTags[boolTag3] = cloneableTags[dateTag3] = cloneableTags[float32Tag3] = cloneableTags[float64Tag3] = cloneableTags[int8Tag3] = cloneableTags[int16Tag3] = cloneableTags[int32Tag3] = cloneableTags[mapTag5] = cloneableTags[numberTag3] = cloneableTags[objectTag4] = cloneableTags[regexpTag3] = cloneableTags[setTag5] = cloneableTags[stringTag3] = cloneableTags[symbolTag3] = cloneableTags[uint8Tag3] = cloneableTags[uint8ClampedTag3] = cloneableTags[uint16Tag3] = cloneableTags[uint32Tag3] = true;
cloneableTags[errorTag3] = cloneableTags[funcTag3] = cloneableTags[weakMapTag3] = false;
function baseClone(value, bitmask, customizer, key, object, stack2) {
  var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
  if (customizer) {
    result2 = object ? customizer(value, key, object, stack2) : customizer(value);
  }
  if (result2 !== void 0) {
    return result2;
  }
  if (!isObject_default(value)) {
    return value;
  }
  var isArr = isArray_default(value);
  if (isArr) {
    result2 = initCloneArray_default(value);
    if (!isDeep) {
      return copyArray_default(value, result2);
    }
  } else {
    var tag = getTag_default(value), isFunc = tag == funcTag3 || tag == genTag2;
    if (isBuffer_default(value)) {
      return cloneBuffer_default(value, isDeep);
    }
    if (tag == objectTag4 || tag == argsTag3 || isFunc && !object) {
      result2 = isFlat || isFunc ? {} : initCloneObject_default(value);
      if (!isDeep) {
        return isFlat ? copySymbolsIn_default(value, baseAssignIn_default(result2, value)) : copySymbols_default(value, baseAssign_default(result2, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result2 = initCloneByTag_default(value, tag, isDeep);
    }
  }
  stack2 || (stack2 = new Stack_default());
  var stacked = stack2.get(value);
  if (stacked) {
    return stacked;
  }
  stack2.set(value, result2);
  if (isSet_default(value)) {
    value.forEach(function(subValue) {
      result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack2));
    });
  } else if (isMap_default(value)) {
    value.forEach(function(subValue, key2) {
      result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack2));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn_default : getAllKeys_default : isFlat ? keysIn_default : keys_default;
  var props = isArr ? void 0 : keysFunc(value);
  arrayEach_default(props || value, function(subValue, key2) {
    if (props) {
      key2 = subValue;
      subValue = value[key2];
    }
    assignValue_default(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack2));
  });
  return result2;
}
var baseClone_default = baseClone;

// node_modules/lodash-es/clone.js
var CLONE_SYMBOLS_FLAG2 = 4;
function clone2(value) {
  return baseClone_default(value, CLONE_SYMBOLS_FLAG2);
}
var clone_default2 = clone2;

// node_modules/lodash-es/cloneDeep.js
var CLONE_DEEP_FLAG2 = 1;
var CLONE_SYMBOLS_FLAG3 = 4;
function cloneDeep(value) {
  return baseClone_default(value, CLONE_DEEP_FLAG2 | CLONE_SYMBOLS_FLAG3);
}
var cloneDeep_default = cloneDeep;

// node_modules/lodash-es/cloneDeepWith.js
var CLONE_DEEP_FLAG3 = 1;
var CLONE_SYMBOLS_FLAG4 = 4;
function cloneDeepWith(value, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return baseClone_default(value, CLONE_DEEP_FLAG3 | CLONE_SYMBOLS_FLAG4, customizer);
}
var cloneDeepWith_default = cloneDeepWith;

// node_modules/lodash-es/cloneWith.js
var CLONE_SYMBOLS_FLAG5 = 4;
function cloneWith(value, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return baseClone_default(value, CLONE_SYMBOLS_FLAG5, customizer);
}
var cloneWith_default = cloneWith;

// node_modules/lodash-es/commit.js
function wrapperCommit() {
  return new LodashWrapper_default(this.value(), this.__chain__);
}
var commit_default = wrapperCommit;

// node_modules/lodash-es/compact.js
function compact(array4) {
  var index8 = -1, length2 = array4 == null ? 0 : array4.length, resIndex = 0, result2 = [];
  while (++index8 < length2) {
    var value = array4[index8];
    if (value) {
      result2[resIndex++] = value;
    }
  }
  return result2;
}
var compact_default = compact;

// node_modules/lodash-es/concat.js
function concat() {
  var length2 = arguments.length;
  if (!length2) {
    return [];
  }
  var args = Array(length2 - 1), array4 = arguments[0], index8 = length2;
  while (index8--) {
    args[index8 - 1] = arguments[index8];
  }
  return arrayPush_default(isArray_default(array4) ? copyArray_default(array4) : [array4], baseFlatten_default(args, 1));
}
var concat_default = concat;

// node_modules/lodash-es/_setCacheAdd.js
var HASH_UNDEFINED3 = "__lodash_hash_undefined__";
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED3);
  return this;
}
var setCacheAdd_default = setCacheAdd;

// node_modules/lodash-es/_setCacheHas.js
function setCacheHas(value) {
  return this.__data__.has(value);
}
var setCacheHas_default = setCacheHas;

// node_modules/lodash-es/_SetCache.js
function SetCache(values2) {
  var index8 = -1, length2 = values2 == null ? 0 : values2.length;
  this.__data__ = new MapCache_default();
  while (++index8 < length2) {
    this.add(values2[index8]);
  }
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd_default;
SetCache.prototype.has = setCacheHas_default;
var SetCache_default = SetCache;

// node_modules/lodash-es/_arraySome.js
function arraySome(array4, predicate) {
  var index8 = -1, length2 = array4 == null ? 0 : array4.length;
  while (++index8 < length2) {
    if (predicate(array4[index8], index8, array4)) {
      return true;
    }
  }
  return false;
}
var arraySome_default = arraySome;

// node_modules/lodash-es/_cacheHas.js
function cacheHas(cache2, key) {
  return cache2.has(key);
}
var cacheHas_default = cacheHas;

// node_modules/lodash-es/_equalArrays.js
var COMPARE_PARTIAL_FLAG = 1;
var COMPARE_UNORDERED_FLAG = 2;
function equalArrays(array4, other, bitmask, customizer, equalFunc, stack2) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array4.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack2.get(array4);
  var othStacked = stack2.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array4;
  }
  var index8 = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache_default() : void 0;
  stack2.set(array4, other);
  stack2.set(other, array4);
  while (++index8 < arrLength) {
    var arrValue = array4[index8], othValue = other[index8];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index8, other, array4, stack2) : customizer(arrValue, othValue, index8, array4, other, stack2);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result2 = false;
      break;
    }
    if (seen) {
      if (!arraySome_default(other, function(othValue2, othIndex) {
        if (!cacheHas_default(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) {
          return seen.push(othIndex);
        }
      })) {
        result2 = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
      result2 = false;
      break;
    }
  }
  stack2["delete"](array4);
  stack2["delete"](other);
  return result2;
}
var equalArrays_default = equalArrays;

// node_modules/lodash-es/_mapToArray.js
function mapToArray(map6) {
  var index8 = -1, result2 = Array(map6.size);
  map6.forEach(function(value, key) {
    result2[++index8] = [key, value];
  });
  return result2;
}
var mapToArray_default = mapToArray;

// node_modules/lodash-es/_setToArray.js
function setToArray(set4) {
  var index8 = -1, result2 = Array(set4.size);
  set4.forEach(function(value) {
    result2[++index8] = value;
  });
  return result2;
}
var setToArray_default = setToArray;

// node_modules/lodash-es/_equalByTag.js
var COMPARE_PARTIAL_FLAG2 = 1;
var COMPARE_UNORDERED_FLAG2 = 2;
var boolTag4 = "[object Boolean]";
var dateTag4 = "[object Date]";
var errorTag4 = "[object Error]";
var mapTag6 = "[object Map]";
var numberTag4 = "[object Number]";
var regexpTag4 = "[object RegExp]";
var setTag6 = "[object Set]";
var stringTag4 = "[object String]";
var symbolTag4 = "[object Symbol]";
var arrayBufferTag4 = "[object ArrayBuffer]";
var dataViewTag5 = "[object DataView]";
var symbolProto3 = Symbol_default ? Symbol_default.prototype : void 0;
var symbolValueOf2 = symbolProto3 ? symbolProto3.valueOf : void 0;
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack2) {
  switch (tag) {
    case dataViewTag5:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag4:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array_default(object), new Uint8Array_default(other))) {
        return false;
      }
      return true;
    case boolTag4:
    case dateTag4:
    case numberTag4:
      return eq_default(+object, +other);
    case errorTag4:
      return object.name == other.name && object.message == other.message;
    case regexpTag4:
    case stringTag4:
      return object == other + "";
    case mapTag6:
      var convert2 = mapToArray_default;
    case setTag6:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG2;
      convert2 || (convert2 = setToArray_default);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack2.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG2;
      stack2.set(object, other);
      var result2 = equalArrays_default(convert2(object), convert2(other), bitmask, customizer, equalFunc, stack2);
      stack2["delete"](object);
      return result2;
    case symbolTag4:
      if (symbolValueOf2) {
        return symbolValueOf2.call(object) == symbolValueOf2.call(other);
      }
  }
  return false;
}
var equalByTag_default = equalByTag;

// node_modules/lodash-es/_equalObjects.js
var COMPARE_PARTIAL_FLAG3 = 1;
var objectProto18 = Object.prototype;
var hasOwnProperty15 = objectProto18.hasOwnProperty;
function equalObjects(object, other, bitmask, customizer, equalFunc, stack2) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG3, objProps = getAllKeys_default(object), objLength = objProps.length, othProps = getAllKeys_default(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index8 = objLength;
  while (index8--) {
    var key = objProps[index8];
    if (!(isPartial ? key in other : hasOwnProperty15.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack2.get(object);
  var othStacked = stack2.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result2 = true;
  stack2.set(object, other);
  stack2.set(other, object);
  var skipCtor = isPartial;
  while (++index8 < objLength) {
    key = objProps[index8];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack2) : customizer(objValue, othValue, key, object, other, stack2);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
      result2 = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result2 && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result2 = false;
    }
  }
  stack2["delete"](object);
  stack2["delete"](other);
  return result2;
}
var equalObjects_default = equalObjects;

// node_modules/lodash-es/_baseIsEqualDeep.js
var COMPARE_PARTIAL_FLAG4 = 1;
var argsTag4 = "[object Arguments]";
var arrayTag3 = "[object Array]";
var objectTag5 = "[object Object]";
var objectProto19 = Object.prototype;
var hasOwnProperty16 = objectProto19.hasOwnProperty;
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack2) {
  var objIsArr = isArray_default(object), othIsArr = isArray_default(other), objTag = objIsArr ? arrayTag3 : getTag_default(object), othTag = othIsArr ? arrayTag3 : getTag_default(other);
  objTag = objTag == argsTag4 ? objectTag5 : objTag;
  othTag = othTag == argsTag4 ? objectTag5 : othTag;
  var objIsObj = objTag == objectTag5, othIsObj = othTag == objectTag5, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer_default(object)) {
    if (!isBuffer_default(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack2 || (stack2 = new Stack_default());
    return objIsArr || isTypedArray_default(object) ? equalArrays_default(object, other, bitmask, customizer, equalFunc, stack2) : equalByTag_default(object, other, objTag, bitmask, customizer, equalFunc, stack2);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG4)) {
    var objIsWrapped = objIsObj && hasOwnProperty16.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty16.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack2 || (stack2 = new Stack_default());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack2 || (stack2 = new Stack_default());
  return equalObjects_default(object, other, bitmask, customizer, equalFunc, stack2);
}
var baseIsEqualDeep_default = baseIsEqualDeep;

// node_modules/lodash-es/_baseIsEqual.js
function baseIsEqual(value, other, bitmask, customizer, stack2) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike_default(value) && !isObjectLike_default(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep_default(value, other, bitmask, customizer, baseIsEqual, stack2);
}
var baseIsEqual_default = baseIsEqual;

// node_modules/lodash-es/_baseIsMatch.js
var COMPARE_PARTIAL_FLAG5 = 1;
var COMPARE_UNORDERED_FLAG3 = 2;
function baseIsMatch(object, source, matchData, customizer) {
  var index8 = matchData.length, length2 = index8, noCustomizer = !customizer;
  if (object == null) {
    return !length2;
  }
  object = Object(object);
  while (index8--) {
    var data = matchData[index8];
    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }
  while (++index8 < length2) {
    data = matchData[index8];
    var key = data[0], objValue = object[key], srcValue = data[1];
    if (noCustomizer && data[2]) {
      if (objValue === void 0 && !(key in object)) {
        return false;
      }
    } else {
      var stack2 = new Stack_default();
      if (customizer) {
        var result2 = customizer(objValue, srcValue, key, object, source, stack2);
      }
      if (!(result2 === void 0 ? baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG5 | COMPARE_UNORDERED_FLAG3, customizer, stack2) : result2)) {
        return false;
      }
    }
  }
  return true;
}
var baseIsMatch_default = baseIsMatch;

// node_modules/lodash-es/_isStrictComparable.js
function isStrictComparable(value) {
  return value === value && !isObject_default(value);
}
var isStrictComparable_default = isStrictComparable;

// node_modules/lodash-es/_getMatchData.js
function getMatchData(object) {
  var result2 = keys_default(object), length2 = result2.length;
  while (length2--) {
    var key = result2[length2], value = object[key];
    result2[length2] = [key, value, isStrictComparable_default(value)];
  }
  return result2;
}
var getMatchData_default = getMatchData;

// node_modules/lodash-es/_matchesStrictComparable.js
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
  };
}
var matchesStrictComparable_default = matchesStrictComparable;

// node_modules/lodash-es/_baseMatches.js
function baseMatches(source) {
  var matchData = getMatchData_default(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable_default(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch_default(object, source, matchData);
  };
}
var baseMatches_default = baseMatches;

// node_modules/lodash-es/_baseHasIn.js
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}
var baseHasIn_default = baseHasIn;

// node_modules/lodash-es/_hasPath.js
function hasPath(object, path, hasFunc) {
  path = castPath_default(path, object);
  var index8 = -1, length2 = path.length, result2 = false;
  while (++index8 < length2) {
    var key = toKey_default(path[index8]);
    if (!(result2 = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result2 || ++index8 != length2) {
    return result2;
  }
  length2 = object == null ? 0 : object.length;
  return !!length2 && isLength_default(length2) && isIndex_default(key, length2) && (isArray_default(object) || isArguments_default(object));
}
var hasPath_default = hasPath;

// node_modules/lodash-es/hasIn.js
function hasIn(object, path) {
  return object != null && hasPath_default(object, path, baseHasIn_default);
}
var hasIn_default = hasIn;

// node_modules/lodash-es/_baseMatchesProperty.js
var COMPARE_PARTIAL_FLAG6 = 1;
var COMPARE_UNORDERED_FLAG4 = 2;
function baseMatchesProperty(path, srcValue) {
  if (isKey_default(path) && isStrictComparable_default(srcValue)) {
    return matchesStrictComparable_default(toKey_default(path), srcValue);
  }
  return function(object) {
    var objValue = get_default(object, path);
    return objValue === void 0 && objValue === srcValue ? hasIn_default(object, path) : baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG6 | COMPARE_UNORDERED_FLAG4);
  };
}
var baseMatchesProperty_default = baseMatchesProperty;

// node_modules/lodash-es/_baseProperty.js
function baseProperty(key) {
  return function(object) {
    return object == null ? void 0 : object[key];
  };
}
var baseProperty_default = baseProperty;

// node_modules/lodash-es/_basePropertyDeep.js
function basePropertyDeep(path) {
  return function(object) {
    return baseGet_default(object, path);
  };
}
var basePropertyDeep_default = basePropertyDeep;

// node_modules/lodash-es/property.js
function property2(path) {
  return isKey_default(path) ? baseProperty_default(toKey_default(path)) : basePropertyDeep_default(path);
}
var property_default2 = property2;

// node_modules/lodash-es/_baseIteratee.js
function baseIteratee(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity_default2;
  }
  if (typeof value == "object") {
    return isArray_default(value) ? baseMatchesProperty_default(value[0], value[1]) : baseMatches_default(value);
  }
  return property_default2(value);
}
var baseIteratee_default = baseIteratee;

// node_modules/lodash-es/cond.js
var FUNC_ERROR_TEXT6 = "Expected a function";
function cond(pairs2) {
  var length2 = pairs2 == null ? 0 : pairs2.length, toIteratee = baseIteratee_default;
  pairs2 = !length2 ? [] : arrayMap_default(pairs2, function(pair) {
    if (typeof pair[1] != "function") {
      throw new TypeError(FUNC_ERROR_TEXT6);
    }
    return [toIteratee(pair[0]), pair[1]];
  });
  return baseRest_default(function(args) {
    var index8 = -1;
    while (++index8 < length2) {
      var pair = pairs2[index8];
      if (apply_default(pair[0], this, args)) {
        return apply_default(pair[1], this, args);
      }
    }
  });
}
var cond_default = cond;

// node_modules/lodash-es/_baseConformsTo.js
function baseConformsTo(object, source, props) {
  var length2 = props.length;
  if (object == null) {
    return !length2;
  }
  object = Object(object);
  while (length2--) {
    var key = props[length2], predicate = source[key], value = object[key];
    if (value === void 0 && !(key in object) || !predicate(value)) {
      return false;
    }
  }
  return true;
}
var baseConformsTo_default = baseConformsTo;

// node_modules/lodash-es/_baseConforms.js
function baseConforms(source) {
  var props = keys_default(source);
  return function(object) {
    return baseConformsTo_default(object, source, props);
  };
}
var baseConforms_default = baseConforms;

// node_modules/lodash-es/conforms.js
var CLONE_DEEP_FLAG4 = 1;
function conforms(source) {
  return baseConforms_default(baseClone_default(source, CLONE_DEEP_FLAG4));
}
var conforms_default = conforms;

// node_modules/lodash-es/conformsTo.js
function conformsTo(object, source) {
  return source == null || baseConformsTo_default(object, source, keys_default(source));
}
var conformsTo_default = conformsTo;

// node_modules/lodash-es/_arrayAggregator.js
function arrayAggregator(array4, setter, iteratee2, accumulator) {
  var index8 = -1, length2 = array4 == null ? 0 : array4.length;
  while (++index8 < length2) {
    var value = array4[index8];
    setter(accumulator, value, iteratee2(value), array4);
  }
  return accumulator;
}
var arrayAggregator_default = arrayAggregator;

// node_modules/lodash-es/_createBaseFor.js
function createBaseFor(fromRight) {
  return function(object, iteratee2, keysFunc) {
    var index8 = -1, iterable = Object(object), props = keysFunc(object), length2 = props.length;
    while (length2--) {
      var key = props[fromRight ? length2 : ++index8];
      if (iteratee2(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var createBaseFor_default = createBaseFor;

// node_modules/lodash-es/_baseFor.js
var baseFor = createBaseFor_default();
var baseFor_default = baseFor;

// node_modules/lodash-es/_baseForOwn.js
function baseForOwn(object, iteratee2) {
  return object && baseFor_default(object, iteratee2, keys_default);
}
var baseForOwn_default = baseForOwn;

// node_modules/lodash-es/_createBaseEach.js
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee2) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike_default(collection)) {
      return eachFunc(collection, iteratee2);
    }
    var length2 = collection.length, index8 = fromRight ? length2 : -1, iterable = Object(collection);
    while (fromRight ? index8-- : ++index8 < length2) {
      if (iteratee2(iterable[index8], index8, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var createBaseEach_default = createBaseEach;

// node_modules/lodash-es/_baseEach.js
var baseEach = createBaseEach_default(baseForOwn_default);
var baseEach_default = baseEach;

// node_modules/lodash-es/_baseAggregator.js
function baseAggregator(collection, setter, iteratee2, accumulator) {
  baseEach_default(collection, function(value, key, collection2) {
    setter(accumulator, value, iteratee2(value), collection2);
  });
  return accumulator;
}
var baseAggregator_default = baseAggregator;

// node_modules/lodash-es/_createAggregator.js
function createAggregator(setter, initializer) {
  return function(collection, iteratee2) {
    var func = isArray_default(collection) ? arrayAggregator_default : baseAggregator_default, accumulator = initializer ? initializer() : {};
    return func(collection, setter, baseIteratee_default(iteratee2, 2), accumulator);
  };
}
var createAggregator_default = createAggregator;

// node_modules/lodash-es/countBy.js
var objectProto20 = Object.prototype;
var hasOwnProperty17 = objectProto20.hasOwnProperty;
var countBy = createAggregator_default(function(result2, value, key) {
  if (hasOwnProperty17.call(result2, key)) {
    ++result2[key];
  } else {
    baseAssignValue_default(result2, key, 1);
  }
});
var countBy_default = countBy;

// node_modules/lodash-es/create.js
function create2(prototype, properties) {
  var result2 = baseCreate_default(prototype);
  return properties == null ? result2 : baseAssign_default(result2, properties);
}
var create_default2 = create2;

// node_modules/lodash-es/curry.js
var WRAP_CURRY_FLAG6 = 8;
function curry2(func, arity, guard2) {
  arity = guard2 ? void 0 : arity;
  var result2 = createWrap_default(func, WRAP_CURRY_FLAG6, void 0, void 0, void 0, void 0, void 0, arity);
  result2.placeholder = curry2.placeholder;
  return result2;
}
curry2.placeholder = {};
var curry_default = curry2;

// node_modules/lodash-es/curryRight.js
var WRAP_CURRY_RIGHT_FLAG4 = 16;
function curryRight(func, arity, guard2) {
  arity = guard2 ? void 0 : arity;
  var result2 = createWrap_default(func, WRAP_CURRY_RIGHT_FLAG4, void 0, void 0, void 0, void 0, void 0, arity);
  result2.placeholder = curryRight.placeholder;
  return result2;
}
curryRight.placeholder = {};
var curryRight_default = curryRight;

// node_modules/lodash-es/defaultTo.js
function defaultTo(value, defaultValue) {
  return value == null || value !== value ? defaultValue : value;
}
var defaultTo_default = defaultTo;

// node_modules/lodash-es/defaults.js
var objectProto21 = Object.prototype;
var hasOwnProperty18 = objectProto21.hasOwnProperty;
var defaults = baseRest_default(function(object, sources) {
  object = Object(object);
  var index8 = -1;
  var length2 = sources.length;
  var guard2 = length2 > 2 ? sources[2] : void 0;
  if (guard2 && isIterateeCall_default(sources[0], sources[1], guard2)) {
    length2 = 1;
  }
  while (++index8 < length2) {
    var source = sources[index8];
    var props = keysIn_default(source);
    var propsIndex = -1;
    var propsLength = props.length;
    while (++propsIndex < propsLength) {
      var key = props[propsIndex];
      var value = object[key];
      if (value === void 0 || eq_default(value, objectProto21[key]) && !hasOwnProperty18.call(object, key)) {
        object[key] = source[key];
      }
    }
  }
  return object;
});
var defaults_default = defaults;

// node_modules/lodash-es/_assignMergeValue.js
function assignMergeValue(object, key, value) {
  if (value !== void 0 && !eq_default(object[key], value) || value === void 0 && !(key in object)) {
    baseAssignValue_default(object, key, value);
  }
}
var assignMergeValue_default = assignMergeValue;

// node_modules/lodash-es/isArrayLikeObject.js
function isArrayLikeObject(value) {
  return isObjectLike_default(value) && isArrayLike_default(value);
}
var isArrayLikeObject_default = isArrayLikeObject;

// node_modules/lodash-es/_safeGet.js
function safeGet(object, key) {
  if (key === "constructor" && typeof object[key] === "function") {
    return;
  }
  if (key == "__proto__") {
    return;
  }
  return object[key];
}
var safeGet_default = safeGet;

// node_modules/lodash-es/toPlainObject.js
function toPlainObject(value) {
  return copyObject_default(value, keysIn_default(value));
}
var toPlainObject_default = toPlainObject;

// node_modules/lodash-es/_baseMergeDeep.js
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack2) {
  var objValue = safeGet_default(object, key), srcValue = safeGet_default(source, key), stacked = stack2.get(srcValue);
  if (stacked) {
    assignMergeValue_default(object, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack2) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray_default(srcValue), isBuff = !isArr && isBuffer_default(srcValue), isTyped = !isArr && !isBuff && isTypedArray_default(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray_default(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject_default(objValue)) {
        newValue = copyArray_default(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer_default(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray_default(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject_default(srcValue) || isArguments_default(srcValue)) {
      newValue = objValue;
      if (isArguments_default(objValue)) {
        newValue = toPlainObject_default(objValue);
      } else if (!isObject_default(objValue) || isFunction_default(objValue)) {
        newValue = initCloneObject_default(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack2.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack2);
    stack2["delete"](srcValue);
  }
  assignMergeValue_default(object, key, newValue);
}
var baseMergeDeep_default = baseMergeDeep;

// node_modules/lodash-es/_baseMerge.js
function baseMerge(object, source, srcIndex, customizer, stack2) {
  if (object === source) {
    return;
  }
  baseFor_default(source, function(srcValue, key) {
    stack2 || (stack2 = new Stack_default());
    if (isObject_default(srcValue)) {
      baseMergeDeep_default(object, source, key, srcIndex, baseMerge, customizer, stack2);
    } else {
      var newValue = customizer ? customizer(safeGet_default(object, key), srcValue, key + "", object, source, stack2) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      assignMergeValue_default(object, key, newValue);
    }
  }, keysIn_default);
}
var baseMerge_default = baseMerge;

// node_modules/lodash-es/_customDefaultsMerge.js
function customDefaultsMerge(objValue, srcValue, key, object, source, stack2) {
  if (isObject_default(objValue) && isObject_default(srcValue)) {
    stack2.set(srcValue, objValue);
    baseMerge_default(objValue, srcValue, void 0, customDefaultsMerge, stack2);
    stack2["delete"](srcValue);
  }
  return objValue;
}
var customDefaultsMerge_default = customDefaultsMerge;

// node_modules/lodash-es/mergeWith.js
var mergeWith = createAssigner_default(function(object, source, srcIndex, customizer) {
  baseMerge_default(object, source, srcIndex, customizer);
});
var mergeWith_default = mergeWith;

// node_modules/lodash-es/defaultsDeep.js
var defaultsDeep = baseRest_default(function(args) {
  args.push(void 0, customDefaultsMerge_default);
  return apply_default(mergeWith_default, void 0, args);
});
var defaultsDeep_default = defaultsDeep;

// node_modules/lodash-es/_baseDelay.js
var FUNC_ERROR_TEXT7 = "Expected a function";
function baseDelay(func, wait, args) {
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT7);
  }
  return setTimeout(function() {
    func.apply(void 0, args);
  }, wait);
}
var baseDelay_default = baseDelay;

// node_modules/lodash-es/defer.js
var defer = baseRest_default(function(func, args) {
  return baseDelay_default(func, 1, args);
});
var defer_default = defer;

// node_modules/lodash-es/delay.js
var delay = baseRest_default(function(func, wait, args) {
  return baseDelay_default(func, toNumber_default(wait) || 0, args);
});
var delay_default2 = delay;

// node_modules/lodash-es/_arrayIncludesWith.js
function arrayIncludesWith(array4, value, comparator) {
  var index8 = -1, length2 = array4 == null ? 0 : array4.length;
  while (++index8 < length2) {
    if (comparator(value, array4[index8])) {
      return true;
    }
  }
  return false;
}
var arrayIncludesWith_default = arrayIncludesWith;

// node_modules/lodash-es/_baseDifference.js
var LARGE_ARRAY_SIZE2 = 200;
function baseDifference(array4, values2, iteratee2, comparator) {
  var index8 = -1, includes2 = arrayIncludes_default, isCommon = true, length2 = array4.length, result2 = [], valuesLength = values2.length;
  if (!length2) {
    return result2;
  }
  if (iteratee2) {
    values2 = arrayMap_default(values2, baseUnary_default(iteratee2));
  }
  if (comparator) {
    includes2 = arrayIncludesWith_default;
    isCommon = false;
  } else if (values2.length >= LARGE_ARRAY_SIZE2) {
    includes2 = cacheHas_default;
    isCommon = false;
    values2 = new SetCache_default(values2);
  }
  outer:
    while (++index8 < length2) {
      var value = array4[index8], computed = iteratee2 == null ? value : iteratee2(value);
      value = comparator || value !== 0 ? value : 0;
      if (isCommon && computed === computed) {
        var valuesIndex = valuesLength;
        while (valuesIndex--) {
          if (values2[valuesIndex] === computed) {
            continue outer;
          }
        }
        result2.push(value);
      } else if (!includes2(values2, computed, comparator)) {
        result2.push(value);
      }
    }
  return result2;
}
var baseDifference_default = baseDifference;

// node_modules/lodash-es/difference.js
var difference3 = baseRest_default(function(array4, values2) {
  return isArrayLikeObject_default(array4) ? baseDifference_default(array4, baseFlatten_default(values2, 1, isArrayLikeObject_default, true)) : [];
});
var difference_default = difference3;

// node_modules/lodash-es/last.js
function last(array4) {
  var length2 = array4 == null ? 0 : array4.length;
  return length2 ? array4[length2 - 1] : void 0;
}
var last_default = last;

// node_modules/lodash-es/differenceBy.js
var differenceBy = baseRest_default(function(array4, values2) {
  var iteratee2 = last_default(values2);
  if (isArrayLikeObject_default(iteratee2)) {
    iteratee2 = void 0;
  }
  return isArrayLikeObject_default(array4) ? baseDifference_default(array4, baseFlatten_default(values2, 1, isArrayLikeObject_default, true), baseIteratee_default(iteratee2, 2)) : [];
});
var differenceBy_default = differenceBy;

// node_modules/lodash-es/differenceWith.js
var differenceWith = baseRest_default(function(array4, values2) {
  var comparator = last_default(values2);
  if (isArrayLikeObject_default(comparator)) {
    comparator = void 0;
  }
  return isArrayLikeObject_default(array4) ? baseDifference_default(array4, baseFlatten_default(values2, 1, isArrayLikeObject_default, true), void 0, comparator) : [];
});
var differenceWith_default = differenceWith;

// node_modules/lodash-es/divide.js
var divide = createMathOperation_default(function(dividend, divisor) {
  return dividend / divisor;
}, 1);
var divide_default = divide;

// node_modules/lodash-es/drop.js
function drop(array4, n2, guard2) {
  var length2 = array4 == null ? 0 : array4.length;
  if (!length2) {
    return [];
  }
  n2 = guard2 || n2 === void 0 ? 1 : toInteger_default(n2);
  return baseSlice_default(array4, n2 < 0 ? 0 : n2, length2);
}
var drop_default = drop;

// node_modules/lodash-es/dropRight.js
function dropRight(array4, n2, guard2) {
  var length2 = array4 == null ? 0 : array4.length;
  if (!length2) {
    return [];
  }
  n2 = guard2 || n2 === void 0 ? 1 : toInteger_default(n2);
  n2 = length2 - n2;
  return baseSlice_default(array4, 0, n2 < 0 ? 0 : n2);
}
var dropRight_default = dropRight;

// node_modules/lodash-es/_baseWhile.js
function baseWhile(array4, predicate, isDrop, fromRight) {
  var length2 = array4.length, index8 = fromRight ? length2 : -1;
  while ((fromRight ? index8-- : ++index8 < length2) && predicate(array4[index8], index8, array4)) {
  }
  return isDrop ? baseSlice_default(array4, fromRight ? 0 : index8, fromRight ? index8 + 1 : length2) : baseSlice_default(array4, fromRight ? index8 + 1 : 0, fromRight ? length2 : index8);
}
var baseWhile_default = baseWhile;

// node_modules/lodash-es/dropRightWhile.js
function dropRightWhile(array4, predicate) {
  return array4 && array4.length ? baseWhile_default(array4, baseIteratee_default(predicate, 3), true, true) : [];
}
var dropRightWhile_default = dropRightWhile;

// node_modules/lodash-es/dropWhile.js
function dropWhile(array4, predicate) {
  return array4 && array4.length ? baseWhile_default(array4, baseIteratee_default(predicate, 3), true) : [];
}
var dropWhile_default = dropWhile;

// node_modules/lodash-es/_castFunction.js
function castFunction(value) {
  return typeof value == "function" ? value : identity_default2;
}
var castFunction_default = castFunction;

// node_modules/lodash-es/forEach.js
function forEach(collection, iteratee2) {
  var func = isArray_default(collection) ? arrayEach_default : baseEach_default;
  return func(collection, castFunction_default(iteratee2));
}
var forEach_default = forEach;

// node_modules/lodash-es/_arrayEachRight.js
function arrayEachRight(array4, iteratee2) {
  var length2 = array4 == null ? 0 : array4.length;
  while (length2--) {
    if (iteratee2(array4[length2], length2, array4) === false) {
      break;
    }
  }
  return array4;
}
var arrayEachRight_default = arrayEachRight;

// node_modules/lodash-es/_baseForRight.js
var baseForRight = createBaseFor_default(true);
var baseForRight_default = baseForRight;

// node_modules/lodash-es/_baseForOwnRight.js
function baseForOwnRight(object, iteratee2) {
  return object && baseForRight_default(object, iteratee2, keys_default);
}
var baseForOwnRight_default = baseForOwnRight;

// node_modules/lodash-es/_baseEachRight.js
var baseEachRight = createBaseEach_default(baseForOwnRight_default, true);
var baseEachRight_default = baseEachRight;

// node_modules/lodash-es/forEachRight.js
function forEachRight(collection, iteratee2) {
  var func = isArray_default(collection) ? arrayEachRight_default : baseEachRight_default;
  return func(collection, castFunction_default(iteratee2));
}
var forEachRight_default = forEachRight;

// node_modules/lodash-es/endsWith.js
function endsWith2(string2, target, position) {
  string2 = toString_default(string2);
  target = baseToString_default(target);
  var length2 = string2.length;
  position = position === void 0 ? length2 : baseClamp_default(toInteger_default(position), 0, length2);
  var end = position;
  position -= target.length;
  return position >= 0 && string2.slice(position, end) == target;
}
var endsWith_default = endsWith2;

// node_modules/lodash-es/_baseToPairs.js
function baseToPairs(object, props) {
  return arrayMap_default(props, function(key) {
    return [key, object[key]];
  });
}
var baseToPairs_default = baseToPairs;

// node_modules/lodash-es/_setToPairs.js
function setToPairs(set4) {
  var index8 = -1, result2 = Array(set4.size);
  set4.forEach(function(value) {
    result2[++index8] = [value, value];
  });
  return result2;
}
var setToPairs_default = setToPairs;

// node_modules/lodash-es/_createToPairs.js
var mapTag7 = "[object Map]";
var setTag7 = "[object Set]";
function createToPairs(keysFunc) {
  return function(object) {
    var tag = getTag_default(object);
    if (tag == mapTag7) {
      return mapToArray_default(object);
    }
    if (tag == setTag7) {
      return setToPairs_default(object);
    }
    return baseToPairs_default(object, keysFunc(object));
  };
}
var createToPairs_default = createToPairs;

// node_modules/lodash-es/toPairs.js
var toPairs = createToPairs_default(keys_default);
var toPairs_default = toPairs;

// node_modules/lodash-es/toPairsIn.js
var toPairsIn = createToPairs_default(keysIn_default);
var toPairsIn_default = toPairsIn;

// node_modules/lodash-es/_escapeHtmlChar.js
var htmlEscapes = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
var escapeHtmlChar = basePropertyOf_default(htmlEscapes);
var escapeHtmlChar_default = escapeHtmlChar;

// node_modules/lodash-es/escape.js
var reUnescapedHtml = /[&<>"']/g;
var reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
function escape2(string2) {
  string2 = toString_default(string2);
  return string2 && reHasUnescapedHtml.test(string2) ? string2.replace(reUnescapedHtml, escapeHtmlChar_default) : string2;
}
var escape_default = escape2;

// node_modules/lodash-es/escapeRegExp.js
var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
var reHasRegExpChar = RegExp(reRegExpChar2.source);
function escapeRegExp(string2) {
  string2 = toString_default(string2);
  return string2 && reHasRegExpChar.test(string2) ? string2.replace(reRegExpChar2, "\\$&") : string2;
}
var escapeRegExp_default = escapeRegExp;

// node_modules/lodash-es/_arrayEvery.js
function arrayEvery(array4, predicate) {
  var index8 = -1, length2 = array4 == null ? 0 : array4.length;
  while (++index8 < length2) {
    if (!predicate(array4[index8], index8, array4)) {
      return false;
    }
  }
  return true;
}
var arrayEvery_default = arrayEvery;

// node_modules/lodash-es/_baseEvery.js
function baseEvery(collection, predicate) {
  var result2 = true;
  baseEach_default(collection, function(value, index8, collection2) {
    result2 = !!predicate(value, index8, collection2);
    return result2;
  });
  return result2;
}
var baseEvery_default = baseEvery;

// node_modules/lodash-es/every.js
function every2(collection, predicate, guard2) {
  var func = isArray_default(collection) ? arrayEvery_default : baseEvery_default;
  if (guard2 && isIterateeCall_default(collection, predicate, guard2)) {
    predicate = void 0;
  }
  return func(collection, baseIteratee_default(predicate, 3));
}
var every_default = every2;

// node_modules/lodash-es/toLength.js
var MAX_ARRAY_LENGTH2 = 4294967295;
function toLength(value) {
  return value ? baseClamp_default(toInteger_default(value), 0, MAX_ARRAY_LENGTH2) : 0;
}
var toLength_default = toLength;

// node_modules/lodash-es/_baseFill.js
function baseFill(array4, value, start2, end) {
  var length2 = array4.length;
  start2 = toInteger_default(start2);
  if (start2 < 0) {
    start2 = -start2 > length2 ? 0 : length2 + start2;
  }
  end = end === void 0 || end > length2 ? length2 : toInteger_default(end);
  if (end < 0) {
    end += length2;
  }
  end = start2 > end ? 0 : toLength_default(end);
  while (start2 < end) {
    array4[start2++] = value;
  }
  return array4;
}
var baseFill_default = baseFill;

// node_modules/lodash-es/fill.js
function fill(array4, value, start2, end) {
  var length2 = array4 == null ? 0 : array4.length;
  if (!length2) {
    return [];
  }
  if (start2 && typeof start2 != "number" && isIterateeCall_default(array4, value, start2)) {
    start2 = 0;
    end = length2;
  }
  return baseFill_default(array4, value, start2, end);
}
var fill_default = fill;

// node_modules/lodash-es/_baseFilter.js
function baseFilter(collection, predicate) {
  var result2 = [];
  baseEach_default(collection, function(value, index8, collection2) {
    if (predicate(value, index8, collection2)) {
      result2.push(value);
    }
  });
  return result2;
}
var baseFilter_default = baseFilter;

// node_modules/lodash-es/filter.js
function filter3(collection, predicate) {
  var func = isArray_default(collection) ? arrayFilter_default : baseFilter_default;
  return func(collection, baseIteratee_default(predicate, 3));
}
var filter_default3 = filter3;

// node_modules/lodash-es/_createFind.js
function createFind(findIndexFunc) {
  return function(collection, predicate, fromIndex) {
    var iterable = Object(collection);
    if (!isArrayLike_default(collection)) {
      var iteratee2 = baseIteratee_default(predicate, 3);
      collection = keys_default(collection);
      predicate = function(key) {
        return iteratee2(iterable[key], key, iterable);
      };
    }
    var index8 = findIndexFunc(collection, predicate, fromIndex);
    return index8 > -1 ? iterable[iteratee2 ? collection[index8] : index8] : void 0;
  };
}
var createFind_default = createFind;

// node_modules/lodash-es/findIndex.js
var nativeMax7 = Math.max;
function findIndex(array4, predicate, fromIndex) {
  var length2 = array4 == null ? 0 : array4.length;
  if (!length2) {
    return -1;
  }
  var index8 = fromIndex == null ? 0 : toInteger_default(fromIndex);
  if (index8 < 0) {
    index8 = nativeMax7(length2 + index8, 0);
  }
  return baseFindIndex_default(array4, baseIteratee_default(predicate, 3), index8);
}
var findIndex_default = findIndex;

// node_modules/lodash-es/find.js
var find3 = createFind_default(findIndex_default);
var find_default4 = find3;

// node_modules/lodash-es/_baseFindKey.js
function baseFindKey(collection, predicate, eachFunc) {
  var result2;
  eachFunc(collection, function(value, key, collection2) {
    if (predicate(value, key, collection2)) {
      result2 = key;
      return false;
    }
  });
  return result2;
}
var baseFindKey_default = baseFindKey;

// node_modules/lodash-es/findKey.js
function findKey(object, predicate) {
  return baseFindKey_default(object, baseIteratee_default(predicate, 3), baseForOwn_default);
}
var findKey_default = findKey;

// node_modules/lodash-es/findLastIndex.js
var nativeMax8 = Math.max;
var nativeMin5 = Math.min;
function findLastIndex(array4, predicate, fromIndex) {
  var length2 = array4 == null ? 0 : array4.length;
  if (!length2) {
    return -1;
  }
  var index8 = length2 - 1;
  if (fromIndex !== void 0) {
    index8 = toInteger_default(fromIndex);
    index8 = fromIndex < 0 ? nativeMax8(length2 + index8, 0) : nativeMin5(index8, length2 - 1);
  }
  return baseFindIndex_default(array4, baseIteratee_default(predicate, 3), index8, true);
}
var findLastIndex_default = findLastIndex;

// node_modules/lodash-es/findLast.js
var findLast = createFind_default(findLastIndex_default);
var findLast_default = findLast;

// node_modules/lodash-es/findLastKey.js
function findLastKey(object, predicate) {
  return baseFindKey_default(object, baseIteratee_default(predicate, 3), baseForOwnRight_default);
}
var findLastKey_default = findLastKey;

// node_modules/lodash-es/head.js
function head(array4) {
  return array4 && array4.length ? array4[0] : void 0;
}
var head_default = head;

// node_modules/lodash-es/_baseMap.js
function baseMap(collection, iteratee2) {
  var index8 = -1, result2 = isArrayLike_default(collection) ? Array(collection.length) : [];
  baseEach_default(collection, function(value, key, collection2) {
    result2[++index8] = iteratee2(value, key, collection2);
  });
  return result2;
}
var baseMap_default = baseMap;

// node_modules/lodash-es/map.js
function map5(collection, iteratee2) {
  var func = isArray_default(collection) ? arrayMap_default : baseMap_default;
  return func(collection, baseIteratee_default(iteratee2, 3));
}
var map_default = map5;

// node_modules/lodash-es/flatMap.js
function flatMap(collection, iteratee2) {
  return baseFlatten_default(map_default(collection, iteratee2), 1);
}
var flatMap_default = flatMap;

// node_modules/lodash-es/flatMapDeep.js
var INFINITY5 = 1 / 0;
function flatMapDeep(collection, iteratee2) {
  return baseFlatten_default(map_default(collection, iteratee2), INFINITY5);
}
var flatMapDeep_default = flatMapDeep;

// node_modules/lodash-es/flatMapDepth.js
function flatMapDepth(collection, iteratee2, depth2) {
  depth2 = depth2 === void 0 ? 1 : toInteger_default(depth2);
  return baseFlatten_default(map_default(collection, iteratee2), depth2);
}
var flatMapDepth_default = flatMapDepth;

// node_modules/lodash-es/flattenDeep.js
var INFINITY6 = 1 / 0;
function flattenDeep(array4) {
  var length2 = array4 == null ? 0 : array4.length;
  return length2 ? baseFlatten_default(array4, INFINITY6) : [];
}
var flattenDeep_default = flattenDeep;

// node_modules/lodash-es/flattenDepth.js
function flattenDepth(array4, depth2) {
  var length2 = array4 == null ? 0 : array4.length;
  if (!length2) {
    return [];
  }
  depth2 = depth2 === void 0 ? 1 : toInteger_default(depth2);
  return baseFlatten_default(array4, depth2);
}
var flattenDepth_default = flattenDepth;

// node_modules/lodash-es/flip.js
var WRAP_FLIP_FLAG3 = 512;
function flip2(func) {
  return createWrap_default(func, WRAP_FLIP_FLAG3);
}
var flip_default = flip2;

// node_modules/lodash-es/floor.js
var floor2 = createRound_default("floor");
var floor_default = floor2;

// node_modules/lodash-es/_createFlow.js
var FUNC_ERROR_TEXT8 = "Expected a function";
var WRAP_CURRY_FLAG7 = 8;
var WRAP_PARTIAL_FLAG6 = 32;
var WRAP_ARY_FLAG5 = 128;
var WRAP_REARG_FLAG3 = 256;
function createFlow(fromRight) {
  return flatRest_default(function(funcs) {
    var length2 = funcs.length, index8 = length2, prereq = LodashWrapper_default.prototype.thru;
    if (fromRight) {
      funcs.reverse();
    }
    while (index8--) {
      var func = funcs[index8];
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT8);
      }
      if (prereq && !wrapper && getFuncName_default(func) == "wrapper") {
        var wrapper = new LodashWrapper_default([], true);
      }
    }
    index8 = wrapper ? index8 : length2;
    while (++index8 < length2) {
      func = funcs[index8];
      var funcName = getFuncName_default(func), data = funcName == "wrapper" ? getData_default(func) : void 0;
      if (data && isLaziable_default(data[0]) && data[1] == (WRAP_ARY_FLAG5 | WRAP_CURRY_FLAG7 | WRAP_PARTIAL_FLAG6 | WRAP_REARG_FLAG3) && !data[4].length && data[9] == 1) {
        wrapper = wrapper[getFuncName_default(data[0])].apply(wrapper, data[3]);
      } else {
        wrapper = func.length == 1 && isLaziable_default(func) ? wrapper[funcName]() : wrapper.thru(func);
      }
    }
    return function() {
      var args = arguments, value = args[0];
      if (wrapper && args.length == 1 && isArray_default(value)) {
        return wrapper.plant(value).value();
      }
      var index9 = 0, result2 = length2 ? funcs[index9].apply(this, args) : value;
      while (++index9 < length2) {
        result2 = funcs[index9].call(this, result2);
      }
      return result2;
    };
  });
}
var createFlow_default = createFlow;

// node_modules/lodash-es/flow.js
var flow = createFlow_default();
var flow_default = flow;

// node_modules/lodash-es/flowRight.js
var flowRight = createFlow_default(true);
var flowRight_default = flowRight;

// node_modules/lodash-es/forIn.js
function forIn(object, iteratee2) {
  return object == null ? object : baseFor_default(object, castFunction_default(iteratee2), keysIn_default);
}
var forIn_default = forIn;

// node_modules/lodash-es/forInRight.js
function forInRight(object, iteratee2) {
  return object == null ? object : baseForRight_default(object, castFunction_default(iteratee2), keysIn_default);
}
var forInRight_default = forInRight;

// node_modules/lodash-es/forOwn.js
function forOwn(object, iteratee2) {
  return object && baseForOwn_default(object, castFunction_default(iteratee2));
}
var forOwn_default = forOwn;

// node_modules/lodash-es/forOwnRight.js
function forOwnRight(object, iteratee2) {
  return object && baseForOwnRight_default(object, castFunction_default(iteratee2));
}
var forOwnRight_default = forOwnRight;

// node_modules/lodash-es/fromPairs.js
function fromPairs(pairs2) {
  var index8 = -1, length2 = pairs2 == null ? 0 : pairs2.length, result2 = {};
  while (++index8 < length2) {
    var pair = pairs2[index8];
    result2[pair[0]] = pair[1];
  }
  return result2;
}
var fromPairs_default = fromPairs;

// node_modules/lodash-es/_baseFunctions.js
function baseFunctions(object, props) {
  return arrayFilter_default(props, function(key) {
    return isFunction_default(object[key]);
  });
}
var baseFunctions_default = baseFunctions;

// node_modules/lodash-es/functions.js
function functions(object) {
  return object == null ? [] : baseFunctions_default(object, keys_default(object));
}
var functions_default = functions;

// node_modules/lodash-es/functionsIn.js
function functionsIn(object) {
  return object == null ? [] : baseFunctions_default(object, keysIn_default(object));
}
var functionsIn_default = functionsIn;

// node_modules/lodash-es/groupBy.js
var objectProto22 = Object.prototype;
var hasOwnProperty19 = objectProto22.hasOwnProperty;
var groupBy = createAggregator_default(function(result2, value, key) {
  if (hasOwnProperty19.call(result2, key)) {
    result2[key].push(value);
  } else {
    baseAssignValue_default(result2, key, [value]);
  }
});
var groupBy_default = groupBy;

// node_modules/lodash-es/_baseGt.js
function baseGt(value, other) {
  return value > other;
}
var baseGt_default = baseGt;

// node_modules/lodash-es/_createRelationalOperation.js
function createRelationalOperation(operator) {
  return function(value, other) {
    if (!(typeof value == "string" && typeof other == "string")) {
      value = toNumber_default(value);
      other = toNumber_default(other);
    }
    return operator(value, other);
  };
}
var createRelationalOperation_default = createRelationalOperation;

// node_modules/lodash-es/gt.js
var gt = createRelationalOperation_default(baseGt_default);
var gt_default = gt;

// node_modules/lodash-es/gte.js
var gte = createRelationalOperation_default(function(value, other) {
  return value >= other;
});
var gte_default = gte;

// node_modules/lodash-es/_baseHas.js
var objectProto23 = Object.prototype;
var hasOwnProperty20 = objectProto23.hasOwnProperty;
function baseHas(object, key) {
  return object != null && hasOwnProperty20.call(object, key);
}
var baseHas_default = baseHas;

// node_modules/lodash-es/has.js
function has(object, path) {
  return object != null && hasPath_default(object, path, baseHas_default);
}
var has_default = has;

// node_modules/lodash-es/_baseInRange.js
var nativeMax9 = Math.max;
var nativeMin6 = Math.min;
function baseInRange(number3, start2, end) {
  return number3 >= nativeMin6(start2, end) && number3 < nativeMax9(start2, end);
}
var baseInRange_default = baseInRange;

// node_modules/lodash-es/inRange.js
function inRange(number3, start2, end) {
  start2 = toFinite_default(start2);
  if (end === void 0) {
    end = start2;
    start2 = 0;
  } else {
    end = toFinite_default(end);
  }
  number3 = toNumber_default(number3);
  return baseInRange_default(number3, start2, end);
}
var inRange_default = inRange;

// node_modules/lodash-es/isString.js
var stringTag5 = "[object String]";
function isString(value) {
  return typeof value == "string" || !isArray_default(value) && isObjectLike_default(value) && baseGetTag_default(value) == stringTag5;
}
var isString_default = isString;

// node_modules/lodash-es/_baseValues.js
function baseValues(object, props) {
  return arrayMap_default(props, function(key) {
    return object[key];
  });
}
var baseValues_default = baseValues;

// node_modules/lodash-es/values.js
function values(object) {
  return object == null ? [] : baseValues_default(object, keys_default(object));
}
var values_default = values;

// node_modules/lodash-es/includes.js
var nativeMax10 = Math.max;
function includes(collection, value, fromIndex, guard2) {
  collection = isArrayLike_default(collection) ? collection : values_default(collection);
  fromIndex = fromIndex && !guard2 ? toInteger_default(fromIndex) : 0;
  var length2 = collection.length;
  if (fromIndex < 0) {
    fromIndex = nativeMax10(length2 + fromIndex, 0);
  }
  return isString_default(collection) ? fromIndex <= length2 && collection.indexOf(value, fromIndex) > -1 : !!length2 && baseIndexOf_default(collection, value, fromIndex) > -1;
}
var includes_default = includes;

// node_modules/lodash-es/indexOf.js
var nativeMax11 = Math.max;
function indexOf(array4, value, fromIndex) {
  var length2 = array4 == null ? 0 : array4.length;
  if (!length2) {
    return -1;
  }
  var index8 = fromIndex == null ? 0 : toInteger_default(fromIndex);
  if (index8 < 0) {
    index8 = nativeMax11(length2 + index8, 0);
  }
  return baseIndexOf_default(array4, value, index8);
}
var indexOf_default = indexOf;

// node_modules/lodash-es/initial.js
function initial(array4) {
  var length2 = array4 == null ? 0 : array4.length;
  return length2 ? baseSlice_default(array4, 0, -1) : [];
}
var initial_default = initial;

// node_modules/lodash-es/_baseIntersection.js
var nativeMin7 = Math.min;
function baseIntersection(arrays, iteratee2, comparator) {
  var includes2 = comparator ? arrayIncludesWith_default : arrayIncludes_default, length2 = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = Infinity, result2 = [];
  while (othIndex--) {
    var array4 = arrays[othIndex];
    if (othIndex && iteratee2) {
      array4 = arrayMap_default(array4, baseUnary_default(iteratee2));
    }
    maxLength = nativeMin7(array4.length, maxLength);
    caches[othIndex] = !comparator && (iteratee2 || length2 >= 120 && array4.length >= 120) ? new SetCache_default(othIndex && array4) : void 0;
  }
  array4 = arrays[0];
  var index8 = -1, seen = caches[0];
  outer:
    while (++index8 < length2 && result2.length < maxLength) {
      var value = array4[index8], computed = iteratee2 ? iteratee2(value) : value;
      value = comparator || value !== 0 ? value : 0;
      if (!(seen ? cacheHas_default(seen, computed) : includes2(result2, computed, comparator))) {
        othIndex = othLength;
        while (--othIndex) {
          var cache2 = caches[othIndex];
          if (!(cache2 ? cacheHas_default(cache2, computed) : includes2(arrays[othIndex], computed, comparator))) {
            continue outer;
          }
        }
        if (seen) {
          seen.push(computed);
        }
        result2.push(value);
      }
    }
  return result2;
}
var baseIntersection_default = baseIntersection;

// node_modules/lodash-es/_castArrayLikeObject.js
function castArrayLikeObject(value) {
  return isArrayLikeObject_default(value) ? value : [];
}
var castArrayLikeObject_default = castArrayLikeObject;

// node_modules/lodash-es/intersection.js
var intersection2 = baseRest_default(function(arrays) {
  var mapped = arrayMap_default(arrays, castArrayLikeObject_default);
  return mapped.length && mapped[0] === arrays[0] ? baseIntersection_default(mapped) : [];
});
var intersection_default = intersection2;

// node_modules/lodash-es/intersectionBy.js
var intersectionBy = baseRest_default(function(arrays) {
  var iteratee2 = last_default(arrays), mapped = arrayMap_default(arrays, castArrayLikeObject_default);
  if (iteratee2 === last_default(mapped)) {
    iteratee2 = void 0;
  } else {
    mapped.pop();
  }
  return mapped.length && mapped[0] === arrays[0] ? baseIntersection_default(mapped, baseIteratee_default(iteratee2, 2)) : [];
});
var intersectionBy_default = intersectionBy;

// node_modules/lodash-es/intersectionWith.js
var intersectionWith = baseRest_default(function(arrays) {
  var comparator = last_default(arrays), mapped = arrayMap_default(arrays, castArrayLikeObject_default);
  comparator = typeof comparator == "function" ? comparator : void 0;
  if (comparator) {
    mapped.pop();
  }
  return mapped.length && mapped[0] === arrays[0] ? baseIntersection_default(mapped, void 0, comparator) : [];
});
var intersectionWith_default = intersectionWith;

// node_modules/lodash-es/_baseInverter.js
function baseInverter(object, setter, iteratee2, accumulator) {
  baseForOwn_default(object, function(value, key, object2) {
    setter(accumulator, iteratee2(value), key, object2);
  });
  return accumulator;
}
var baseInverter_default = baseInverter;

// node_modules/lodash-es/_createInverter.js
function createInverter(setter, toIteratee) {
  return function(object, iteratee2) {
    return baseInverter_default(object, setter, toIteratee(iteratee2), {});
  };
}
var createInverter_default = createInverter;

// node_modules/lodash-es/invert.js
var objectProto24 = Object.prototype;
var nativeObjectToString3 = objectProto24.toString;
var invert = createInverter_default(function(result2, value, key) {
  if (value != null && typeof value.toString != "function") {
    value = nativeObjectToString3.call(value);
  }
  result2[value] = key;
}, constant_default6(identity_default2));
var invert_default = invert;

// node_modules/lodash-es/invertBy.js
var objectProto25 = Object.prototype;
var hasOwnProperty21 = objectProto25.hasOwnProperty;
var nativeObjectToString4 = objectProto25.toString;
var invertBy = createInverter_default(function(result2, value, key) {
  if (value != null && typeof value.toString != "function") {
    value = nativeObjectToString4.call(value);
  }
  if (hasOwnProperty21.call(result2, value)) {
    result2[value].push(key);
  } else {
    result2[value] = [key];
  }
}, baseIteratee_default);
var invertBy_default = invertBy;

// node_modules/lodash-es/_parent.js
function parent(object, path) {
  return path.length < 2 ? object : baseGet_default(object, baseSlice_default(path, 0, -1));
}
var parent_default = parent;

// node_modules/lodash-es/_baseInvoke.js
function baseInvoke(object, path, args) {
  path = castPath_default(path, object);
  object = parent_default(object, path);
  var func = object == null ? object : object[toKey_default(last_default(path))];
  return func == null ? void 0 : apply_default(func, object, args);
}
var baseInvoke_default = baseInvoke;

// node_modules/lodash-es/invoke.js
var invoke = baseRest_default(baseInvoke_default);
var invoke_default = invoke;

// node_modules/lodash-es/invokeMap.js
var invokeMap = baseRest_default(function(collection, path, args) {
  var index8 = -1, isFunc = typeof path == "function", result2 = isArrayLike_default(collection) ? Array(collection.length) : [];
  baseEach_default(collection, function(value) {
    result2[++index8] = isFunc ? apply_default(path, value, args) : baseInvoke_default(value, path, args);
  });
  return result2;
});
var invokeMap_default = invokeMap;

// node_modules/lodash-es/_baseIsArrayBuffer.js
var arrayBufferTag5 = "[object ArrayBuffer]";
function baseIsArrayBuffer(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == arrayBufferTag5;
}
var baseIsArrayBuffer_default = baseIsArrayBuffer;

// node_modules/lodash-es/isArrayBuffer.js
var nodeIsArrayBuffer = nodeUtil_default && nodeUtil_default.isArrayBuffer;
var isArrayBuffer = nodeIsArrayBuffer ? baseUnary_default(nodeIsArrayBuffer) : baseIsArrayBuffer_default;
var isArrayBuffer_default = isArrayBuffer;

// node_modules/lodash-es/isBoolean.js
var boolTag5 = "[object Boolean]";
function isBoolean(value) {
  return value === true || value === false || isObjectLike_default(value) && baseGetTag_default(value) == boolTag5;
}
var isBoolean_default = isBoolean;

// node_modules/lodash-es/_baseIsDate.js
var dateTag5 = "[object Date]";
function baseIsDate(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == dateTag5;
}
var baseIsDate_default = baseIsDate;

// node_modules/lodash-es/isDate.js
var nodeIsDate = nodeUtil_default && nodeUtil_default.isDate;
var isDate = nodeIsDate ? baseUnary_default(nodeIsDate) : baseIsDate_default;
var isDate_default = isDate;

// node_modules/lodash-es/isElement.js
function isElement(value) {
  return isObjectLike_default(value) && value.nodeType === 1 && !isPlainObject_default(value);
}
var isElement_default = isElement;

// node_modules/lodash-es/isEmpty.js
var mapTag8 = "[object Map]";
var setTag8 = "[object Set]";
var objectProto26 = Object.prototype;
var hasOwnProperty22 = objectProto26.hasOwnProperty;
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike_default(value) && (isArray_default(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer_default(value) || isTypedArray_default(value) || isArguments_default(value))) {
    return !value.length;
  }
  var tag = getTag_default(value);
  if (tag == mapTag8 || tag == setTag8) {
    return !value.size;
  }
  if (isPrototype_default(value)) {
    return !baseKeys_default(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty22.call(value, key)) {
      return false;
    }
  }
  return true;
}
var isEmpty_default = isEmpty;

// node_modules/lodash-es/isEqual.js
function isEqual(value, other) {
  return baseIsEqual_default(value, other);
}
var isEqual_default = isEqual;

// node_modules/lodash-es/isEqualWith.js
function isEqualWith(value, other, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  var result2 = customizer ? customizer(value, other) : void 0;
  return result2 === void 0 ? baseIsEqual_default(value, other, void 0, customizer) : !!result2;
}
var isEqualWith_default = isEqualWith;

// node_modules/lodash-es/isFinite.js
var nativeIsFinite2 = root_default4.isFinite;
function isFinite2(value) {
  return typeof value == "number" && nativeIsFinite2(value);
}
var isFinite_default = isFinite2;

// node_modules/lodash-es/isInteger.js
function isInteger(value) {
  return typeof value == "number" && value == toInteger_default(value);
}
var isInteger_default = isInteger;

// node_modules/lodash-es/isMatch.js
function isMatch(object, source) {
  return object === source || baseIsMatch_default(object, source, getMatchData_default(source));
}
var isMatch_default = isMatch;

// node_modules/lodash-es/isMatchWith.js
function isMatchWith(object, source, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return baseIsMatch_default(object, source, getMatchData_default(source), customizer);
}
var isMatchWith_default = isMatchWith;

// node_modules/lodash-es/isNumber.js
var numberTag5 = "[object Number]";
function isNumber(value) {
  return typeof value == "number" || isObjectLike_default(value) && baseGetTag_default(value) == numberTag5;
}
var isNumber_default = isNumber;

// node_modules/lodash-es/isNaN.js
function isNaN2(value) {
  return isNumber_default(value) && value != +value;
}
var isNaN_default = isNaN2;

// node_modules/lodash-es/_isMaskable.js
var isMaskable = coreJsData_default ? isFunction_default : stubFalse_default;
var isMaskable_default = isMaskable;

// node_modules/lodash-es/isNative.js
var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.";
function isNative(value) {
  if (isMaskable_default(value)) {
    throw new Error(CORE_ERROR_TEXT);
  }
  return baseIsNative_default(value);
}
var isNative_default = isNative;

// node_modules/lodash-es/isNil.js
function isNil(value) {
  return value == null;
}
var isNil_default = isNil;

// node_modules/lodash-es/isNull.js
function isNull(value) {
  return value === null;
}
var isNull_default = isNull;

// node_modules/lodash-es/_baseIsRegExp.js
var regexpTag5 = "[object RegExp]";
function baseIsRegExp(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == regexpTag5;
}
var baseIsRegExp_default = baseIsRegExp;

// node_modules/lodash-es/isRegExp.js
var nodeIsRegExp = nodeUtil_default && nodeUtil_default.isRegExp;
var isRegExp = nodeIsRegExp ? baseUnary_default(nodeIsRegExp) : baseIsRegExp_default;
var isRegExp_default = isRegExp;

// node_modules/lodash-es/isSafeInteger.js
var MAX_SAFE_INTEGER3 = 9007199254740991;
function isSafeInteger(value) {
  return isInteger_default(value) && value >= -MAX_SAFE_INTEGER3 && value <= MAX_SAFE_INTEGER3;
}
var isSafeInteger_default = isSafeInteger;

// node_modules/lodash-es/isUndefined.js
function isUndefined(value) {
  return value === void 0;
}
var isUndefined_default = isUndefined;

// node_modules/lodash-es/isWeakMap.js
var weakMapTag4 = "[object WeakMap]";
function isWeakMap(value) {
  return isObjectLike_default(value) && getTag_default(value) == weakMapTag4;
}
var isWeakMap_default = isWeakMap;

// node_modules/lodash-es/isWeakSet.js
var weakSetTag = "[object WeakSet]";
function isWeakSet(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == weakSetTag;
}
var isWeakSet_default = isWeakSet;

// node_modules/lodash-es/iteratee.js
var CLONE_DEEP_FLAG5 = 1;
function iteratee(func) {
  return baseIteratee_default(typeof func == "function" ? func : baseClone_default(func, CLONE_DEEP_FLAG5));
}
var iteratee_default = iteratee;

// node_modules/lodash-es/join.js
var arrayProto2 = Array.prototype;
var nativeJoin = arrayProto2.join;
function join(array4, separator) {
  return array4 == null ? "" : nativeJoin.call(array4, separator);
}
var join_default2 = join;

// node_modules/lodash-es/kebabCase.js
var kebabCase = createCompounder_default(function(result2, word, index8) {
  return result2 + (index8 ? "-" : "") + word.toLowerCase();
});
var kebabCase_default = kebabCase;

// node_modules/lodash-es/keyBy.js
var keyBy = createAggregator_default(function(result2, value, key) {
  baseAssignValue_default(result2, key, value);
});
var keyBy_default = keyBy;

// node_modules/lodash-es/_strictLastIndexOf.js
function strictLastIndexOf(array4, value, fromIndex) {
  var index8 = fromIndex + 1;
  while (index8--) {
    if (array4[index8] === value) {
      return index8;
    }
  }
  return index8;
}
var strictLastIndexOf_default = strictLastIndexOf;

// node_modules/lodash-es/lastIndexOf.js
var nativeMax12 = Math.max;
var nativeMin8 = Math.min;
function lastIndexOf(array4, value, fromIndex) {
  var length2 = array4 == null ? 0 : array4.length;
  if (!length2) {
    return -1;
  }
  var index8 = length2;
  if (fromIndex !== void 0) {
    index8 = toInteger_default(fromIndex);
    index8 = index8 < 0 ? nativeMax12(length2 + index8, 0) : nativeMin8(index8, length2 - 1);
  }
  return value === value ? strictLastIndexOf_default(array4, value, index8) : baseFindIndex_default(array4, baseIsNaN_default, index8, true);
}
var lastIndexOf_default = lastIndexOf;

// node_modules/lodash-es/lowerCase.js
var lowerCase = createCompounder_default(function(result2, word, index8) {
  return result2 + (index8 ? " " : "") + word.toLowerCase();
});
var lowerCase_default = lowerCase;

// node_modules/lodash-es/lowerFirst.js
var lowerFirst = createCaseFirst_default("toLowerCase");
var lowerFirst_default = lowerFirst;

// node_modules/lodash-es/_baseLt.js
function baseLt(value, other) {
  return value < other;
}
var baseLt_default = baseLt;

// node_modules/lodash-es/lt.js
var lt = createRelationalOperation_default(baseLt_default);
var lt_default = lt;

// node_modules/lodash-es/lte.js
var lte = createRelationalOperation_default(function(value, other) {
  return value <= other;
});
var lte_default = lte;

// node_modules/lodash-es/mapKeys.js
function mapKeys(object, iteratee2) {
  var result2 = {};
  iteratee2 = baseIteratee_default(iteratee2, 3);
  baseForOwn_default(object, function(value, key, object2) {
    baseAssignValue_default(result2, iteratee2(value, key, object2), value);
  });
  return result2;
}
var mapKeys_default = mapKeys;

// node_modules/lodash-es/mapValues.js
function mapValues(object, iteratee2) {
  var result2 = {};
  iteratee2 = baseIteratee_default(iteratee2, 3);
  baseForOwn_default(object, function(value, key, object2) {
    baseAssignValue_default(result2, key, iteratee2(value, key, object2));
  });
  return result2;
}
var mapValues_default = mapValues;

// node_modules/lodash-es/matches.js
var CLONE_DEEP_FLAG6 = 1;
function matches(source) {
  return baseMatches_default(baseClone_default(source, CLONE_DEEP_FLAG6));
}
var matches_default = matches;

// node_modules/lodash-es/matchesProperty.js
var CLONE_DEEP_FLAG7 = 1;
function matchesProperty(path, srcValue) {
  return baseMatchesProperty_default(path, baseClone_default(srcValue, CLONE_DEEP_FLAG7));
}
var matchesProperty_default = matchesProperty;

// node_modules/lodash-es/_baseExtremum.js
function baseExtremum(array4, iteratee2, comparator) {
  var index8 = -1, length2 = array4.length;
  while (++index8 < length2) {
    var value = array4[index8], current = iteratee2(value);
    if (current != null && (computed === void 0 ? current === current && !isSymbol_default(current) : comparator(current, computed))) {
      var computed = current, result2 = value;
    }
  }
  return result2;
}
var baseExtremum_default = baseExtremum;

// node_modules/lodash-es/max.js
function max4(array4) {
  return array4 && array4.length ? baseExtremum_default(array4, identity_default2, baseGt_default) : void 0;
}
var max_default = max4;

// node_modules/lodash-es/maxBy.js
function maxBy(array4, iteratee2) {
  return array4 && array4.length ? baseExtremum_default(array4, baseIteratee_default(iteratee2, 2), baseGt_default) : void 0;
}
var maxBy_default = maxBy;

// node_modules/lodash-es/_baseSum.js
function baseSum(array4, iteratee2) {
  var result2, index8 = -1, length2 = array4.length;
  while (++index8 < length2) {
    var current = iteratee2(array4[index8]);
    if (current !== void 0) {
      result2 = result2 === void 0 ? current : result2 + current;
    }
  }
  return result2;
}
var baseSum_default = baseSum;

// node_modules/lodash-es/_baseMean.js
var NAN3 = 0 / 0;
function baseMean(array4, iteratee2) {
  var length2 = array4 == null ? 0 : array4.length;
  return length2 ? baseSum_default(array4, iteratee2) / length2 : NAN3;
}
var baseMean_default = baseMean;

// node_modules/lodash-es/mean.js
function mean2(array4) {
  return baseMean_default(array4, identity_default2);
}
var mean_default = mean2;

// node_modules/lodash-es/meanBy.js
function meanBy(array4, iteratee2) {
  return baseMean_default(array4, baseIteratee_default(iteratee2, 2));
}
var meanBy_default = meanBy;

// node_modules/lodash-es/merge.js
var merge2 = createAssigner_default(function(object, source, srcIndex) {
  baseMerge_default(object, source, srcIndex);
});
var merge_default3 = merge2;

// node_modules/lodash-es/method.js
var method = baseRest_default(function(path, args) {
  return function(object) {
    return baseInvoke_default(object, path, args);
  };
});
var method_default = method;

// node_modules/lodash-es/methodOf.js
var methodOf = baseRest_default(function(object, args) {
  return function(path) {
    return baseInvoke_default(object, path, args);
  };
});
var methodOf_default = methodOf;

// node_modules/lodash-es/min.js
function min3(array4) {
  return array4 && array4.length ? baseExtremum_default(array4, identity_default2, baseLt_default) : void 0;
}
var min_default = min3;

// node_modules/lodash-es/minBy.js
function minBy(array4, iteratee2) {
  return array4 && array4.length ? baseExtremum_default(array4, baseIteratee_default(iteratee2, 2), baseLt_default) : void 0;
}
var minBy_default = minBy;

// node_modules/lodash-es/mixin.js
function mixin(object, source, options) {
  var props = keys_default(source), methodNames = baseFunctions_default(source, props);
  var chain2 = !(isObject_default(options) && "chain" in options) || !!options.chain, isFunc = isFunction_default(object);
  arrayEach_default(methodNames, function(methodName) {
    var func = source[methodName];
    object[methodName] = func;
    if (isFunc) {
      object.prototype[methodName] = function() {
        var chainAll = this.__chain__;
        if (chain2 || chainAll) {
          var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray_default(this.__actions__);
          actions.push({ "func": func, "args": arguments, "thisArg": object });
          result2.__chain__ = chainAll;
          return result2;
        }
        return func.apply(object, arrayPush_default([this.value()], arguments));
      };
    }
  });
  return object;
}
var mixin_default = mixin;

// node_modules/lodash-es/multiply.js
var multiply = createMathOperation_default(function(multiplier, multiplicand) {
  return multiplier * multiplicand;
}, 1);
var multiply_default = multiply;

// node_modules/lodash-es/negate.js
var FUNC_ERROR_TEXT9 = "Expected a function";
function negate2(predicate) {
  if (typeof predicate != "function") {
    throw new TypeError(FUNC_ERROR_TEXT9);
  }
  return function() {
    var args = arguments;
    switch (args.length) {
      case 0:
        return !predicate.call(this);
      case 1:
        return !predicate.call(this, args[0]);
      case 2:
        return !predicate.call(this, args[0], args[1]);
      case 3:
        return !predicate.call(this, args[0], args[1], args[2]);
    }
    return !predicate.apply(this, args);
  };
}
var negate_default = negate2;

// node_modules/lodash-es/_iteratorToArray.js
function iteratorToArray(iterator) {
  var data, result2 = [];
  while (!(data = iterator.next()).done) {
    result2.push(data.value);
  }
  return result2;
}
var iteratorToArray_default = iteratorToArray;

// node_modules/lodash-es/toArray.js
var mapTag9 = "[object Map]";
var setTag9 = "[object Set]";
var symIterator = Symbol_default ? Symbol_default.iterator : void 0;
function toArray(value) {
  if (!value) {
    return [];
  }
  if (isArrayLike_default(value)) {
    return isString_default(value) ? stringToArray_default(value) : copyArray_default(value);
  }
  if (symIterator && value[symIterator]) {
    return iteratorToArray_default(value[symIterator]());
  }
  var tag = getTag_default(value), func = tag == mapTag9 ? mapToArray_default : tag == setTag9 ? setToArray_default : values_default;
  return func(value);
}
var toArray_default = toArray;

// node_modules/lodash-es/next.js
function wrapperNext() {
  if (this.__values__ === void 0) {
    this.__values__ = toArray_default(this.value());
  }
  var done = this.__index__ >= this.__values__.length, value = done ? void 0 : this.__values__[this.__index__++];
  return { "done": done, "value": value };
}
var next_default = wrapperNext;

// node_modules/lodash-es/_baseNth.js
function baseNth(array4, n2) {
  var length2 = array4.length;
  if (!length2) {
    return;
  }
  n2 += n2 < 0 ? length2 : 0;
  return isIndex_default(n2, length2) ? array4[n2] : void 0;
}
var baseNth_default = baseNth;

// node_modules/lodash-es/nth.js
function nth(array4, n2) {
  return array4 && array4.length ? baseNth_default(array4, toInteger_default(n2)) : void 0;
}
var nth_default = nth;

// node_modules/lodash-es/nthArg.js
function nthArg(n2) {
  n2 = toInteger_default(n2);
  return baseRest_default(function(args) {
    return baseNth_default(args, n2);
  });
}
var nthArg_default = nthArg;

// node_modules/lodash-es/_baseUnset.js
var objectProto27 = Object.prototype;
var hasOwnProperty23 = objectProto27.hasOwnProperty;
function baseUnset(object, path) {
  path = castPath_default(path, object);
  var index8 = -1, length2 = path.length;
  if (!length2) {
    return true;
  }
  var isRootPrimitive = object == null || typeof object !== "object" && typeof object !== "function";
  while (++index8 < length2) {
    var key = path[index8];
    if (typeof key !== "string") {
      continue;
    }
    if (key === "__proto__" && !hasOwnProperty23.call(object, "__proto__")) {
      return false;
    }
    if (key === "constructor" && index8 + 1 < length2 && typeof path[index8 + 1] === "string" && path[index8 + 1] === "prototype") {
      if (isRootPrimitive && index8 === 0) {
        continue;
      }
      return false;
    }
  }
  var obj = parent_default(object, path);
  return obj == null || delete obj[toKey_default(last_default(path))];
}
var baseUnset_default = baseUnset;

// node_modules/lodash-es/_customOmitClone.js
function customOmitClone(value) {
  return isPlainObject_default(value) ? void 0 : value;
}
var customOmitClone_default = customOmitClone;

// node_modules/lodash-es/omit.js
var CLONE_DEEP_FLAG8 = 1;
var CLONE_FLAT_FLAG2 = 2;
var CLONE_SYMBOLS_FLAG6 = 4;
var omit3 = flatRest_default(function(object, paths) {
  var result2 = {};
  if (object == null) {
    return result2;
  }
  var isDeep = false;
  paths = arrayMap_default(paths, function(path) {
    path = castPath_default(path, object);
    isDeep || (isDeep = path.length > 1);
    return path;
  });
  copyObject_default(object, getAllKeysIn_default(object), result2);
  if (isDeep) {
    result2 = baseClone_default(result2, CLONE_DEEP_FLAG8 | CLONE_FLAT_FLAG2 | CLONE_SYMBOLS_FLAG6, customOmitClone_default);
  }
  var length2 = paths.length;
  while (length2--) {
    baseUnset_default(result2, paths[length2]);
  }
  return result2;
});
var omit_default = omit3;

// node_modules/lodash-es/_baseSet.js
function baseSet(object, path, value, customizer) {
  if (!isObject_default(object)) {
    return object;
  }
  path = castPath_default(path, object);
  var index8 = -1, length2 = path.length, lastIndex = length2 - 1, nested = object;
  while (nested != null && ++index8 < length2) {
    var key = toKey_default(path[index8]), newValue = value;
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return object;
    }
    if (index8 != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject_default(objValue) ? objValue : isIndex_default(path[index8 + 1]) ? [] : {};
      }
    }
    assignValue_default(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}
var baseSet_default = baseSet;

// node_modules/lodash-es/_basePickBy.js
function basePickBy(object, paths, predicate) {
  var index8 = -1, length2 = paths.length, result2 = {};
  while (++index8 < length2) {
    var path = paths[index8], value = baseGet_default(object, path);
    if (predicate(value, path)) {
      baseSet_default(result2, castPath_default(path, object), value);
    }
  }
  return result2;
}
var basePickBy_default = basePickBy;

// node_modules/lodash-es/pickBy.js
function pickBy(object, predicate) {
  if (object == null) {
    return {};
  }
  var props = arrayMap_default(getAllKeysIn_default(object), function(prop) {
    return [prop];
  });
  predicate = baseIteratee_default(predicate);
  return basePickBy_default(object, props, function(value, path) {
    return predicate(value, path[0]);
  });
}
var pickBy_default = pickBy;

// node_modules/lodash-es/omitBy.js
function omitBy(object, predicate) {
  return pickBy_default(object, negate_default(baseIteratee_default(predicate)));
}
var omitBy_default = omitBy;

// node_modules/lodash-es/once.js
function once(func) {
  return before_default(2, func);
}
var once_default = once;

// node_modules/lodash-es/_baseSortBy.js
function baseSortBy(array4, comparer) {
  var length2 = array4.length;
  array4.sort(comparer);
  while (length2--) {
    array4[length2] = array4[length2].value;
  }
  return array4;
}
var baseSortBy_default = baseSortBy;

// node_modules/lodash-es/_compareAscending.js
function compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol_default(value);
    var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol_default(other);
    if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
      return 1;
    }
    if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}
var compareAscending_default = compareAscending;

// node_modules/lodash-es/_compareMultiple.js
function compareMultiple(object, other, orders) {
  var index8 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length2 = objCriteria.length, ordersLength = orders.length;
  while (++index8 < length2) {
    var result2 = compareAscending_default(objCriteria[index8], othCriteria[index8]);
    if (result2) {
      if (index8 >= ordersLength) {
        return result2;
      }
      var order = orders[index8];
      return result2 * (order == "desc" ? -1 : 1);
    }
  }
  return object.index - other.index;
}
var compareMultiple_default = compareMultiple;

// node_modules/lodash-es/_baseOrderBy.js
function baseOrderBy(collection, iteratees, orders) {
  if (iteratees.length) {
    iteratees = arrayMap_default(iteratees, function(iteratee2) {
      if (isArray_default(iteratee2)) {
        return function(value) {
          return baseGet_default(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
        };
      }
      return iteratee2;
    });
  } else {
    iteratees = [identity_default2];
  }
  var index8 = -1;
  iteratees = arrayMap_default(iteratees, baseUnary_default(baseIteratee_default));
  var result2 = baseMap_default(collection, function(value, key, collection2) {
    var criteria = arrayMap_default(iteratees, function(iteratee2) {
      return iteratee2(value);
    });
    return { "criteria": criteria, "index": ++index8, "value": value };
  });
  return baseSortBy_default(result2, function(object, other) {
    return compareMultiple_default(object, other, orders);
  });
}
var baseOrderBy_default = baseOrderBy;

// node_modules/lodash-es/orderBy.js
function orderBy(collection, iteratees, orders, guard2) {
  if (collection == null) {
    return [];
  }
  if (!isArray_default(iteratees)) {
    iteratees = iteratees == null ? [] : [iteratees];
  }
  orders = guard2 ? void 0 : orders;
  if (!isArray_default(orders)) {
    orders = orders == null ? [] : [orders];
  }
  return baseOrderBy_default(collection, iteratees, orders);
}
var orderBy_default = orderBy;

// node_modules/lodash-es/_createOver.js
function createOver(arrayFunc) {
  return flatRest_default(function(iteratees) {
    iteratees = arrayMap_default(iteratees, baseUnary_default(baseIteratee_default));
    return baseRest_default(function(args) {
      var thisArg = this;
      return arrayFunc(iteratees, function(iteratee2) {
        return apply_default(iteratee2, thisArg, args);
      });
    });
  });
}
var createOver_default = createOver;

// node_modules/lodash-es/over.js
var over = createOver_default(arrayMap_default);
var over_default = over;

// node_modules/lodash-es/_castRest.js
var castRest = baseRest_default;
var castRest_default = castRest;

// node_modules/lodash-es/overArgs.js
var nativeMin9 = Math.min;
var overArgs = castRest_default(function(func, transforms) {
  transforms = transforms.length == 1 && isArray_default(transforms[0]) ? arrayMap_default(transforms[0], baseUnary_default(baseIteratee_default)) : arrayMap_default(baseFlatten_default(transforms, 1), baseUnary_default(baseIteratee_default));
  var funcsLength = transforms.length;
  return baseRest_default(function(args) {
    var index8 = -1, length2 = nativeMin9(args.length, funcsLength);
    while (++index8 < length2) {
      args[index8] = transforms[index8].call(this, args[index8]);
    }
    return apply_default(func, this, args);
  });
});
var overArgs_default = overArgs;

// node_modules/lodash-es/overEvery.js
var overEvery = createOver_default(arrayEvery_default);
var overEvery_default = overEvery;

// node_modules/lodash-es/overSome.js
var overSome = createOver_default(arraySome_default);
var overSome_default = overSome;

// node_modules/lodash-es/_baseRepeat.js
var MAX_SAFE_INTEGER4 = 9007199254740991;
var nativeFloor = Math.floor;
function baseRepeat(string2, n2) {
  var result2 = "";
  if (!string2 || n2 < 1 || n2 > MAX_SAFE_INTEGER4) {
    return result2;
  }
  do {
    if (n2 % 2) {
      result2 += string2;
    }
    n2 = nativeFloor(n2 / 2);
    if (n2) {
      string2 += string2;
    }
  } while (n2);
  return result2;
}
var baseRepeat_default = baseRepeat;

// node_modules/lodash-es/_asciiSize.js
var asciiSize = baseProperty_default("length");
var asciiSize_default = asciiSize;

// node_modules/lodash-es/_unicodeSize.js
var rsAstralRange4 = "\\ud800-\\udfff";
var rsComboMarksRange5 = "\\u0300-\\u036f";
var reComboHalfMarksRange5 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange5 = "\\u20d0-\\u20ff";
var rsComboRange5 = rsComboMarksRange5 + reComboHalfMarksRange5 + rsComboSymbolsRange5;
var rsVarRange4 = "\\ufe0e\\ufe0f";
var rsAstral2 = "[" + rsAstralRange4 + "]";
var rsCombo4 = "[" + rsComboRange5 + "]";
var rsFitz3 = "\\ud83c[\\udffb-\\udfff]";
var rsModifier3 = "(?:" + rsCombo4 + "|" + rsFitz3 + ")";
var rsNonAstral3 = "[^" + rsAstralRange4 + "]";
var rsRegional3 = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair3 = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsZWJ4 = "\\u200d";
var reOptMod3 = rsModifier3 + "?";
var rsOptVar3 = "[" + rsVarRange4 + "]?";
var rsOptJoin3 = "(?:" + rsZWJ4 + "(?:" + [rsNonAstral3, rsRegional3, rsSurrPair3].join("|") + ")" + rsOptVar3 + reOptMod3 + ")*";
var rsSeq3 = rsOptVar3 + reOptMod3 + rsOptJoin3;
var rsSymbol2 = "(?:" + [rsNonAstral3 + rsCombo4 + "?", rsCombo4, rsRegional3, rsSurrPair3, rsAstral2].join("|") + ")";
var reUnicode2 = RegExp(rsFitz3 + "(?=" + rsFitz3 + ")|" + rsSymbol2 + rsSeq3, "g");
function unicodeSize(string2) {
  var result2 = reUnicode2.lastIndex = 0;
  while (reUnicode2.test(string2)) {
    ++result2;
  }
  return result2;
}
var unicodeSize_default = unicodeSize;

// node_modules/lodash-es/_stringSize.js
function stringSize(string2) {
  return hasUnicode_default(string2) ? unicodeSize_default(string2) : asciiSize_default(string2);
}
var stringSize_default = stringSize;

// node_modules/lodash-es/_createPadding.js
var nativeCeil2 = Math.ceil;
function createPadding(length2, chars) {
  chars = chars === void 0 ? " " : baseToString_default(chars);
  var charsLength = chars.length;
  if (charsLength < 2) {
    return charsLength ? baseRepeat_default(chars, length2) : chars;
  }
  var result2 = baseRepeat_default(chars, nativeCeil2(length2 / stringSize_default(chars)));
  return hasUnicode_default(chars) ? castSlice_default(stringToArray_default(result2), 0, length2).join("") : result2.slice(0, length2);
}
var createPadding_default = createPadding;

// node_modules/lodash-es/pad.js
var nativeCeil3 = Math.ceil;
var nativeFloor2 = Math.floor;
function pad3(string2, length2, chars) {
  string2 = toString_default(string2);
  length2 = toInteger_default(length2);
  var strLength = length2 ? stringSize_default(string2) : 0;
  if (!length2 || strLength >= length2) {
    return string2;
  }
  var mid = (length2 - strLength) / 2;
  return createPadding_default(nativeFloor2(mid), chars) + string2 + createPadding_default(nativeCeil3(mid), chars);
}
var pad_default = pad3;

// node_modules/lodash-es/padEnd.js
function padEnd(string2, length2, chars) {
  string2 = toString_default(string2);
  length2 = toInteger_default(length2);
  var strLength = length2 ? stringSize_default(string2) : 0;
  return length2 && strLength < length2 ? string2 + createPadding_default(length2 - strLength, chars) : string2;
}
var padEnd_default = padEnd;

// node_modules/lodash-es/padStart.js
function padStart(string2, length2, chars) {
  string2 = toString_default(string2);
  length2 = toInteger_default(length2);
  var strLength = length2 ? stringSize_default(string2) : 0;
  return length2 && strLength < length2 ? createPadding_default(length2 - strLength, chars) + string2 : string2;
}
var padStart_default = padStart;

// node_modules/lodash-es/parseInt.js
var reTrimStart2 = /^\s+/;
var nativeParseInt = root_default4.parseInt;
function parseInt2(string2, radix, guard2) {
  if (guard2 || radix == null) {
    radix = 0;
  } else if (radix) {
    radix = +radix;
  }
  return nativeParseInt(toString_default(string2).replace(reTrimStart2, ""), radix || 0);
}
var parseInt_default = parseInt2;

// node_modules/lodash-es/partial.js
var WRAP_PARTIAL_FLAG7 = 32;
var partial = baseRest_default(function(func, partials) {
  var holders = replaceHolders_default(partials, getHolder_default(partial));
  return createWrap_default(func, WRAP_PARTIAL_FLAG7, void 0, partials, holders);
});
partial.placeholder = {};
var partial_default = partial;

// node_modules/lodash-es/partialRight.js
var WRAP_PARTIAL_RIGHT_FLAG4 = 64;
var partialRight = baseRest_default(function(func, partials) {
  var holders = replaceHolders_default(partials, getHolder_default(partialRight));
  return createWrap_default(func, WRAP_PARTIAL_RIGHT_FLAG4, void 0, partials, holders);
});
partialRight.placeholder = {};
var partialRight_default = partialRight;

// node_modules/lodash-es/partition.js
var partition = createAggregator_default(function(result2, value, key) {
  result2[key ? 0 : 1].push(value);
}, function() {
  return [[], []];
});
var partition_default = partition;

// node_modules/lodash-es/_basePick.js
function basePick(object, paths) {
  return basePickBy_default(object, paths, function(value, path) {
    return hasIn_default(object, path);
  });
}
var basePick_default = basePick;

// node_modules/lodash-es/pick.js
var pick = flatRest_default(function(object, paths) {
  return object == null ? {} : basePick_default(object, paths);
});
var pick_default = pick;

// node_modules/lodash-es/plant.js
function wrapperPlant(value) {
  var result2, parent2 = this;
  while (parent2 instanceof baseLodash_default) {
    var clone3 = wrapperClone_default(parent2);
    clone3.__index__ = 0;
    clone3.__values__ = void 0;
    if (result2) {
      previous.__wrapped__ = clone3;
    } else {
      result2 = clone3;
    }
    var previous = clone3;
    parent2 = parent2.__wrapped__;
  }
  previous.__wrapped__ = value;
  return result2;
}
var plant_default = wrapperPlant;

// node_modules/lodash-es/propertyOf.js
function propertyOf(object) {
  return function(path) {
    return object == null ? void 0 : baseGet_default(object, path);
  };
}
var propertyOf_default = propertyOf;

// node_modules/lodash-es/_baseIndexOfWith.js
function baseIndexOfWith(array4, value, fromIndex, comparator) {
  var index8 = fromIndex - 1, length2 = array4.length;
  while (++index8 < length2) {
    if (comparator(array4[index8], value)) {
      return index8;
    }
  }
  return -1;
}
var baseIndexOfWith_default = baseIndexOfWith;

// node_modules/lodash-es/_basePullAll.js
var arrayProto3 = Array.prototype;
var splice2 = arrayProto3.splice;
function basePullAll(array4, values2, iteratee2, comparator) {
  var indexOf2 = comparator ? baseIndexOfWith_default : baseIndexOf_default, index8 = -1, length2 = values2.length, seen = array4;
  if (array4 === values2) {
    values2 = copyArray_default(values2);
  }
  if (iteratee2) {
    seen = arrayMap_default(array4, baseUnary_default(iteratee2));
  }
  while (++index8 < length2) {
    var fromIndex = 0, value = values2[index8], computed = iteratee2 ? iteratee2(value) : value;
    while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
      if (seen !== array4) {
        splice2.call(seen, fromIndex, 1);
      }
      splice2.call(array4, fromIndex, 1);
    }
  }
  return array4;
}
var basePullAll_default = basePullAll;

// node_modules/lodash-es/pullAll.js
function pullAll(array4, values2) {
  return array4 && array4.length && values2 && values2.length ? basePullAll_default(array4, values2) : array4;
}
var pullAll_default = pullAll;

// node_modules/lodash-es/pull.js
var pull = baseRest_default(pullAll_default);
var pull_default = pull;

// node_modules/lodash-es/pullAllBy.js
function pullAllBy(array4, values2, iteratee2) {
  return array4 && array4.length && values2 && values2.length ? basePullAll_default(array4, values2, baseIteratee_default(iteratee2, 2)) : array4;
}
var pullAllBy_default = pullAllBy;

// node_modules/lodash-es/pullAllWith.js
function pullAllWith(array4, values2, comparator) {
  return array4 && array4.length && values2 && values2.length ? basePullAll_default(array4, values2, void 0, comparator) : array4;
}
var pullAllWith_default = pullAllWith;

// node_modules/lodash-es/_basePullAt.js
var arrayProto4 = Array.prototype;
var splice3 = arrayProto4.splice;
function basePullAt(array4, indexes2) {
  var length2 = array4 ? indexes2.length : 0, lastIndex = length2 - 1;
  while (length2--) {
    var index8 = indexes2[length2];
    if (length2 == lastIndex || index8 !== previous) {
      var previous = index8;
      if (isIndex_default(index8)) {
        splice3.call(array4, index8, 1);
      } else {
        baseUnset_default(array4, index8);
      }
    }
  }
  return array4;
}
var basePullAt_default = basePullAt;

// node_modules/lodash-es/pullAt.js
var pullAt = flatRest_default(function(array4, indexes2) {
  var length2 = array4 == null ? 0 : array4.length, result2 = baseAt_default(array4, indexes2);
  basePullAt_default(array4, arrayMap_default(indexes2, function(index8) {
    return isIndex_default(index8, length2) ? +index8 : index8;
  }).sort(compareAscending_default));
  return result2;
});
var pullAt_default = pullAt;

// node_modules/lodash-es/_baseRandom.js
var nativeFloor3 = Math.floor;
var nativeRandom = Math.random;
function baseRandom(lower2, upper) {
  return lower2 + nativeFloor3(nativeRandom() * (upper - lower2 + 1));
}
var baseRandom_default = baseRandom;

// node_modules/lodash-es/random.js
var freeParseFloat = parseFloat;
var nativeMin10 = Math.min;
var nativeRandom2 = Math.random;
function random(lower2, upper, floating) {
  if (floating && typeof floating != "boolean" && isIterateeCall_default(lower2, upper, floating)) {
    upper = floating = void 0;
  }
  if (floating === void 0) {
    if (typeof upper == "boolean") {
      floating = upper;
      upper = void 0;
    } else if (typeof lower2 == "boolean") {
      floating = lower2;
      lower2 = void 0;
    }
  }
  if (lower2 === void 0 && upper === void 0) {
    lower2 = 0;
    upper = 1;
  } else {
    lower2 = toFinite_default(lower2);
    if (upper === void 0) {
      upper = lower2;
      lower2 = 0;
    } else {
      upper = toFinite_default(upper);
    }
  }
  if (lower2 > upper) {
    var temp = lower2;
    lower2 = upper;
    upper = temp;
  }
  if (floating || lower2 % 1 || upper % 1) {
    var rand2 = nativeRandom2();
    return nativeMin10(lower2 + rand2 * (upper - lower2 + freeParseFloat("1e-" + ((rand2 + "").length - 1))), upper);
  }
  return baseRandom_default(lower2, upper);
}
var random_default = random;

// node_modules/lodash-es/_baseRange.js
var nativeCeil4 = Math.ceil;
var nativeMax13 = Math.max;
function baseRange(start2, end, step2, fromRight) {
  var index8 = -1, length2 = nativeMax13(nativeCeil4((end - start2) / (step2 || 1)), 0), result2 = Array(length2);
  while (length2--) {
    result2[fromRight ? length2 : ++index8] = start2;
    start2 += step2;
  }
  return result2;
}
var baseRange_default = baseRange;

// node_modules/lodash-es/_createRange.js
function createRange(fromRight) {
  return function(start2, end, step2) {
    if (step2 && typeof step2 != "number" && isIterateeCall_default(start2, end, step2)) {
      end = step2 = void 0;
    }
    start2 = toFinite_default(start2);
    if (end === void 0) {
      end = start2;
      start2 = 0;
    } else {
      end = toFinite_default(end);
    }
    step2 = step2 === void 0 ? start2 < end ? 1 : -1 : toFinite_default(step2);
    return baseRange_default(start2, end, step2, fromRight);
  };
}
var createRange_default = createRange;

// node_modules/lodash-es/range.js
var range3 = createRange_default();
var range_default = range3;

// node_modules/lodash-es/rangeRight.js
var rangeRight = createRange_default(true);
var rangeRight_default = rangeRight;

// node_modules/lodash-es/rearg.js
var WRAP_REARG_FLAG4 = 256;
var rearg = flatRest_default(function(func, indexes2) {
  return createWrap_default(func, WRAP_REARG_FLAG4, void 0, void 0, void 0, indexes2);
});
var rearg_default = rearg;

// node_modules/lodash-es/_baseReduce.js
function baseReduce(collection, iteratee2, accumulator, initAccum, eachFunc) {
  eachFunc(collection, function(value, index8, collection2) {
    accumulator = initAccum ? (initAccum = false, value) : iteratee2(accumulator, value, index8, collection2);
  });
  return accumulator;
}
var baseReduce_default = baseReduce;

// node_modules/lodash-es/reduce.js
function reduce2(collection, iteratee2, accumulator) {
  var func = isArray_default(collection) ? arrayReduce_default : baseReduce_default, initAccum = arguments.length < 3;
  return func(collection, baseIteratee_default(iteratee2, 4), accumulator, initAccum, baseEach_default);
}
var reduce_default = reduce2;

// node_modules/lodash-es/_arrayReduceRight.js
function arrayReduceRight(array4, iteratee2, accumulator, initAccum) {
  var length2 = array4 == null ? 0 : array4.length;
  if (initAccum && length2) {
    accumulator = array4[--length2];
  }
  while (length2--) {
    accumulator = iteratee2(accumulator, array4[length2], length2, array4);
  }
  return accumulator;
}
var arrayReduceRight_default = arrayReduceRight;

// node_modules/lodash-es/reduceRight.js
function reduceRight(collection, iteratee2, accumulator) {
  var func = isArray_default(collection) ? arrayReduceRight_default : baseReduce_default, initAccum = arguments.length < 3;
  return func(collection, baseIteratee_default(iteratee2, 4), accumulator, initAccum, baseEachRight_default);
}
var reduceRight_default = reduceRight;

// node_modules/lodash-es/reject.js
function reject(collection, predicate) {
  var func = isArray_default(collection) ? arrayFilter_default : baseFilter_default;
  return func(collection, negate_default(baseIteratee_default(predicate, 3)));
}
var reject_default = reject;

// node_modules/lodash-es/remove.js
function remove3(array4, predicate) {
  var result2 = [];
  if (!(array4 && array4.length)) {
    return result2;
  }
  var index8 = -1, indexes2 = [], length2 = array4.length;
  predicate = baseIteratee_default(predicate, 3);
  while (++index8 < length2) {
    var value = array4[index8];
    if (predicate(value, index8, array4)) {
      result2.push(value);
      indexes2.push(index8);
    }
  }
  basePullAt_default(array4, indexes2);
  return result2;
}
var remove_default6 = remove3;

// node_modules/lodash-es/repeat.js
function repeat(string2, n2, guard2) {
  if (guard2 ? isIterateeCall_default(string2, n2, guard2) : n2 === void 0) {
    n2 = 1;
  } else {
    n2 = toInteger_default(n2);
  }
  return baseRepeat_default(toString_default(string2), n2);
}
var repeat_default = repeat;

// node_modules/lodash-es/replace.js
function replace() {
  var args = arguments, string2 = toString_default(args[0]);
  return args.length < 3 ? string2 : string2.replace(args[1], args[2]);
}
var replace_default = replace;

// node_modules/lodash-es/rest.js
var FUNC_ERROR_TEXT10 = "Expected a function";
function rest(func, start2) {
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT10);
  }
  start2 = start2 === void 0 ? start2 : toInteger_default(start2);
  return baseRest_default(func, start2);
}
var rest_default = rest;

// node_modules/lodash-es/result.js
function result(object, path, defaultValue) {
  path = castPath_default(path, object);
  var index8 = -1, length2 = path.length;
  if (!length2) {
    length2 = 1;
    object = void 0;
  }
  while (++index8 < length2) {
    var value = object == null ? void 0 : object[toKey_default(path[index8])];
    if (value === void 0) {
      index8 = length2;
      value = defaultValue;
    }
    object = isFunction_default(value) ? value.call(object) : value;
  }
  return object;
}
var result_default = result;

// node_modules/lodash-es/reverse.js
var arrayProto5 = Array.prototype;
var nativeReverse = arrayProto5.reverse;
function reverse2(array4) {
  return array4 == null ? array4 : nativeReverse.call(array4);
}
var reverse_default = reverse2;

// node_modules/lodash-es/round.js
var round2 = createRound_default("round");
var round_default2 = round2;

// node_modules/lodash-es/_arraySample.js
function arraySample(array4) {
  var length2 = array4.length;
  return length2 ? array4[baseRandom_default(0, length2 - 1)] : void 0;
}
var arraySample_default = arraySample;

// node_modules/lodash-es/_baseSample.js
function baseSample(collection) {
  return arraySample_default(values_default(collection));
}
var baseSample_default = baseSample;

// node_modules/lodash-es/sample.js
function sample2(collection) {
  var func = isArray_default(collection) ? arraySample_default : baseSample_default;
  return func(collection);
}
var sample_default = sample2;

// node_modules/lodash-es/_shuffleSelf.js
function shuffleSelf(array4, size2) {
  var index8 = -1, length2 = array4.length, lastIndex = length2 - 1;
  size2 = size2 === void 0 ? length2 : size2;
  while (++index8 < size2) {
    var rand2 = baseRandom_default(index8, lastIndex), value = array4[rand2];
    array4[rand2] = array4[index8];
    array4[index8] = value;
  }
  array4.length = size2;
  return array4;
}
var shuffleSelf_default = shuffleSelf;

// node_modules/lodash-es/_arraySampleSize.js
function arraySampleSize(array4, n2) {
  return shuffleSelf_default(copyArray_default(array4), baseClamp_default(n2, 0, array4.length));
}
var arraySampleSize_default = arraySampleSize;

// node_modules/lodash-es/_baseSampleSize.js
function baseSampleSize(collection, n2) {
  var array4 = values_default(collection);
  return shuffleSelf_default(array4, baseClamp_default(n2, 0, array4.length));
}
var baseSampleSize_default = baseSampleSize;

// node_modules/lodash-es/sampleSize.js
function sampleSize(collection, n2, guard2) {
  if (guard2 ? isIterateeCall_default(collection, n2, guard2) : n2 === void 0) {
    n2 = 1;
  } else {
    n2 = toInteger_default(n2);
  }
  var func = isArray_default(collection) ? arraySampleSize_default : baseSampleSize_default;
  return func(collection, n2);
}
var sampleSize_default = sampleSize;

// node_modules/lodash-es/set.js
function set3(object, path, value) {
  return object == null ? object : baseSet_default(object, path, value);
}
var set_default = set3;

// node_modules/lodash-es/setWith.js
function setWith(object, path, value, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return object == null ? object : baseSet_default(object, path, value, customizer);
}
var setWith_default = setWith;

// node_modules/lodash-es/_arrayShuffle.js
function arrayShuffle(array4) {
  return shuffleSelf_default(copyArray_default(array4));
}
var arrayShuffle_default = arrayShuffle;

// node_modules/lodash-es/_baseShuffle.js
function baseShuffle(collection) {
  return shuffleSelf_default(values_default(collection));
}
var baseShuffle_default = baseShuffle;

// node_modules/lodash-es/shuffle.js
function shuffle(collection) {
  var func = isArray_default(collection) ? arrayShuffle_default : baseShuffle_default;
  return func(collection);
}
var shuffle_default2 = shuffle;

// node_modules/lodash-es/size.js
var mapTag10 = "[object Map]";
var setTag10 = "[object Set]";
function size(collection) {
  if (collection == null) {
    return 0;
  }
  if (isArrayLike_default(collection)) {
    return isString_default(collection) ? stringSize_default(collection) : collection.length;
  }
  var tag = getTag_default(collection);
  if (tag == mapTag10 || tag == setTag10) {
    return collection.size;
  }
  return baseKeys_default(collection).length;
}
var size_default5 = size;

// node_modules/lodash-es/slice.js
function slice3(array4, start2, end) {
  var length2 = array4 == null ? 0 : array4.length;
  if (!length2) {
    return [];
  }
  if (end && typeof end != "number" && isIterateeCall_default(array4, start2, end)) {
    start2 = 0;
    end = length2;
  } else {
    start2 = start2 == null ? 0 : toInteger_default(start2);
    end = end === void 0 ? length2 : toInteger_default(end);
  }
  return baseSlice_default(array4, start2, end);
}
var slice_default = slice3;

// node_modules/lodash-es/snakeCase.js
var snakeCase = createCompounder_default(function(result2, word, index8) {
  return result2 + (index8 ? "_" : "") + word.toLowerCase();
});
var snakeCase_default = snakeCase;

// node_modules/lodash-es/_baseSome.js
function baseSome(collection, predicate) {
  var result2;
  baseEach_default(collection, function(value, index8, collection2) {
    result2 = predicate(value, index8, collection2);
    return !result2;
  });
  return !!result2;
}
var baseSome_default = baseSome;

// node_modules/lodash-es/some.js
function some2(collection, predicate, guard2) {
  var func = isArray_default(collection) ? arraySome_default : baseSome_default;
  if (guard2 && isIterateeCall_default(collection, predicate, guard2)) {
    predicate = void 0;
  }
  return func(collection, baseIteratee_default(predicate, 3));
}
var some_default = some2;

// node_modules/lodash-es/sortBy.js
var sortBy = baseRest_default(function(collection, iteratees) {
  if (collection == null) {
    return [];
  }
  var length2 = iteratees.length;
  if (length2 > 1 && isIterateeCall_default(collection, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length2 > 2 && isIterateeCall_default(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }
  return baseOrderBy_default(collection, baseFlatten_default(iteratees, 1), []);
});
var sortBy_default = sortBy;

// node_modules/lodash-es/_baseSortedIndexBy.js
var MAX_ARRAY_LENGTH3 = 4294967295;
var MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH3 - 1;
var nativeFloor4 = Math.floor;
var nativeMin11 = Math.min;
function baseSortedIndexBy(array4, value, iteratee2, retHighest) {
  var low = 0, high = array4 == null ? 0 : array4.length;
  if (high === 0) {
    return 0;
  }
  value = iteratee2(value);
  var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol_default(value), valIsUndefined = value === void 0;
  while (low < high) {
    var mid = nativeFloor4((low + high) / 2), computed = iteratee2(array4[mid]), othIsDefined = computed !== void 0, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol_default(computed);
    if (valIsNaN) {
      var setLow = retHighest || othIsReflexive;
    } else if (valIsUndefined) {
      setLow = othIsReflexive && (retHighest || othIsDefined);
    } else if (valIsNull) {
      setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
    } else if (valIsSymbol) {
      setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
    } else if (othIsNull || othIsSymbol) {
      setLow = false;
    } else {
      setLow = retHighest ? computed <= value : computed < value;
    }
    if (setLow) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }
  return nativeMin11(high, MAX_ARRAY_INDEX);
}
var baseSortedIndexBy_default = baseSortedIndexBy;

// node_modules/lodash-es/_baseSortedIndex.js
var MAX_ARRAY_LENGTH4 = 4294967295;
var HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH4 >>> 1;
function baseSortedIndex(array4, value, retHighest) {
  var low = 0, high = array4 == null ? low : array4.length;
  if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
    while (low < high) {
      var mid = low + high >>> 1, computed = array4[mid];
      if (computed !== null && !isSymbol_default(computed) && (retHighest ? computed <= value : computed < value)) {
        low = mid + 1;
      } else {
        high = mid;
      }
    }
    return high;
  }
  return baseSortedIndexBy_default(array4, value, identity_default2, retHighest);
}
var baseSortedIndex_default = baseSortedIndex;

// node_modules/lodash-es/sortedIndex.js
function sortedIndex(array4, value) {
  return baseSortedIndex_default(array4, value);
}
var sortedIndex_default = sortedIndex;

// node_modules/lodash-es/sortedIndexBy.js
function sortedIndexBy(array4, value, iteratee2) {
  return baseSortedIndexBy_default(array4, value, baseIteratee_default(iteratee2, 2));
}
var sortedIndexBy_default = sortedIndexBy;

// node_modules/lodash-es/sortedIndexOf.js
function sortedIndexOf(array4, value) {
  var length2 = array4 == null ? 0 : array4.length;
  if (length2) {
    var index8 = baseSortedIndex_default(array4, value);
    if (index8 < length2 && eq_default(array4[index8], value)) {
      return index8;
    }
  }
  return -1;
}
var sortedIndexOf_default = sortedIndexOf;

// node_modules/lodash-es/sortedLastIndex.js
function sortedLastIndex(array4, value) {
  return baseSortedIndex_default(array4, value, true);
}
var sortedLastIndex_default = sortedLastIndex;

// node_modules/lodash-es/sortedLastIndexBy.js
function sortedLastIndexBy(array4, value, iteratee2) {
  return baseSortedIndexBy_default(array4, value, baseIteratee_default(iteratee2, 2), true);
}
var sortedLastIndexBy_default = sortedLastIndexBy;

// node_modules/lodash-es/sortedLastIndexOf.js
function sortedLastIndexOf(array4, value) {
  var length2 = array4 == null ? 0 : array4.length;
  if (length2) {
    var index8 = baseSortedIndex_default(array4, value, true) - 1;
    if (eq_default(array4[index8], value)) {
      return index8;
    }
  }
  return -1;
}
var sortedLastIndexOf_default = sortedLastIndexOf;

// node_modules/lodash-es/_baseSortedUniq.js
function baseSortedUniq(array4, iteratee2) {
  var index8 = -1, length2 = array4.length, resIndex = 0, result2 = [];
  while (++index8 < length2) {
    var value = array4[index8], computed = iteratee2 ? iteratee2(value) : value;
    if (!index8 || !eq_default(computed, seen)) {
      var seen = computed;
      result2[resIndex++] = value === 0 ? 0 : value;
    }
  }
  return result2;
}
var baseSortedUniq_default = baseSortedUniq;

// node_modules/lodash-es/sortedUniq.js
function sortedUniq(array4) {
  return array4 && array4.length ? baseSortedUniq_default(array4) : [];
}
var sortedUniq_default = sortedUniq;

// node_modules/lodash-es/sortedUniqBy.js
function sortedUniqBy(array4, iteratee2) {
  return array4 && array4.length ? baseSortedUniq_default(array4, baseIteratee_default(iteratee2, 2)) : [];
}
var sortedUniqBy_default = sortedUniqBy;

// node_modules/lodash-es/split.js
var MAX_ARRAY_LENGTH5 = 4294967295;
function split2(string2, separator, limit) {
  if (limit && typeof limit != "number" && isIterateeCall_default(string2, separator, limit)) {
    separator = limit = void 0;
  }
  limit = limit === void 0 ? MAX_ARRAY_LENGTH5 : limit >>> 0;
  if (!limit) {
    return [];
  }
  string2 = toString_default(string2);
  if (string2 && (typeof separator == "string" || separator != null && !isRegExp_default(separator))) {
    separator = baseToString_default(separator);
    if (!separator && hasUnicode_default(string2)) {
      return castSlice_default(stringToArray_default(string2), 0, limit);
    }
  }
  return string2.split(separator, limit);
}
var split_default = split2;

// node_modules/lodash-es/spread.js
var FUNC_ERROR_TEXT11 = "Expected a function";
var nativeMax14 = Math.max;
function spread(func, start2) {
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT11);
  }
  start2 = start2 == null ? 0 : nativeMax14(toInteger_default(start2), 0);
  return baseRest_default(function(args) {
    var array4 = args[start2], otherArgs = castSlice_default(args, 0, start2);
    if (array4) {
      arrayPush_default(otherArgs, array4);
    }
    return apply_default(func, this, otherArgs);
  });
}
var spread_default = spread;

// node_modules/lodash-es/startCase.js
var startCase = createCompounder_default(function(result2, word, index8) {
  return result2 + (index8 ? " " : "") + upperFirst_default(word);
});
var startCase_default = startCase;

// node_modules/lodash-es/startsWith.js
function startsWith(string2, target, position) {
  string2 = toString_default(string2);
  position = position == null ? 0 : baseClamp_default(toInteger_default(position), 0, string2.length);
  target = baseToString_default(target);
  return string2.slice(position, position + target.length) == target;
}
var startsWith_default = startsWith;

// node_modules/lodash-es/stubObject.js
function stubObject() {
  return {};
}
var stubObject_default = stubObject;

// node_modules/lodash-es/stubString.js
function stubString() {
  return "";
}
var stubString_default = stubString;

// node_modules/lodash-es/stubTrue.js
function stubTrue() {
  return true;
}
var stubTrue_default = stubTrue;

// node_modules/lodash-es/subtract.js
var subtract = createMathOperation_default(function(minuend, subtrahend) {
  return minuend - subtrahend;
}, 0);
var subtract_default = subtract;

// node_modules/lodash-es/sum.js
function sum2(array4) {
  return array4 && array4.length ? baseSum_default(array4, identity_default2) : 0;
}
var sum_default = sum2;

// node_modules/lodash-es/sumBy.js
function sumBy(array4, iteratee2) {
  return array4 && array4.length ? baseSum_default(array4, baseIteratee_default(iteratee2, 2)) : 0;
}
var sumBy_default = sumBy;

// node_modules/lodash-es/tail.js
function tail(array4) {
  var length2 = array4 == null ? 0 : array4.length;
  return length2 ? baseSlice_default(array4, 1, length2) : [];
}
var tail_default = tail;

// node_modules/lodash-es/take.js
function take(array4, n2, guard2) {
  if (!(array4 && array4.length)) {
    return [];
  }
  n2 = guard2 || n2 === void 0 ? 1 : toInteger_default(n2);
  return baseSlice_default(array4, 0, n2 < 0 ? 0 : n2);
}
var take_default = take;

// node_modules/lodash-es/takeRight.js
function takeRight(array4, n2, guard2) {
  var length2 = array4 == null ? 0 : array4.length;
  if (!length2) {
    return [];
  }
  n2 = guard2 || n2 === void 0 ? 1 : toInteger_default(n2);
  n2 = length2 - n2;
  return baseSlice_default(array4, n2 < 0 ? 0 : n2, length2);
}
var takeRight_default = takeRight;

// node_modules/lodash-es/takeRightWhile.js
function takeRightWhile(array4, predicate) {
  return array4 && array4.length ? baseWhile_default(array4, baseIteratee_default(predicate, 3), false, true) : [];
}
var takeRightWhile_default = takeRightWhile;

// node_modules/lodash-es/takeWhile.js
function takeWhile(array4, predicate) {
  return array4 && array4.length ? baseWhile_default(array4, baseIteratee_default(predicate, 3)) : [];
}
var takeWhile_default = takeWhile;

// node_modules/lodash-es/tap.js
function tap(value, interceptor) {
  interceptor(value);
  return value;
}
var tap_default = tap;

// node_modules/lodash-es/_customDefaultsAssignIn.js
var objectProto28 = Object.prototype;
var hasOwnProperty24 = objectProto28.hasOwnProperty;
function customDefaultsAssignIn(objValue, srcValue, key, object) {
  if (objValue === void 0 || eq_default(objValue, objectProto28[key]) && !hasOwnProperty24.call(object, key)) {
    return srcValue;
  }
  return objValue;
}
var customDefaultsAssignIn_default = customDefaultsAssignIn;

// node_modules/lodash-es/_escapeStringChar.js
var stringEscapes = {
  "\\": "\\",
  "'": "'",
  "\n": "n",
  "\r": "r",
  "\u2028": "u2028",
  "\u2029": "u2029"
};
function escapeStringChar(chr) {
  return "\\" + stringEscapes[chr];
}
var escapeStringChar_default = escapeStringChar;

// node_modules/lodash-es/_reInterpolate.js
var reInterpolate = /<%=([\s\S]+?)%>/g;
var reInterpolate_default = reInterpolate;

// node_modules/lodash-es/_reEscape.js
var reEscape = /<%-([\s\S]+?)%>/g;
var reEscape_default = reEscape;

// node_modules/lodash-es/_reEvaluate.js
var reEvaluate = /<%([\s\S]+?)%>/g;
var reEvaluate_default = reEvaluate;

// node_modules/lodash-es/templateSettings.js
var templateSettings = {
  /**
   * Used to detect `data` property values to be HTML-escaped.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  "escape": reEscape_default,
  /**
   * Used to detect code to be evaluated.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  "evaluate": reEvaluate_default,
  /**
   * Used to detect `data` property values to inject.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  "interpolate": reInterpolate_default,
  /**
   * Used to reference the data object in the template text.
   *
   * @memberOf _.templateSettings
   * @type {string}
   */
  "variable": "",
  /**
   * Used to import variables into the compiled template.
   *
   * @memberOf _.templateSettings
   * @type {Object}
   */
  "imports": {
    /**
     * A reference to the `lodash` function.
     *
     * @memberOf _.templateSettings.imports
     * @type {Function}
     */
    "_": { "escape": escape_default }
  }
};
var templateSettings_default = templateSettings;

// node_modules/lodash-es/template.js
var INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
var reEmptyStringLeading = /\b__p \+= '';/g;
var reEmptyStringMiddle = /\b(__p \+=) '' \+/g;
var reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
var reNoMatch = /($^)/;
var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
var objectProto29 = Object.prototype;
var hasOwnProperty25 = objectProto29.hasOwnProperty;
function template(string2, options, guard2) {
  var settings = templateSettings_default.imports._.templateSettings || templateSettings_default;
  if (guard2 && isIterateeCall_default(string2, options, guard2)) {
    options = void 0;
  }
  string2 = toString_default(string2);
  options = assignInWith_default({}, options, settings, customDefaultsAssignIn_default);
  var imports = assignInWith_default({}, options.imports, settings.imports, customDefaultsAssignIn_default), importsKeys = keys_default(imports), importsValues = baseValues_default(imports, importsKeys);
  var isEscaping, isEvaluating, index8 = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
  var reDelimiters = RegExp(
    (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate_default ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
    "g"
  );
  var sourceURL = hasOwnProperty25.call(options, "sourceURL") ? "//# sourceURL=" + (options.sourceURL + "").replace(/\s/g, " ") + "\n" : "";
  string2.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
    interpolateValue || (interpolateValue = esTemplateValue);
    source += string2.slice(index8, offset).replace(reUnescapedString, escapeStringChar_default);
    if (escapeValue) {
      isEscaping = true;
      source += "' +\n__e(" + escapeValue + ") +\n'";
    }
    if (evaluateValue) {
      isEvaluating = true;
      source += "';\n" + evaluateValue + ";\n__p += '";
    }
    if (interpolateValue) {
      source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
    }
    index8 = offset + match.length;
    return match;
  });
  source += "';\n";
  var variable = hasOwnProperty25.call(options, "variable") && options.variable;
  if (!variable) {
    source = "with (obj) {\n" + source + "\n}\n";
  } else if (reForbiddenIdentifierChars.test(variable)) {
    throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
  }
  source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
  source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
  var result2 = attempt_default(function() {
    return Function(importsKeys, sourceURL + "return " + source).apply(void 0, importsValues);
  });
  result2.source = source;
  if (isError_default(result2)) {
    throw result2;
  }
  return result2;
}
var template_default = template;

// node_modules/lodash-es/throttle.js
var FUNC_ERROR_TEXT12 = "Expected a function";
function throttle2(func, wait, options) {
  var leading = true, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT12);
  }
  if (isObject_default(options)) {
    leading = "leading" in options ? !!options.leading : leading;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  return debounce_default(func, wait, {
    "leading": leading,
    "maxWait": wait,
    "trailing": trailing
  });
}
var throttle_default = throttle2;

// node_modules/lodash-es/thru.js
function thru(value, interceptor) {
  return interceptor(value);
}
var thru_default = thru;

// node_modules/lodash-es/times.js
var MAX_SAFE_INTEGER5 = 9007199254740991;
var MAX_ARRAY_LENGTH6 = 4294967295;
var nativeMin12 = Math.min;
function times(n2, iteratee2) {
  n2 = toInteger_default(n2);
  if (n2 < 1 || n2 > MAX_SAFE_INTEGER5) {
    return [];
  }
  var index8 = MAX_ARRAY_LENGTH6, length2 = nativeMin12(n2, MAX_ARRAY_LENGTH6);
  iteratee2 = castFunction_default(iteratee2);
  n2 -= MAX_ARRAY_LENGTH6;
  var result2 = baseTimes_default(length2, iteratee2);
  while (++index8 < n2) {
    iteratee2(index8);
  }
  return result2;
}
var times_default = times;

// node_modules/lodash-es/toIterator.js
function wrapperToIterator() {
  return this;
}
var toIterator_default = wrapperToIterator;

// node_modules/lodash-es/_baseWrapperValue.js
function baseWrapperValue(value, actions) {
  var result2 = value;
  if (result2 instanceof LazyWrapper_default) {
    result2 = result2.value();
  }
  return arrayReduce_default(actions, function(result3, action) {
    return action.func.apply(action.thisArg, arrayPush_default([result3], action.args));
  }, result2);
}
var baseWrapperValue_default = baseWrapperValue;

// node_modules/lodash-es/wrapperValue.js
function wrapperValue() {
  return baseWrapperValue_default(this.__wrapped__, this.__actions__);
}
var wrapperValue_default = wrapperValue;

// node_modules/lodash-es/toLower.js
function toLower(value) {
  return toString_default(value).toLowerCase();
}
var toLower_default = toLower;

// node_modules/lodash-es/toPath.js
function toPath(value) {
  if (isArray_default(value)) {
    return arrayMap_default(value, toKey_default);
  }
  return isSymbol_default(value) ? [value] : copyArray_default(stringToPath_default(toString_default(value)));
}
var toPath_default = toPath;

// node_modules/lodash-es/toSafeInteger.js
var MAX_SAFE_INTEGER6 = 9007199254740991;
function toSafeInteger(value) {
  return value ? baseClamp_default(toInteger_default(value), -MAX_SAFE_INTEGER6, MAX_SAFE_INTEGER6) : value === 0 ? value : 0;
}
var toSafeInteger_default = toSafeInteger;

// node_modules/lodash-es/toUpper.js
function toUpper(value) {
  return toString_default(value).toUpperCase();
}
var toUpper_default = toUpper;

// node_modules/lodash-es/transform.js
function transform2(object, iteratee2, accumulator) {
  var isArr = isArray_default(object), isArrLike = isArr || isBuffer_default(object) || isTypedArray_default(object);
  iteratee2 = baseIteratee_default(iteratee2, 4);
  if (accumulator == null) {
    var Ctor = object && object.constructor;
    if (isArrLike) {
      accumulator = isArr ? new Ctor() : [];
    } else if (isObject_default(object)) {
      accumulator = isFunction_default(Ctor) ? baseCreate_default(getPrototype_default(object)) : {};
    } else {
      accumulator = {};
    }
  }
  (isArrLike ? arrayEach_default : baseForOwn_default)(object, function(value, index8, object2) {
    return iteratee2(accumulator, value, index8, object2);
  });
  return accumulator;
}
var transform_default = transform2;

// node_modules/lodash-es/_charsEndIndex.js
function charsEndIndex(strSymbols, chrSymbols) {
  var index8 = strSymbols.length;
  while (index8-- && baseIndexOf_default(chrSymbols, strSymbols[index8], 0) > -1) {
  }
  return index8;
}
var charsEndIndex_default = charsEndIndex;

// node_modules/lodash-es/_charsStartIndex.js
function charsStartIndex(strSymbols, chrSymbols) {
  var index8 = -1, length2 = strSymbols.length;
  while (++index8 < length2 && baseIndexOf_default(chrSymbols, strSymbols[index8], 0) > -1) {
  }
  return index8;
}
var charsStartIndex_default = charsStartIndex;

// node_modules/lodash-es/trim.js
function trim(string2, chars, guard2) {
  string2 = toString_default(string2);
  if (string2 && (guard2 || chars === void 0)) {
    return baseTrim_default(string2);
  }
  if (!string2 || !(chars = baseToString_default(chars))) {
    return string2;
  }
  var strSymbols = stringToArray_default(string2), chrSymbols = stringToArray_default(chars), start2 = charsStartIndex_default(strSymbols, chrSymbols), end = charsEndIndex_default(strSymbols, chrSymbols) + 1;
  return castSlice_default(strSymbols, start2, end).join("");
}
var trim_default = trim;

// node_modules/lodash-es/trimEnd.js
function trimEnd(string2, chars, guard2) {
  string2 = toString_default(string2);
  if (string2 && (guard2 || chars === void 0)) {
    return string2.slice(0, trimmedEndIndex_default(string2) + 1);
  }
  if (!string2 || !(chars = baseToString_default(chars))) {
    return string2;
  }
  var strSymbols = stringToArray_default(string2), end = charsEndIndex_default(strSymbols, stringToArray_default(chars)) + 1;
  return castSlice_default(strSymbols, 0, end).join("");
}
var trimEnd_default = trimEnd;

// node_modules/lodash-es/trimStart.js
var reTrimStart3 = /^\s+/;
function trimStart(string2, chars, guard2) {
  string2 = toString_default(string2);
  if (string2 && (guard2 || chars === void 0)) {
    return string2.replace(reTrimStart3, "");
  }
  if (!string2 || !(chars = baseToString_default(chars))) {
    return string2;
  }
  var strSymbols = stringToArray_default(string2), start2 = charsStartIndex_default(strSymbols, stringToArray_default(chars));
  return castSlice_default(strSymbols, start2).join("");
}
var trimStart_default = trimStart;

// node_modules/lodash-es/truncate.js
var DEFAULT_TRUNC_LENGTH = 30;
var DEFAULT_TRUNC_OMISSION = "...";
var reFlags2 = /\w*$/;
function truncate(string2, options) {
  var length2 = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
  if (isObject_default(options)) {
    var separator = "separator" in options ? options.separator : separator;
    length2 = "length" in options ? toInteger_default(options.length) : length2;
    omission = "omission" in options ? baseToString_default(options.omission) : omission;
  }
  string2 = toString_default(string2);
  var strLength = string2.length;
  if (hasUnicode_default(string2)) {
    var strSymbols = stringToArray_default(string2);
    strLength = strSymbols.length;
  }
  if (length2 >= strLength) {
    return string2;
  }
  var end = length2 - stringSize_default(omission);
  if (end < 1) {
    return omission;
  }
  var result2 = strSymbols ? castSlice_default(strSymbols, 0, end).join("") : string2.slice(0, end);
  if (separator === void 0) {
    return result2 + omission;
  }
  if (strSymbols) {
    end += result2.length - end;
  }
  if (isRegExp_default(separator)) {
    if (string2.slice(end).search(separator)) {
      var match, substring = result2;
      if (!separator.global) {
        separator = RegExp(separator.source, toString_default(reFlags2.exec(separator)) + "g");
      }
      separator.lastIndex = 0;
      while (match = separator.exec(substring)) {
        var newEnd = match.index;
      }
      result2 = result2.slice(0, newEnd === void 0 ? end : newEnd);
    }
  } else if (string2.indexOf(baseToString_default(separator), end) != end) {
    var index8 = result2.lastIndexOf(separator);
    if (index8 > -1) {
      result2 = result2.slice(0, index8);
    }
  }
  return result2 + omission;
}
var truncate_default = truncate;

// node_modules/lodash-es/unary.js
function unary(func) {
  return ary_default(func, 1);
}
var unary_default = unary;

// node_modules/lodash-es/_unescapeHtmlChar.js
var htmlUnescapes = {
  "&amp;": "&",
  "&lt;": "<",
  "&gt;": ">",
  "&quot;": '"',
  "&#39;": "'"
};
var unescapeHtmlChar = basePropertyOf_default(htmlUnescapes);
var unescapeHtmlChar_default = unescapeHtmlChar;

// node_modules/lodash-es/unescape.js
var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g;
var reHasEscapedHtml = RegExp(reEscapedHtml.source);
function unescape(string2) {
  string2 = toString_default(string2);
  return string2 && reHasEscapedHtml.test(string2) ? string2.replace(reEscapedHtml, unescapeHtmlChar_default) : string2;
}
var unescape_default = unescape;

// node_modules/lodash-es/_createSet.js
var INFINITY7 = 1 / 0;
var createSet = !(Set_default && 1 / setToArray_default(new Set_default([, -0]))[1] == INFINITY7) ? noop_default : function(values2) {
  return new Set_default(values2);
};
var createSet_default = createSet;

// node_modules/lodash-es/_baseUniq.js
var LARGE_ARRAY_SIZE3 = 200;
function baseUniq(array4, iteratee2, comparator) {
  var index8 = -1, includes2 = arrayIncludes_default, length2 = array4.length, isCommon = true, result2 = [], seen = result2;
  if (comparator) {
    isCommon = false;
    includes2 = arrayIncludesWith_default;
  } else if (length2 >= LARGE_ARRAY_SIZE3) {
    var set4 = iteratee2 ? null : createSet_default(array4);
    if (set4) {
      return setToArray_default(set4);
    }
    isCommon = false;
    includes2 = cacheHas_default;
    seen = new SetCache_default();
  } else {
    seen = iteratee2 ? [] : result2;
  }
  outer:
    while (++index8 < length2) {
      var value = array4[index8], computed = iteratee2 ? iteratee2(value) : value;
      value = comparator || value !== 0 ? value : 0;
      if (isCommon && computed === computed) {
        var seenIndex = seen.length;
        while (seenIndex--) {
          if (seen[seenIndex] === computed) {
            continue outer;
          }
        }
        if (iteratee2) {
          seen.push(computed);
        }
        result2.push(value);
      } else if (!includes2(seen, computed, comparator)) {
        if (seen !== result2) {
          seen.push(computed);
        }
        result2.push(value);
      }
    }
  return result2;
}
var baseUniq_default = baseUniq;

// node_modules/lodash-es/union.js
var union2 = baseRest_default(function(arrays) {
  return baseUniq_default(baseFlatten_default(arrays, 1, isArrayLikeObject_default, true));
});
var union_default = union2;

// node_modules/lodash-es/unionBy.js
var unionBy = baseRest_default(function(arrays) {
  var iteratee2 = last_default(arrays);
  if (isArrayLikeObject_default(iteratee2)) {
    iteratee2 = void 0;
  }
  return baseUniq_default(baseFlatten_default(arrays, 1, isArrayLikeObject_default, true), baseIteratee_default(iteratee2, 2));
});
var unionBy_default = unionBy;

// node_modules/lodash-es/unionWith.js
var unionWith = baseRest_default(function(arrays) {
  var comparator = last_default(arrays);
  comparator = typeof comparator == "function" ? comparator : void 0;
  return baseUniq_default(baseFlatten_default(arrays, 1, isArrayLikeObject_default, true), void 0, comparator);
});
var unionWith_default = unionWith;

// node_modules/lodash-es/uniq.js
function uniq(array4) {
  return array4 && array4.length ? baseUniq_default(array4) : [];
}
var uniq_default = uniq;

// node_modules/lodash-es/uniqBy.js
function uniqBy(array4, iteratee2) {
  return array4 && array4.length ? baseUniq_default(array4, baseIteratee_default(iteratee2, 2)) : [];
}
var uniqBy_default = uniqBy;

// node_modules/lodash-es/uniqWith.js
function uniqWith(array4, comparator) {
  comparator = typeof comparator == "function" ? comparator : void 0;
  return array4 && array4.length ? baseUniq_default(array4, void 0, comparator) : [];
}
var uniqWith_default = uniqWith;

// node_modules/lodash-es/uniqueId.js
var idCounter = 0;
function uniqueId(prefix) {
  var id2 = ++idCounter;
  return toString_default(prefix) + id2;
}
var uniqueId_default = uniqueId;

// node_modules/lodash-es/unset.js
function unset(object, path) {
  return object == null ? true : baseUnset_default(object, path);
}
var unset_default = unset;

// node_modules/lodash-es/unzip.js
var nativeMax15 = Math.max;
function unzip(array4) {
  if (!(array4 && array4.length)) {
    return [];
  }
  var length2 = 0;
  array4 = arrayFilter_default(array4, function(group2) {
    if (isArrayLikeObject_default(group2)) {
      length2 = nativeMax15(group2.length, length2);
      return true;
    }
  });
  return baseTimes_default(length2, function(index8) {
    return arrayMap_default(array4, baseProperty_default(index8));
  });
}
var unzip_default = unzip;

// node_modules/lodash-es/unzipWith.js
function unzipWith(array4, iteratee2) {
  if (!(array4 && array4.length)) {
    return [];
  }
  var result2 = unzip_default(array4);
  if (iteratee2 == null) {
    return result2;
  }
  return arrayMap_default(result2, function(group2) {
    return apply_default(iteratee2, void 0, group2);
  });
}
var unzipWith_default = unzipWith;

// node_modules/lodash-es/_baseUpdate.js
function baseUpdate(object, path, updater, customizer) {
  return baseSet_default(object, path, updater(baseGet_default(object, path)), customizer);
}
var baseUpdate_default = baseUpdate;

// node_modules/lodash-es/update.js
function update7(object, path, updater) {
  return object == null ? object : baseUpdate_default(object, path, castFunction_default(updater));
}
var update_default = update7;

// node_modules/lodash-es/updateWith.js
function updateWith(object, path, updater, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return object == null ? object : baseUpdate_default(object, path, castFunction_default(updater), customizer);
}
var updateWith_default = updateWith;

// node_modules/lodash-es/upperCase.js
var upperCase = createCompounder_default(function(result2, word, index8) {
  return result2 + (index8 ? " " : "") + word.toUpperCase();
});
var upperCase_default = upperCase;

// node_modules/lodash-es/valuesIn.js
function valuesIn(object) {
  return object == null ? [] : baseValues_default(object, keysIn_default(object));
}
var valuesIn_default = valuesIn;

// node_modules/lodash-es/without.js
var without = baseRest_default(function(array4, values2) {
  return isArrayLikeObject_default(array4) ? baseDifference_default(array4, values2) : [];
});
var without_default = without;

// node_modules/lodash-es/wrap.js
function wrap(value, wrapper) {
  return partial_default(castFunction_default(wrapper), value);
}
var wrap_default = wrap;

// node_modules/lodash-es/wrapperAt.js
var wrapperAt = flatRest_default(function(paths) {
  var length2 = paths.length, start2 = length2 ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
    return baseAt_default(object, paths);
  };
  if (length2 > 1 || this.__actions__.length || !(value instanceof LazyWrapper_default) || !isIndex_default(start2)) {
    return this.thru(interceptor);
  }
  value = value.slice(start2, +start2 + (length2 ? 1 : 0));
  value.__actions__.push({
    "func": thru_default,
    "args": [interceptor],
    "thisArg": void 0
  });
  return new LodashWrapper_default(value, this.__chain__).thru(function(array4) {
    if (length2 && !array4.length) {
      array4.push(void 0);
    }
    return array4;
  });
});
var wrapperAt_default = wrapperAt;

// node_modules/lodash-es/wrapperChain.js
function wrapperChain() {
  return chain_default(this);
}
var wrapperChain_default = wrapperChain;

// node_modules/lodash-es/wrapperReverse.js
function wrapperReverse() {
  var value = this.__wrapped__;
  if (value instanceof LazyWrapper_default) {
    var wrapped = value;
    if (this.__actions__.length) {
      wrapped = new LazyWrapper_default(this);
    }
    wrapped = wrapped.reverse();
    wrapped.__actions__.push({
      "func": thru_default,
      "args": [reverse_default],
      "thisArg": void 0
    });
    return new LodashWrapper_default(wrapped, this.__chain__);
  }
  return this.thru(reverse_default);
}
var wrapperReverse_default = wrapperReverse;

// node_modules/lodash-es/_baseXor.js
function baseXor(arrays, iteratee2, comparator) {
  var length2 = arrays.length;
  if (length2 < 2) {
    return length2 ? baseUniq_default(arrays[0]) : [];
  }
  var index8 = -1, result2 = Array(length2);
  while (++index8 < length2) {
    var array4 = arrays[index8], othIndex = -1;
    while (++othIndex < length2) {
      if (othIndex != index8) {
        result2[index8] = baseDifference_default(result2[index8] || array4, arrays[othIndex], iteratee2, comparator);
      }
    }
  }
  return baseUniq_default(baseFlatten_default(result2, 1), iteratee2, comparator);
}
var baseXor_default = baseXor;

// node_modules/lodash-es/xor.js
var xor2 = baseRest_default(function(arrays) {
  return baseXor_default(arrayFilter_default(arrays, isArrayLikeObject_default));
});
var xor_default = xor2;

// node_modules/lodash-es/xorBy.js
var xorBy = baseRest_default(function(arrays) {
  var iteratee2 = last_default(arrays);
  if (isArrayLikeObject_default(iteratee2)) {
    iteratee2 = void 0;
  }
  return baseXor_default(arrayFilter_default(arrays, isArrayLikeObject_default), baseIteratee_default(iteratee2, 2));
});
var xorBy_default = xorBy;

// node_modules/lodash-es/xorWith.js
var xorWith = baseRest_default(function(arrays) {
  var comparator = last_default(arrays);
  comparator = typeof comparator == "function" ? comparator : void 0;
  return baseXor_default(arrayFilter_default(arrays, isArrayLikeObject_default), void 0, comparator);
});
var xorWith_default = xorWith;

// node_modules/lodash-es/zip.js
var zip2 = baseRest_default(unzip_default);
var zip_default = zip2;

// node_modules/lodash-es/_baseZipObject.js
function baseZipObject(props, values2, assignFunc) {
  var index8 = -1, length2 = props.length, valsLength = values2.length, result2 = {};
  while (++index8 < length2) {
    var value = index8 < valsLength ? values2[index8] : void 0;
    assignFunc(result2, props[index8], value);
  }
  return result2;
}
var baseZipObject_default = baseZipObject;

// node_modules/lodash-es/zipObject.js
function zipObject(props, values2) {
  return baseZipObject_default(props || [], values2 || [], assignValue_default);
}
var zipObject_default = zipObject;

// node_modules/lodash-es/zipObjectDeep.js
function zipObjectDeep(props, values2) {
  return baseZipObject_default(props || [], values2 || [], baseSet_default);
}
var zipObjectDeep_default = zipObjectDeep;

// node_modules/lodash-es/zipWith.js
var zipWith = baseRest_default(function(arrays) {
  var length2 = arrays.length, iteratee2 = length2 > 1 ? arrays[length2 - 1] : void 0;
  iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : void 0;
  return unzipWith_default(arrays, iteratee2);
});
var zipWith_default = zipWith;

// node_modules/lodash-es/array.default.js
var array_default_default = {
  chunk: chunk_default,
  compact: compact_default,
  concat: concat_default,
  difference: difference_default,
  differenceBy: differenceBy_default,
  differenceWith: differenceWith_default,
  drop: drop_default,
  dropRight: dropRight_default,
  dropRightWhile: dropRightWhile_default,
  dropWhile: dropWhile_default,
  fill: fill_default,
  findIndex: findIndex_default,
  findLastIndex: findLastIndex_default,
  first: head_default,
  flatten: flatten_default,
  flattenDeep: flattenDeep_default,
  flattenDepth: flattenDepth_default,
  fromPairs: fromPairs_default,
  head: head_default,
  indexOf: indexOf_default,
  initial: initial_default,
  intersection: intersection_default,
  intersectionBy: intersectionBy_default,
  intersectionWith: intersectionWith_default,
  join: join_default2,
  last: last_default,
  lastIndexOf: lastIndexOf_default,
  nth: nth_default,
  pull: pull_default,
  pullAll: pullAll_default,
  pullAllBy: pullAllBy_default,
  pullAllWith: pullAllWith_default,
  pullAt: pullAt_default,
  remove: remove_default6,
  reverse: reverse_default,
  slice: slice_default,
  sortedIndex: sortedIndex_default,
  sortedIndexBy: sortedIndexBy_default,
  sortedIndexOf: sortedIndexOf_default,
  sortedLastIndex: sortedLastIndex_default,
  sortedLastIndexBy: sortedLastIndexBy_default,
  sortedLastIndexOf: sortedLastIndexOf_default,
  sortedUniq: sortedUniq_default,
  sortedUniqBy: sortedUniqBy_default,
  tail: tail_default,
  take: take_default,
  takeRight: takeRight_default,
  takeRightWhile: takeRightWhile_default,
  takeWhile: takeWhile_default,
  union: union_default,
  unionBy: unionBy_default,
  unionWith: unionWith_default,
  uniq: uniq_default,
  uniqBy: uniqBy_default,
  uniqWith: uniqWith_default,
  unzip: unzip_default,
  unzipWith: unzipWith_default,
  without: without_default,
  xor: xor_default,
  xorBy: xorBy_default,
  xorWith: xorWith_default,
  zip: zip_default,
  zipObject: zipObject_default,
  zipObjectDeep: zipObjectDeep_default,
  zipWith: zipWith_default
};

// node_modules/lodash-es/collection.default.js
var collection_default_default = {
  countBy: countBy_default,
  each: forEach_default,
  eachRight: forEachRight_default,
  every: every_default,
  filter: filter_default3,
  find: find_default4,
  findLast: findLast_default,
  flatMap: flatMap_default,
  flatMapDeep: flatMapDeep_default,
  flatMapDepth: flatMapDepth_default,
  forEach: forEach_default,
  forEachRight: forEachRight_default,
  groupBy: groupBy_default,
  includes: includes_default,
  invokeMap: invokeMap_default,
  keyBy: keyBy_default,
  map: map_default,
  orderBy: orderBy_default,
  partition: partition_default,
  reduce: reduce_default,
  reduceRight: reduceRight_default,
  reject: reject_default,
  sample: sample_default,
  sampleSize: sampleSize_default,
  shuffle: shuffle_default2,
  size: size_default5,
  some: some_default,
  sortBy: sortBy_default
};

// node_modules/lodash-es/date.default.js
var date_default_default = {
  now: now_default
};

// node_modules/lodash-es/function.default.js
var function_default_default = {
  after: after_default,
  ary: ary_default,
  before: before_default,
  bind: bind_default,
  bindKey: bindKey_default,
  curry: curry_default,
  curryRight: curryRight_default,
  debounce: debounce_default,
  defer: defer_default,
  delay: delay_default2,
  flip: flip_default,
  memoize: memoize_default,
  negate: negate_default,
  once: once_default,
  overArgs: overArgs_default,
  partial: partial_default,
  partialRight: partialRight_default,
  rearg: rearg_default,
  rest: rest_default,
  spread: spread_default,
  throttle: throttle_default,
  unary: unary_default,
  wrap: wrap_default
};

// node_modules/lodash-es/lang.default.js
var lang_default_default = {
  castArray: castArray_default,
  clone: clone_default2,
  cloneDeep: cloneDeep_default,
  cloneDeepWith: cloneDeepWith_default,
  cloneWith: cloneWith_default,
  conformsTo: conformsTo_default,
  eq: eq_default,
  gt: gt_default,
  gte: gte_default,
  isArguments: isArguments_default,
  isArray: isArray_default,
  isArrayBuffer: isArrayBuffer_default,
  isArrayLike: isArrayLike_default,
  isArrayLikeObject: isArrayLikeObject_default,
  isBoolean: isBoolean_default,
  isBuffer: isBuffer_default,
  isDate: isDate_default,
  isElement: isElement_default,
  isEmpty: isEmpty_default,
  isEqual: isEqual_default,
  isEqualWith: isEqualWith_default,
  isError: isError_default,
  isFinite: isFinite_default,
  isFunction: isFunction_default,
  isInteger: isInteger_default,
  isLength: isLength_default,
  isMap: isMap_default,
  isMatch: isMatch_default,
  isMatchWith: isMatchWith_default,
  isNaN: isNaN_default,
  isNative: isNative_default,
  isNil: isNil_default,
  isNull: isNull_default,
  isNumber: isNumber_default,
  isObject: isObject_default,
  isObjectLike: isObjectLike_default,
  isPlainObject: isPlainObject_default,
  isRegExp: isRegExp_default,
  isSafeInteger: isSafeInteger_default,
  isSet: isSet_default,
  isString: isString_default,
  isSymbol: isSymbol_default,
  isTypedArray: isTypedArray_default,
  isUndefined: isUndefined_default,
  isWeakMap: isWeakMap_default,
  isWeakSet: isWeakSet_default,
  lt: lt_default,
  lte: lte_default,
  toArray: toArray_default,
  toFinite: toFinite_default,
  toInteger: toInteger_default,
  toLength: toLength_default,
  toNumber: toNumber_default,
  toPlainObject: toPlainObject_default,
  toSafeInteger: toSafeInteger_default,
  toString: toString_default
};

// node_modules/lodash-es/math.default.js
var math_default_default = {
  add: add_default4,
  ceil: ceil_default,
  divide: divide_default,
  floor: floor_default,
  max: max_default,
  maxBy: maxBy_default,
  mean: mean_default,
  meanBy: meanBy_default,
  min: min_default,
  minBy: minBy_default,
  multiply: multiply_default,
  round: round_default2,
  subtract: subtract_default,
  sum: sum_default,
  sumBy: sumBy_default
};

// node_modules/lodash-es/number.default.js
var number_default_default = {
  clamp: clamp_default,
  inRange: inRange_default,
  random: random_default
};

// node_modules/lodash-es/object.default.js
var object_default_default = {
  assign: assign_default,
  assignIn: assignIn_default,
  assignInWith: assignInWith_default,
  assignWith: assignWith_default,
  at: at_default,
  create: create_default2,
  defaults: defaults_default,
  defaultsDeep: defaultsDeep_default,
  entries: toPairs_default,
  entriesIn: toPairsIn_default,
  extend: assignIn_default,
  extendWith: assignInWith_default,
  findKey: findKey_default,
  findLastKey: findLastKey_default,
  forIn: forIn_default,
  forInRight: forInRight_default,
  forOwn: forOwn_default,
  forOwnRight: forOwnRight_default,
  functions: functions_default,
  functionsIn: functionsIn_default,
  get: get_default,
  has: has_default,
  hasIn: hasIn_default,
  invert: invert_default,
  invertBy: invertBy_default,
  invoke: invoke_default,
  keys: keys_default,
  keysIn: keysIn_default,
  mapKeys: mapKeys_default,
  mapValues: mapValues_default,
  merge: merge_default3,
  mergeWith: mergeWith_default,
  omit: omit_default,
  omitBy: omitBy_default,
  pick: pick_default,
  pickBy: pickBy_default,
  result: result_default,
  set: set_default,
  setWith: setWith_default,
  toPairs: toPairs_default,
  toPairsIn: toPairsIn_default,
  transform: transform_default,
  unset: unset_default,
  update: update_default,
  updateWith: updateWith_default,
  values: values_default,
  valuesIn: valuesIn_default
};

// node_modules/lodash-es/seq.default.js
var seq_default_default = {
  at: wrapperAt_default,
  chain: chain_default,
  commit: commit_default,
  lodash: wrapperLodash_default,
  next: next_default,
  plant: plant_default,
  reverse: wrapperReverse_default,
  tap: tap_default,
  thru: thru_default,
  toIterator: toIterator_default,
  toJSON: wrapperValue_default,
  value: wrapperValue_default,
  valueOf: wrapperValue_default,
  wrapperChain: wrapperChain_default
};

// node_modules/lodash-es/string.default.js
var string_default_default = {
  camelCase: camelCase_default,
  capitalize: capitalize_default,
  deburr: deburr_default,
  endsWith: endsWith_default,
  escape: escape_default,
  escapeRegExp: escapeRegExp_default,
  kebabCase: kebabCase_default,
  lowerCase: lowerCase_default,
  lowerFirst: lowerFirst_default,
  pad: pad_default,
  padEnd: padEnd_default,
  padStart: padStart_default,
  parseInt: parseInt_default,
  repeat: repeat_default,
  replace: replace_default,
  snakeCase: snakeCase_default,
  split: split_default,
  startCase: startCase_default,
  startsWith: startsWith_default,
  template: template_default,
  templateSettings: templateSettings_default,
  toLower: toLower_default,
  toUpper: toUpper_default,
  trim: trim_default,
  trimEnd: trimEnd_default,
  trimStart: trimStart_default,
  truncate: truncate_default,
  unescape: unescape_default,
  upperCase: upperCase_default,
  upperFirst: upperFirst_default,
  words: words_default
};

// node_modules/lodash-es/util.default.js
var util_default_default = {
  attempt: attempt_default,
  bindAll: bindAll_default,
  cond: cond_default,
  conforms: conforms_default,
  constant: constant_default6,
  defaultTo: defaultTo_default,
  flow: flow_default,
  flowRight: flowRight_default,
  identity: identity_default2,
  iteratee: iteratee_default,
  matches: matches_default,
  matchesProperty: matchesProperty_default,
  method: method_default,
  methodOf: methodOf_default,
  mixin: mixin_default,
  noop: noop_default,
  nthArg: nthArg_default,
  over: over_default,
  overEvery: overEvery_default,
  overSome: overSome_default,
  property: property_default2,
  propertyOf: propertyOf_default,
  range: range_default,
  rangeRight: rangeRight_default,
  stubArray: stubArray_default,
  stubFalse: stubFalse_default,
  stubObject: stubObject_default,
  stubString: stubString_default,
  stubTrue: stubTrue_default,
  times: times_default,
  toPath: toPath_default,
  uniqueId: uniqueId_default
};

// node_modules/lodash-es/_lazyClone.js
function lazyClone() {
  var result2 = new LazyWrapper_default(this.__wrapped__);
  result2.__actions__ = copyArray_default(this.__actions__);
  result2.__dir__ = this.__dir__;
  result2.__filtered__ = this.__filtered__;
  result2.__iteratees__ = copyArray_default(this.__iteratees__);
  result2.__takeCount__ = this.__takeCount__;
  result2.__views__ = copyArray_default(this.__views__);
  return result2;
}
var lazyClone_default = lazyClone;

// node_modules/lodash-es/_lazyReverse.js
function lazyReverse() {
  if (this.__filtered__) {
    var result2 = new LazyWrapper_default(this);
    result2.__dir__ = -1;
    result2.__filtered__ = true;
  } else {
    result2 = this.clone();
    result2.__dir__ *= -1;
  }
  return result2;
}
var lazyReverse_default = lazyReverse;

// node_modules/lodash-es/_getView.js
var nativeMax16 = Math.max;
var nativeMin13 = Math.min;
function getView(start2, end, transforms) {
  var index8 = -1, length2 = transforms.length;
  while (++index8 < length2) {
    var data = transforms[index8], size2 = data.size;
    switch (data.type) {
      case "drop":
        start2 += size2;
        break;
      case "dropRight":
        end -= size2;
        break;
      case "take":
        end = nativeMin13(end, start2 + size2);
        break;
      case "takeRight":
        start2 = nativeMax16(start2, end - size2);
        break;
    }
  }
  return { "start": start2, "end": end };
}
var getView_default = getView;

// node_modules/lodash-es/_lazyValue.js
var LAZY_FILTER_FLAG = 1;
var LAZY_MAP_FLAG = 2;
var nativeMin14 = Math.min;
function lazyValue() {
  var array4 = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray_default(array4), isRight = dir < 0, arrLength = isArr ? array4.length : 0, view = getView_default(0, arrLength, this.__views__), start2 = view.start, end = view.end, length2 = end - start2, index8 = isRight ? end : start2 - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin14(length2, this.__takeCount__);
  if (!isArr || !isRight && arrLength == length2 && takeCount == length2) {
    return baseWrapperValue_default(array4, this.__actions__);
  }
  var result2 = [];
  outer:
    while (length2-- && resIndex < takeCount) {
      index8 += dir;
      var iterIndex = -1, value = array4[index8];
      while (++iterIndex < iterLength) {
        var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
        if (type == LAZY_MAP_FLAG) {
          value = computed;
        } else if (!computed) {
          if (type == LAZY_FILTER_FLAG) {
            continue outer;
          } else {
            break outer;
          }
        }
      }
      result2[resIndex++] = value;
    }
  return result2;
}
var lazyValue_default = lazyValue;

// node_modules/lodash-es/lodash.default.js
var VERSION = "4.17.23";
var WRAP_BIND_KEY_FLAG7 = 2;
var LAZY_FILTER_FLAG2 = 1;
var LAZY_WHILE_FLAG = 3;
var MAX_ARRAY_LENGTH7 = 4294967295;
var arrayProto6 = Array.prototype;
var objectProto30 = Object.prototype;
var hasOwnProperty26 = objectProto30.hasOwnProperty;
var symIterator2 = Symbol_default ? Symbol_default.iterator : void 0;
var nativeMax17 = Math.max;
var nativeMin15 = Math.min;
var mixin2 = /* @__PURE__ */ (function(func) {
  return function(object, source, options) {
    if (options == null) {
      var isObj = isObject_default(source), props = isObj && keys_default(source), methodNames = props && props.length && baseFunctions_default(source, props);
      if (!(methodNames ? methodNames.length : isObj)) {
        options = source;
        source = object;
        object = this;
      }
    }
    return func(object, source, options);
  };
})(mixin_default);
wrapperLodash_default.after = function_default_default.after;
wrapperLodash_default.ary = function_default_default.ary;
wrapperLodash_default.assign = object_default_default.assign;
wrapperLodash_default.assignIn = object_default_default.assignIn;
wrapperLodash_default.assignInWith = object_default_default.assignInWith;
wrapperLodash_default.assignWith = object_default_default.assignWith;
wrapperLodash_default.at = object_default_default.at;
wrapperLodash_default.before = function_default_default.before;
wrapperLodash_default.bind = function_default_default.bind;
wrapperLodash_default.bindAll = util_default_default.bindAll;
wrapperLodash_default.bindKey = function_default_default.bindKey;
wrapperLodash_default.castArray = lang_default_default.castArray;
wrapperLodash_default.chain = seq_default_default.chain;
wrapperLodash_default.chunk = array_default_default.chunk;
wrapperLodash_default.compact = array_default_default.compact;
wrapperLodash_default.concat = array_default_default.concat;
wrapperLodash_default.cond = util_default_default.cond;
wrapperLodash_default.conforms = util_default_default.conforms;
wrapperLodash_default.constant = util_default_default.constant;
wrapperLodash_default.countBy = collection_default_default.countBy;
wrapperLodash_default.create = object_default_default.create;
wrapperLodash_default.curry = function_default_default.curry;
wrapperLodash_default.curryRight = function_default_default.curryRight;
wrapperLodash_default.debounce = function_default_default.debounce;
wrapperLodash_default.defaults = object_default_default.defaults;
wrapperLodash_default.defaultsDeep = object_default_default.defaultsDeep;
wrapperLodash_default.defer = function_default_default.defer;
wrapperLodash_default.delay = function_default_default.delay;
wrapperLodash_default.difference = array_default_default.difference;
wrapperLodash_default.differenceBy = array_default_default.differenceBy;
wrapperLodash_default.differenceWith = array_default_default.differenceWith;
wrapperLodash_default.drop = array_default_default.drop;
wrapperLodash_default.dropRight = array_default_default.dropRight;
wrapperLodash_default.dropRightWhile = array_default_default.dropRightWhile;
wrapperLodash_default.dropWhile = array_default_default.dropWhile;
wrapperLodash_default.fill = array_default_default.fill;
wrapperLodash_default.filter = collection_default_default.filter;
wrapperLodash_default.flatMap = collection_default_default.flatMap;
wrapperLodash_default.flatMapDeep = collection_default_default.flatMapDeep;
wrapperLodash_default.flatMapDepth = collection_default_default.flatMapDepth;
wrapperLodash_default.flatten = array_default_default.flatten;
wrapperLodash_default.flattenDeep = array_default_default.flattenDeep;
wrapperLodash_default.flattenDepth = array_default_default.flattenDepth;
wrapperLodash_default.flip = function_default_default.flip;
wrapperLodash_default.flow = util_default_default.flow;
wrapperLodash_default.flowRight = util_default_default.flowRight;
wrapperLodash_default.fromPairs = array_default_default.fromPairs;
wrapperLodash_default.functions = object_default_default.functions;
wrapperLodash_default.functionsIn = object_default_default.functionsIn;
wrapperLodash_default.groupBy = collection_default_default.groupBy;
wrapperLodash_default.initial = array_default_default.initial;
wrapperLodash_default.intersection = array_default_default.intersection;
wrapperLodash_default.intersectionBy = array_default_default.intersectionBy;
wrapperLodash_default.intersectionWith = array_default_default.intersectionWith;
wrapperLodash_default.invert = object_default_default.invert;
wrapperLodash_default.invertBy = object_default_default.invertBy;
wrapperLodash_default.invokeMap = collection_default_default.invokeMap;
wrapperLodash_default.iteratee = util_default_default.iteratee;
wrapperLodash_default.keyBy = collection_default_default.keyBy;
wrapperLodash_default.keys = keys_default;
wrapperLodash_default.keysIn = object_default_default.keysIn;
wrapperLodash_default.map = collection_default_default.map;
wrapperLodash_default.mapKeys = object_default_default.mapKeys;
wrapperLodash_default.mapValues = object_default_default.mapValues;
wrapperLodash_default.matches = util_default_default.matches;
wrapperLodash_default.matchesProperty = util_default_default.matchesProperty;
wrapperLodash_default.memoize = function_default_default.memoize;
wrapperLodash_default.merge = object_default_default.merge;
wrapperLodash_default.mergeWith = object_default_default.mergeWith;
wrapperLodash_default.method = util_default_default.method;
wrapperLodash_default.methodOf = util_default_default.methodOf;
wrapperLodash_default.mixin = mixin2;
wrapperLodash_default.negate = negate_default;
wrapperLodash_default.nthArg = util_default_default.nthArg;
wrapperLodash_default.omit = object_default_default.omit;
wrapperLodash_default.omitBy = object_default_default.omitBy;
wrapperLodash_default.once = function_default_default.once;
wrapperLodash_default.orderBy = collection_default_default.orderBy;
wrapperLodash_default.over = util_default_default.over;
wrapperLodash_default.overArgs = function_default_default.overArgs;
wrapperLodash_default.overEvery = util_default_default.overEvery;
wrapperLodash_default.overSome = util_default_default.overSome;
wrapperLodash_default.partial = function_default_default.partial;
wrapperLodash_default.partialRight = function_default_default.partialRight;
wrapperLodash_default.partition = collection_default_default.partition;
wrapperLodash_default.pick = object_default_default.pick;
wrapperLodash_default.pickBy = object_default_default.pickBy;
wrapperLodash_default.property = util_default_default.property;
wrapperLodash_default.propertyOf = util_default_default.propertyOf;
wrapperLodash_default.pull = array_default_default.pull;
wrapperLodash_default.pullAll = array_default_default.pullAll;
wrapperLodash_default.pullAllBy = array_default_default.pullAllBy;
wrapperLodash_default.pullAllWith = array_default_default.pullAllWith;
wrapperLodash_default.pullAt = array_default_default.pullAt;
wrapperLodash_default.range = util_default_default.range;
wrapperLodash_default.rangeRight = util_default_default.rangeRight;
wrapperLodash_default.rearg = function_default_default.rearg;
wrapperLodash_default.reject = collection_default_default.reject;
wrapperLodash_default.remove = array_default_default.remove;
wrapperLodash_default.rest = function_default_default.rest;
wrapperLodash_default.reverse = array_default_default.reverse;
wrapperLodash_default.sampleSize = collection_default_default.sampleSize;
wrapperLodash_default.set = object_default_default.set;
wrapperLodash_default.setWith = object_default_default.setWith;
wrapperLodash_default.shuffle = collection_default_default.shuffle;
wrapperLodash_default.slice = array_default_default.slice;
wrapperLodash_default.sortBy = collection_default_default.sortBy;
wrapperLodash_default.sortedUniq = array_default_default.sortedUniq;
wrapperLodash_default.sortedUniqBy = array_default_default.sortedUniqBy;
wrapperLodash_default.split = string_default_default.split;
wrapperLodash_default.spread = function_default_default.spread;
wrapperLodash_default.tail = array_default_default.tail;
wrapperLodash_default.take = array_default_default.take;
wrapperLodash_default.takeRight = array_default_default.takeRight;
wrapperLodash_default.takeRightWhile = array_default_default.takeRightWhile;
wrapperLodash_default.takeWhile = array_default_default.takeWhile;
wrapperLodash_default.tap = seq_default_default.tap;
wrapperLodash_default.throttle = function_default_default.throttle;
wrapperLodash_default.thru = thru_default;
wrapperLodash_default.toArray = lang_default_default.toArray;
wrapperLodash_default.toPairs = object_default_default.toPairs;
wrapperLodash_default.toPairsIn = object_default_default.toPairsIn;
wrapperLodash_default.toPath = util_default_default.toPath;
wrapperLodash_default.toPlainObject = lang_default_default.toPlainObject;
wrapperLodash_default.transform = object_default_default.transform;
wrapperLodash_default.unary = function_default_default.unary;
wrapperLodash_default.union = array_default_default.union;
wrapperLodash_default.unionBy = array_default_default.unionBy;
wrapperLodash_default.unionWith = array_default_default.unionWith;
wrapperLodash_default.uniq = array_default_default.uniq;
wrapperLodash_default.uniqBy = array_default_default.uniqBy;
wrapperLodash_default.uniqWith = array_default_default.uniqWith;
wrapperLodash_default.unset = object_default_default.unset;
wrapperLodash_default.unzip = array_default_default.unzip;
wrapperLodash_default.unzipWith = array_default_default.unzipWith;
wrapperLodash_default.update = object_default_default.update;
wrapperLodash_default.updateWith = object_default_default.updateWith;
wrapperLodash_default.values = object_default_default.values;
wrapperLodash_default.valuesIn = object_default_default.valuesIn;
wrapperLodash_default.without = array_default_default.without;
wrapperLodash_default.words = string_default_default.words;
wrapperLodash_default.wrap = function_default_default.wrap;
wrapperLodash_default.xor = array_default_default.xor;
wrapperLodash_default.xorBy = array_default_default.xorBy;
wrapperLodash_default.xorWith = array_default_default.xorWith;
wrapperLodash_default.zip = array_default_default.zip;
wrapperLodash_default.zipObject = array_default_default.zipObject;
wrapperLodash_default.zipObjectDeep = array_default_default.zipObjectDeep;
wrapperLodash_default.zipWith = array_default_default.zipWith;
wrapperLodash_default.entries = object_default_default.toPairs;
wrapperLodash_default.entriesIn = object_default_default.toPairsIn;
wrapperLodash_default.extend = object_default_default.assignIn;
wrapperLodash_default.extendWith = object_default_default.assignInWith;
mixin2(wrapperLodash_default, wrapperLodash_default);
wrapperLodash_default.add = math_default_default.add;
wrapperLodash_default.attempt = util_default_default.attempt;
wrapperLodash_default.camelCase = string_default_default.camelCase;
wrapperLodash_default.capitalize = string_default_default.capitalize;
wrapperLodash_default.ceil = math_default_default.ceil;
wrapperLodash_default.clamp = number_default_default.clamp;
wrapperLodash_default.clone = lang_default_default.clone;
wrapperLodash_default.cloneDeep = lang_default_default.cloneDeep;
wrapperLodash_default.cloneDeepWith = lang_default_default.cloneDeepWith;
wrapperLodash_default.cloneWith = lang_default_default.cloneWith;
wrapperLodash_default.conformsTo = lang_default_default.conformsTo;
wrapperLodash_default.deburr = string_default_default.deburr;
wrapperLodash_default.defaultTo = util_default_default.defaultTo;
wrapperLodash_default.divide = math_default_default.divide;
wrapperLodash_default.endsWith = string_default_default.endsWith;
wrapperLodash_default.eq = lang_default_default.eq;
wrapperLodash_default.escape = string_default_default.escape;
wrapperLodash_default.escapeRegExp = string_default_default.escapeRegExp;
wrapperLodash_default.every = collection_default_default.every;
wrapperLodash_default.find = collection_default_default.find;
wrapperLodash_default.findIndex = array_default_default.findIndex;
wrapperLodash_default.findKey = object_default_default.findKey;
wrapperLodash_default.findLast = collection_default_default.findLast;
wrapperLodash_default.findLastIndex = array_default_default.findLastIndex;
wrapperLodash_default.findLastKey = object_default_default.findLastKey;
wrapperLodash_default.floor = math_default_default.floor;
wrapperLodash_default.forEach = collection_default_default.forEach;
wrapperLodash_default.forEachRight = collection_default_default.forEachRight;
wrapperLodash_default.forIn = object_default_default.forIn;
wrapperLodash_default.forInRight = object_default_default.forInRight;
wrapperLodash_default.forOwn = object_default_default.forOwn;
wrapperLodash_default.forOwnRight = object_default_default.forOwnRight;
wrapperLodash_default.get = object_default_default.get;
wrapperLodash_default.gt = lang_default_default.gt;
wrapperLodash_default.gte = lang_default_default.gte;
wrapperLodash_default.has = object_default_default.has;
wrapperLodash_default.hasIn = object_default_default.hasIn;
wrapperLodash_default.head = array_default_default.head;
wrapperLodash_default.identity = identity_default2;
wrapperLodash_default.includes = collection_default_default.includes;
wrapperLodash_default.indexOf = array_default_default.indexOf;
wrapperLodash_default.inRange = number_default_default.inRange;
wrapperLodash_default.invoke = object_default_default.invoke;
wrapperLodash_default.isArguments = lang_default_default.isArguments;
wrapperLodash_default.isArray = isArray_default;
wrapperLodash_default.isArrayBuffer = lang_default_default.isArrayBuffer;
wrapperLodash_default.isArrayLike = lang_default_default.isArrayLike;
wrapperLodash_default.isArrayLikeObject = lang_default_default.isArrayLikeObject;
wrapperLodash_default.isBoolean = lang_default_default.isBoolean;
wrapperLodash_default.isBuffer = lang_default_default.isBuffer;
wrapperLodash_default.isDate = lang_default_default.isDate;
wrapperLodash_default.isElement = lang_default_default.isElement;
wrapperLodash_default.isEmpty = lang_default_default.isEmpty;
wrapperLodash_default.isEqual = lang_default_default.isEqual;
wrapperLodash_default.isEqualWith = lang_default_default.isEqualWith;
wrapperLodash_default.isError = lang_default_default.isError;
wrapperLodash_default.isFinite = lang_default_default.isFinite;
wrapperLodash_default.isFunction = lang_default_default.isFunction;
wrapperLodash_default.isInteger = lang_default_default.isInteger;
wrapperLodash_default.isLength = lang_default_default.isLength;
wrapperLodash_default.isMap = lang_default_default.isMap;
wrapperLodash_default.isMatch = lang_default_default.isMatch;
wrapperLodash_default.isMatchWith = lang_default_default.isMatchWith;
wrapperLodash_default.isNaN = lang_default_default.isNaN;
wrapperLodash_default.isNative = lang_default_default.isNative;
wrapperLodash_default.isNil = lang_default_default.isNil;
wrapperLodash_default.isNull = lang_default_default.isNull;
wrapperLodash_default.isNumber = lang_default_default.isNumber;
wrapperLodash_default.isObject = isObject_default;
wrapperLodash_default.isObjectLike = lang_default_default.isObjectLike;
wrapperLodash_default.isPlainObject = lang_default_default.isPlainObject;
wrapperLodash_default.isRegExp = lang_default_default.isRegExp;
wrapperLodash_default.isSafeInteger = lang_default_default.isSafeInteger;
wrapperLodash_default.isSet = lang_default_default.isSet;
wrapperLodash_default.isString = lang_default_default.isString;
wrapperLodash_default.isSymbol = lang_default_default.isSymbol;
wrapperLodash_default.isTypedArray = lang_default_default.isTypedArray;
wrapperLodash_default.isUndefined = lang_default_default.isUndefined;
wrapperLodash_default.isWeakMap = lang_default_default.isWeakMap;
wrapperLodash_default.isWeakSet = lang_default_default.isWeakSet;
wrapperLodash_default.join = array_default_default.join;
wrapperLodash_default.kebabCase = string_default_default.kebabCase;
wrapperLodash_default.last = last_default;
wrapperLodash_default.lastIndexOf = array_default_default.lastIndexOf;
wrapperLodash_default.lowerCase = string_default_default.lowerCase;
wrapperLodash_default.lowerFirst = string_default_default.lowerFirst;
wrapperLodash_default.lt = lang_default_default.lt;
wrapperLodash_default.lte = lang_default_default.lte;
wrapperLodash_default.max = math_default_default.max;
wrapperLodash_default.maxBy = math_default_default.maxBy;
wrapperLodash_default.mean = math_default_default.mean;
wrapperLodash_default.meanBy = math_default_default.meanBy;
wrapperLodash_default.min = math_default_default.min;
wrapperLodash_default.minBy = math_default_default.minBy;
wrapperLodash_default.stubArray = util_default_default.stubArray;
wrapperLodash_default.stubFalse = util_default_default.stubFalse;
wrapperLodash_default.stubObject = util_default_default.stubObject;
wrapperLodash_default.stubString = util_default_default.stubString;
wrapperLodash_default.stubTrue = util_default_default.stubTrue;
wrapperLodash_default.multiply = math_default_default.multiply;
wrapperLodash_default.nth = array_default_default.nth;
wrapperLodash_default.noop = util_default_default.noop;
wrapperLodash_default.now = date_default_default.now;
wrapperLodash_default.pad = string_default_default.pad;
wrapperLodash_default.padEnd = string_default_default.padEnd;
wrapperLodash_default.padStart = string_default_default.padStart;
wrapperLodash_default.parseInt = string_default_default.parseInt;
wrapperLodash_default.random = number_default_default.random;
wrapperLodash_default.reduce = collection_default_default.reduce;
wrapperLodash_default.reduceRight = collection_default_default.reduceRight;
wrapperLodash_default.repeat = string_default_default.repeat;
wrapperLodash_default.replace = string_default_default.replace;
wrapperLodash_default.result = object_default_default.result;
wrapperLodash_default.round = math_default_default.round;
wrapperLodash_default.sample = collection_default_default.sample;
wrapperLodash_default.size = collection_default_default.size;
wrapperLodash_default.snakeCase = string_default_default.snakeCase;
wrapperLodash_default.some = collection_default_default.some;
wrapperLodash_default.sortedIndex = array_default_default.sortedIndex;
wrapperLodash_default.sortedIndexBy = array_default_default.sortedIndexBy;
wrapperLodash_default.sortedIndexOf = array_default_default.sortedIndexOf;
wrapperLodash_default.sortedLastIndex = array_default_default.sortedLastIndex;
wrapperLodash_default.sortedLastIndexBy = array_default_default.sortedLastIndexBy;
wrapperLodash_default.sortedLastIndexOf = array_default_default.sortedLastIndexOf;
wrapperLodash_default.startCase = string_default_default.startCase;
wrapperLodash_default.startsWith = string_default_default.startsWith;
wrapperLodash_default.subtract = math_default_default.subtract;
wrapperLodash_default.sum = math_default_default.sum;
wrapperLodash_default.sumBy = math_default_default.sumBy;
wrapperLodash_default.template = string_default_default.template;
wrapperLodash_default.times = util_default_default.times;
wrapperLodash_default.toFinite = lang_default_default.toFinite;
wrapperLodash_default.toInteger = toInteger_default;
wrapperLodash_default.toLength = lang_default_default.toLength;
wrapperLodash_default.toLower = string_default_default.toLower;
wrapperLodash_default.toNumber = lang_default_default.toNumber;
wrapperLodash_default.toSafeInteger = lang_default_default.toSafeInteger;
wrapperLodash_default.toString = lang_default_default.toString;
wrapperLodash_default.toUpper = string_default_default.toUpper;
wrapperLodash_default.trim = string_default_default.trim;
wrapperLodash_default.trimEnd = string_default_default.trimEnd;
wrapperLodash_default.trimStart = string_default_default.trimStart;
wrapperLodash_default.truncate = string_default_default.truncate;
wrapperLodash_default.unescape = string_default_default.unescape;
wrapperLodash_default.uniqueId = util_default_default.uniqueId;
wrapperLodash_default.upperCase = string_default_default.upperCase;
wrapperLodash_default.upperFirst = string_default_default.upperFirst;
wrapperLodash_default.each = collection_default_default.forEach;
wrapperLodash_default.eachRight = collection_default_default.forEachRight;
wrapperLodash_default.first = array_default_default.head;
mixin2(wrapperLodash_default, (function() {
  var source = {};
  baseForOwn_default(wrapperLodash_default, function(func, methodName) {
    if (!hasOwnProperty26.call(wrapperLodash_default.prototype, methodName)) {
      source[methodName] = func;
    }
  });
  return source;
})(), { "chain": false });
wrapperLodash_default.VERSION = VERSION;
(wrapperLodash_default.templateSettings = string_default_default.templateSettings).imports._ = wrapperLodash_default;
arrayEach_default(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
  wrapperLodash_default[methodName].placeholder = wrapperLodash_default;
});
arrayEach_default(["drop", "take"], function(methodName, index8) {
  LazyWrapper_default.prototype[methodName] = function(n2) {
    n2 = n2 === void 0 ? 1 : nativeMax17(toInteger_default(n2), 0);
    var result2 = this.__filtered__ && !index8 ? new LazyWrapper_default(this) : this.clone();
    if (result2.__filtered__) {
      result2.__takeCount__ = nativeMin15(n2, result2.__takeCount__);
    } else {
      result2.__views__.push({
        "size": nativeMin15(n2, MAX_ARRAY_LENGTH7),
        "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
      });
    }
    return result2;
  };
  LazyWrapper_default.prototype[methodName + "Right"] = function(n2) {
    return this.reverse()[methodName](n2).reverse();
  };
});
arrayEach_default(["filter", "map", "takeWhile"], function(methodName, index8) {
  var type = index8 + 1, isFilter = type == LAZY_FILTER_FLAG2 || type == LAZY_WHILE_FLAG;
  LazyWrapper_default.prototype[methodName] = function(iteratee2) {
    var result2 = this.clone();
    result2.__iteratees__.push({
      "iteratee": baseIteratee_default(iteratee2, 3),
      "type": type
    });
    result2.__filtered__ = result2.__filtered__ || isFilter;
    return result2;
  };
});
arrayEach_default(["head", "last"], function(methodName, index8) {
  var takeName = "take" + (index8 ? "Right" : "");
  LazyWrapper_default.prototype[methodName] = function() {
    return this[takeName](1).value()[0];
  };
});
arrayEach_default(["initial", "tail"], function(methodName, index8) {
  var dropName = "drop" + (index8 ? "" : "Right");
  LazyWrapper_default.prototype[methodName] = function() {
    return this.__filtered__ ? new LazyWrapper_default(this) : this[dropName](1);
  };
});
LazyWrapper_default.prototype.compact = function() {
  return this.filter(identity_default2);
};
LazyWrapper_default.prototype.find = function(predicate) {
  return this.filter(predicate).head();
};
LazyWrapper_default.prototype.findLast = function(predicate) {
  return this.reverse().find(predicate);
};
LazyWrapper_default.prototype.invokeMap = baseRest_default(function(path, args) {
  if (typeof path == "function") {
    return new LazyWrapper_default(this);
  }
  return this.map(function(value) {
    return baseInvoke_default(value, path, args);
  });
});
LazyWrapper_default.prototype.reject = function(predicate) {
  return this.filter(negate_default(baseIteratee_default(predicate)));
};
LazyWrapper_default.prototype.slice = function(start2, end) {
  start2 = toInteger_default(start2);
  var result2 = this;
  if (result2.__filtered__ && (start2 > 0 || end < 0)) {
    return new LazyWrapper_default(result2);
  }
  if (start2 < 0) {
    result2 = result2.takeRight(-start2);
  } else if (start2) {
    result2 = result2.drop(start2);
  }
  if (end !== void 0) {
    end = toInteger_default(end);
    result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start2);
  }
  return result2;
};
LazyWrapper_default.prototype.takeRightWhile = function(predicate) {
  return this.reverse().takeWhile(predicate).reverse();
};
LazyWrapper_default.prototype.toArray = function() {
  return this.take(MAX_ARRAY_LENGTH7);
};
baseForOwn_default(LazyWrapper_default.prototype, function(func, methodName) {
  var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = wrapperLodash_default[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
  if (!lodashFunc) {
    return;
  }
  wrapperLodash_default.prototype[methodName] = function() {
    var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper_default, iteratee2 = args[0], useLazy = isLazy || isArray_default(value);
    var interceptor = function(value2) {
      var result3 = lodashFunc.apply(wrapperLodash_default, arrayPush_default([value2], args));
      return isTaker && chainAll ? result3[0] : result3;
    };
    if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
      isLazy = useLazy = false;
    }
    var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
    if (!retUnwrapped && useLazy) {
      value = onlyLazy ? value : new LazyWrapper_default(this);
      var result2 = func.apply(value, args);
      result2.__actions__.push({ "func": thru_default, "args": [interceptor], "thisArg": void 0 });
      return new LodashWrapper_default(result2, chainAll);
    }
    if (isUnwrapped && onlyLazy) {
      return func.apply(this, args);
    }
    result2 = this.thru(interceptor);
    return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
  };
});
arrayEach_default(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
  var func = arrayProto6[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
  wrapperLodash_default.prototype[methodName] = function() {
    var args = arguments;
    if (retUnwrapped && !this.__chain__) {
      var value = this.value();
      return func.apply(isArray_default(value) ? value : [], args);
    }
    return this[chainName](function(value2) {
      return func.apply(isArray_default(value2) ? value2 : [], args);
    });
  };
});
baseForOwn_default(LazyWrapper_default.prototype, function(func, methodName) {
  var lodashFunc = wrapperLodash_default[methodName];
  if (lodashFunc) {
    var key = lodashFunc.name + "";
    if (!hasOwnProperty26.call(realNames_default, key)) {
      realNames_default[key] = [];
    }
    realNames_default[key].push({ "name": methodName, "func": lodashFunc });
  }
});
realNames_default[createHybrid_default(void 0, WRAP_BIND_KEY_FLAG7).name] = [{
  "name": "wrapper",
  "func": void 0
}];
LazyWrapper_default.prototype.clone = lazyClone_default;
LazyWrapper_default.prototype.reverse = lazyReverse_default;
LazyWrapper_default.prototype.value = lazyValue_default;
wrapperLodash_default.prototype.at = seq_default_default.at;
wrapperLodash_default.prototype.chain = seq_default_default.wrapperChain;
wrapperLodash_default.prototype.commit = seq_default_default.commit;
wrapperLodash_default.prototype.next = seq_default_default.next;
wrapperLodash_default.prototype.plant = seq_default_default.plant;
wrapperLodash_default.prototype.reverse = seq_default_default.reverse;
wrapperLodash_default.prototype.toJSON = wrapperLodash_default.prototype.valueOf = wrapperLodash_default.prototype.value = seq_default_default.value;
wrapperLodash_default.prototype.first = wrapperLodash_default.prototype.head;
if (symIterator2) {
  wrapperLodash_default.prototype[symIterator2] = seq_default_default.toIterator;
}

// node_modules/canvas-color-tracker/dist/canvas-color-tracker.mjs
function _arrayLikeToArray11(r2, a3) {
  (null == a3 || a3 > r2.length) && (a3 = r2.length);
  for (var e3 = 0, n2 = Array(a3); e3 < a3; e3++) n2[e3] = r2[e3];
  return n2;
}
function _arrayWithoutHoles9(r2) {
  if (Array.isArray(r2)) return _arrayLikeToArray11(r2);
}
function _assertClassBrand3(e3, t5, n2) {
  if ("function" == typeof e3 ? e3 === t5 : e3.has(t5)) return arguments.length < 3 ? t5 : n2;
  throw new TypeError("Private element is not present on this object");
}
function _checkPrivateRedeclaration3(e3, t5) {
  if (t5.has(e3)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function _classCallCheck4(a3, n2) {
  if (!(a3 instanceof n2)) throw new TypeError("Cannot call a class as a function");
}
function _classPrivateFieldGet23(s2, a3) {
  return s2.get(_assertClassBrand3(s2, a3));
}
function _classPrivateFieldInitSpec3(e3, t5, a3) {
  _checkPrivateRedeclaration3(e3, t5), t5.set(e3, a3);
}
function _classPrivateFieldSet23(s2, a3, r2) {
  return s2.set(_assertClassBrand3(s2, a3), r2), r2;
}
function _defineProperties3(e3, r2) {
  for (var t5 = 0; t5 < r2.length; t5++) {
    var o2 = r2[t5];
    o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e3, _toPropertyKey9(o2.key), o2);
  }
}
function _createClass4(e3, r2, t5) {
  return r2 && _defineProperties3(e3.prototype, r2), Object.defineProperty(e3, "prototype", {
    writable: false
  }), e3;
}
function _iterableToArray9(r2) {
  if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"]) return Array.from(r2);
}
function _nonIterableSpread9() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toConsumableArray9(r2) {
  return _arrayWithoutHoles9(r2) || _iterableToArray9(r2) || _unsupportedIterableToArray11(r2) || _nonIterableSpread9();
}
function _toPrimitive9(t5, r2) {
  if ("object" != typeof t5 || !t5) return t5;
  var e3 = t5[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t5, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t5);
}
function _toPropertyKey9(t5) {
  var i2 = _toPrimitive9(t5, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _unsupportedIterableToArray11(r2, a3) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray11(r2, a3);
    var t5 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t5 && r2.constructor && (t5 = r2.constructor.name), "Map" === t5 || "Set" === t5 ? Array.from(r2) : "Arguments" === t5 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t5) ? _arrayLikeToArray11(r2, a3) : void 0;
  }
}
var ENTROPY = 123;
var int2HexColor = function int2HexColor2(num) {
  return "#".concat(Math.min(num, Math.pow(2, 24)).toString(16).padStart(6, "0"));
};
var rgb2Int = function rgb2Int2(r2, g3, b) {
  return (r2 << 16) + (g3 << 8) + b;
};
var colorStr2Int = function colorStr2Int2(str) {
  var _tinyColor$toRgb = tinycolor(str).toRgb(), r2 = _tinyColor$toRgb.r, g3 = _tinyColor$toRgb.g, b = _tinyColor$toRgb.b;
  return rgb2Int(r2, g3, b);
};
var checksum = function checksum2(n2, csBits) {
  return n2 * ENTROPY % Math.pow(2, csBits);
};
var _registry = /* @__PURE__ */ new WeakMap();
var _csBits = /* @__PURE__ */ new WeakMap();
var _default15 = (function() {
  function _default25() {
    var csBits = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 6;
    _classCallCheck4(this, _default25);
    _classPrivateFieldInitSpec3(this, _registry, void 0);
    _classPrivateFieldInitSpec3(this, _csBits, void 0);
    _classPrivateFieldSet23(_csBits, this, csBits);
    this.reset();
  }
  return _createClass4(_default25, [{
    key: "reset",
    value: function reset() {
      _classPrivateFieldSet23(_registry, this, ["__reserved for background__"]);
    }
  }, {
    key: "register",
    value: function register(obj) {
      if (_classPrivateFieldGet23(_registry, this).length >= Math.pow(2, 24 - _classPrivateFieldGet23(_csBits, this))) {
        return null;
      }
      var idx = _classPrivateFieldGet23(_registry, this).length;
      var cs = checksum(idx, _classPrivateFieldGet23(_csBits, this));
      var color3 = int2HexColor(idx + (cs << 24 - _classPrivateFieldGet23(_csBits, this)));
      _classPrivateFieldGet23(_registry, this).push(obj);
      return color3;
    }
  }, {
    key: "lookup",
    value: function lookup(color3) {
      if (!color3) return null;
      var n2 = typeof color3 === "string" ? colorStr2Int(color3) : rgb2Int.apply(void 0, _toConsumableArray9(color3));
      if (!n2) return null;
      var idx = n2 & Math.pow(2, 24 - _classPrivateFieldGet23(_csBits, this)) - 1;
      var cs = n2 >> 24 - _classPrivateFieldGet23(_csBits, this) & Math.pow(2, _classPrivateFieldGet23(_csBits, this)) - 1;
      if (checksum(idx, _classPrivateFieldGet23(_csBits, this)) !== cs || idx >= _classPrivateFieldGet23(_registry, this).length) return null;
      return _classPrivateFieldGet23(_registry, this)[idx];
    }
    // How many bits to reserve for checksum. Will eat away into the usable size of the registry.
  }]);
})();

// node_modules/bezier-js/src/utils.js
var { abs: abs2, cos: cos2, sin: sin2, acos: acos2, atan2: atan22, sqrt: sqrt3, pow: pow5 } = Math;
function crt(v2) {
  return v2 < 0 ? -pow5(-v2, 1 / 3) : pow5(v2, 1 / 3);
}
var pi2 = Math.PI;
var tau2 = 2 * pi2;
var quart = pi2 / 2;
var epsilon = 1e-6;
var nMax = Number.MAX_SAFE_INTEGER || 9007199254740991;
var nMin = Number.MIN_SAFE_INTEGER || -9007199254740991;
var ZERO = { x: 0, y: 0, z: 0 };
var utils = {
  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))
  Tvalues: [
    -0.06405689286260563,
    0.06405689286260563,
    -0.1911188674736163,
    0.1911188674736163,
    -0.3150426796961634,
    0.3150426796961634,
    -0.4337935076260451,
    0.4337935076260451,
    -0.5454214713888396,
    0.5454214713888396,
    -0.6480936519369755,
    0.6480936519369755,
    -0.7401241915785544,
    0.7401241915785544,
    -0.820001985973903,
    0.820001985973903,
    -0.8864155270044011,
    0.8864155270044011,
    -0.9382745520027328,
    0.9382745520027328,
    -0.9747285559713095,
    0.9747285559713095,
    -0.9951872199970213,
    0.9951872199970213
  ],
  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)
  Cvalues: [
    0.12793819534675216,
    0.12793819534675216,
    0.1258374563468283,
    0.1258374563468283,
    0.12167047292780339,
    0.12167047292780339,
    0.1155056680537256,
    0.1155056680537256,
    0.10744427011596563,
    0.10744427011596563,
    0.09761865210411388,
    0.09761865210411388,
    0.08619016153195327,
    0.08619016153195327,
    0.0733464814110803,
    0.0733464814110803,
    0.05929858491543678,
    0.05929858491543678,
    0.04427743881741981,
    0.04427743881741981,
    0.028531388628933663,
    0.028531388628933663,
    0.0123412297999872,
    0.0123412297999872
  ],
  arcfn: function(t5, derivativeFn) {
    const d3 = derivativeFn(t5);
    let l2 = d3.x * d3.x + d3.y * d3.y;
    if (typeof d3.z !== "undefined") {
      l2 += d3.z * d3.z;
    }
    return sqrt3(l2);
  },
  compute: function(t5, points, _3d) {
    if (t5 === 0) {
      points[0].t = 0;
      return points[0];
    }
    const order = points.length - 1;
    if (t5 === 1) {
      points[order].t = 1;
      return points[order];
    }
    const mt = 1 - t5;
    let p3 = points;
    if (order === 0) {
      points[0].t = t5;
      return points[0];
    }
    if (order === 1) {
      const ret = {
        x: mt * p3[0].x + t5 * p3[1].x,
        y: mt * p3[0].y + t5 * p3[1].y,
        t: t5
      };
      if (_3d) {
        ret.z = mt * p3[0].z + t5 * p3[1].z;
      }
      return ret;
    }
    if (order < 4) {
      let mt2 = mt * mt, t22 = t5 * t5, a3, b, c5, d3 = 0;
      if (order === 2) {
        p3 = [p3[0], p3[1], p3[2], ZERO];
        a3 = mt2;
        b = mt * t5 * 2;
        c5 = t22;
      } else if (order === 3) {
        a3 = mt2 * mt;
        b = mt2 * t5 * 3;
        c5 = mt * t22 * 3;
        d3 = t5 * t22;
      }
      const ret = {
        x: a3 * p3[0].x + b * p3[1].x + c5 * p3[2].x + d3 * p3[3].x,
        y: a3 * p3[0].y + b * p3[1].y + c5 * p3[2].y + d3 * p3[3].y,
        t: t5
      };
      if (_3d) {
        ret.z = a3 * p3[0].z + b * p3[1].z + c5 * p3[2].z + d3 * p3[3].z;
      }
      return ret;
    }
    const dCpts = JSON.parse(JSON.stringify(points));
    while (dCpts.length > 1) {
      for (let i2 = 0; i2 < dCpts.length - 1; i2++) {
        dCpts[i2] = {
          x: dCpts[i2].x + (dCpts[i2 + 1].x - dCpts[i2].x) * t5,
          y: dCpts[i2].y + (dCpts[i2 + 1].y - dCpts[i2].y) * t5
        };
        if (typeof dCpts[i2].z !== "undefined") {
          dCpts[i2].z = dCpts[i2].z + (dCpts[i2 + 1].z - dCpts[i2].z) * t5;
        }
      }
      dCpts.splice(dCpts.length - 1, 1);
    }
    dCpts[0].t = t5;
    return dCpts[0];
  },
  computeWithRatios: function(t5, points, ratios, _3d) {
    const mt = 1 - t5, r2 = ratios, p3 = points;
    let f1 = r2[0], f22 = r2[1], f3 = r2[2], f4 = r2[3], d3;
    f1 *= mt;
    f22 *= t5;
    if (p3.length === 2) {
      d3 = f1 + f22;
      return {
        x: (f1 * p3[0].x + f22 * p3[1].x) / d3,
        y: (f1 * p3[0].y + f22 * p3[1].y) / d3,
        z: !_3d ? false : (f1 * p3[0].z + f22 * p3[1].z) / d3,
        t: t5
      };
    }
    f1 *= mt;
    f22 *= 2 * mt;
    f3 *= t5 * t5;
    if (p3.length === 3) {
      d3 = f1 + f22 + f3;
      return {
        x: (f1 * p3[0].x + f22 * p3[1].x + f3 * p3[2].x) / d3,
        y: (f1 * p3[0].y + f22 * p3[1].y + f3 * p3[2].y) / d3,
        z: !_3d ? false : (f1 * p3[0].z + f22 * p3[1].z + f3 * p3[2].z) / d3,
        t: t5
      };
    }
    f1 *= mt;
    f22 *= 1.5 * mt;
    f3 *= 3 * mt;
    f4 *= t5 * t5 * t5;
    if (p3.length === 4) {
      d3 = f1 + f22 + f3 + f4;
      return {
        x: (f1 * p3[0].x + f22 * p3[1].x + f3 * p3[2].x + f4 * p3[3].x) / d3,
        y: (f1 * p3[0].y + f22 * p3[1].y + f3 * p3[2].y + f4 * p3[3].y) / d3,
        z: !_3d ? false : (f1 * p3[0].z + f22 * p3[1].z + f3 * p3[2].z + f4 * p3[3].z) / d3,
        t: t5
      };
    }
  },
  derive: function(points, _3d) {
    const dpoints = [];
    for (let p3 = points, d3 = p3.length, c5 = d3 - 1; d3 > 1; d3--, c5--) {
      const list = [];
      for (let j2 = 0, dpt; j2 < c5; j2++) {
        dpt = {
          x: c5 * (p3[j2 + 1].x - p3[j2].x),
          y: c5 * (p3[j2 + 1].y - p3[j2].y)
        };
        if (_3d) {
          dpt.z = c5 * (p3[j2 + 1].z - p3[j2].z);
        }
        list.push(dpt);
      }
      dpoints.push(list);
      p3 = list;
    }
    return dpoints;
  },
  between: function(v2, m3, M2) {
    return m3 <= v2 && v2 <= M2 || utils.approximately(v2, m3) || utils.approximately(v2, M2);
  },
  approximately: function(a3, b, precision) {
    return abs2(a3 - b) <= (precision || epsilon);
  },
  length: function(derivativeFn) {
    const z3 = 0.5, len = utils.Tvalues.length;
    let sum3 = 0;
    for (let i2 = 0, t5; i2 < len; i2++) {
      t5 = z3 * utils.Tvalues[i2] + z3;
      sum3 += utils.Cvalues[i2] * utils.arcfn(t5, derivativeFn);
    }
    return z3 * sum3;
  },
  map: function(v2, ds, de, ts, te2) {
    const d1 = de - ds, d22 = te2 - ts, v22 = v2 - ds, r2 = v22 / d1;
    return ts + d22 * r2;
  },
  lerp: function(r2, v1, v2) {
    const ret = {
      x: v1.x + r2 * (v2.x - v1.x),
      y: v1.y + r2 * (v2.y - v1.y)
    };
    if (v1.z !== void 0 && v2.z !== void 0) {
      ret.z = v1.z + r2 * (v2.z - v1.z);
    }
    return ret;
  },
  pointToString: function(p3) {
    let s2 = p3.x + "/" + p3.y;
    if (typeof p3.z !== "undefined") {
      s2 += "/" + p3.z;
    }
    return s2;
  },
  pointsToString: function(points) {
    return "[" + points.map(utils.pointToString).join(", ") + "]";
  },
  copy: function(obj) {
    return JSON.parse(JSON.stringify(obj));
  },
  angle: function(o2, v1, v2) {
    const dx1 = v1.x - o2.x, dy1 = v1.y - o2.y, dx2 = v2.x - o2.x, dy2 = v2.y - o2.y, cross3 = dx1 * dy2 - dy1 * dx2, dot2 = dx1 * dx2 + dy1 * dy2;
    return atan22(cross3, dot2);
  },
  // round as string, to avoid rounding errors
  round: function(v2, d3) {
    const s2 = "" + v2;
    const pos = s2.indexOf(".");
    return parseFloat(s2.substring(0, pos + 1 + d3));
  },
  dist: function(p1, p22) {
    const dx = p1.x - p22.x, dy = p1.y - p22.y;
    return sqrt3(dx * dx + dy * dy);
  },
  closest: function(LUT, point2) {
    let mdist = pow5(2, 63), mpos, d3;
    LUT.forEach(function(p3, idx) {
      d3 = utils.dist(point2, p3);
      if (d3 < mdist) {
        mdist = d3;
        mpos = idx;
      }
    });
    return { mdist, mpos };
  },
  abcratio: function(t5, n2) {
    if (n2 !== 2 && n2 !== 3) {
      return false;
    }
    if (typeof t5 === "undefined") {
      t5 = 0.5;
    } else if (t5 === 0 || t5 === 1) {
      return t5;
    }
    const bottom = pow5(t5, n2) + pow5(1 - t5, n2), top = bottom - 1;
    return abs2(top / bottom);
  },
  projectionratio: function(t5, n2) {
    if (n2 !== 2 && n2 !== 3) {
      return false;
    }
    if (typeof t5 === "undefined") {
      t5 = 0.5;
    } else if (t5 === 0 || t5 === 1) {
      return t5;
    }
    const top = pow5(1 - t5, n2), bottom = pow5(t5, n2) + top;
    return top / bottom;
  },
  lli8: function(x1, y1, x22, y22, x3, y3, x4, y4) {
    const nx = (x1 * y22 - y1 * x22) * (x3 - x4) - (x1 - x22) * (x3 * y4 - y3 * x4), ny = (x1 * y22 - y1 * x22) * (y3 - y4) - (y1 - y22) * (x3 * y4 - y3 * x4), d3 = (x1 - x22) * (y3 - y4) - (y1 - y22) * (x3 - x4);
    if (d3 == 0) {
      return false;
    }
    return { x: nx / d3, y: ny / d3 };
  },
  lli4: function(p1, p22, p3, p4) {
    const x1 = p1.x, y1 = p1.y, x22 = p22.x, y22 = p22.y, x3 = p3.x, y3 = p3.y, x4 = p4.x, y4 = p4.y;
    return utils.lli8(x1, y1, x22, y22, x3, y3, x4, y4);
  },
  lli: function(v1, v2) {
    return utils.lli4(v1, v1.c, v2, v2.c);
  },
  makeline: function(p1, p22) {
    return new Bezier(
      p1.x,
      p1.y,
      (p1.x + p22.x) / 2,
      (p1.y + p22.y) / 2,
      p22.x,
      p22.y
    );
  },
  findbbox: function(sections) {
    let mx = nMax, my = nMax, MX = nMin, MY = nMin;
    sections.forEach(function(s2) {
      const bbox = s2.bbox();
      if (mx > bbox.x.min) mx = bbox.x.min;
      if (my > bbox.y.min) my = bbox.y.min;
      if (MX < bbox.x.max) MX = bbox.x.max;
      if (MY < bbox.y.max) MY = bbox.y.max;
    });
    return {
      x: { min: mx, mid: (mx + MX) / 2, max: MX, size: MX - mx },
      y: { min: my, mid: (my + MY) / 2, max: MY, size: MY - my }
    };
  },
  shapeintersections: function(s1, bbox1, s2, bbox2, curveIntersectionThreshold) {
    if (!utils.bboxoverlap(bbox1, bbox2)) return [];
    const intersections = [];
    const a1 = [s1.startcap, s1.forward, s1.back, s1.endcap];
    const a22 = [s2.startcap, s2.forward, s2.back, s2.endcap];
    a1.forEach(function(l1) {
      if (l1.virtual) return;
      a22.forEach(function(l2) {
        if (l2.virtual) return;
        const iss = l1.intersects(l2, curveIntersectionThreshold);
        if (iss.length > 0) {
          iss.c1 = l1;
          iss.c2 = l2;
          iss.s1 = s1;
          iss.s2 = s2;
          intersections.push(iss);
        }
      });
    });
    return intersections;
  },
  makeshape: function(forward, back, curveIntersectionThreshold) {
    const bpl = back.points.length;
    const fpl = forward.points.length;
    const start2 = utils.makeline(back.points[bpl - 1], forward.points[0]);
    const end = utils.makeline(forward.points[fpl - 1], back.points[0]);
    const shape = {
      startcap: start2,
      forward,
      back,
      endcap: end,
      bbox: utils.findbbox([start2, forward, back, end])
    };
    shape.intersections = function(s2) {
      return utils.shapeintersections(
        shape,
        shape.bbox,
        s2,
        s2.bbox,
        curveIntersectionThreshold
      );
    };
    return shape;
  },
  getminmax: function(curve, d3, list) {
    if (!list) return { min: 0, max: 0 };
    let min5 = nMax, max6 = nMin, t5, c5;
    if (list.indexOf(0) === -1) {
      list = [0].concat(list);
    }
    if (list.indexOf(1) === -1) {
      list.push(1);
    }
    for (let i2 = 0, len = list.length; i2 < len; i2++) {
      t5 = list[i2];
      c5 = curve.get(t5);
      if (c5[d3] < min5) {
        min5 = c5[d3];
      }
      if (c5[d3] > max6) {
        max6 = c5[d3];
      }
    }
    return { min: min5, mid: (min5 + max6) / 2, max: max6, size: max6 - min5 };
  },
  align: function(points, line) {
    const tx = line.p1.x, ty = line.p1.y, a3 = -atan22(line.p2.y - ty, line.p2.x - tx), d3 = function(v2) {
      return {
        x: (v2.x - tx) * cos2(a3) - (v2.y - ty) * sin2(a3),
        y: (v2.x - tx) * sin2(a3) + (v2.y - ty) * cos2(a3)
      };
    };
    return points.map(d3);
  },
  roots: function(points, line) {
    line = line || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };
    const order = points.length - 1;
    const aligned = utils.align(points, line);
    const reduce3 = function(t5) {
      return 0 <= t5 && t5 <= 1;
    };
    if (order === 2) {
      const a4 = aligned[0].y, b10 = aligned[1].y, c6 = aligned[2].y, d4 = a4 - 2 * b10 + c6;
      if (d4 !== 0) {
        const m1 = -sqrt3(b10 * b10 - a4 * c6), m22 = -a4 + b10, v12 = -(m1 + m22) / d4, v2 = -(-m1 + m22) / d4;
        return [v12, v2].filter(reduce3);
      } else if (b10 !== c6 && d4 === 0) {
        return [(2 * b10 - c6) / (2 * b10 - 2 * c6)].filter(reduce3);
      }
      return [];
    }
    const pa = aligned[0].y, pb = aligned[1].y, pc = aligned[2].y, pd = aligned[3].y;
    let d3 = -pa + 3 * pb - 3 * pc + pd, a3 = 3 * pa - 6 * pb + 3 * pc, b = -3 * pa + 3 * pb, c5 = pa;
    if (utils.approximately(d3, 0)) {
      if (utils.approximately(a3, 0)) {
        if (utils.approximately(b, 0)) {
          return [];
        }
        return [-c5 / b].filter(reduce3);
      }
      const q3 = sqrt3(b * b - 4 * a3 * c5), a22 = 2 * a3;
      return [(q3 - b) / a22, (-b - q3) / a22].filter(reduce3);
    }
    a3 /= d3;
    b /= d3;
    c5 /= d3;
    const p3 = (3 * b - a3 * a3) / 3, p32 = p3 / 3, q2 = (2 * a3 * a3 * a3 - 9 * a3 * b + 27 * c5) / 27, q22 = q2 / 2, discriminant = q22 * q22 + p32 * p32 * p32;
    let u1, v1, x1, x22, x3;
    if (discriminant < 0) {
      const mp3 = -p3 / 3, mp33 = mp3 * mp3 * mp3, r2 = sqrt3(mp33), t5 = -q2 / (2 * r2), cosphi = t5 < -1 ? -1 : t5 > 1 ? 1 : t5, phi = acos2(cosphi), crtr = crt(r2), t13 = 2 * crtr;
      x1 = t13 * cos2(phi / 3) - a3 / 3;
      x22 = t13 * cos2((phi + tau2) / 3) - a3 / 3;
      x3 = t13 * cos2((phi + 2 * tau2) / 3) - a3 / 3;
      return [x1, x22, x3].filter(reduce3);
    } else if (discriminant === 0) {
      u1 = q22 < 0 ? crt(-q22) : -crt(q22);
      x1 = 2 * u1 - a3 / 3;
      x22 = -u1 - a3 / 3;
      return [x1, x22].filter(reduce3);
    } else {
      const sd = sqrt3(discriminant);
      u1 = crt(-q22 + sd);
      v1 = crt(q22 + sd);
      return [u1 - v1 - a3 / 3].filter(reduce3);
    }
  },
  droots: function(p3) {
    if (p3.length === 3) {
      const a3 = p3[0], b = p3[1], c5 = p3[2], d3 = a3 - 2 * b + c5;
      if (d3 !== 0) {
        const m1 = -sqrt3(b * b - a3 * c5), m22 = -a3 + b, v1 = -(m1 + m22) / d3, v2 = -(-m1 + m22) / d3;
        return [v1, v2];
      } else if (b !== c5 && d3 === 0) {
        return [(2 * b - c5) / (2 * (b - c5))];
      }
      return [];
    }
    if (p3.length === 2) {
      const a3 = p3[0], b = p3[1];
      if (a3 !== b) {
        return [a3 / (a3 - b)];
      }
      return [];
    }
    return [];
  },
  curvature: function(t5, d1, d22, _3d, kOnly) {
    let num, dnm, adk, dk, k2 = 0, r2 = 0;
    const d3 = utils.compute(t5, d1);
    const dd = utils.compute(t5, d22);
    const qdsum = d3.x * d3.x + d3.y * d3.y;
    if (_3d) {
      num = sqrt3(
        pow5(d3.y * dd.z - dd.y * d3.z, 2) + pow5(d3.z * dd.x - dd.z * d3.x, 2) + pow5(d3.x * dd.y - dd.x * d3.y, 2)
      );
      dnm = pow5(qdsum + d3.z * d3.z, 3 / 2);
    } else {
      num = d3.x * dd.y - d3.y * dd.x;
      dnm = pow5(qdsum, 3 / 2);
    }
    if (num === 0 || dnm === 0) {
      return { k: 0, r: 0 };
    }
    k2 = num / dnm;
    r2 = dnm / num;
    if (!kOnly) {
      const pk = utils.curvature(t5 - 1e-3, d1, d22, _3d, true).k;
      const nk = utils.curvature(t5 + 1e-3, d1, d22, _3d, true).k;
      dk = (nk - k2 + (k2 - pk)) / 2;
      adk = (abs2(nk - k2) + abs2(k2 - pk)) / 2;
    }
    return { k: k2, r: r2, dk, adk };
  },
  inflections: function(points) {
    if (points.length < 4) return [];
    const p3 = utils.align(points, { p1: points[0], p2: points.slice(-1)[0] }), a3 = p3[2].x * p3[1].y, b = p3[3].x * p3[1].y, c5 = p3[1].x * p3[2].y, d3 = p3[3].x * p3[2].y, v1 = 18 * (-3 * a3 + 2 * b + 3 * c5 - d3), v2 = 18 * (3 * a3 - b - 3 * c5), v3 = 18 * (c5 - a3);
    if (utils.approximately(v1, 0)) {
      if (!utils.approximately(v2, 0)) {
        let t5 = -v3 / v2;
        if (0 <= t5 && t5 <= 1) return [t5];
      }
      return [];
    }
    const d22 = 2 * v1;
    if (utils.approximately(d22, 0)) return [];
    const trm = v2 * v2 - 4 * v1 * v3;
    if (trm < 0) return [];
    const sq = Math.sqrt(trm);
    return [(sq - v2) / d22, -(v2 + sq) / d22].filter(function(r2) {
      return 0 <= r2 && r2 <= 1;
    });
  },
  bboxoverlap: function(b12, b23) {
    const dims = ["x", "y"], len = dims.length;
    for (let i2 = 0, dim, l2, t5, d3; i2 < len; i2++) {
      dim = dims[i2];
      l2 = b12[dim].mid;
      t5 = b23[dim].mid;
      d3 = (b12[dim].size + b23[dim].size) / 2;
      if (abs2(l2 - t5) >= d3) return false;
    }
    return true;
  },
  expandbox: function(bbox, _bbox) {
    if (_bbox.x.min < bbox.x.min) {
      bbox.x.min = _bbox.x.min;
    }
    if (_bbox.y.min < bbox.y.min) {
      bbox.y.min = _bbox.y.min;
    }
    if (_bbox.z && _bbox.z.min < bbox.z.min) {
      bbox.z.min = _bbox.z.min;
    }
    if (_bbox.x.max > bbox.x.max) {
      bbox.x.max = _bbox.x.max;
    }
    if (_bbox.y.max > bbox.y.max) {
      bbox.y.max = _bbox.y.max;
    }
    if (_bbox.z && _bbox.z.max > bbox.z.max) {
      bbox.z.max = _bbox.z.max;
    }
    bbox.x.mid = (bbox.x.min + bbox.x.max) / 2;
    bbox.y.mid = (bbox.y.min + bbox.y.max) / 2;
    if (bbox.z) {
      bbox.z.mid = (bbox.z.min + bbox.z.max) / 2;
    }
    bbox.x.size = bbox.x.max - bbox.x.min;
    bbox.y.size = bbox.y.max - bbox.y.min;
    if (bbox.z) {
      bbox.z.size = bbox.z.max - bbox.z.min;
    }
  },
  pairiteration: function(c1, c22, curveIntersectionThreshold) {
    const c1b = c1.bbox(), c2b = c22.bbox(), r2 = 1e5, threshold2 = curveIntersectionThreshold || 0.5;
    if (c1b.x.size + c1b.y.size < threshold2 && c2b.x.size + c2b.y.size < threshold2) {
      return [
        (r2 * (c1._t1 + c1._t2) / 2 | 0) / r2 + "/" + (r2 * (c22._t1 + c22._t2) / 2 | 0) / r2
      ];
    }
    let cc1 = c1.split(0.5), cc2 = c22.split(0.5), pairs2 = [
      { left: cc1.left, right: cc2.left },
      { left: cc1.left, right: cc2.right },
      { left: cc1.right, right: cc2.right },
      { left: cc1.right, right: cc2.left }
    ];
    pairs2 = pairs2.filter(function(pair) {
      return utils.bboxoverlap(pair.left.bbox(), pair.right.bbox());
    });
    let results = [];
    if (pairs2.length === 0) return results;
    pairs2.forEach(function(pair) {
      results = results.concat(
        utils.pairiteration(pair.left, pair.right, threshold2)
      );
    });
    results = results.filter(function(v2, i2) {
      return results.indexOf(v2) === i2;
    });
    return results;
  },
  getccenter: function(p1, p22, p3) {
    const dx1 = p22.x - p1.x, dy1 = p22.y - p1.y, dx2 = p3.x - p22.x, dy2 = p3.y - p22.y, dx1p = dx1 * cos2(quart) - dy1 * sin2(quart), dy1p = dx1 * sin2(quart) + dy1 * cos2(quart), dx2p = dx2 * cos2(quart) - dy2 * sin2(quart), dy2p = dx2 * sin2(quart) + dy2 * cos2(quart), mx1 = (p1.x + p22.x) / 2, my1 = (p1.y + p22.y) / 2, mx2 = (p22.x + p3.x) / 2, my2 = (p22.y + p3.y) / 2, mx1n = mx1 + dx1p, my1n = my1 + dy1p, mx2n = mx2 + dx2p, my2n = my2 + dy2p, arc = utils.lli8(mx1, my1, mx1n, my1n, mx2, my2, mx2n, my2n), r2 = utils.dist(arc, p1);
    let s2 = atan22(p1.y - arc.y, p1.x - arc.x), m3 = atan22(p22.y - arc.y, p22.x - arc.x), e3 = atan22(p3.y - arc.y, p3.x - arc.x), _2;
    if (s2 < e3) {
      if (s2 > m3 || m3 > e3) {
        s2 += tau2;
      }
      if (s2 > e3) {
        _2 = e3;
        e3 = s2;
        s2 = _2;
      }
    } else {
      if (e3 < m3 && m3 < s2) {
        _2 = e3;
        e3 = s2;
        s2 = _2;
      } else {
        e3 += tau2;
      }
    }
    arc.s = s2;
    arc.e = e3;
    arc.r = r2;
    return arc;
  },
  numberSort: function(a3, b) {
    return a3 - b;
  }
};

// node_modules/bezier-js/src/poly-bezier.js
var PolyBezier = class _PolyBezier {
  constructor(curves) {
    this.curves = [];
    this._3d = false;
    if (!!curves) {
      this.curves = curves;
      this._3d = this.curves[0]._3d;
    }
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return "[" + this.curves.map(function(curve) {
      return utils.pointsToString(curve.points);
    }).join(", ") + "]";
  }
  addCurve(curve) {
    this.curves.push(curve);
    this._3d = this._3d || curve._3d;
  }
  length() {
    return this.curves.map(function(v2) {
      return v2.length();
    }).reduce(function(a3, b) {
      return a3 + b;
    });
  }
  curve(idx) {
    return this.curves[idx];
  }
  bbox() {
    const c5 = this.curves;
    var bbox = c5[0].bbox();
    for (var i2 = 1; i2 < c5.length; i2++) {
      utils.expandbox(bbox, c5[i2].bbox());
    }
    return bbox;
  }
  offset(d3) {
    const offset = [];
    this.curves.forEach(function(v2) {
      offset.push(...v2.offset(d3));
    });
    return new _PolyBezier(offset);
  }
};

// node_modules/bezier-js/src/bezier.js
var { abs: abs3, min: min4, max: max5, cos: cos3, sin: sin3, acos: acos3, sqrt: sqrt4 } = Math;
var pi3 = Math.PI;
var Bezier = class _Bezier {
  constructor(coords) {
    let args = coords && coords.forEach ? coords : Array.from(arguments).slice();
    let coordlen = false;
    if (typeof args[0] === "object") {
      coordlen = args.length;
      const newargs = [];
      args.forEach(function(point3) {
        ["x", "y", "z"].forEach(function(d3) {
          if (typeof point3[d3] !== "undefined") {
            newargs.push(point3[d3]);
          }
        });
      });
      args = newargs;
    }
    let higher = false;
    const len = args.length;
    if (coordlen) {
      if (coordlen > 4) {
        if (arguments.length !== 1) {
          throw new Error(
            "Only new Bezier(point[]) is accepted for 4th and higher order curves"
          );
        }
        higher = true;
      }
    } else {
      if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {
        if (arguments.length !== 1) {
          throw new Error(
            "Only new Bezier(point[]) is accepted for 4th and higher order curves"
          );
        }
      }
    }
    const _3d = this._3d = !higher && (len === 9 || len === 12) || coords && coords[0] && typeof coords[0].z !== "undefined";
    const points = this.points = [];
    for (let idx = 0, step2 = _3d ? 3 : 2; idx < len; idx += step2) {
      var point2 = {
        x: args[idx],
        y: args[idx + 1]
      };
      if (_3d) {
        point2.z = args[idx + 2];
      }
      points.push(point2);
    }
    const order = this.order = points.length - 1;
    const dims = this.dims = ["x", "y"];
    if (_3d) dims.push("z");
    this.dimlen = dims.length;
    const aligned = utils.align(points, { p1: points[0], p2: points[order] });
    const baselength = utils.dist(points[0], points[order]);
    this._linear = aligned.reduce((t5, p3) => t5 + abs3(p3.y), 0) < baselength / 50;
    this._lut = [];
    this._t1 = 0;
    this._t2 = 1;
    this.update();
  }
  static quadraticFromPoints(p1, p22, p3, t5) {
    if (typeof t5 === "undefined") {
      t5 = 0.5;
    }
    if (t5 === 0) {
      return new _Bezier(p22, p22, p3);
    }
    if (t5 === 1) {
      return new _Bezier(p1, p22, p22);
    }
    const abc = _Bezier.getABC(2, p1, p22, p3, t5);
    return new _Bezier(p1, abc.A, p3);
  }
  static cubicFromPoints(S2, B4, E3, t5, d1) {
    if (typeof t5 === "undefined") {
      t5 = 0.5;
    }
    const abc = _Bezier.getABC(3, S2, B4, E3, t5);
    if (typeof d1 === "undefined") {
      d1 = utils.dist(B4, abc.C);
    }
    const d22 = d1 * (1 - t5) / t5;
    const selen = utils.dist(S2, E3), lx = (E3.x - S2.x) / selen, ly = (E3.y - S2.y) / selen, bx1 = d1 * lx, by1 = d1 * ly, bx2 = d22 * lx, by2 = d22 * ly;
    const e1 = { x: B4.x - bx1, y: B4.y - by1 }, e22 = { x: B4.x + bx2, y: B4.y + by2 }, A3 = abc.A, v1 = { x: A3.x + (e1.x - A3.x) / (1 - t5), y: A3.y + (e1.y - A3.y) / (1 - t5) }, v2 = { x: A3.x + (e22.x - A3.x) / t5, y: A3.y + (e22.y - A3.y) / t5 }, nc1 = { x: S2.x + (v1.x - S2.x) / t5, y: S2.y + (v1.y - S2.y) / t5 }, nc2 = {
      x: E3.x + (v2.x - E3.x) / (1 - t5),
      y: E3.y + (v2.y - E3.y) / (1 - t5)
    };
    return new _Bezier(S2, nc1, nc2, E3);
  }
  static getUtils() {
    return utils;
  }
  getUtils() {
    return _Bezier.getUtils();
  }
  static get PolyBezier() {
    return PolyBezier;
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return utils.pointsToString(this.points);
  }
  toSVG() {
    if (this._3d) return false;
    const p3 = this.points, x3 = p3[0].x, y3 = p3[0].y, s2 = ["M", x3, y3, this.order === 2 ? "Q" : "C"];
    for (let i2 = 1, last2 = p3.length; i2 < last2; i2++) {
      s2.push(p3[i2].x);
      s2.push(p3[i2].y);
    }
    return s2.join(" ");
  }
  setRatios(ratios) {
    if (ratios.length !== this.points.length) {
      throw new Error("incorrect number of ratio values");
    }
    this.ratios = ratios;
    this._lut = [];
  }
  verify() {
    const print = this.coordDigest();
    if (print !== this._print) {
      this._print = print;
      this.update();
    }
  }
  coordDigest() {
    return this.points.map(function(c5, pos) {
      return "" + pos + c5.x + c5.y + (c5.z ? c5.z : 0);
    }).join("");
  }
  update() {
    this._lut = [];
    this.dpoints = utils.derive(this.points, this._3d);
    this.computedirection();
  }
  computedirection() {
    const points = this.points;
    const angle2 = utils.angle(points[0], points[this.order], points[1]);
    this.clockwise = angle2 > 0;
  }
  length() {
    return utils.length(this.derivative.bind(this));
  }
  static getABC(order = 2, S2, B4, E3, t5 = 0.5) {
    const u2 = utils.projectionratio(t5, order), um = 1 - u2, C3 = {
      x: u2 * S2.x + um * E3.x,
      y: u2 * S2.y + um * E3.y
    }, s2 = utils.abcratio(t5, order), A3 = {
      x: B4.x + (B4.x - C3.x) / s2,
      y: B4.y + (B4.y - C3.y) / s2
    };
    return { A: A3, B: B4, C: C3, S: S2, E: E3 };
  }
  getABC(t5, B4) {
    B4 = B4 || this.get(t5);
    let S2 = this.points[0];
    let E3 = this.points[this.order];
    return _Bezier.getABC(this.order, S2, B4, E3, t5);
  }
  getLUT(steps) {
    this.verify();
    steps = steps || 100;
    if (this._lut.length === steps + 1) {
      return this._lut;
    }
    this._lut = [];
    steps++;
    this._lut = [];
    for (let i2 = 0, p3, t5; i2 < steps; i2++) {
      t5 = i2 / (steps - 1);
      p3 = this.compute(t5);
      p3.t = t5;
      this._lut.push(p3);
    }
    return this._lut;
  }
  on(point2, error2) {
    error2 = error2 || 5;
    const lut2 = this.getLUT(), hits = [];
    for (let i2 = 0, c5, t5 = 0; i2 < lut2.length; i2++) {
      c5 = lut2[i2];
      if (utils.dist(c5, point2) < error2) {
        hits.push(c5);
        t5 += i2 / lut2.length;
      }
    }
    if (!hits.length) return false;
    return t /= hits.length;
  }
  project(point2) {
    const LUT = this.getLUT(), l2 = LUT.length - 1, closest = utils.closest(LUT, point2), mpos = closest.mpos, t13 = (mpos - 1) / l2, t22 = (mpos + 1) / l2, step2 = 0.1 / l2;
    let mdist = closest.mdist, t5 = t13, ft = t5, p3;
    mdist += 1;
    for (let d3; t5 < t22 + step2; t5 += step2) {
      p3 = this.compute(t5);
      d3 = utils.dist(point2, p3);
      if (d3 < mdist) {
        mdist = d3;
        ft = t5;
      }
    }
    ft = ft < 0 ? 0 : ft > 1 ? 1 : ft;
    p3 = this.compute(ft);
    p3.t = ft;
    p3.d = mdist;
    return p3;
  }
  get(t5) {
    return this.compute(t5);
  }
  point(idx) {
    return this.points[idx];
  }
  compute(t5) {
    if (this.ratios) {
      return utils.computeWithRatios(t5, this.points, this.ratios, this._3d);
    }
    return utils.compute(t5, this.points, this._3d, this.ratios);
  }
  raise() {
    const p3 = this.points, np = [p3[0]], k2 = p3.length;
    for (let i2 = 1, pi4, pim; i2 < k2; i2++) {
      pi4 = p3[i2];
      pim = p3[i2 - 1];
      np[i2] = {
        x: (k2 - i2) / k2 * pi4.x + i2 / k2 * pim.x,
        y: (k2 - i2) / k2 * pi4.y + i2 / k2 * pim.y
      };
    }
    np[k2] = p3[k2 - 1];
    return new _Bezier(np);
  }
  derivative(t5) {
    return utils.compute(t5, this.dpoints[0], this._3d);
  }
  dderivative(t5) {
    return utils.compute(t5, this.dpoints[1], this._3d);
  }
  align() {
    let p3 = this.points;
    return new _Bezier(utils.align(p3, { p1: p3[0], p2: p3[p3.length - 1] }));
  }
  curvature(t5) {
    return utils.curvature(t5, this.dpoints[0], this.dpoints[1], this._3d);
  }
  inflections() {
    return utils.inflections(this.points);
  }
  normal(t5) {
    return this._3d ? this.__normal3(t5) : this.__normal2(t5);
  }
  __normal2(t5) {
    const d3 = this.derivative(t5);
    const q2 = sqrt4(d3.x * d3.x + d3.y * d3.y);
    return { t: t5, x: -d3.y / q2, y: d3.x / q2 };
  }
  __normal3(t5) {
    const r1 = this.derivative(t5), r2 = this.derivative(t5 + 0.01), q12 = sqrt4(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z), q2 = sqrt4(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);
    r1.x /= q12;
    r1.y /= q12;
    r1.z /= q12;
    r2.x /= q2;
    r2.y /= q2;
    r2.z /= q2;
    const c5 = {
      x: r2.y * r1.z - r2.z * r1.y,
      y: r2.z * r1.x - r2.x * r1.z,
      z: r2.x * r1.y - r2.y * r1.x
    };
    const m3 = sqrt4(c5.x * c5.x + c5.y * c5.y + c5.z * c5.z);
    c5.x /= m3;
    c5.y /= m3;
    c5.z /= m3;
    const R = [
      c5.x * c5.x,
      c5.x * c5.y - c5.z,
      c5.x * c5.z + c5.y,
      c5.x * c5.y + c5.z,
      c5.y * c5.y,
      c5.y * c5.z - c5.x,
      c5.x * c5.z - c5.y,
      c5.y * c5.z + c5.x,
      c5.z * c5.z
    ];
    const n2 = {
      t: t5,
      x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,
      y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,
      z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z
    };
    return n2;
  }
  hull(t5) {
    let p3 = this.points, _p = [], q2 = [], idx = 0;
    q2[idx++] = p3[0];
    q2[idx++] = p3[1];
    q2[idx++] = p3[2];
    if (this.order === 3) {
      q2[idx++] = p3[3];
    }
    while (p3.length > 1) {
      _p = [];
      for (let i2 = 0, pt, l2 = p3.length - 1; i2 < l2; i2++) {
        pt = utils.lerp(t5, p3[i2], p3[i2 + 1]);
        q2[idx++] = pt;
        _p.push(pt);
      }
      p3 = _p;
    }
    return q2;
  }
  split(t13, t22) {
    if (t13 === 0 && !!t22) {
      return this.split(t22).left;
    }
    if (t22 === 1) {
      return this.split(t13).right;
    }
    const q2 = this.hull(t13);
    const result2 = {
      left: this.order === 2 ? new _Bezier([q2[0], q2[3], q2[5]]) : new _Bezier([q2[0], q2[4], q2[7], q2[9]]),
      right: this.order === 2 ? new _Bezier([q2[5], q2[4], q2[2]]) : new _Bezier([q2[9], q2[8], q2[6], q2[3]]),
      span: q2
    };
    result2.left._t1 = utils.map(0, 0, 1, this._t1, this._t2);
    result2.left._t2 = utils.map(t13, 0, 1, this._t1, this._t2);
    result2.right._t1 = utils.map(t13, 0, 1, this._t1, this._t2);
    result2.right._t2 = utils.map(1, 0, 1, this._t1, this._t2);
    if (!t22) {
      return result2;
    }
    t22 = utils.map(t22, t13, 1, 0, 1);
    return result2.right.split(t22).left;
  }
  extrema() {
    const result2 = {};
    let roots = [];
    this.dims.forEach(
      (function(dim) {
        let mfn = function(v2) {
          return v2[dim];
        };
        let p3 = this.dpoints[0].map(mfn);
        result2[dim] = utils.droots(p3);
        if (this.order === 3) {
          p3 = this.dpoints[1].map(mfn);
          result2[dim] = result2[dim].concat(utils.droots(p3));
        }
        result2[dim] = result2[dim].filter(function(t5) {
          return t5 >= 0 && t5 <= 1;
        });
        roots = roots.concat(result2[dim].sort(utils.numberSort));
      }).bind(this)
    );
    result2.values = roots.sort(utils.numberSort).filter(function(v2, idx) {
      return roots.indexOf(v2) === idx;
    });
    return result2;
  }
  bbox() {
    const extrema = this.extrema(), result2 = {};
    this.dims.forEach(
      (function(d3) {
        result2[d3] = utils.getminmax(this, d3, extrema[d3]);
      }).bind(this)
    );
    return result2;
  }
  overlaps(curve) {
    const lbbox = this.bbox(), tbbox = curve.bbox();
    return utils.bboxoverlap(lbbox, tbbox);
  }
  offset(t5, d3) {
    if (typeof d3 !== "undefined") {
      const c5 = this.get(t5), n2 = this.normal(t5);
      const ret = {
        c: c5,
        n: n2,
        x: c5.x + n2.x * d3,
        y: c5.y + n2.y * d3
      };
      if (this._3d) {
        ret.z = c5.z + n2.z * d3;
      }
      return ret;
    }
    if (this._linear) {
      const nv = this.normal(0), coords = this.points.map(function(p3) {
        const ret = {
          x: p3.x + t5 * nv.x,
          y: p3.y + t5 * nv.y
        };
        if (p3.z && nv.z) {
          ret.z = p3.z + t5 * nv.z;
        }
        return ret;
      });
      return [new _Bezier(coords)];
    }
    return this.reduce().map(function(s2) {
      if (s2._linear) {
        return s2.offset(t5)[0];
      }
      return s2.scale(t5);
    });
  }
  simple() {
    if (this.order === 3) {
      const a1 = utils.angle(this.points[0], this.points[3], this.points[1]);
      const a22 = utils.angle(this.points[0], this.points[3], this.points[2]);
      if (a1 > 0 && a22 < 0 || a1 < 0 && a22 > 0) return false;
    }
    const n1 = this.normal(0);
    const n2 = this.normal(1);
    let s2 = n1.x * n2.x + n1.y * n2.y;
    if (this._3d) {
      s2 += n1.z * n2.z;
    }
    return abs3(acos3(s2)) < pi3 / 3;
  }
  reduce() {
    let i2, t13 = 0, t22 = 0, step2 = 0.01, segment, pass1 = [], pass2 = [];
    let extrema = this.extrema().values;
    if (extrema.indexOf(0) === -1) {
      extrema = [0].concat(extrema);
    }
    if (extrema.indexOf(1) === -1) {
      extrema.push(1);
    }
    for (t13 = extrema[0], i2 = 1; i2 < extrema.length; i2++) {
      t22 = extrema[i2];
      segment = this.split(t13, t22);
      segment._t1 = t13;
      segment._t2 = t22;
      pass1.push(segment);
      t13 = t22;
    }
    pass1.forEach(function(p1) {
      t13 = 0;
      t22 = 0;
      while (t22 <= 1) {
        for (t22 = t13 + step2; t22 <= 1 + step2; t22 += step2) {
          segment = p1.split(t13, t22);
          if (!segment.simple()) {
            t22 -= step2;
            if (abs3(t13 - t22) < step2) {
              return [];
            }
            segment = p1.split(t13, t22);
            segment._t1 = utils.map(t13, 0, 1, p1._t1, p1._t2);
            segment._t2 = utils.map(t22, 0, 1, p1._t1, p1._t2);
            pass2.push(segment);
            t13 = t22;
            break;
          }
        }
      }
      if (t13 < 1) {
        segment = p1.split(t13, 1);
        segment._t1 = utils.map(t13, 0, 1, p1._t1, p1._t2);
        segment._t2 = p1._t2;
        pass2.push(segment);
      }
    });
    return pass2;
  }
  translate(v2, d1, d22) {
    d22 = typeof d22 === "number" ? d22 : d1;
    const o2 = this.order;
    let d3 = this.points.map((_2, i2) => (1 - i2 / o2) * d1 + i2 / o2 * d22);
    return new _Bezier(
      this.points.map((p3, i2) => ({
        x: p3.x + v2.x * d3[i2],
        y: p3.y + v2.y * d3[i2]
      }))
    );
  }
  scale(d3) {
    const order = this.order;
    let distanceFn = false;
    if (typeof d3 === "function") {
      distanceFn = d3;
    }
    if (distanceFn && order === 2) {
      return this.raise().scale(distanceFn);
    }
    const clockwise = this.clockwise;
    const points = this.points;
    if (this._linear) {
      return this.translate(
        this.normal(0),
        distanceFn ? distanceFn(0) : d3,
        distanceFn ? distanceFn(1) : d3
      );
    }
    const r1 = distanceFn ? distanceFn(0) : d3;
    const r2 = distanceFn ? distanceFn(1) : d3;
    const v2 = [this.offset(0, 10), this.offset(1, 10)];
    const np = [];
    const o2 = utils.lli4(v2[0], v2[0].c, v2[1], v2[1].c);
    if (!o2) {
      throw new Error("cannot scale this curve. Try reducing it first.");
    }
    [0, 1].forEach(function(t5) {
      const p3 = np[t5 * order] = utils.copy(points[t5 * order]);
      p3.x += (t5 ? r2 : r1) * v2[t5].n.x;
      p3.y += (t5 ? r2 : r1) * v2[t5].n.y;
    });
    if (!distanceFn) {
      [0, 1].forEach((t5) => {
        if (order === 2 && !!t5) return;
        const p3 = np[t5 * order];
        const d4 = this.derivative(t5);
        const p22 = { x: p3.x + d4.x, y: p3.y + d4.y };
        np[t5 + 1] = utils.lli4(p3, p22, o2, points[t5 + 1]);
      });
      return new _Bezier(np);
    }
    [0, 1].forEach(function(t5) {
      if (order === 2 && !!t5) return;
      var p3 = points[t5 + 1];
      var ov = {
        x: p3.x - o2.x,
        y: p3.y - o2.y
      };
      var rc = distanceFn ? distanceFn((t5 + 1) / order) : d3;
      if (distanceFn && !clockwise) rc = -rc;
      var m3 = sqrt4(ov.x * ov.x + ov.y * ov.y);
      ov.x /= m3;
      ov.y /= m3;
      np[t5 + 1] = {
        x: p3.x + rc * ov.x,
        y: p3.y + rc * ov.y
      };
    });
    return new _Bezier(np);
  }
  outline(d1, d22, d3, d4) {
    d22 = d22 === void 0 ? d1 : d22;
    if (this._linear) {
      const n2 = this.normal(0);
      const start2 = this.points[0];
      const end = this.points[this.points.length - 1];
      let s2, mid, e3;
      if (d3 === void 0) {
        d3 = d1;
        d4 = d22;
      }
      s2 = { x: start2.x + n2.x * d1, y: start2.y + n2.y * d1 };
      e3 = { x: end.x + n2.x * d3, y: end.y + n2.y * d3 };
      mid = { x: (s2.x + e3.x) / 2, y: (s2.y + e3.y) / 2 };
      const fline = [s2, mid, e3];
      s2 = { x: start2.x - n2.x * d22, y: start2.y - n2.y * d22 };
      e3 = { x: end.x - n2.x * d4, y: end.y - n2.y * d4 };
      mid = { x: (s2.x + e3.x) / 2, y: (s2.y + e3.y) / 2 };
      const bline = [e3, mid, s2];
      const ls2 = utils.makeline(bline[2], fline[0]);
      const le2 = utils.makeline(fline[2], bline[0]);
      const segments2 = [ls2, new _Bezier(fline), le2, new _Bezier(bline)];
      return new PolyBezier(segments2);
    }
    const reduced = this.reduce(), len = reduced.length, fcurves = [];
    let bcurves = [], p3, alen = 0, tlen = this.length();
    const graduated = typeof d3 !== "undefined" && typeof d4 !== "undefined";
    function linearDistanceFunction(s2, e3, tlen2, alen2, slen) {
      return function(v2) {
        const f1 = alen2 / tlen2, f22 = (alen2 + slen) / tlen2, d5 = e3 - s2;
        return utils.map(v2, 0, 1, s2 + f1 * d5, s2 + f22 * d5);
      };
    }
    reduced.forEach(function(segment) {
      const slen = segment.length();
      if (graduated) {
        fcurves.push(
          segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen))
        );
        bcurves.push(
          segment.scale(linearDistanceFunction(-d22, -d4, tlen, alen, slen))
        );
      } else {
        fcurves.push(segment.scale(d1));
        bcurves.push(segment.scale(-d22));
      }
      alen += slen;
    });
    bcurves = bcurves.map(function(s2) {
      p3 = s2.points;
      if (p3[3]) {
        s2.points = [p3[3], p3[2], p3[1], p3[0]];
      } else {
        s2.points = [p3[2], p3[1], p3[0]];
      }
      return s2;
    }).reverse();
    const fs = fcurves[0].points[0], fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1], bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1], be = bcurves[0].points[0], ls = utils.makeline(bs, fs), le = utils.makeline(fe, be), segments = [ls].concat(fcurves).concat([le]).concat(bcurves);
    return new PolyBezier(segments);
  }
  outlineshapes(d1, d22, curveIntersectionThreshold) {
    d22 = d22 || d1;
    const outline = this.outline(d1, d22).curves;
    const shapes = [];
    for (let i2 = 1, len = outline.length; i2 < len / 2; i2++) {
      const shape = utils.makeshape(
        outline[i2],
        outline[len - i2],
        curveIntersectionThreshold
      );
      shape.startcap.virtual = i2 > 1;
      shape.endcap.virtual = i2 < len / 2 - 1;
      shapes.push(shape);
    }
    return shapes;
  }
  intersects(curve, curveIntersectionThreshold) {
    if (!curve) return this.selfintersects(curveIntersectionThreshold);
    if (curve.p1 && curve.p2) {
      return this.lineIntersects(curve);
    }
    if (curve instanceof _Bezier) {
      curve = curve.reduce();
    }
    return this.curveintersects(
      this.reduce(),
      curve,
      curveIntersectionThreshold
    );
  }
  lineIntersects(line) {
    const mx = min4(line.p1.x, line.p2.x), my = min4(line.p1.y, line.p2.y), MX = max5(line.p1.x, line.p2.x), MY = max5(line.p1.y, line.p2.y);
    return utils.roots(this.points, line).filter((t5) => {
      var p3 = this.get(t5);
      return utils.between(p3.x, mx, MX) && utils.between(p3.y, my, MY);
    });
  }
  selfintersects(curveIntersectionThreshold) {
    const reduced = this.reduce(), len = reduced.length - 2, results = [];
    for (let i2 = 0, result2, left, right; i2 < len; i2++) {
      left = reduced.slice(i2, i2 + 1);
      right = reduced.slice(i2 + 2);
      result2 = this.curveintersects(left, right, curveIntersectionThreshold);
      results.push(...result2);
    }
    return results;
  }
  curveintersects(c1, c22, curveIntersectionThreshold) {
    const pairs2 = [];
    c1.forEach(function(l2) {
      c22.forEach(function(r2) {
        if (l2.overlaps(r2)) {
          pairs2.push({ left: l2, right: r2 });
        }
      });
    });
    let intersections = [];
    pairs2.forEach(function(pair) {
      const result2 = utils.pairiteration(
        pair.left,
        pair.right,
        curveIntersectionThreshold
      );
      if (result2.length > 0) {
        intersections = intersections.concat(result2);
      }
    });
    return intersections;
  }
  arcs(errorThreshold) {
    errorThreshold = errorThreshold || 0.5;
    return this._iterate(errorThreshold, []);
  }
  _error(pc, np1, s2, e3) {
    const q2 = (e3 - s2) / 4, c1 = this.get(s2 + q2), c22 = this.get(e3 - q2), ref = utils.dist(pc, np1), d1 = utils.dist(pc, c1), d22 = utils.dist(pc, c22);
    return abs3(d1 - ref) + abs3(d22 - ref);
  }
  _iterate(errorThreshold, circles) {
    let t_s = 0, t_e = 1, safety;
    do {
      safety = 0;
      t_e = 1;
      let np1 = this.get(t_s), np2, np3, arc, prev_arc;
      let curr_good = false, prev_good = false, done;
      let t_m = t_e, prev_e = 1, step2 = 0;
      do {
        prev_good = curr_good;
        prev_arc = arc;
        t_m = (t_s + t_e) / 2;
        step2++;
        np2 = this.get(t_m);
        np3 = this.get(t_e);
        arc = utils.getccenter(np1, np2, np3);
        arc.interval = {
          start: t_s,
          end: t_e
        };
        let error2 = this._error(arc, np1, t_s, t_e);
        curr_good = error2 <= errorThreshold;
        done = prev_good && !curr_good;
        if (!done) prev_e = t_e;
        if (curr_good) {
          if (t_e >= 1) {
            arc.interval.end = prev_e = 1;
            prev_arc = arc;
            if (t_e > 1) {
              let d3 = {
                x: arc.x + arc.r * cos3(arc.e),
                y: arc.y + arc.r * sin3(arc.e)
              };
              arc.e += utils.angle({ x: arc.x, y: arc.y }, d3, this.get(1));
            }
            break;
          }
          t_e = t_e + (t_e - t_s) / 2;
        } else {
          t_e = t_m;
        }
      } while (!done && safety++ < 100);
      if (safety >= 100) {
        break;
      }
      prev_arc = prev_arc ? prev_arc : arc;
      circles.push(prev_arc);
      t_s = prev_e;
    } while (t_e < 1);
    return circles;
  }
};

// node_modules/index-array-by/dist/index-array-by.mjs
function _arrayLikeToArray12(r2, a3) {
  (null == a3 || a3 > r2.length) && (a3 = r2.length);
  for (var e3 = 0, n2 = Array(a3); e3 < a3; e3++) n2[e3] = r2[e3];
  return n2;
}
function _arrayWithHoles10(r2) {
  if (Array.isArray(r2)) return r2;
}
function _arrayWithoutHoles10(r2) {
  if (Array.isArray(r2)) return _arrayLikeToArray12(r2);
}
function _iterableToArray10(r2) {
  if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"]) return Array.from(r2);
}
function _iterableToArrayLimit10(r2, l2) {
  var t5 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t5) {
    var e3, n2, i2, u2, a3 = [], f3 = true, o2 = false;
    try {
      if (i2 = (t5 = t5.call(r2)).next, 0 === l2) ;
      else for (; !(f3 = (e3 = i2.call(t5)).done) && (a3.push(e3.value), a3.length !== l2); f3 = true) ;
    } catch (r3) {
      o2 = true, n2 = r3;
    } finally {
      try {
        if (!f3 && null != t5.return && (u2 = t5.return(), Object(u2) !== u2)) return;
      } finally {
        if (o2) throw n2;
      }
    }
    return a3;
  }
}
function _nonIterableRest10() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableSpread10() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _objectWithoutProperties(e3, t5) {
  if (null == e3) return {};
  var o2, r2, i2 = _objectWithoutPropertiesLoose(e3, t5);
  if (Object.getOwnPropertySymbols) {
    var s2 = Object.getOwnPropertySymbols(e3);
    for (r2 = 0; r2 < s2.length; r2++) o2 = s2[r2], t5.includes(o2) || {}.propertyIsEnumerable.call(e3, o2) && (i2[o2] = e3[o2]);
  }
  return i2;
}
function _objectWithoutPropertiesLoose(r2, e3) {
  if (null == r2) return {};
  var t5 = {};
  for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
    if (e3.includes(n2)) continue;
    t5[n2] = r2[n2];
  }
  return t5;
}
function _slicedToArray10(r2, e3) {
  return _arrayWithHoles10(r2) || _iterableToArrayLimit10(r2, e3) || _unsupportedIterableToArray12(r2, e3) || _nonIterableRest10();
}
function _toConsumableArray10(r2) {
  return _arrayWithoutHoles10(r2) || _iterableToArray10(r2) || _unsupportedIterableToArray12(r2) || _nonIterableSpread10();
}
function _toPrimitive10(t5, r2) {
  if ("object" != typeof t5 || !t5) return t5;
  var e3 = t5[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t5, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t5);
}
function _toPropertyKey10(t5) {
  var i2 = _toPrimitive10(t5, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _unsupportedIterableToArray12(r2, a3) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray12(r2, a3);
    var t5 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t5 && r2.constructor && (t5 = r2.constructor.name), "Map" === t5 || "Set" === t5 ? Array.from(r2) : "Arguments" === t5 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t5) ? _arrayLikeToArray12(r2, a3) : void 0;
  }
}
var index7 = (function() {
  var list = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  var keyAccessors = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var multiItem = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  var flattenKeys = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  var keys2 = (keyAccessors instanceof Array ? keyAccessors.length ? keyAccessors : [void 0] : [keyAccessors]).map(function(key) {
    return {
      keyAccessor: key,
      isProp: !(key instanceof Function)
    };
  });
  var indexedResult = list.reduce(function(res, item) {
    var iterObj = res;
    var itemVal = item;
    keys2.forEach(function(_ref, idx) {
      var keyAccessor = _ref.keyAccessor, isProp = _ref.isProp;
      var key;
      if (isProp) {
        var _itemVal = itemVal, propVal = _itemVal[keyAccessor], rest2 = _objectWithoutProperties(_itemVal, [keyAccessor].map(_toPropertyKey10));
        key = propVal;
        itemVal = rest2;
      } else {
        key = keyAccessor(itemVal, idx);
      }
      if (idx + 1 < keys2.length) {
        if (!iterObj.hasOwnProperty(key)) {
          iterObj[key] = {};
        }
        iterObj = iterObj[key];
      } else {
        if (multiItem) {
          if (!iterObj.hasOwnProperty(key)) {
            iterObj[key] = [];
          }
          iterObj[key].push(itemVal);
        } else {
          iterObj[key] = itemVal;
        }
      }
    });
    return res;
  }, {});
  if (multiItem instanceof Function) {
    (function reduce3(node) {
      var level = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      if (level === keys2.length) {
        Object.keys(node).forEach(function(k2) {
          return node[k2] = multiItem(node[k2]);
        });
      } else {
        Object.values(node).forEach(function(child) {
          return reduce3(child, level + 1);
        });
      }
    })(indexedResult);
  }
  var result2 = indexedResult;
  if (flattenKeys) {
    result2 = [];
    (function flatten2(node) {
      var accKeys = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      if (accKeys.length === keys2.length) {
        result2.push({
          keys: accKeys,
          vals: node
        });
      } else {
        Object.entries(node).forEach(function(_ref2) {
          var _ref3 = _slicedToArray10(_ref2, 2), key = _ref3[0], val = _ref3[1];
          return flatten2(val, [].concat(_toConsumableArray10(accKeys), [key]));
        });
      }
    })(indexedResult);
    if (keyAccessors instanceof Array && keyAccessors.length === 0 && result2.length === 1) {
      result2[0].keys = [];
    }
  }
  return result2;
});

// node_modules/force-graph/dist/force-graph.mjs
function styleInject5(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;
  if (typeof document === "undefined") {
    return;
  }
  var head2 = document.head || document.getElementsByTagName("head")[0];
  var style = document.createElement("style");
  style.type = "text/css";
  if (insertAt === "top") {
    if (head2.firstChild) {
      head2.insertBefore(style, head2.firstChild);
    } else {
      head2.appendChild(style);
    }
  } else {
    head2.appendChild(style);
  }
  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}
var css_248z5 = ".force-graph-container canvas {\n  display: block;\n  user-select: none;\n  outline: none;\n  -webkit-tap-highlight-color: transparent;\n}\n\n.force-graph-container .clickable {\n  cursor: pointer;\n}\n\n.force-graph-container .grabbable {\n  cursor: move;\n  cursor: grab;\n  cursor: -moz-grab;\n  cursor: -webkit-grab;\n}\n\n.force-graph-container .grabbable:active {\n  cursor: grabbing;\n  cursor: -moz-grabbing;\n  cursor: -webkit-grabbing;\n}\n";
styleInject5(css_248z5);
function _arrayLikeToArray13(r2, a3) {
  (null == a3 || a3 > r2.length) && (a3 = r2.length);
  for (var e3 = 0, n2 = Array(a3); e3 < a3; e3++) n2[e3] = r2[e3];
  return n2;
}
function _arrayWithHoles11(r2) {
  if (Array.isArray(r2)) return r2;
}
function _arrayWithoutHoles11(r2) {
  if (Array.isArray(r2)) return _arrayLikeToArray13(r2);
}
function _construct3(t5, e3, r2) {
  if (_isNativeReflectConstruct3()) return Reflect.construct.apply(null, arguments);
  var o2 = [null];
  o2.push.apply(o2, e3);
  var p3 = new (t5.bind.apply(t5, o2))();
  return p3;
}
function _defineProperty8(e3, r2, t5) {
  return (r2 = _toPropertyKey11(r2)) in e3 ? Object.defineProperty(e3, r2, {
    value: t5,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e3[r2] = t5, e3;
}
function _isNativeReflectConstruct3() {
  try {
    var t5 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t6) {
  }
  return (_isNativeReflectConstruct3 = function() {
    return !!t5;
  })();
}
function _iterableToArray11(r2) {
  if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"]) return Array.from(r2);
}
function _iterableToArrayLimit11(r2, l2) {
  var t5 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t5) {
    var e3, n2, i2, u2, a3 = [], f3 = true, o2 = false;
    try {
      if (i2 = (t5 = t5.call(r2)).next, 0 === l2) ;
      else for (; !(f3 = (e3 = i2.call(t5)).done) && (a3.push(e3.value), a3.length !== l2); f3 = true) ;
    } catch (r3) {
      o2 = true, n2 = r3;
    } finally {
      try {
        if (!f3 && null != t5.return && (u2 = t5.return(), Object(u2) !== u2)) return;
      } finally {
        if (o2) throw n2;
      }
    }
    return a3;
  }
}
function _nonIterableRest11() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableSpread11() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function ownKeys6(e3, r2) {
  var t5 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t5.push.apply(t5, o2);
  }
  return t5;
}
function _objectSpread26(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t5 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys6(Object(t5), true).forEach(function(r3) {
      _defineProperty8(e3, r3, t5[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t5)) : ownKeys6(Object(t5)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t5, r3));
    });
  }
  return e3;
}
function _slicedToArray11(r2, e3) {
  return _arrayWithHoles11(r2) || _iterableToArrayLimit11(r2, e3) || _unsupportedIterableToArray13(r2, e3) || _nonIterableRest11();
}
function _toConsumableArray11(r2) {
  return _arrayWithoutHoles11(r2) || _iterableToArray11(r2) || _unsupportedIterableToArray13(r2) || _nonIterableSpread11();
}
function _toPrimitive11(t5, r2) {
  if ("object" != typeof t5 || !t5) return t5;
  var e3 = t5[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t5, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t5);
}
function _toPropertyKey11(t5) {
  var i2 = _toPrimitive11(t5, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _typeof4(o2) {
  "@babel/helpers - typeof";
  return _typeof4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof4(o2);
}
function _unsupportedIterableToArray13(r2, a3) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray13(r2, a3);
    var t5 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t5 && r2.constructor && (t5 = r2.constructor.name), "Map" === t5 || "Set" === t5 ? Array.from(r2) : "Arguments" === t5 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t5) ? _arrayLikeToArray13(r2, a3) : void 0;
  }
}
var autoColorScale2 = ordinal(Paired_default);
function autoColorObjects2(objects, colorByAccessor, colorField) {
  if (!colorByAccessor || typeof colorField !== "string") return;
  objects.filter(function(obj) {
    return !obj[colorField];
  }).forEach(function(obj) {
    obj[colorField] = autoColorScale2(colorByAccessor(obj));
  });
}
function getDagDepths2(_ref, idAccessor) {
  var nodes = _ref.nodes, links = _ref.links;
  var _ref2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, _ref2$nodeFilter = _ref2.nodeFilter, nodeFilter = _ref2$nodeFilter === void 0 ? function() {
    return true;
  } : _ref2$nodeFilter, _ref2$onLoopError = _ref2.onLoopError, onLoopError = _ref2$onLoopError === void 0 ? function(loopIds) {
    throw "Invalid DAG structure! Found cycle in node path: ".concat(loopIds.join(" -> "), ".");
  } : _ref2$onLoopError;
  var graph = {};
  nodes.forEach(function(node) {
    return graph[idAccessor(node)] = {
      data: node,
      out: [],
      depth: -1,
      skip: !nodeFilter(node)
    };
  });
  links.forEach(function(_ref3) {
    var source = _ref3.source, target = _ref3.target;
    var sourceId = getNodeId(source);
    var targetId = getNodeId(target);
    if (!graph.hasOwnProperty(sourceId)) throw "Missing source node with id: ".concat(sourceId);
    if (!graph.hasOwnProperty(targetId)) throw "Missing target node with id: ".concat(targetId);
    var sourceNode = graph[sourceId];
    var targetNode = graph[targetId];
    sourceNode.out.push(targetNode);
    function getNodeId(node) {
      return _typeof4(node) === "object" ? idAccessor(node) : node;
    }
  });
  var foundLoops = [];
  traverse(Object.values(graph));
  var nodeDepths = Object.assign.apply(Object, [{}].concat(_toConsumableArray11(Object.entries(graph).filter(function(_ref4) {
    var _ref5 = _slicedToArray11(_ref4, 2), node = _ref5[1];
    return !node.skip;
  }).map(function(_ref6) {
    var _ref7 = _slicedToArray11(_ref6, 2), id2 = _ref7[0], node = _ref7[1];
    return _defineProperty8({}, id2, node.depth);
  }))));
  return nodeDepths;
  function traverse(nodes2) {
    var nodeStack = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    var currentDepth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    var _loop = function _loop2() {
      var node = nodes2[i2];
      if (nodeStack.indexOf(node) !== -1) {
        var loop = [].concat(_toConsumableArray11(nodeStack.slice(nodeStack.indexOf(node))), [node]).map(function(d3) {
          return idAccessor(d3.data);
        });
        if (!foundLoops.some(function(foundLoop) {
          return foundLoop.length === loop.length && foundLoop.every(function(id2, idx) {
            return id2 === loop[idx];
          });
        })) {
          foundLoops.push(loop);
          onLoopError(loop);
        }
        return 1;
      }
      if (currentDepth > node.depth) {
        node.depth = currentDepth;
        traverse(node.out, [].concat(_toConsumableArray11(nodeStack), [node]), currentDepth + (node.skip ? 0 : 1));
      }
    };
    for (var i2 = 0, l2 = nodes2.length; i2 < l2; i2++) {
      if (_loop()) continue;
    }
  }
}
var DAG_LEVEL_NODE_RATIO2 = 2;
var notifyRedraw = function notifyRedraw2(_2, state) {
  return state.onNeedsRedraw && state.onNeedsRedraw();
};
var updDataPhotons = function updDataPhotons2(_2, state) {
  if (!state.isShadow) {
    var linkParticlesAccessor = index4(state.linkDirectionalParticles);
    state.graphData.links.forEach(function(link) {
      var numPhotons = Math.round(Math.abs(linkParticlesAccessor(link)));
      if (numPhotons) {
        link.__photons = _toConsumableArray11(Array(numPhotons)).map(function() {
          return {};
        });
      } else {
        delete link.__photons;
      }
    });
  }
};
var CanvasForceGraph = index3({
  props: {
    graphData: {
      "default": {
        nodes: [],
        links: []
      },
      onChange: function onChange15(_2, state) {
        state.engineRunning = false;
        updDataPhotons(_2, state);
      }
    },
    dagMode: {
      onChange: function onChange16(dagMode, state) {
        !dagMode && (state.graphData.nodes || []).forEach(function(n2) {
          return n2.fx = n2.fy = void 0;
        });
      }
    },
    dagLevelDistance: {},
    dagNodeFilter: {
      "default": function _default16(node) {
        return true;
      }
    },
    onDagError: {
      triggerUpdate: false
    },
    nodeRelSize: {
      "default": 4,
      triggerUpdate: false,
      onChange: notifyRedraw
    },
    // area per val unit
    nodeId: {
      "default": "id"
    },
    nodeVal: {
      "default": "val",
      triggerUpdate: false,
      onChange: notifyRedraw
    },
    nodeColor: {
      "default": "color",
      triggerUpdate: false,
      onChange: notifyRedraw
    },
    nodeAutoColorBy: {},
    nodeCanvasObject: {
      triggerUpdate: false,
      onChange: notifyRedraw
    },
    nodeCanvasObjectMode: {
      "default": function _default17() {
        return "replace";
      },
      triggerUpdate: false,
      onChange: notifyRedraw
    },
    nodeVisibility: {
      "default": true,
      triggerUpdate: false,
      onChange: notifyRedraw
    },
    linkSource: {
      "default": "source"
    },
    linkTarget: {
      "default": "target"
    },
    linkVisibility: {
      "default": true,
      triggerUpdate: false,
      onChange: notifyRedraw
    },
    linkColor: {
      "default": "color",
      triggerUpdate: false,
      onChange: notifyRedraw
    },
    linkAutoColorBy: {},
    linkLineDash: {
      triggerUpdate: false,
      onChange: notifyRedraw
    },
    linkWidth: {
      "default": 1,
      triggerUpdate: false,
      onChange: notifyRedraw
    },
    linkCurvature: {
      "default": 0,
      triggerUpdate: false,
      onChange: notifyRedraw
    },
    linkCanvasObject: {
      triggerUpdate: false,
      onChange: notifyRedraw
    },
    linkCanvasObjectMode: {
      "default": function _default18() {
        return "replace";
      },
      triggerUpdate: false,
      onChange: notifyRedraw
    },
    linkDirectionalArrowLength: {
      "default": 0,
      triggerUpdate: false,
      onChange: notifyRedraw
    },
    linkDirectionalArrowColor: {
      triggerUpdate: false,
      onChange: notifyRedraw
    },
    linkDirectionalArrowRelPos: {
      "default": 0.5,
      triggerUpdate: false,
      onChange: notifyRedraw
    },
    // value between 0<>1 indicating the relative pos along the (exposed) line
    linkDirectionalParticles: {
      "default": 0,
      triggerUpdate: false,
      onChange: updDataPhotons
    },
    // animate photons travelling in the link direction
    linkDirectionalParticleSpeed: {
      "default": 0.01,
      triggerUpdate: false
    },
    // in link length ratio per frame
    linkDirectionalParticleOffset: {
      "default": 0,
      triggerUpdate: false
    },
    // starting position offset along the link's length, like a pre-delay. Values between [0, 1]
    linkDirectionalParticleWidth: {
      "default": 4,
      triggerUpdate: false
    },
    linkDirectionalParticleColor: {
      triggerUpdate: false
    },
    linkDirectionalParticleCanvasObject: {
      triggerUpdate: false
    },
    globalScale: {
      "default": 1,
      triggerUpdate: false
    },
    d3AlphaMin: {
      "default": 0,
      triggerUpdate: false
    },
    d3AlphaDecay: {
      "default": 0.0228,
      triggerUpdate: false,
      onChange: function onChange17(alphaDecay, state) {
        state.forceLayout.alphaDecay(alphaDecay);
      }
    },
    d3AlphaTarget: {
      "default": 0,
      triggerUpdate: false,
      onChange: function onChange18(alphaTarget, state) {
        state.forceLayout.alphaTarget(alphaTarget);
      }
    },
    d3VelocityDecay: {
      "default": 0.4,
      triggerUpdate: false,
      onChange: function onChange19(velocityDecay, state) {
        state.forceLayout.velocityDecay(velocityDecay);
      }
    },
    warmupTicks: {
      "default": 0,
      triggerUpdate: false
    },
    // how many times to tick the force engine at init before starting to render
    cooldownTicks: {
      "default": Infinity,
      triggerUpdate: false
    },
    cooldownTime: {
      "default": 15e3,
      triggerUpdate: false
    },
    // ms
    onUpdate: {
      "default": function _default19() {
      },
      triggerUpdate: false
    },
    onFinishUpdate: {
      "default": function _default20() {
      },
      triggerUpdate: false
    },
    onEngineTick: {
      "default": function _default21() {
      },
      triggerUpdate: false
    },
    onEngineStop: {
      "default": function _default22() {
      },
      triggerUpdate: false
    },
    onNeedsRedraw: {
      triggerUpdate: false
    },
    isShadow: {
      "default": false,
      triggerUpdate: false
    }
  },
  methods: {
    // Expose d3 forces for external manipulation
    d3Force: function d3Force2(state, forceName, forceFn) {
      if (forceFn === void 0) {
        return state.forceLayout.force(forceName);
      }
      state.forceLayout.force(forceName, forceFn);
      return this;
    },
    d3ReheatSimulation: function d3ReheatSimulation2(state) {
      state.forceLayout.alpha(1);
      this.resetCountdown();
      return this;
    },
    // reset cooldown state
    resetCountdown: function resetCountdown2(state) {
      state.cntTicks = 0;
      state.startTickTime = /* @__PURE__ */ new Date();
      state.engineRunning = true;
      return this;
    },
    isEngineRunning: function isEngineRunning(state) {
      return !!state.engineRunning;
    },
    tickFrame: function tickFrame2(state) {
      !state.isShadow && layoutTick();
      paintLinks();
      !state.isShadow && paintArrows();
      !state.isShadow && paintPhotons();
      paintNodes();
      return this;
      function layoutTick() {
        if (state.engineRunning) {
          if (++state.cntTicks > state.cooldownTicks || /* @__PURE__ */ new Date() - state.startTickTime > state.cooldownTime || state.d3AlphaMin > 0 && state.forceLayout.alpha() < state.d3AlphaMin) {
            state.engineRunning = false;
            state.onEngineStop();
          } else {
            state.forceLayout.tick();
            state.onEngineTick();
          }
        }
      }
      function paintNodes() {
        var getVisibility = index4(state.nodeVisibility);
        var getVal = index4(state.nodeVal);
        var getColor = index4(state.nodeColor);
        var getNodeCanvasObjectMode = index4(state.nodeCanvasObjectMode);
        var ctx = state.ctx;
        var padAmount = state.isShadow / state.globalScale;
        var visibleNodes = state.graphData.nodes.filter(getVisibility);
        ctx.save();
        visibleNodes.forEach(function(node) {
          var nodeCanvasObjectMode = getNodeCanvasObjectMode(node);
          if (state.nodeCanvasObject && (nodeCanvasObjectMode === "before" || nodeCanvasObjectMode === "replace")) {
            state.nodeCanvasObject(node, ctx, state.globalScale);
            if (nodeCanvasObjectMode === "replace") {
              ctx.restore();
              return;
            }
          }
          var r2 = Math.sqrt(Math.max(0, getVal(node) || 1)) * state.nodeRelSize + padAmount;
          ctx.beginPath();
          ctx.arc(node.x, node.y, r2, 0, 2 * Math.PI, false);
          ctx.fillStyle = getColor(node) || "rgba(31, 120, 180, 0.92)";
          ctx.fill();
          if (state.nodeCanvasObject && nodeCanvasObjectMode === "after") {
            state.nodeCanvasObject(node, state.ctx, state.globalScale);
          }
        });
        ctx.restore();
      }
      function paintLinks() {
        var getVisibility = index4(state.linkVisibility);
        var getColor = index4(state.linkColor);
        var getWidth = index4(state.linkWidth);
        var getLineDash = index4(state.linkLineDash);
        var getCurvature = index4(state.linkCurvature);
        var getLinkCanvasObjectMode = index4(state.linkCanvasObjectMode);
        var ctx = state.ctx;
        var padAmount = state.isShadow * 2;
        var visibleLinks = state.graphData.links.filter(getVisibility);
        visibleLinks.forEach(calcLinkControlPoints);
        var beforeCustomLinks = [], afterCustomLinks = [], defaultPaintLinks = visibleLinks;
        if (state.linkCanvasObject) {
          var replaceCustomLinks = [], otherCustomLinks = [];
          visibleLinks.forEach(function(d3) {
            return ({
              before: beforeCustomLinks,
              after: afterCustomLinks,
              replace: replaceCustomLinks
            }[getLinkCanvasObjectMode(d3)] || otherCustomLinks).push(d3);
          });
          defaultPaintLinks = [].concat(_toConsumableArray11(beforeCustomLinks), afterCustomLinks, otherCustomLinks);
          beforeCustomLinks = beforeCustomLinks.concat(replaceCustomLinks);
        }
        ctx.save();
        beforeCustomLinks.forEach(function(link) {
          return state.linkCanvasObject(link, ctx, state.globalScale);
        });
        ctx.restore();
        var linksPerColor = index7(defaultPaintLinks, [getColor, getWidth, getLineDash]);
        ctx.save();
        Object.entries(linksPerColor).forEach(function(_ref) {
          var _ref2 = _slicedToArray11(_ref, 2), color3 = _ref2[0], linksPerWidth = _ref2[1];
          var lineColor = !color3 || color3 === "undefined" ? "rgba(0,0,0,0.15)" : color3;
          Object.entries(linksPerWidth).forEach(function(_ref3) {
            var _ref4 = _slicedToArray11(_ref3, 2), width = _ref4[0], linesPerLineDash = _ref4[1];
            var lineWidth = (width || 1) / state.globalScale + padAmount;
            Object.entries(linesPerLineDash).forEach(function(_ref5) {
              var _ref6 = _slicedToArray11(_ref5, 2);
              _ref6[0];
              var links = _ref6[1];
              var lineDashSegments = getLineDash(links[0]);
              ctx.beginPath();
              links.forEach(function(link) {
                var start2 = link.source;
                var end = link.target;
                if (!start2 || !end || !start2.hasOwnProperty("x") || !end.hasOwnProperty("x")) return;
                ctx.moveTo(start2.x, start2.y);
                var controlPoints = link.__controlPoints;
                if (!controlPoints) {
                  ctx.lineTo(end.x, end.y);
                } else {
                  ctx[controlPoints.length === 2 ? "quadraticCurveTo" : "bezierCurveTo"].apply(ctx, _toConsumableArray11(controlPoints).concat([end.x, end.y]));
                }
              });
              ctx.strokeStyle = lineColor;
              ctx.lineWidth = lineWidth;
              ctx.setLineDash(lineDashSegments || []);
              ctx.stroke();
            });
          });
        });
        ctx.restore();
        ctx.save();
        afterCustomLinks.forEach(function(link) {
          return state.linkCanvasObject(link, ctx, state.globalScale);
        });
        ctx.restore();
        function calcLinkControlPoints(link) {
          var curvature = getCurvature(link);
          if (!curvature) {
            link.__controlPoints = null;
            return;
          }
          var start2 = link.source;
          var end = link.target;
          if (!start2 || !end || !start2.hasOwnProperty("x") || !end.hasOwnProperty("x")) return;
          var l2 = Math.sqrt(Math.pow(end.x - start2.x, 2) + Math.pow(end.y - start2.y, 2));
          if (l2 > 0) {
            var a3 = Math.atan2(end.y - start2.y, end.x - start2.x);
            var d3 = l2 * curvature;
            var cp = {
              // control point
              x: (start2.x + end.x) / 2 + d3 * Math.cos(a3 - Math.PI / 2),
              y: (start2.y + end.y) / 2 + d3 * Math.sin(a3 - Math.PI / 2)
            };
            link.__controlPoints = [cp.x, cp.y];
          } else {
            var _d = curvature * 70;
            link.__controlPoints = [end.x, end.y - _d, end.x + _d, end.y];
          }
        }
      }
      function paintArrows() {
        var ARROW_WH_RATIO = 1.6;
        var ARROW_VLEN_RATIO = 0.2;
        var getLength = index4(state.linkDirectionalArrowLength);
        var getRelPos = index4(state.linkDirectionalArrowRelPos);
        var getVisibility = index4(state.linkVisibility);
        var getColor = index4(state.linkDirectionalArrowColor || state.linkColor);
        var getNodeVal = index4(state.nodeVal);
        var ctx = state.ctx;
        ctx.save();
        state.graphData.links.filter(getVisibility).forEach(function(link) {
          var arrowLength = getLength(link);
          if (!arrowLength || arrowLength < 0) return;
          var start2 = link.source;
          var end = link.target;
          if (!start2 || !end || !start2.hasOwnProperty("x") || !end.hasOwnProperty("x")) return;
          var startR = Math.sqrt(Math.max(0, getNodeVal(start2) || 1)) * state.nodeRelSize;
          var endR = Math.sqrt(Math.max(0, getNodeVal(end) || 1)) * state.nodeRelSize;
          var arrowRelPos = Math.min(1, Math.max(0, getRelPos(link)));
          var arrowColor = getColor(link) || "rgba(0,0,0,0.28)";
          var arrowHalfWidth = arrowLength / ARROW_WH_RATIO / 2;
          var bzLine = link.__controlPoints && _construct3(Bezier, [start2.x, start2.y].concat(_toConsumableArray11(link.__controlPoints), [end.x, end.y]));
          var getCoordsAlongLine = bzLine ? function(t5) {
            return bzLine.get(t5);
          } : function(t5) {
            return {
              // straight line: interpolate linearly
              x: start2.x + (end.x - start2.x) * t5 || 0,
              y: start2.y + (end.y - start2.y) * t5 || 0
            };
          };
          var lineLen = bzLine ? bzLine.length() : Math.sqrt(Math.pow(end.x - start2.x, 2) + Math.pow(end.y - start2.y, 2));
          var posAlongLine = startR + arrowLength + (lineLen - startR - endR - arrowLength) * arrowRelPos;
          var arrowHead = getCoordsAlongLine(posAlongLine / lineLen);
          var arrowTail = getCoordsAlongLine((posAlongLine - arrowLength) / lineLen);
          var arrowTailVertex = getCoordsAlongLine((posAlongLine - arrowLength * (1 - ARROW_VLEN_RATIO)) / lineLen);
          var arrowTailAngle = Math.atan2(arrowHead.y - arrowTail.y, arrowHead.x - arrowTail.x) - Math.PI / 2;
          ctx.beginPath();
          ctx.moveTo(arrowHead.x, arrowHead.y);
          ctx.lineTo(arrowTail.x + arrowHalfWidth * Math.cos(arrowTailAngle), arrowTail.y + arrowHalfWidth * Math.sin(arrowTailAngle));
          ctx.lineTo(arrowTailVertex.x, arrowTailVertex.y);
          ctx.lineTo(arrowTail.x - arrowHalfWidth * Math.cos(arrowTailAngle), arrowTail.y - arrowHalfWidth * Math.sin(arrowTailAngle));
          ctx.fillStyle = arrowColor;
          ctx.fill();
        });
        ctx.restore();
      }
      function paintPhotons() {
        var getNumPhotons = index4(state.linkDirectionalParticles);
        var getSpeed = index4(state.linkDirectionalParticleSpeed);
        var getOffset = index4(state.linkDirectionalParticleOffset);
        var getDiameter = index4(state.linkDirectionalParticleWidth);
        var getVisibility = index4(state.linkVisibility);
        var getColor = index4(state.linkDirectionalParticleColor || state.linkColor);
        var ctx = state.ctx;
        ctx.save();
        state.graphData.links.filter(getVisibility).forEach(function(link) {
          var numCyclePhotons = getNumPhotons(link);
          if (!link.hasOwnProperty("__photons") || !link.__photons.length) return;
          var start2 = link.source;
          var end = link.target;
          if (!start2 || !end || !start2.hasOwnProperty("x") || !end.hasOwnProperty("x")) return;
          var particleSpeed = getSpeed(link);
          var particleOffset = Math.abs(getOffset(link));
          var photons = link.__photons || [];
          var photonR = Math.max(0, getDiameter(link) / 2) / Math.sqrt(state.globalScale);
          var photonColor = getColor(link) || "rgba(0,0,0,0.28)";
          ctx.fillStyle = photonColor;
          var bzLine = link.__controlPoints ? _construct3(Bezier, [start2.x, start2.y].concat(_toConsumableArray11(link.__controlPoints), [end.x, end.y])) : null;
          var cyclePhotonIdx = 0;
          var needsCleanup = false;
          photons.forEach(function(photon) {
            var singleHop = !!photon.__singleHop;
            if (!photon.hasOwnProperty("__progressRatio")) {
              photon.__progressRatio = singleHop ? 0 : (cyclePhotonIdx + particleOffset) / numCyclePhotons;
            }
            !singleHop && cyclePhotonIdx++;
            photon.__progressRatio += particleSpeed;
            if (photon.__progressRatio >= 1) {
              if (!singleHop) {
                photon.__progressRatio = photon.__progressRatio % 1;
              } else {
                needsCleanup = true;
                return;
              }
            }
            var photonPosRatio = photon.__progressRatio;
            var coords = bzLine ? bzLine.get(photonPosRatio) : {
              // straight line: interpolate linearly
              x: start2.x + (end.x - start2.x) * photonPosRatio || 0,
              y: start2.y + (end.y - start2.y) * photonPosRatio || 0
            };
            if (state.linkDirectionalParticleCanvasObject) {
              state.linkDirectionalParticleCanvasObject(coords.x, coords.y, link, ctx, state.globalScale);
            } else {
              ctx.beginPath();
              ctx.arc(coords.x, coords.y, photonR, 0, 2 * Math.PI, false);
              ctx.fill();
            }
          });
          if (needsCleanup) {
            link.__photons = link.__photons.filter(function(photon) {
              return !photon.__singleHop || photon.__progressRatio <= 1;
            });
          }
        });
        ctx.restore();
      }
    },
    emitParticle: function emitParticle2(state, link) {
      if (link) {
        !link.__photons && (link.__photons = []);
        link.__photons.push({
          __singleHop: true
        });
      }
      return this;
    }
  },
  stateInit: function stateInit4() {
    return {
      forceLayout: simulation_default().force("link", link_default()).force("charge", manyBody_default()).force("center", center_default()).force("dagRadial", null).stop(),
      engineRunning: false
    };
  },
  init: function init8(canvasCtx, state) {
    state.ctx = canvasCtx;
  },
  update: function update8(state, changedProps) {
    state.engineRunning = false;
    state.onUpdate();
    if (state.nodeAutoColorBy !== null) {
      autoColorObjects2(state.graphData.nodes, index4(state.nodeAutoColorBy), state.nodeColor);
    }
    if (state.linkAutoColorBy !== null) {
      autoColorObjects2(state.graphData.links, index4(state.linkAutoColorBy), state.linkColor);
    }
    state.graphData.links.forEach(function(link) {
      link.source = link[state.linkSource];
      link.target = link[state.linkTarget];
    });
    state.forceLayout.stop().alpha(1).nodes(state.graphData.nodes);
    var linkForce = state.forceLayout.force("link");
    if (linkForce) {
      linkForce.id(function(d3) {
        return d3[state.nodeId];
      }).links(state.graphData.links);
    }
    var nodeDepths = state.dagMode && getDagDepths2(state.graphData, function(node) {
      return node[state.nodeId];
    }, {
      nodeFilter: state.dagNodeFilter,
      onLoopError: state.onDagError || void 0
    });
    var maxDepth = Math.max.apply(Math, _toConsumableArray11(Object.values(nodeDepths || [])));
    var dagLevelDistance = state.dagLevelDistance || state.graphData.nodes.length / (maxDepth || 1) * DAG_LEVEL_NODE_RATIO2 * (["radialin", "radialout"].indexOf(state.dagMode) !== -1 ? 0.7 : 1);
    if (["lr", "rl", "td", "bu"].includes(changedProps.dagMode)) {
      var resetProp = ["lr", "rl"].includes(changedProps.dagMode) ? "fx" : "fy";
      state.graphData.nodes.filter(state.dagNodeFilter).forEach(function(node) {
        return delete node[resetProp];
      });
    }
    if (["lr", "rl", "td", "bu"].includes(state.dagMode)) {
      var invert2 = ["rl", "bu"].includes(state.dagMode);
      var fixFn = function fixFn2(node) {
        return (nodeDepths[node[state.nodeId]] - maxDepth / 2) * dagLevelDistance * (invert2 ? -1 : 1);
      };
      var _resetProp = ["lr", "rl"].includes(state.dagMode) ? "fx" : "fy";
      state.graphData.nodes.filter(state.dagNodeFilter).forEach(function(node) {
        return node[_resetProp] = fixFn(node);
      });
    }
    state.forceLayout.force("dagRadial", ["radialin", "radialout"].indexOf(state.dagMode) !== -1 ? radial_default(function(node) {
      var nodeDepth = nodeDepths[node[state.nodeId]] || -1;
      return (state.dagMode === "radialin" ? maxDepth - nodeDepth : nodeDepth) * dagLevelDistance;
    }).strength(function(node) {
      return state.dagNodeFilter(node) ? 1 : 0;
    }) : null);
    for (var i2 = 0; i2 < state.warmupTicks && !(state.d3AlphaMin > 0 && state.forceLayout.alpha() < state.d3AlphaMin); i2++) {
      state.forceLayout.tick();
    }
    this.resetCountdown();
    state.onFinishUpdate();
  }
});
function linkKapsule2(kapsulePropNames, kapsuleType) {
  var propNames = kapsulePropNames instanceof Array ? kapsulePropNames : [kapsulePropNames];
  var dummyK = new kapsuleType();
  dummyK._destructor && dummyK._destructor();
  return {
    linkProp: function linkProp(prop) {
      return {
        "default": dummyK[prop](),
        onChange: function onChange29(v2, state) {
          propNames.forEach(function(propName) {
            return state[propName][prop](v2);
          });
        },
        triggerUpdate: false
      };
    },
    linkMethod: function linkMethod(method2) {
      return function(state) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        var returnVals = [];
        propNames.forEach(function(propName) {
          var kapsuleInstance = state[propName];
          var returnVal = kapsuleInstance[method2].apply(kapsuleInstance, args);
          if (returnVal !== kapsuleInstance) {
            returnVals.push(returnVal);
          }
        });
        return returnVals.length ? returnVals[0] : this;
      };
    }
  };
}
var HOVER_CANVAS_THROTTLE_DELAY = 800;
var ZOOM2NODES_FACTOR = 4;
var DRAG_CLICK_TOLERANCE_PX = 5;
var bindFG2 = linkKapsule2("forceGraph", CanvasForceGraph);
var bindBoth = linkKapsule2(["forceGraph", "shadowGraph"], CanvasForceGraph);
var linkedProps = Object.assign.apply(Object, _toConsumableArray11(["nodeColor", "nodeAutoColorBy", "nodeCanvasObject", "nodeCanvasObjectMode", "linkColor", "linkAutoColorBy", "linkLineDash", "linkWidth", "linkCanvasObject", "linkCanvasObjectMode", "linkDirectionalArrowLength", "linkDirectionalArrowColor", "linkDirectionalArrowRelPos", "linkDirectionalParticles", "linkDirectionalParticleSpeed", "linkDirectionalParticleOffset", "linkDirectionalParticleWidth", "linkDirectionalParticleColor", "linkDirectionalParticleCanvasObject", "dagMode", "dagLevelDistance", "dagNodeFilter", "onDagError", "d3AlphaMin", "d3AlphaDecay", "d3VelocityDecay", "warmupTicks", "cooldownTicks", "cooldownTime", "onEngineTick", "onEngineStop"].map(function(p3) {
  return _defineProperty8({}, p3, bindFG2.linkProp(p3));
})).concat(_toConsumableArray11(["nodeRelSize", "nodeId", "nodeVal", "nodeVisibility", "linkSource", "linkTarget", "linkVisibility", "linkCurvature"].map(function(p3) {
  return _defineProperty8({}, p3, bindBoth.linkProp(p3));
}))));
var linkedMethods = Object.assign.apply(Object, _toConsumableArray11(["d3Force", "d3ReheatSimulation", "emitParticle"].map(function(p3) {
  return _defineProperty8({}, p3, bindFG2.linkMethod(p3));
})));
function adjustCanvasSize(state) {
  if (state.canvas) {
    var curWidth = state.canvas.width;
    var curHeight = state.canvas.height;
    if (curWidth === 300 && curHeight === 150) {
      curWidth = curHeight = 0;
    }
    var pxScale = window.devicePixelRatio;
    curWidth /= pxScale;
    curHeight /= pxScale;
    [state.canvas, state.shadowCanvas].forEach(function(canvas) {
      canvas.style.width = "".concat(state.width, "px");
      canvas.style.height = "".concat(state.height, "px");
      canvas.width = state.width * pxScale;
      canvas.height = state.height * pxScale;
      if (!curWidth && !curHeight) {
        canvas.getContext("2d").scale(pxScale, pxScale);
      }
    });
    var k2 = transform(state.canvas).k;
    state.zoom.translateBy(state.zoom.__baseElem, (state.width - curWidth) / 2 / k2, (state.height - curHeight) / 2 / k2);
    state.needsRedraw = true;
  }
}
function resetTransform(ctx) {
  var pxRatio = window.devicePixelRatio;
  ctx.setTransform(pxRatio, 0, 0, pxRatio, 0, 0);
}
function clearCanvas(ctx, width, height) {
  ctx.save();
  resetTransform(ctx);
  ctx.clearRect(0, 0, width, height);
  ctx.restore();
}
var forceGraph = index3({
  props: _objectSpread26({
    width: {
      "default": window.innerWidth,
      onChange: function onChange20(_2, state) {
        return adjustCanvasSize(state);
      },
      triggerUpdate: false
    },
    height: {
      "default": window.innerHeight,
      onChange: function onChange21(_2, state) {
        return adjustCanvasSize(state);
      },
      triggerUpdate: false
    },
    graphData: {
      "default": {
        nodes: [],
        links: []
      },
      onChange: function onChange22(d3, state) {
        [d3.nodes, d3.links].every(function(arr) {
          return (arr || []).every(function(d4) {
            return !d4.hasOwnProperty("__indexColor");
          });
        }) && state.colorTracker.reset();
        [{
          type: "Node",
          objs: d3.nodes
        }, {
          type: "Link",
          objs: d3.links
        }].forEach(hexIndex);
        state.forceGraph.graphData(d3);
        state.shadowGraph.graphData(d3);
        function hexIndex(_ref4) {
          var type = _ref4.type, objs = _ref4.objs;
          objs.filter(function(d4) {
            if (!d4.hasOwnProperty("__indexColor")) return true;
            var cur = state.colorTracker.lookup(d4.__indexColor);
            return !cur || !cur.hasOwnProperty("d") || cur.d !== d4;
          }).forEach(function(d4) {
            d4.__indexColor = state.colorTracker.register({
              type,
              d: d4
            });
          });
        }
      },
      triggerUpdate: false
    },
    backgroundColor: {
      onChange: function onChange23(color3, state) {
        state.canvas && color3 && (state.canvas.style.background = color3);
      },
      triggerUpdate: false
    },
    nodeLabel: {
      "default": "name",
      triggerUpdate: false
    },
    nodePointerAreaPaint: {
      onChange: function onChange24(paintFn, state) {
        state.shadowGraph.nodeCanvasObject(!paintFn ? null : function(node, ctx, globalScale) {
          return paintFn(node, node.__indexColor, ctx, globalScale);
        });
        state.flushShadowCanvas && state.flushShadowCanvas();
      },
      triggerUpdate: false
    },
    linkPointerAreaPaint: {
      onChange: function onChange25(paintFn, state) {
        state.shadowGraph.linkCanvasObject(!paintFn ? null : function(link, ctx, globalScale) {
          return paintFn(link, link.__indexColor, ctx, globalScale);
        });
        state.flushShadowCanvas && state.flushShadowCanvas();
      },
      triggerUpdate: false
    },
    linkLabel: {
      "default": "name",
      triggerUpdate: false
    },
    linkHoverPrecision: {
      "default": 4,
      triggerUpdate: false
    },
    minZoom: {
      "default": 0.01,
      onChange: function onChange26(minZoom, state) {
        state.zoom.scaleExtent([minZoom, state.zoom.scaleExtent()[1]]);
      },
      triggerUpdate: false
    },
    maxZoom: {
      "default": 1e3,
      onChange: function onChange27(maxZoom, state) {
        state.zoom.scaleExtent([state.zoom.scaleExtent()[0], maxZoom]);
      },
      triggerUpdate: false
    },
    enableNodeDrag: {
      "default": true,
      triggerUpdate: false
    },
    enableZoomInteraction: {
      "default": true,
      triggerUpdate: false
    },
    enablePanInteraction: {
      "default": true,
      triggerUpdate: false
    },
    enableZoomPanInteraction: {
      "default": true,
      triggerUpdate: false
    },
    // to be deprecated
    enablePointerInteraction: {
      "default": true,
      onChange: function onChange28(_2, state) {
        state.hoverObj = null;
      },
      triggerUpdate: false
    },
    autoPauseRedraw: {
      "default": true,
      triggerUpdate: false
    },
    onNodeDrag: {
      "default": function _default23() {
      },
      triggerUpdate: false
    },
    onNodeDragEnd: {
      "default": function _default24() {
      },
      triggerUpdate: false
    },
    onNodeClick: {
      triggerUpdate: false
    },
    onNodeRightClick: {
      triggerUpdate: false
    },
    onNodeHover: {
      triggerUpdate: false
    },
    onLinkClick: {
      triggerUpdate: false
    },
    onLinkRightClick: {
      triggerUpdate: false
    },
    onLinkHover: {
      triggerUpdate: false
    },
    onBackgroundClick: {
      triggerUpdate: false
    },
    onBackgroundRightClick: {
      triggerUpdate: false
    },
    showPointerCursor: {
      "default": true,
      triggerUpdate: false
    },
    onZoom: {
      triggerUpdate: false
    },
    onZoomEnd: {
      triggerUpdate: false
    },
    onRenderFramePre: {
      triggerUpdate: false
    },
    onRenderFramePost: {
      triggerUpdate: false
    }
  }, linkedProps),
  aliases: {
    // Prop names supported for backwards compatibility
    stopAnimation: "pauseAnimation"
  },
  methods: _objectSpread26({
    graph2ScreenCoords: function graph2ScreenCoords(state, x3, y3) {
      var t5 = transform(state.canvas);
      return {
        x: x3 * t5.k + t5.x,
        y: y3 * t5.k + t5.y
      };
    },
    screen2GraphCoords: function screen2GraphCoords(state, x3, y3) {
      var t5 = transform(state.canvas);
      return {
        x: (x3 - t5.x) / t5.k,
        y: (y3 - t5.y) / t5.k
      };
    },
    centerAt: function centerAt(state, x3, y3, transitionDuration) {
      if (!state.canvas) return null;
      if (x3 !== void 0 || y3 !== void 0) {
        var finalPos = Object.assign({}, x3 !== void 0 ? {
          x: x3
        } : {}, y3 !== void 0 ? {
          y: y3
        } : {});
        if (!transitionDuration) {
          setCenter(finalPos);
        } else {
          state.tweenGroup.add(new Tween(getCenter()).to(finalPos, transitionDuration).easing(Easing.Quadratic.Out).onUpdate(setCenter).start());
        }
        return this;
      }
      return getCenter();
      function getCenter() {
        var t5 = transform(state.canvas);
        return {
          x: (state.width / 2 - t5.x) / t5.k,
          y: (state.height / 2 - t5.y) / t5.k
        };
      }
      function setCenter(_ref5) {
        var x4 = _ref5.x, y4 = _ref5.y;
        state.zoom.translateTo(state.zoom.__baseElem, x4 === void 0 ? getCenter().x : x4, y4 === void 0 ? getCenter().y : y4);
        state.needsRedraw = true;
      }
    },
    zoom: function zoom(state, k2, transitionDuration) {
      if (!state.canvas) return null;
      if (k2 !== void 0) {
        if (!transitionDuration) {
          setZoom(k2);
        } else {
          state.tweenGroup.add(new Tween({
            k: getZoom()
          }).to({
            k: k2
          }, transitionDuration).easing(Easing.Quadratic.Out).onUpdate(function(_ref6) {
            var k3 = _ref6.k;
            return setZoom(k3);
          }).start());
        }
        return this;
      }
      return getZoom();
      function getZoom() {
        return transform(state.canvas).k;
      }
      function setZoom(k3) {
        state.zoom.scaleTo(state.zoom.__baseElem, k3);
        state.needsRedraw = true;
      }
    },
    zoomToFit: function zoomToFit3(state) {
      var transitionDuration = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var padding = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 10;
      for (var _len = arguments.length, bboxArgs = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
        bboxArgs[_key - 3] = arguments[_key];
      }
      var bbox = this.getGraphBbox.apply(this, bboxArgs);
      if (bbox) {
        var center = {
          x: (bbox.x[0] + bbox.x[1]) / 2,
          y: (bbox.y[0] + bbox.y[1]) / 2
        };
        var zoomK = Math.max(1e-12, Math.min(1e12, (state.width - padding * 2) / (bbox.x[1] - bbox.x[0]), (state.height - padding * 2) / (bbox.y[1] - bbox.y[0])));
        this.centerAt(center.x, center.y, transitionDuration);
        this.zoom(zoomK, transitionDuration);
      }
      return this;
    },
    getGraphBbox: function getGraphBbox2(state) {
      var nodeFilter = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
        return true;
      };
      var getVal = index4(state.nodeVal);
      var getR = function getR2(node) {
        return Math.sqrt(Math.max(0, getVal(node) || 1)) * state.nodeRelSize;
      };
      var nodesPos = state.graphData.nodes.filter(nodeFilter).map(function(node) {
        return {
          x: node.x,
          y: node.y,
          r: getR(node)
        };
      });
      return !nodesPos.length ? null : {
        x: [min(nodesPos, function(node) {
          return node.x - node.r;
        }), max2(nodesPos, function(node) {
          return node.x + node.r;
        })],
        y: [min(nodesPos, function(node) {
          return node.y - node.r;
        }), max2(nodesPos, function(node) {
          return node.y + node.r;
        })]
      };
    },
    pauseAnimation: function pauseAnimation2(state) {
      if (state.animationFrameRequestId) {
        cancelAnimationFrame(state.animationFrameRequestId);
        state.animationFrameRequestId = null;
      }
      return this;
    },
    resumeAnimation: function resumeAnimation2(state) {
      if (!state.animationFrameRequestId) {
        this._animationCycle();
      }
      return this;
    },
    _destructor: function _destructor4() {
      this.pauseAnimation();
      this.graphData({
        nodes: [],
        links: []
      });
    }
  }, linkedMethods),
  stateInit: function stateInit5() {
    return {
      lastSetZoom: 1,
      zoom: zoom_default2(),
      forceGraph: new CanvasForceGraph(),
      shadowGraph: new CanvasForceGraph().cooldownTicks(0).nodeColor("__indexColor").linkColor("__indexColor").isShadow(true),
      colorTracker: new _default15(),
      // indexed objects for rgb lookup
      tweenGroup: new Group3()
    };
  },
  init: function init9(domNode, state) {
    var _this = this;
    domNode.innerHTML = "";
    var container = document.createElement("div");
    container.classList.add("force-graph-container");
    container.style.position = "relative";
    domNode.appendChild(container);
    state.canvas = document.createElement("canvas");
    if (state.backgroundColor) state.canvas.style.background = state.backgroundColor;
    container.appendChild(state.canvas);
    state.shadowCanvas = document.createElement("canvas");
    var ctx = state.canvas.getContext("2d");
    var shadowCtx = state.shadowCanvas.getContext("2d", {
      willReadFrequently: true
    });
    var pointerPos = {
      x: -1e12,
      y: -1e12
    };
    var getObjUnderPointer = function getObjUnderPointer2() {
      var obj = null;
      var pxScale = window.devicePixelRatio;
      var px2 = pointerPos.x > 0 && pointerPos.y > 0 ? shadowCtx.getImageData(pointerPos.x * pxScale, pointerPos.y * pxScale, 1, 1) : null;
      px2 && (obj = state.colorTracker.lookup(px2.data));
      return obj;
    };
    select_default2(state.canvas).call(drag_default().subject(function() {
      if (!state.enableNodeDrag) {
        return null;
      }
      var obj = getObjUnderPointer();
      return obj && obj.type === "Node" ? obj.d : null;
    }).on("start", function(ev) {
      var obj = ev.subject;
      obj.__initialDragPos = {
        x: obj.x,
        y: obj.y,
        fx: obj.fx,
        fy: obj.fy
      };
      if (!ev.active) {
        obj.fx = obj.x;
        obj.fy = obj.y;
      }
      state.canvas.classList.add("grabbable");
    }).on("drag", function(ev) {
      var obj = ev.subject;
      var initPos = obj.__initialDragPos;
      var dragPos = ev;
      var k2 = transform(state.canvas).k;
      var translate = {
        x: initPos.x + (dragPos.x - initPos.x) / k2 - obj.x,
        y: initPos.y + (dragPos.y - initPos.y) / k2 - obj.y
      };
      ["x", "y"].forEach(function(c5) {
        return obj["f".concat(c5)] = obj[c5] = initPos[c5] + (dragPos[c5] - initPos[c5]) / k2;
      });
      if (!obj.__dragged && DRAG_CLICK_TOLERANCE_PX >= Math.sqrt(sum(["x", "y"].map(function(k3) {
        return Math.pow(ev[k3] - initPos[k3], 2);
      })))) return;
      state.forceGraph.d3AlphaTarget(0.3).resetCountdown();
      state.isPointerDragging = true;
      obj.__dragged = true;
      state.onNodeDrag(obj, translate);
    }).on("end", function(ev) {
      var obj = ev.subject;
      var initPos = obj.__initialDragPos;
      var translate = {
        x: obj.x - initPos.x,
        y: obj.y - initPos.y
      };
      if (initPos.fx === void 0) {
        obj.fx = void 0;
      }
      if (initPos.fy === void 0) {
        obj.fy = void 0;
      }
      delete obj.__initialDragPos;
      if (state.forceGraph.d3AlphaTarget()) {
        state.forceGraph.d3AlphaTarget(0).resetCountdown();
      }
      state.canvas.classList.remove("grabbable");
      state.isPointerDragging = false;
      if (obj.__dragged) {
        delete obj.__dragged;
        state.onNodeDragEnd(obj, translate);
      }
    }));
    state.zoom(state.zoom.__baseElem = select_default2(state.canvas));
    state.zoom.__baseElem.on("dblclick.zoom", null);
    state.zoom.filter(function(ev) {
      return (
        // disable zoom interaction
        !ev.button && state.enableZoomPanInteraction && (ev.type !== "wheel" || index4(state.enableZoomInteraction)(ev)) && (ev.type === "wheel" || index4(state.enablePanInteraction)(ev))
      );
    }).on("zoom", function(ev) {
      var t5 = ev.transform;
      [ctx, shadowCtx].forEach(function(c5) {
        resetTransform(c5);
        c5.translate(t5.x, t5.y);
        c5.scale(t5.k, t5.k);
      });
      state.isPointerDragging = true;
      state.onZoom && state.onZoom(_objectSpread26(_objectSpread26({}, t5), _this.centerAt()));
      state.needsRedraw = true;
    }).on("end", function(ev) {
      state.isPointerDragging = false;
      state.onZoomEnd && state.onZoomEnd(_objectSpread26(_objectSpread26({}, ev.transform), _this.centerAt()));
    });
    adjustCanvasSize(state);
    state.forceGraph.onNeedsRedraw(function() {
      return state.needsRedraw = true;
    }).onFinishUpdate(function() {
      if (transform(state.canvas).k === state.lastSetZoom && state.graphData.nodes.length) {
        state.zoom.scaleTo(state.zoom.__baseElem, state.lastSetZoom = ZOOM2NODES_FACTOR / Math.cbrt(state.graphData.nodes.length));
        state.needsRedraw = true;
      }
    });
    state.tooltip = new index6(container);
    ["pointermove", "pointerdown"].forEach(function(evType) {
      return container.addEventListener(evType, function(ev) {
        if (evType === "pointerdown") {
          state.isPointerPressed = true;
          state.pointerDownEvent = ev;
        }
        !state.isPointerDragging && ev.type === "pointermove" && state.onBackgroundClick && (ev.pressure > 0 || state.isPointerPressed) && (ev.pointerType === "mouse" || ev.movementX === void 0 || [ev.movementX, ev.movementY].some(function(m3) {
          return Math.abs(m3) > 1;
        })) && (state.isPointerDragging = true);
        var offset = getOffset(container);
        pointerPos.x = ev.pageX - offset.left;
        pointerPos.y = ev.pageY - offset.top;
        function getOffset(el) {
          var rect = el.getBoundingClientRect(), scrollLeft = window.pageXOffset || document.documentElement.scrollLeft, scrollTop = window.pageYOffset || document.documentElement.scrollTop;
          return {
            top: rect.top + scrollTop,
            left: rect.left + scrollLeft
          };
        }
      }, {
        passive: true
      });
    });
    container.addEventListener("pointerup", function(ev) {
      if (!state.isPointerPressed) {
        return;
      }
      state.isPointerPressed = false;
      if (state.isPointerDragging) {
        state.isPointerDragging = false;
        return;
      }
      var cbEvents = [ev, state.pointerDownEvent];
      requestAnimationFrame(function() {
        if (ev.button === 0) {
          if (state.hoverObj) {
            var fn = state["on".concat(state.hoverObj.type, "Click")];
            fn && fn.apply(void 0, [state.hoverObj.d].concat(cbEvents));
          } else {
            state.onBackgroundClick && state.onBackgroundClick.apply(state, cbEvents);
          }
        }
        if (ev.button === 2) {
          if (state.hoverObj) {
            var _fn = state["on".concat(state.hoverObj.type, "RightClick")];
            _fn && _fn.apply(void 0, [state.hoverObj.d].concat(cbEvents));
          } else {
            state.onBackgroundRightClick && state.onBackgroundRightClick.apply(state, cbEvents);
          }
        }
      });
    }, {
      passive: true
    });
    container.addEventListener("contextmenu", function(ev) {
      if (!state.onBackgroundRightClick && !state.onNodeRightClick && !state.onLinkRightClick) return true;
      ev.preventDefault();
      return false;
    });
    state.forceGraph(ctx);
    state.shadowGraph(shadowCtx);
    var refreshShadowCanvas = throttle_default(function() {
      clearCanvas(shadowCtx, state.width, state.height);
      state.shadowGraph.linkWidth(function(l2) {
        return index4(state.linkWidth)(l2) + state.linkHoverPrecision;
      });
      var t5 = transform(state.canvas);
      state.shadowGraph.globalScale(t5.k).tickFrame();
    }, HOVER_CANVAS_THROTTLE_DELAY);
    state.flushShadowCanvas = refreshShadowCanvas.flush;
    (this._animationCycle = function animate() {
      var doRedraw = !state.autoPauseRedraw || !!state.needsRedraw || state.forceGraph.isEngineRunning() || state.graphData.links.some(function(d3) {
        return d3.__photons && d3.__photons.length;
      });
      state.needsRedraw = false;
      if (state.enablePointerInteraction) {
        var obj = !state.isPointerDragging ? getObjUnderPointer() : null;
        if (obj !== state.hoverObj) {
          var prevObj = state.hoverObj;
          var prevObjType = prevObj ? prevObj.type : null;
          var objType = obj ? obj.type : null;
          if (prevObjType && prevObjType !== objType) {
            var fn = state["on".concat(prevObjType, "Hover")];
            fn && fn(null, prevObj.d);
          }
          if (objType) {
            var _fn2 = state["on".concat(objType, "Hover")];
            _fn2 && _fn2(obj.d, prevObjType === objType ? prevObj.d : null);
          }
          state.tooltip.content(obj ? index4(state["".concat(obj.type.toLowerCase(), "Label")])(obj.d) || null : null);
          state.canvas.classList[(obj && state["on".concat(objType, "Click")] || !obj && state.onBackgroundClick) && index4(state.showPointerCursor)(obj === null || obj === void 0 ? void 0 : obj.d) ? "add" : "remove"]("clickable");
          state.hoverObj = obj;
        }
        doRedraw && refreshShadowCanvas();
      }
      if (doRedraw) {
        clearCanvas(ctx, state.width, state.height);
        var globalScale = transform(state.canvas).k;
        state.onRenderFramePre && state.onRenderFramePre(ctx, globalScale);
        state.forceGraph.globalScale(globalScale).tickFrame();
        state.onRenderFramePost && state.onRenderFramePost(ctx, globalScale);
      }
      state.tweenGroup.update();
      state.animationFrameRequestId = requestAnimationFrame(animate);
    })();
  },
  update: function updateFn(state) {
  }
});

// node_modules/react-force-graph/dist/react-force-graph.mjs
var commonPropTypes = {
  width: import_prop_types.default.number,
  height: import_prop_types.default.number,
  graphData: import_prop_types.default.shape({
    nodes: import_prop_types.default.arrayOf(import_prop_types.default.object).isRequired,
    links: import_prop_types.default.arrayOf(import_prop_types.default.object).isRequired
  }),
  backgroundColor: import_prop_types.default.string,
  nodeRelSize: import_prop_types.default.number,
  nodeId: import_prop_types.default.string,
  nodeLabel: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.func]),
  nodeVal: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string, import_prop_types.default.func]),
  nodeVisibility: import_prop_types.default.oneOfType([import_prop_types.default.bool, import_prop_types.default.string, import_prop_types.default.func]),
  nodeColor: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.func]),
  nodeAutoColorBy: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.func]),
  onNodeHover: import_prop_types.default.func,
  onNodeClick: import_prop_types.default.func,
  linkSource: import_prop_types.default.string,
  linkTarget: import_prop_types.default.string,
  linkLabel: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.func]),
  linkVisibility: import_prop_types.default.oneOfType([import_prop_types.default.bool, import_prop_types.default.string, import_prop_types.default.func]),
  linkColor: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.func]),
  linkAutoColorBy: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.func]),
  linkWidth: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string, import_prop_types.default.func]),
  linkCurvature: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string, import_prop_types.default.func]),
  linkDirectionalArrowLength: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string, import_prop_types.default.func]),
  linkDirectionalArrowColor: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.func]),
  linkDirectionalArrowRelPos: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string, import_prop_types.default.func]),
  linkDirectionalParticles: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string, import_prop_types.default.func]),
  linkDirectionalParticleSpeed: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string, import_prop_types.default.func]),
  linkDirectionalParticleOffset: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string, import_prop_types.default.func]),
  linkDirectionalParticleWidth: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string, import_prop_types.default.func]),
  linkDirectionalParticleColor: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.func]),
  onLinkHover: import_prop_types.default.func,
  onLinkClick: import_prop_types.default.func,
  dagMode: import_prop_types.default.oneOf(["td", "bu", "lr", "rl", "zin", "zout", "radialin", "radialout"]),
  dagLevelDistance: import_prop_types.default.number,
  dagNodeFilter: import_prop_types.default.func,
  onDagError: import_prop_types.default.func,
  d3AlphaMin: import_prop_types.default.number,
  d3AlphaDecay: import_prop_types.default.number,
  d3VelocityDecay: import_prop_types.default.number,
  warmupTicks: import_prop_types.default.number,
  cooldownTicks: import_prop_types.default.number,
  cooldownTime: import_prop_types.default.number,
  onEngineTick: import_prop_types.default.func,
  onEngineStop: import_prop_types.default.func,
  getGraphBbox: import_prop_types.default.func
};
var pointerBasedPropTypes = {
  zoomToFit: import_prop_types.default.func,
  onNodeRightClick: import_prop_types.default.func,
  onNodeDrag: import_prop_types.default.func,
  onNodeDragEnd: import_prop_types.default.func,
  onLinkRightClick: import_prop_types.default.func,
  linkHoverPrecision: import_prop_types.default.number,
  onBackgroundClick: import_prop_types.default.func,
  onBackgroundRightClick: import_prop_types.default.func,
  showPointerCursor: import_prop_types.default.oneOfType([import_prop_types.default.bool, import_prop_types.default.func]),
  enablePointerInteraction: import_prop_types.default.bool,
  enableNodeDrag: import_prop_types.default.bool
};
var threeBasedPropTypes = {
  showNavInfo: import_prop_types.default.bool,
  nodeOpacity: import_prop_types.default.number,
  nodeResolution: import_prop_types.default.number,
  nodeThreeObject: import_prop_types.default.oneOfType([import_prop_types.default.object, import_prop_types.default.string, import_prop_types.default.func]),
  nodeThreeObjectExtend: import_prop_types.default.oneOfType([import_prop_types.default.bool, import_prop_types.default.string, import_prop_types.default.func]),
  nodePositionUpdate: import_prop_types.default.func,
  linkOpacity: import_prop_types.default.number,
  linkResolution: import_prop_types.default.number,
  linkCurveRotation: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string, import_prop_types.default.func]),
  linkMaterial: import_prop_types.default.oneOfType([import_prop_types.default.object, import_prop_types.default.string, import_prop_types.default.func]),
  linkThreeObject: import_prop_types.default.oneOfType([import_prop_types.default.object, import_prop_types.default.string, import_prop_types.default.func]),
  linkThreeObjectExtend: import_prop_types.default.oneOfType([import_prop_types.default.bool, import_prop_types.default.string, import_prop_types.default.func]),
  linkPositionUpdate: import_prop_types.default.func,
  linkDirectionalArrowResolution: import_prop_types.default.number,
  linkDirectionalParticleResolution: import_prop_types.default.number,
  linkDirectionalParticleThreeObject: import_prop_types.default.oneOfType([import_prop_types.default.object, import_prop_types.default.string, import_prop_types.default.func]),
  forceEngine: import_prop_types.default.oneOf(["d3", "ngraph"]),
  ngraphPhysics: import_prop_types.default.object,
  numDimensions: import_prop_types.default.oneOf([1, 2, 3])
};
var ForceGraph2DPropTypes = Object.assign({}, commonPropTypes, pointerBasedPropTypes, {
  linkLineDash: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.number), import_prop_types.default.string, import_prop_types.default.func]),
  nodeCanvasObjectMode: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.func]),
  nodeCanvasObject: import_prop_types.default.func,
  nodePointerAreaPaint: import_prop_types.default.func,
  linkCanvasObjectMode: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.func]),
  linkCanvasObject: import_prop_types.default.func,
  linkPointerAreaPaint: import_prop_types.default.func,
  linkDirectionalParticleCanvasObject: import_prop_types.default.func,
  autoPauseRedraw: import_prop_types.default.bool,
  minZoom: import_prop_types.default.number,
  maxZoom: import_prop_types.default.number,
  enableZoomInteraction: import_prop_types.default.oneOfType([import_prop_types.default.bool, import_prop_types.default.func]),
  enablePanInteraction: import_prop_types.default.oneOfType([import_prop_types.default.bool, import_prop_types.default.func]),
  onZoom: import_prop_types.default.func,
  onZoomEnd: import_prop_types.default.func,
  onRenderFramePre: import_prop_types.default.func,
  onRenderFramePost: import_prop_types.default.func
});
var ForceGraph3DPropTypes = Object.assign({}, commonPropTypes, pointerBasedPropTypes, threeBasedPropTypes, {
  enableNavigationControls: import_prop_types.default.bool,
  controlType: import_prop_types.default.oneOf(["trackball", "orbit", "fly"]),
  rendererConfig: import_prop_types.default.object,
  extraRenderers: import_prop_types.default.arrayOf(import_prop_types.default.shape({
    render: import_prop_types.default.func.isRequired
  }))
});
var ForceGraphVRPropTypes = Object.assign({}, commonPropTypes, threeBasedPropTypes, {
  nodeDesc: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.func]),
  linkDesc: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.func])
});
var ForceGraphARPropTypes = Object.assign({}, commonPropTypes, threeBasedPropTypes, {
  markerAttrs: import_prop_types.default.object,
  yOffset: import_prop_types.default.number,
  glScale: import_prop_types.default.number
});
var ForceGraphVR = index(_3dForceGraphVr, {
  methodNames: [
    // bind methods
    "getGraphBbox",
    "emitParticle",
    "d3Force",
    "d3ReheatSimulation",
    "refresh"
  ]
});
ForceGraphVR.displayName = "ForceGraphVR";
ForceGraphVR.propTypes = ForceGraphVRPropTypes;
var ForceGraphAR = index(_3dForceGraphAr, {
  methodNames: [
    // bind methods
    "getGraphBbox",
    "emitParticle",
    "d3Force",
    "d3ReheatSimulation",
    "refresh"
  ],
  initPropNames: ["markerAttrs"]
});
ForceGraphAR.displayName = "ForceGraphAR";
ForceGraphAR.propTypes = ForceGraphARPropTypes;
var ForceGraph3D = index(_3dForceGraph, {
  methodNames: [
    // bind methods
    "emitParticle",
    "d3Force",
    "d3ReheatSimulation",
    "stopAnimation",
    "pauseAnimation",
    "resumeAnimation",
    "cameraPosition",
    "zoomToFit",
    "getGraphBbox",
    "screen2GraphCoords",
    "graph2ScreenCoords",
    "postProcessingComposer",
    "lights",
    "scene",
    "camera",
    "renderer",
    "controls",
    "refresh"
  ],
  initPropNames: ["controlType", "rendererConfig", "extraRenderers"]
});
ForceGraph3D.displayName = "ForceGraph3D";
ForceGraph3D.propTypes = ForceGraph3DPropTypes;
var ForceGraph2D = index(forceGraph, {
  methodNames: [
    // bind methods
    "emitParticle",
    "d3Force",
    "d3ReheatSimulation",
    "stopAnimation",
    "pauseAnimation",
    "resumeAnimation",
    "centerAt",
    "zoom",
    "zoomToFit",
    "getGraphBbox",
    "screen2GraphCoords",
    "graph2ScreenCoords"
  ]
});
ForceGraph2D.displayName = "ForceGraph2D";
ForceGraph2D.propTypes = ForceGraph2DPropTypes;
export {
  ForceGraph2D,
  ForceGraph3D,
  ForceGraphAR,
  ForceGraphVR
};
//# sourceMappingURL=react-force-graph.js.map
